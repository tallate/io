<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-04T15:45:36+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字节码插桩<br>
atach</p>
<p>协程<br>
arthas<br>
pinpoint</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T18:38:41+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  23 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本地线程任务的同步策略"><a class="header-anchor" href="#本地线程任务的同步策略">¶</a>本地线程任务的同步策略</h2>
<h3 id="线程同步和锁"><a class="header-anchor" href="#线程同步和锁">¶</a>线程同步和锁</h3>
<p>线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。<br>
线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：</p>
<ul>
<li>内存<br>
共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（Atomic）、阻塞队列（BlockingQueue）等。</li>
<li>磁盘<br>
共享文件、消息队列等。</li>
<li>网络<br>
Socket等。</li>
</ul>
<p>像Java中Thread的wait、notify的实现基本也可以使用内存共享来解释，只不过它们是native方法，实现由平台说了算；volatile关键字不能算是同步机制，因为它实际上无法保证线程安全性。</p>
<h3 id="乐观锁和悲观锁"><a class="header-anchor" href="#乐观锁和悲观锁">¶</a>乐观锁和悲观锁</h3>
<p>乐观锁和悲观锁是在数据库中使用的名词。</p>
<ul>
<li>悲观锁<br>
悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，数据库中实现是对数据记录操作前给记录加<strong>排它锁</strong>。如果获取锁失败，则说明数据正在被其它线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>
使用悲观锁的一个常用的例子： <code>select * from 表 where .. for update;</code>。</li>
<li>乐观锁<br>
乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。具体说是根据 update 返回的行数让用户决定如何去做。<br>
例如：<code>update 表 set comment='***',status='operator',version=version+1 where version = 1 and id = 1;</code><br>
乐观锁并不会使用数据库提供的锁机制，一般在表添加 version 字段或者使用业务状态来做。乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。</li>
</ul>
<h3 id="死锁"><a class="header-anchor" href="#死锁">¶</a>死锁</h3>
<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p>
<h4 id="死锁产生的条件"><a class="header-anchor" href="#死锁产生的条件">¶</a>死锁产生的条件</h4>
<p>死锁的产生必须满足以下4个必要条件：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其它进行请求获取该资源，则请求者只能等待，直至占有资源的线程用毕释放。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源；T1 正在等待 T2 占用的资源，……Tn正在等待已被 T0 占用的资源。</li>
</ul>
<p>举个形象的例子，两辆车在窄道上相向而行，他们占着道不肯退开，又希望对方能让开，最终形成了死锁。<br>
例1 - 死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程A：</span><br><span class="line">synchronized(resourceA) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceB) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程B：</span><br><span class="line">synchronized(resourceB) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceA) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先资源 resourceA 和 resourceB 都是互斥资源，当线程 A 调用 synchronized(resourceA) 获取到 resourceA 上的监视器锁后释放前，线程 B 在调用 synchronized(resourceA) 尝试获取该资源会被阻塞，只有线程 A 主动释放该锁，线程 B 才能获得，这满足了<strong>资源互斥条件</strong>。<br>
线程 A 首先通过 synchronized(resourceA) 获取到 resourceA 上的监视器锁资源，然后通过 synchronized(resourceB) 等待获取到 resourceB 上的监视器锁资源，这就满足了<strong>持有并等待</strong>。<br>
线程 A 在获取 resourceA 上的监视器锁资源后，不会被线程 B 掠夺走，只有线程 A 自己主动释放 resourceA 的资源时候，才会放弃对该资源的持有权，这满足了资源的<strong>不可剥夺条件</strong>。<br>
线程 A 持有 objectA 资源并等待获取 objectB 资源，而线程 B 持有 objectB 资源并等待 objectA 资源，这满足了<strong>循环等待条件</strong>。<br>
所以线程 A 和 B 就形成了死锁状态。</p>
<h4 id="死锁避免"><a class="header-anchor" href="#死锁避免">¶</a>死锁避免</h4>
<p>要想避免死锁，需要破坏构造死锁必要条件的至少一个即可，但是目前只有持有并等待和循环等待是可以被破坏的。<br>
其实，实现死锁避免最简单的方案就是控制资源申请的有序性。</p>
<h3 id="阻塞锁"><a class="header-anchor" href="#阻塞锁">¶</a>阻塞锁</h3>
<p>阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。<br>
JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有：synchronized 关键字（其中的重量锁）, ReentrantLock, Object.wait() / notify(), LockSupport.park() / unpart()</p>
<p>阻塞锁的优势在于，阻塞的线程不会占用cpu时间，不会导致 CPU 占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。<br>
在竞争激烈的情况下阻塞锁的性能要明显高于自旋锁。<br>
理想的情况：在线程竞争不激烈的情况下使用自旋锁，竞争激烈的情况下使用阻塞锁。</p>
<h3 id="独占锁和共享锁"><a class="header-anchor" href="#独占锁和共享锁">¶</a>独占锁和共享锁</h3>
<p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁分为独占锁和共享锁。<br>
独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock 就是以独占方式实现的。共享锁则同时有多个线程可以持有，例如 ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。<br>
独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其它线程必须等待当前线程释放锁才能进行读取。<br>
共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<h3 id="公平性"><a class="header-anchor" href="#公平性">¶</a>公平性</h3>
<p>锁有公平和非公平之分：</p>
<ul>
<li>公平锁：每个线程按调用lock的顺序来获取锁，不可插队；</li>
<li>非公平锁：每个线程获取锁的顺序不确定，存在插队的问题。</li>
</ul>
<p>平时使用的 ReentrantLock 默认的lock()就是非公平锁，它会先尝试用CAS获取一次锁，若获取不到才进入一个队列等待锁的释放。<br>
Semaphore中，tryAcquire是非公平的而acquire是公平的。<br>
在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。</p>
<h3 id="可重入性"><a class="header-anchor" href="#可重入性">¶</a>可重入性</h3>
<p>当一个线程要获取一个被其它线程持有的独占锁时候，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限制次数（高级篇我们会知道严格来说是有限次数）进入被该锁锁住的代码。</p>
<h4 id="可重入锁原理"><a class="header-anchor" href="#可重入锁原理">¶</a>可重入锁原理</h4>
<p>可重入锁的原理是在锁内部维护了一个线程标示，用来标示该锁目前被那个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其它线程在获取该锁时候发现锁的所有者不是自己就会被阻塞挂起。<br>
但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己，就会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为 null，这时候阻塞的线程会获取被唤醒来竞争获取该锁。</p>
<h4 id="synchronized-监视器锁-是可重入的"><a class="header-anchor" href="#synchronized-监视器锁-是可重入的">¶</a>synchronized（监视器锁）是可重入的</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reentrantlock是可重入的"><a class="header-anchor" href="#reentrantlock是可重入的">¶</a>ReentrantLock是可重入的</h4>
<blockquote>
<p>废话，名字里Reentrant就是可重入的意思。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h4 id="reentrantreadwritelock"><a class="header-anchor" href="#reentrantreadwritelock">¶</a>ReentrantReadWriteLock</h4>
<p>加锁分三种情况：</p>
<ul>
<li>
<p>读锁本身定义就支持重入；</p>
</li>
<li>
<p>写锁支持重入</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读锁和写锁同时使用会死锁</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.readLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抢占"><a class="header-anchor" href="#抢占">¶</a>抢占</h3>
<p>TODO</p>
<h3 id="spinlock-自旋锁"><a class="header-anchor" href="#spinlock-自旋锁">¶</a>SpinLock（自旋锁）</h3>
<p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class SpinLock &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; sign = new AtomicReference&lt;&gt;();</span><br><span class="line">    public void lock()&#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        // 当sign的值为null时才设置为current</span><br><span class="line">        while(!sign .compareAndSet(null, current))&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock ()&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        sign .compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LockTest &#123;</span><br><span class="line">    SpinLock spinLock = new SpinLock();</span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。<br>
但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。<br>
如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。<br>
该例子为非公平锁，获得锁的先后顺序不会按照进入lock的先后顺序进行。</p>
<h3 id="锁算法-clhlock-craig-landin-and-hagersten-locks"><a class="header-anchor" href="#锁算法-clhlock-craig-landin-and-hagersten-locks">¶</a>锁算法 - CLHLock（Craig, Landin, and Hagersten locks）</h3>
<p>使用链表协调每个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CLHLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class CLHNode &#123;</span><br><span class="line">        // 刚开始当前线程是锁住的</span><br><span class="line">        private volatile Thread isLocked;</span><br><span class="line">        // boolean方案、private volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile CLHNode tail;</span><br><span class="line">    private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;();</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        CLHNode node = new CLHNode();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        // 原子更新当前CLHLock对应的值，并返回旧值</span><br><span class="line">        // getAndSet使自己成为队列的尾部，同时获取其前驱节点的引用</span><br><span class="line">        // 如果是第一个调用lock的，直接返回，如果不是，则等待上一个unlock</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(this, node);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            // boolean方案：while(preNode.isLocked) &#123;&#125;</span><br><span class="line">            preNode.isLocked = Thread.currentThread();</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            preNode = null;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        CLHNode node = LOCAL.get();</span><br><span class="line">        if (!UPDATER.compareAndSet(this, node, null)) &#123;</span><br><span class="line">            // boolean方案：node.isLocked = false;</span><br><span class="line">            System.out.println(&quot;unlock\t&quot; + node.isLocked.getName());</span><br><span class="line">            LockSupport.unpark(node.isLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        node = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中注明了另一种boolean实现方案，boolean方案看起来会直观一点。</p>
<p>JUC ReentrantLock 默认内部使用的锁 即是 CLH 锁（有很多改进的地方，将自旋锁换成了阻塞锁等等）。<br>
CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O(L+n)，n个线程有n个Node，L个锁有L个tail），CLH的一种变体被应用在了JAVA并发框架中（AbstractQueuedSynchronizer.Node）。<br>
CLH在SMP系统结构下是非常有效的，但在NUMA系统结构下，每个线程有自己的内存，而CLHLock会不停地查询前驱变量，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，一种解决NUMA系统结构的思路是MCS队列锁。</p>
<h3 id="锁算法-mcslock"><a class="header-anchor" href="#锁算法-mcslock">¶</a>锁算法 - MCSLock</h3>
<p>MCSLock则是对本地变量的节点进行循环，不会出现CLHLock的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MCSLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class MCSNode &#123;</span><br><span class="line"></span><br><span class="line">        volatile MCSNode next;</span><br><span class="line">        volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;MCSNode&gt;();</span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile MCSNode queue;</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class,</span><br><span class="line">            MCSNode.class, &quot;queue&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        MCSNode currentNode = new MCSNode();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        MCSNode preNode = UPDATER.getAndSet(this, currentNode);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            while (currentNode.isLocked) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        MCSNode currentNode = NODE.get();</span><br><span class="line">        if (currentNode.next == null) &#123;</span><br><span class="line">            if (!UPDATER.compareAndSet(this, currentNode, null)) &#123;</span><br><span class="line">                while (currentNode.next == null) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.next.isLocked = false;</span><br><span class="line">            currentNode.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLH 的队列是隐式的队列，没有真实的后继结点属性。<br>
MCS 的队列是显式的队列，有真实的后继结点属性。</p>
<h3 id="锁算法-ticketlock"><a class="header-anchor" href="#锁算法-ticketlock">¶</a>锁算法 - TicketLock</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class TicketLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger serviceNum = new AtomicInteger();</span><br><span class="line">    private AtomicInteger ticketNum = new AtomicInteger();</span><br><span class="line">    private static final ThreadLocal&lt;Integer&gt; LOCAL =</span><br><span class="line">            new ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        // 得到门票</span><br><span class="line">        int myticket = ticketNum.getAndIncrement();</span><br><span class="line">        LOCAL.set(myticket);</span><br><span class="line">        // 如果当前叫票和自己的票号不同</span><br><span class="line">        while (myticket != serviceNum.get()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int myticket = LOCAL.get();</span><br><span class="line">        // compareAndSet内部会循环判断当前值是否为myticket，然后才执行赋值操作</span><br><span class="line">        serviceNum.compareAndSet(myticket, myticket + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        // TicketLock保存在主线程内，子线程每次lock拿到一张票，</span><br><span class="line">        // 此时别的线程unlock，直到票数增长到自己的票号</span><br><span class="line">        TicketLock ticketLock = new TicketLock();</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            ticketLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            ticketLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            // 线程的执行顺序和每个线程调用lock的顺序相同</span><br><span class="line">            new Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TicketLock，主要解决的是访问顺序的问题，主要的问题是在多核cpu上。<br>
缺点是每次都要查询一个serviceNum 服务号，影响性能（必须要到主内存读取，并阻止其他cpu修改）。</p>
<h3 id="互斥锁-reentrantlock"><a class="header-anchor" href="#互斥锁-reentrantlock">¶</a>互斥锁 - ReentrantLock</h3>
<h3 id="读写锁-reentrantreadwritelock"><a class="header-anchor" href="#读写锁-reentrantreadwritelock">¶</a>读写锁 - ReentrantReadWriteLock</h3>
<h3 id="条件-condition"><a class="header-anchor" href="#条件-condition">¶</a>条件 - Condition</h3>
<p>实例 - Condition的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock l = new ReentrantLock();</span><br><span class="line">// Condition相当于一个0-1信号量</span><br><span class="line">// （其实是使用了一个叫AbstractQueuedSynchronizer.Node等待队列）</span><br><span class="line">Condition c = l.newCondition();</span><br><span class="line">c.await(); // 信号量-1</span><br><span class="line">c.signal(); // 信号量+1</span><br><span class="line">c.signalAll(); // 所有信号量+1</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<p>实例 - 多线程下的缓冲区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();//锁对象  </span><br><span class="line">    final Condition notFull = lock.newCondition();//写线程条件   </span><br><span class="line">    final Condition notEmpty = lock.newCondition();//读线程条件   </span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[100];//缓存队列  </span><br><span class="line">    int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;</span><br><span class="line"></span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)//如果队列满了   </span><br><span class="line">            &#123;</span><br><span class="line">                notFull.await();//阻塞写线程  </span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;//赋值   </span><br><span class="line">            if (++putptr == items.length) &#123;</span><br><span class="line">                putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            ++count;//个数++  </span><br><span class="line">            notEmpty.signal();//唤醒读线程  </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)//如果队列为空  </span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty.await();//阻塞读线程  </span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];//取值   </span><br><span class="line">            if (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            --count;//个数--  </span><br><span class="line">            notFull.signal();//唤醒写线程  </span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程调度-和-locksupport"><a class="header-anchor" href="#线程调度-和-locksupport">¶</a>线程调度 和 LockSupport</h3>
<p>挂起和唤醒是线程调度中和锁的实现最密切的操作，juc中通过一个LockSupport来抽象这两种操作，它是创建锁和其它同步类的基础。</p>
<ul>
<li>LockSupport 类与每个使用它的线程都会关联一个许可证,默认调用LockSupport 类的方法的线程是不持有许可证的</li>
<li>LockSupport 内部使用 Unsafe 类实现</li>
</ul>
<h4 id="void-park"><a class="header-anchor" href="#void-park">¶</a>void park()</h4>
<p>如果调用 park() 的线程已经拿到了与 LockSupport 关联的<strong>permit（许可证）</strong>，则调用 LockSupport.park() 会马上返回，否者调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;begin park&quot;);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(&quot;end park&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>在其它线程调用 unpark(Thread thread)方法并且当前线程作为参数时候，调用park方法被阻塞的线程会返回；</li>
<li>其他线程调用interrupt()设置中断标识后可以返回，不会抛出InterruptedException异常；</li>
<li>由于线程的虚假唤醒也会导致阻塞的线程返回，所以调用park()最好也用循环条件判断方式。</li>
</ul>
<h3 id="锁实现的基础-abstractqueuedsynchronizer-aqs"><a class="header-anchor" href="#锁实现的基础-abstractqueuedsynchronizer-aqs">¶</a>锁实现的基础 - AbstractQueuedSynchronizer（AQS）</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/AQS%E7%B1%BB%E5%9B%BE.png" alt="AQS类图" title="AQS类图"><br>
虽然AQS本质上是一个双向队列，是juc中大部分并发安全组件的实现基础。</p>
<p>AQS 是一个 FIFO 的双向队列，内部通过节点 <code>head</code> 和 <code>tail</code> 记录队首和队尾元素，队列元素类型为 <code>Node</code>。</p>
<ul>
<li>其中 Node 中 <code>thread</code> 变量用来存放进入 AQS 队列里面的线程；</li>
<li>Node 节点内部 <code>SHARED</code> 用来标记该线程是获取共享资源时候被阻塞挂起后放入 AQS 队列，<code>EXCLUSIVE</code> 标示线程是获取独占资源时候被挂起后放入 AQS 队列；</li>
<li><code>waitStatus</code> 记录当前线程等待状态，分别为 <code>CANCELLED</code>（线程被取消了），<code>SIGNAL</code>（线程需要被唤醒），<code>CONDITION</code>（线程在条件队列里面等待），<code>PROPAGATE</code>（释放共享资源时候需要通知其它节点）；</li>
<li><code>prev</code> 记录当前节点的前驱节点，<code>next</code> 记录当前节点后继节点。</li>
</ul>
<p>AQS 中维持了一个单一的状态信息 <code>state</code>, 可以通过 getState, setState, compareAndSetState 函数修改其值</p>
<ul>
<li>对于 ReentrantLock 的实现来说，state 可以用来表示当前线程获取锁的可重入次数；</li>
<li>对应读写锁 ReentrantReadWriteLock 来说 state 的高 16 位表示读状态也就是获取该读锁的次数，低 16 位表示获取到写锁的线程的可重入次数；</li>
<li>对于 semaphore 来说 state 用来表示当前可用信号的个数；</li>
<li>对于 FutuerTask 来说，state 用来表示任务状态（例如还没开始，运行，完成，取消）；</li>
</ul>
<blockquote>
<p>1.8版本中FutuerTask取消了对AQS的依赖，改为通过CAS跟踪状态、Treiber stack管理等待中的线程，是因为通过AQS的实现存在，这篇文章的最后提到了这个问题：<a href="https://www.jianshu.com/p/16d6f0a22111" target="_blank" rel="noopener">线程阻塞(三)，FutureTask</a>，官方有一个Bug Report：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8016247" target="_blank" rel="noopener">JDK-8016247 : ThreadPoolExecutor may interrupt the wrong task</a>。</p>
</blockquote>
<ul>
<li>对应 CountDownlatch 和 CyclicBarrie 来说 state 用来表示计数器当前的值。</li>
</ul>
<p>AQS 有个内部类 <code>ConditionObject</code> 是用来结合锁实现线程同步，ConditionObject 可以直接访问 AQS 对象内部的变量，比如 state 状态值和 AQS 队列；<br>
ConditionObject 是条件变量，每个条件变量对应着一个条件队列 (单向链表队列)，用来存放调用条件变量的 await() 方法后被阻塞的线程，如类图，这个条件队列的头尾元素分别为 <code>firstWaiter</code> 和 <code>lastWaiter</code>。</p>
<h2 id="同步工具类"><a class="header-anchor" href="#同步工具类">¶</a>同步工具类</h2>
<h3 id="闭锁-countdownlatch"><a class="header-anchor" href="#闭锁-countdownlatch">¶</a>闭锁 - CountDownLatch</h3>
<p>日常开发中经常会遇到需要在主线程中开启多线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后在进行汇总的场景，在 CountDownLatch 出现之前一般都是使用线程的 join() 方法来实现，但是 join 不够灵活，不能够满足不同场景的需要。</p>
<blockquote>
<p>join相对CountDownLatch来说有以下两点劣势：<br>
调用一个线程的join后，该线程会一直被阻塞直到该线程运行完毕，而 CountDownLatch 则可以在子线程运行完毕或运行过程中递减计数器，从而让await返回。<br>
另外，使用线程池来管理线程时候一般都是直接添加一个 Runable 实例到线程池，这时就不方便再调用线程的join方法了。</p>
</blockquote>
<h4 id="类图"><a class="header-anchor" href="#类图">¶</a>类图</h4>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/CountDownLatch%E7%B1%BB%E5%9B%BE.png" alt="CountDownLatch类图" title="CountDownLatch类图"></p>
<ul>
<li>CountDownLatch是公平的，其实现基础同样是AQS。</li>
</ul>
<h4 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h4>
<p>构造方法中初始化Sync时把计数器的值赋值给了 AQS 的状态值 state，也就是这里 AQS 的状态值来表示计数器值。</p>
<h4 id="void-await"><a class="header-anchor" href="#void-await">¶</a>void await()</h4>
<p>挂起当前线程，直到下面情况之一发生时才返回：</p>
<ul>
<li>当所有线程都调用了 CountDownLatch 对象的 <code>countDown()</code> 方法后，也就是计时器值为 0 的时候；</li>
<li>其它线程调用了当前线程的 <code>interrupt()</code> 方法中断了当前线程，当前线程会抛出 InterruptedException 异常后返回</li>
</ul>
<p>CountDownLatch.await()<br>
-&gt; AbstractQueuedSynchronizer.acquireSharedInterruptibly：获取共享资源，且可中断<br>
&gt; 为什么是acquireSharedInterruptibly而不是获取独占资源的acquireInterruptibly？因为这里状态值需要的并不是非 0 即 1 的效果，而是和初始化时候指定的计数器值有关系，比如你初始化时候计数器值为 8，那么 state 的值应该就有 0 到 8 的状态，而不是只有 0 和 1 的情况下的独占效果。<br>
1. 先调用Thread.interrupted()判断一下线程的中断状态，若被中断则抛出异常<br>
1. 尝试看当前是否计数值为0，为0则直接返回，否则进入AQS的队列等待<br>
-&gt; AbstractQueuedSynchronizer.doAcquireSharedInterruptibly</p>
<h4 id="boolean-await-long-timeout-timeunit-unit"><a class="header-anchor" href="#boolean-await-long-timeout-timeunit-unit">¶</a>boolean await(long timeout, TimeUnit unit)</h4>
<p>比起await多了个返回条件：</p>
<ul>
<li>超时后返回false。</li>
</ul>
<h4 id="void-countdown"><a class="header-anchor" href="#void-countdown">¶</a>void countDown()</h4>
<p>递减计数器的值，递减后如果计数器为 0 则会唤醒所有调用 await 方法而被阻塞的线程。</p>
<p>CountDownLatch.countDown<br>
-&gt; AbstractQueuedSynchronizer.releaseShared<br>
-&gt; CountDownLatch.Sync.tryReleaseShared：循环CAS设置状态值，返回值表示当前线程是否为第一个将状态值设置为0的，当前状态值已经为0则返回false，或者当前线程成功完成cas使计数值（状态值state）减一并更新到state并返回，如果当前状态值为0返回true<br>
-&gt; AbstractQueuedSynchronizer.doReleaseShared</p>
<h4 id="long-getcount"><a class="header-anchor" href="#long-getcount">¶</a>long getCount()</h4>
<p>获取当前计数器的值，也就是AQS的state的值，一般在 debug 测试时候使用。</p>
<h4 id="实例-模拟并发请求"><a class="header-anchor" href="#实例-模拟并发请求">¶</a>实例 - 模拟并发请求</h4>
<p>如果要用Java模拟并发请求，最基本的方案就是创建多个线程然后一一启动，但是如此一来请求就会带上先后顺序了，一种解决办法是通过CountDownLatch来同步多个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">CountDownLatch end = new CountDownLatch(10);</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            start.await();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                end.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">start.countDown();</span><br><span class="line">end.await();</span><br></pre></td></tr></table></figure>
<h3 id="栅栏-cyclicbarrier"><a class="header-anchor" href="#栅栏-cyclicbarrier">¶</a>栅栏 - CyclicBarrier</h3>
<h3 id="futuretask"><a class="header-anchor" href="#futuretask">¶</a>FutureTask</h3>
<p>TODO</p>
<h3 id="completablefuture"><a class="header-anchor" href="#completablefuture">¶</a>CompletableFuture</h3>
<h3 id="guava-listenablefuture"><a class="header-anchor" href="#guava-listenablefuture">¶</a>Guava - ListenableFuture</h3>
<h3 id="semaphore"><a class="header-anchor" href="#semaphore">¶</a>Semaphore</h3>
<h3 id="phase"><a class="header-anchor" href="#phase">¶</a>Phase</h3>
<p>相对CountDownLatch和CyclicBarrier来说，Phase支持多阶段协同；</p>
<ul>
<li>Phase表示当前阶段，最多可以有(2^32 - 1)个阶段；</li>
<li>Parties表示参与此次过程的参与者（不一定是线程）数量，最多65535个。</li>
</ul>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ol>
<li>什么是 Java 中原子性操作？</li>
<li>什么是 Java 中的 CAS 操作，AtomicLong 的实现原理？</li>
<li>什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？</li>
<li>抽象同步队列 AQS (AbstractQueuedSynchronizer) 概述，AQS 是实现同步的基础组件，并发包中锁的实现底层就是使用 AQS 实现，虽然大多数开发者可能从来不会直接用到 AQS，但是知道其原理对于架构设计还是很有帮助的。</li>
<li>独占锁 ReentrantLock 原理探究，ReentrantLock 是可重入的独占锁或者叫做排它锁，同时只能有一个线程可以获取该锁，其实现分为公平与非公平的独占锁。</li>
<li>读写锁 ReentrantReadWriteLock 原理，ReentrantLock 是独占锁，同时只有一个线程可以获取该锁，而实际情况下会有写少读多的场景，显然 ReentrantLock 满足不了需求，所以 ReentrantReadWriteLock 应运而生，本文来介绍读写分离锁的实现。</li>
<li>JUC 中倒数计数器 CountDownLatch 的使用与原理分析，当需要等待多个线程执行完毕后在做一件事情时候 CountDownLatch 是比调用线程的 join 方法更好的选择，CountDownLatch 与 线程的 join 方法区别是什么？</li>
<li>JUC 中 回环屏障 CyclicBarrier 的使用与分析，它也可以实现像 CountDownLatch 一样让一组线程全部到达一个状态后再全部同时执行，但是 CyclicBarrier 可以被复用。那么 CyclicBarrier 内部的实现与 CountDownLatch 有何不同那？</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  748 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>平滑迁移指的是互联网公司发版时为能正常发布新功能而又不影响用户体验所做的一些措施。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/0.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程和状态机"><a class="header-anchor" href="#线程和状态机">¶</a>线程和状态机</h2>
<h3 id="线程和线程任务"><a class="header-anchor" href="#线程和线程任务">¶</a>线程和线程任务</h3>
<p>线程任务区别于线程，可以理解为线程需要执行的逻辑，类似Thread中要执行的Runnable。</p>
<h3 id="前台线程-用户线程-和后台线程-守护线程"><a class="header-anchor" href="#前台线程-用户线程-和后台线程-守护线程">¶</a>前台线程（用户线程）和后台线程（守护线程）</h3>
<p>jvm不区分主线程和用户线程，各个线程是独立的，不同于win32的线程模型。jvm把线程分为前台线程和后台线程，前台线程官方术语叫<strong>用户线程（User）</strong>，后台线程则叫<strong>守护线程（Daemon）</strong>，jvm结束的条件是 <strong>所有的前台线程结束</strong> 。<br>
Java 中线程分为两类，分别为 Daemon 线程（守护线程）和 User 线程（用户线程），类似于Unix中的用户进程和守护进程，实际上它们的区别不大，只是它们的含义不同，用户线程为用户服务，守护线程为其他线程服务。在 JVM 启动时候会调用 main 函数，main 函数所在的线程是一个用户线程，这个是我们可以看到的线程，其实 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程（严格说属于 JVM 线程），并且在所有用户线程都退出后守护线程也一并退出。<br>
守护线程和用户线程的<strong>区别</strong>：只有且仅有当最后一个用户线程结束后JVM会正常退出，而不管当前是否有守护线程。<br>
正常构建的线程都是前台线程，可以在线程未开始前调用Thread类的setDaemon(true)方法将线程改变为后台守护线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.setDaemon(true);</span><br></pre></td></tr></table></figure>
<p>下面的例子区分了守护线程和用户线程的特点（注意不要使用JUNIT测试，因为JUNIT在主线程退出后会直接退出JVM）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 主线程退出后JVM不会退出</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      for(;;)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  //启动子线</span><br><span class="line">  thread.start();</span><br><span class="line">  System.out.print(&quot;main thread is over&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子证明主线程退出、而仍存在子线程运行时JVM是不会退出的。下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 主线程退出后不管守护线程是否仍在运行、直接退出JVM</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      for (; ; ) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  //启动子线</span><br><span class="line">  thread.setDaemon(true);</span><br><span class="line">  thread.start();</span><br><span class="line">  System.out.print(&quot;main thread is over&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果你想在主线程结束后 JVM 进程马上结束，那么创建线程的时候可以设置线程为守护线程，否则如果希望主线程结束后子线程继续工作，等子线程结束后在让 JVM 进程结束那么就设置子线程为用户线程。</p>
<h4 id="守护线程原理"><a class="header-anchor" href="#守护线程原理">¶</a>守护线程原理</h4>
<p>Java 中在 main 线程运行结束后，JVM 会自动启动一个叫做 DestroyJavaVM 线程，该线程会等待所有用户线程结束后终止 JVM 进程。<br>
翻开 JVM 的代码，最终会调用到 JavaMain 这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int JNICALL</span><br><span class="line">JavaMain(void * _args)</span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">    //执行Java中的main函数 </span><br><span class="line">    (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br><span class="line"></span><br><span class="line">    //main函数返回值</span><br><span class="line">    ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;</span><br><span class="line"></span><br><span class="line">    //等待所有非守护线程结束，然后销毁JVM进程</span><br><span class="line">    LEAVE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LEAVE 是 C 语言里面的一个宏定义，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define LEAVE() \</span><br><span class="line">    do &#123; \</span><br><span class="line">        if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) &#123; \</span><br><span class="line">            JLI_ReportErrorMessage(JVM_ERROR2); \</span><br><span class="line">            ret = 1; \</span><br><span class="line">        &#125; \</span><br><span class="line">        if (JNI_TRUE) &#123; \</span><br><span class="line">            (*vm)-&gt;DestroyJavaVM(vm); \</span><br><span class="line">            return ret; \</span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; while (JNI_FALSE)</span><br></pre></td></tr></table></figure>
<p>上面宏的作用实际是创建了一个名字叫做 DestroyJavaVM 的线程来等待所有用户线程结束。</p>
<h3 id="线程上下文切换"><a class="header-anchor" href="#线程上下文切换">¶</a>线程上下文切换</h3>
<p>在多线程编程中，线程个数一般都大于 CPU 个数，而每个 CPU 同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行，CPU 资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片，在时间片内占用 CPU 执行任务。当前线程的时间片使用完毕后当前就会处于就绪状态并让出 CPU 让其它线程占用，这就是上下文切换，从当前线程的上下文切换到了其它线程。<br>
那么就有一个问题让出 CPU 的线程等下次轮到自己占有 CPU 时候如何知道之前运行到哪里了？所以在切换线程上下文时候需要保存当前线程的执行现场，当再次执行时候根据保存的执行现场信息恢复执行现场。</p>
<h4 id="线程上下文切换时机"><a class="header-anchor" href="#线程上下文切换时机">¶</a>线程上下文切换时机</h4>
<ul>
<li>当前线程的 CPU 时间片使用完毕处于就绪状态时候；</li>
<li>当前线程被其它线程中断时候。</li>
</ul>
<h4 id="线程上下文切换开销问题"><a class="header-anchor" href="#线程上下文切换开销问题">¶</a>线程上下文切换开销问题</h4>
<p>由于线程切换是有开销的，所以并不是开的线程越多越好，比如如果机器是4核心的，你开启了100个线程，那么同时执行的只有4个线程，这100个线程会来回切换线程上下文来共享这四个 CPU。</p>
<h3 id="java如何执行线程任务"><a class="header-anchor" href="#java如何执行线程任务">¶</a>Java如何执行线程任务</h3>
<p>这个问题其实和一个经典面试题很像——如何创建线程？<br>
其实Java中创建线程的方式只有一种，就是<code>new Thread</code>，其他的所谓创建线程都是指的如何调度线程，包括Runnable、Future、Callable，及各种线程池ExecutorService、ForkJoinPool等。</p>
<h4 id="runnable和thread"><a class="header-anchor" href="#runnable和thread">¶</a>Runnable和Thread</h4>
<p>使用Runnable比直接使用Thread更加灵活：</p>
<ul>
<li>Thread继承的方式下，run()内获取当前线程可以直接使用this，但是Java不支持多重继承，如果继承了Thread就不能再继承其他类了，且任务与代码没有分离，当多个线程执行一样的任务时需要实例化多个继承的线程类。</li>
<li>实现Runnable的方式下，任务与代码分离，run()内获取当前线程必须使用Thread.currentThread()。</li>
</ul>
<h4 id="callable和future"><a class="header-anchor" href="#callable和future">¶</a>Callable和Future</h4>
<p>Java5使用Callable来执行逻辑、返回线程执行结果，且支持声明抛出异常，Future接口是Callable的执行器，可以获取Callable中call()的返回值，它有一个实现类FutureTask：</p>
<ul>
<li>可以提供给Thread调度，因为FutureTask实现了Runnable接口；</li>
<li>控制关联的Callable，比如calcel()可以取消Callable任务、get()可以获取call()方法的返回值（阻塞直到call()返回）。</li>
</ul>
<h3 id="java如何实现多线程？"><a class="header-anchor" href="#java如何实现多线程？">¶</a>Java如何实现多线程？</h3>
<p>Java并不依靠JVM实现多线程，Thread的<code>start0()</code>方法是一个native方法，这意味着线程的执行是平台相关的。<br>
JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p>
<p>Java 中在 main 线程运行结束后，JVM 会自动启动一个叫做 <strong>DestroyJavaVM 线程</strong>，该线程会等待所有用户线程结束后终止 JVM 进程，下面是 JVM 中的相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int JNICALL</span><br><span class="line">JavaMain(void * _args)</span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">    //执行Java中的main函数 </span><br><span class="line">    (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br><span class="line"></span><br><span class="line">    //main函数返回值</span><br><span class="line">    ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;</span><br><span class="line"></span><br><span class="line">    //等待所有非守护线程结束，然后销毁JVM进程</span><br><span class="line">    LEAVE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LEAVE 是 C 语言里面的一个宏定义，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define LEAVE() \</span><br><span class="line">    do &#123; \</span><br><span class="line">        if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) &#123; \</span><br><span class="line">            JLI_ReportErrorMessage(JVM_ERROR2); \</span><br><span class="line">            ret = 1; \</span><br><span class="line">        &#125; \</span><br><span class="line">        if (JNI_TRUE) &#123; \</span><br><span class="line">            (*vm)-&gt;DestroyJavaVM(vm); \</span><br><span class="line">            return ret; \</span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; while (JNI_FALSE)</span><br></pre></td></tr></table></figure>
<p>上面宏的作用实际是创建了一个名字叫做 DestroyJavaVM 的线程来等待所有用户线程结束。</p>
<p>在 Tomcat 的 NIO 实现 NioEndpoint 中会开启一组接受线程用来接受用户的链接请求和一组处理线程负责具体处理用户请求，那么这些线程是用户线程还是守护线程呢？下面我们看下 NioEndpoint 的 startInternal 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void startInternal() throws Exception &#123;</span><br><span class="line">    if (!running) &#123;</span><br><span class="line">        running = true;</span><br><span class="line">        paused = false;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //创建处理线程</span><br><span class="line">        pollers = new Poller[getPollerThreadCount()];</span><br><span class="line">        for (int i=0; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = new Poller();</span><br><span class="line">            Thread pollerThread = new Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(true);//声明为守护线程</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //启动接受线程</span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected final void startAcceptorThreads() &#123;</span><br><span class="line">    int count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = new Acceptor[count];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        acceptors[i] = createAcceptor();</span><br><span class="line">        String threadName = getName() + &quot;-Acceptor-&quot; + i;</span><br><span class="line">        acceptors[i].setThreadName(threadName);</span><br><span class="line">        Thread t = new Thread(acceptors[i], threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());//设置是否为守护线程，默认为守护线程</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean daemon = true;</span><br><span class="line">public void setDaemon(boolean b) &#123; daemon = b; &#125;</span><br><span class="line">public boolean getDaemon() &#123; return daemon; &#125;</span><br></pre></td></tr></table></figure>
<p>如上代码也就是说默认情况下接受线程和处理线程都是守护线程，这意味着当 Tomact 收到 shutdown 命令后 Tomact 进程会马上消亡，而不会等处理线程处理完当前的请求。</p>
<h3 id="有限状态机-fsm"><a class="header-anchor" href="#有限状态机-fsm">¶</a>有限状态机（FSM）</h3>
<p>有限状态机也称为FSM(Finite State Machine)，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。FSM可以把模型的多状态、多状态建的转换条件解耦。可以使维护变得容易，代码也更加具有可读性。<br>
<img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%844%E8%A6%81%E7%B4%A0.png" alt="有限状态机的4要素" title="有限状态机的4要素"></p>
<h4 id="要素"><a class="header-anchor" href="#要素">¶</a>要素</h4>
<p>状态机可归纳为4个要素：现态、条件、动作、次态。</p>
<ul>
<li>现态：指当前流程所处的状态，包括起始、中间、终结状态。</li>
<li>条件：也可称为事件；当一个条件被满足时，将会触发一个动作并执行一次状态的迁移。</li>
<li>动作：当条件满足后要执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。</li>
<li>次态：当条件满足后要迁往的状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li>
</ul>
<h4 id="状态"><a class="header-anchor" href="#状态">¶</a>状态</h4>
<p>状态表示流程中的持久状态，流程图上的每一个圈代表一个状态。</p>
<ul>
<li>初始状态： 流程开始时的某一状态；</li>
<li>中间状态： 流程中间过程的某一状态；</li>
<li>终结状态： 流程完成时的某一状态。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>状态必须是一个持久状态，而不能是一个临时状态；</li>
<li>终结状态不能是中间状态，不能继续进行流程流转；</li>
<li>状态划分合理，不要把多个状态强制合并为一个状态；</li>
<li>状态尽量精简，同一状态的不同情况可以用其它字段表示。</li>
</ul>
<h4 id="动作"><a class="header-anchor" href="#动作">¶</a>动作</h4>
<p>动作的三要素：角色、现态、次态，流程图上的每一条线代表一个动作。</p>
<ul>
<li>角色： 谁发起的这个操作，可以是用户、定时任务等；</li>
<li>现态： 触发动作时当前的状态，是执行动作的前提条件；</li>
<li>次态： 完成动作后达到的状态，是执行动作的最终目标。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>每个动作执行前，必须检查当前状态和触发动作状态的一致性；</li>
<li>状态机的状态更改，只能通过动作进行，其它操作都是不符合规范的；</li>
<li>需要添加分布式锁保证动作的原子性，添加数据库事务保证数据的一致性；</li>
<li>类似的动作（比如操作用户、请求参数、动作含义等）可以合并为一个动作，并根据动作执行结果转向不同的状态。</li>
</ul>
<h3 id="线程状态"><a class="header-anchor" href="#线程状态">¶</a>线程状态</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC.jpg" alt="线程状态流转" title="线程状态流转"></p>
<ul>
<li><strong>创建（NEW）</strong>：实例化线程对象，此时还没有调用start执行线程。</li>
<li><strong>就绪（RUNNABLE）</strong>：调用了线程的start，此时调度器还没来得及给线程分配时间片，线程还处于就绪队列中。</li>
<li><strong>运行（RUNNABLE）</strong>：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li><strong>阻塞</strong>：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep、suspend、wait等方法都可以导致线程阻塞。阻塞分三种情况：
<ol>
<li>等待阻塞（WAITING）：调用wait，让线程等待某工作的完成后调用notify通知；</li>
<li>同步阻塞（BLOCKED）：synchronized获取监视器锁失败，进入同步阻塞状态，直到其他线程放开监视器锁；</li>
<li>其他阻塞（TIMED_WAITING）：sleep、join或发出了IO请求时，线程阻塞，直到sleep超时、join等待线程终止 / 超时、或IO处理完毕，线程重新进入就绪状态。</li>
</ol>
</li>
<li><strong>死亡（TERMINATED）</strong>：一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</li>
</ul>
<blockquote>
<p>Java线程状态和操作系统线程状态并不是一一映射的，这些状态是由JVM维护的，并不是调磁盘IO系统调用线程就进入BLOCKED状态。<br>
Java中线程没有RUNNING状态，RUNNABLE映射了操作系统的READY、RUNNING和WAITING三个状态，实际上RUNNABLE表示线程正在Java虚拟机中执行，但它可能正在等待来自操作系统的其他资源，比如处理器、硬盘、网卡等。</p>
</blockquote>
<h3 id="线程状态模拟"><a class="header-anchor" href="#线程状态模拟">¶</a>线程状态模拟</h3>
<ul>
<li>RUNNABLE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInBlockedIOState() throws InterruptedException &#123;</span><br><span class="line">    Scanner in = new Scanner(System.in);</span><br><span class="line">    // 创建一个名为“输入输出”的线程t</span><br><span class="line">    Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 命令行中的阻塞读</span><br><span class="line">                String input = in.nextLine();</span><br><span class="line">                System.out.println(input);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (in != null) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;输入输出&quot;); // 线程的名字</span><br><span class="line"></span><br><span class="line">    // 启动</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    // 确保run已经得到执行</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">    // 状态为RUNNABLE</span><br><span class="line">    assertThat(t.getState(), IsEqual.equalTo(State.RUNNABLE));</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testBlockedSocketState() throws Exception &#123;</span><br><span class="line">    Thread serverThread = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            ServerSocket serverSocket = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                serverSocket = new ServerSocket(10086);</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    // 阻塞的accept方法</span><br><span class="line">                    Socket socket = serverSocket.accept();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;socket线程&quot;); // 线程的名字</span><br><span class="line">    serverThread.start();</span><br><span class="line"></span><br><span class="line">    // 确保run已经得到执行</span><br><span class="line">    Thread.sleep(500);</span><br><span class="line"></span><br><span class="line">    // 状态为RUNNABLE</span><br><span class="line">    assertThat(serverThread.getState(), IsEqual.equalTo(Thread.State.RUNNABLE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WAITING状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInWaiting() throws InterruptedException &#123;</span><br><span class="line">    Object lock = new Object();</span><br><span class="line">    Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(&quot;wait finished&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;等待&quot;); // 线程的名字</span><br><span class="line"></span><br><span class="line">    // 启动</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    // 确保run已经得到执行</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">    // 状态为RUNNABLE</span><br><span class="line">    assertThat(t.getState(), IsEqual.equalTo(State.WAITING));</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        lock.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程调度方法"><a class="header-anchor" href="#线程调度方法">¶</a>线程调度方法</h3>
<p>Thread类有许多方法用于调度线程：<br>
<strong>sleep（睡眠）</strong> 使线程进入阻塞状态，直到睡眠时间结束<br>
<strong>wait（等待）</strong> 使线程进入等待状态，直到别的线程调用锁定对象的notify()或notifyall()方法<br>
<strong>yield（让步）</strong> 提醒线程调度器给别的线程分配更多时间<br>
<strong>join（加入）</strong> 若调用自身的join()，则等待其他线程终止；若调用了别的对象的join()，则当前线程进入阻塞状态，直到另一个线程运行结束。<br>
<strong>notify（唤醒）</strong> 唤醒此对象监视器上等待的一个线程<br>
<strong>interrupt（中断）</strong> 中断使线程离开阻塞状态，并准备下一次运行<br>
<strong>run</strong> 和 <strong>start</strong>：run定义了线程的执行逻辑，是由用户定义的，是一个回调函数，当调用start方法后并没有立刻执行而是处于就绪状态，这个就绪状态是指该线程已经获取了除 CPU 资源外的其它资源，等获取CPU资源后才会真正处于运行状态，这个资源一般指由操作系统分配的CPU时间片，当run方法执行完毕后，该线程就处于终止状态了。</p>
<h3 id="监视器锁"><a class="header-anchor" href="#监视器锁">¶</a>监视器锁</h3>
<p>在具体探究线程状态流转前，首先需要明确一个**监视器锁（monitor）**的概念，每个对象（包括Class）都持有一个monitor锁，因为每个对象都属于共享资源，多线程读写一个对象的属性，必然面临并发问题。</p>
<h3 id="线程的终止"><a class="header-anchor" href="#线程的终止">¶</a>线程的终止</h3>
<p>有三种方式：stop、interrupt和设置条件变量。</p>
<ol>
<li>stop<br>
不推荐</li>
<li>interrupt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置条件变量<br>
创建线程任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class StopTest implements Runnable &#123;</span><br><span class="line">    boolean isStop;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while(! isStop) &#123;</span><br><span class="line">            System.out.println(&quot;running...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;stop...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当想要终止该线程时，设置条件变量为true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StopTest s = new StopTest();</span><br><span class="line">Thread t = new Thread(s);</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">s.setStop(true);</span><br></pre></td></tr></table></figure>
<h3 id="wait-notify-线程等待与通知"><a class="header-anchor" href="#wait-notify-线程等待与通知">¶</a>wait / notify 线程等待与通知</h3>
<ul>
<li>在调用具体共享对象的 wait 或者 notify 系列函数前要先获取共享对象的锁；</li>
<li>notify和notifyAll的区别；</li>
<li>由于线程<strong>虚假唤醒</strong>的存在，一定要使用循环检查的方式。</li>
</ul>
<p>当一个线程调用一个共享对象的 wait() 方法时候，调用线程会被阻塞<strong>挂起</strong>，直到下面几个事情之一发生才返回：</p>
<ol>
<li>其它线程调用了该共享对象的 notify() 或者 notifyAll() 方法；</li>
<li>其它线程调用了该线程的 interrupt() 方法设置了该线程的中断标志，该线程会抛出 InterruptedException 异常返回。</li>
</ol>
<p>wait / notify方法签名：</p>
<ul>
<li>void wait()</li>
<li>void wait(long timeout)<br>
该方法相比 wait() 方法多一个超时参数，不同在于如果一个线程调用了共享对象的该方法挂起后，如果没有在指定的 timeout ms 时间内被其它线程调用该共享变量的 notify() 或者 notifyAll() 方法唤醒，那么该函数还是会因为超时而返回。<br>
需要注意的是如果在调用该函数时候 timeout 传递了负数会抛出 IllegalArgumentException 异常。</li>
<li>void wait(long timeout, int nanos)<br>
内部是调用 wait(long timeout)，如下代码：只是当 nanos&gt;0 时候让参数一递增1。</li>
<li>void notify()<br>
一个线程调用共享对象的 notify() 方法后，会唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程，一个共享变量上可能会有多个线程在等待，具体唤醒哪一个等待的线程是随机的。<br>
另外被唤醒的线程不能马上从 wait 返回继续执行，它必须获取了共享对象的监视器后才可以返回,也就是唤醒它的线程释放了共享变量上面的监视器锁后，被唤醒它的线程也不一定会获取到共享对象的监视器，这是因为该线程还需要和其它线程一块竞争该锁，只有该线程竞争到了该共享变量的监视器后才可以继续执行。<br>
类似 wait 系列方法，只有当前线程已经获取到了该共享变量的监视器锁后，才可以调用该共享变量的 notify() 方法，否者会抛出 <code>IllegalMonitorStateException</code> 异常。</li>
<li>void notifyAll()<br>
不同于 nofity() 方法在共享变量上调用一次就会唤醒在该共享变量上调用 wait 系列方法被挂起的一个线程，notifyAll() 则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li>
</ul>
<p>可以通过synchronized关键字获取监视器锁，需要注意，如果调用 wait() 方法的线程没有事先获取到该对象的<strong>监视器锁</strong>，则调用 wait() 方法时候调用线程会抛出 IllegalMonitorStateException 异常。</p>
<p>例1 - 获取监视器锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用同步代码块</span><br><span class="line">synchronized（共享变量）&#123;</span><br><span class="line">    //doSomething</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用同步方法</span><br><span class="line">synchronized void add(int a,int b)&#123;</span><br><span class="line">    //doSomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是一个线程可以从挂起状态变为可以运行状态（也就是被唤醒）即使该线程没有被其它线程调用 notify()，notifyAll() 进行通知，或者被中断，或者等待超时，这就是所谓的<strong>虚假唤醒</strong>。<br>
虽然虚假唤醒在应用实践中很少发生，但是还是需要防范于未然的，做法就是不停的去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中去调用 wait() 方法进行防范，退出循环的条件是条件满足了唤醒该线程。</p>
<p>例2 - 防止虚假唤醒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (条件不满足)&#123;</span><br><span class="line">        obj.wait();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码为经典的调用共享变量 wait() 方法的实例，首先通过同步块获取 obj 上面的监视器锁，然后通过 while 循环内调用 obj 的 wait() 方法。</p>
<p>另外当一个线程调用了共享变量的 wait() 方法后该线程会被挂起，同时该线程会暂时释放对该共享变量监视器的持有，直到另外一个线程调用了共享变量的 notify() 或者 notifyAll() 方法才有可能会重新获取到该共享变量的监视器的持有权（这里说有可能，是因为考虑到多个线程第一次都调用了 wait() 方法，所以多个线程会竞争持有该共享变量的监视器）。</p>
<p>例3 - 生产者消费者：<br>
下面从生产者消费者例子来加深理解，如下面代码是一个生产者的例子，其中 queue 为共享变量，生产者线程在调用 queue 的 wait 方法前，通过使用 synchronized 关键字拿到了该共享变量 queue 的监视器，所以调用 wait() 方法才不会抛出 IllegalMonitorStateException 异常，如果当前队列没有空闲容量则会调用 queued 的 wait() 挂起当前线程，这里使用循环就是为了避免上面说的虚假唤醒问题，这里假如当前线程虚假唤醒了，但是队列还是没有空余容量的话，当前线程还是会调用 wait() 把自己挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//生产线程</span><br><span class="line">synchronized (queue) &#123; </span><br><span class="line"></span><br><span class="line">    //消费队列满，则等待队列空闲</span><br><span class="line">    while (queue.size() == MAX_SIZE) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            //挂起当前线程，并释放通过同步块获取的queue上面的锁，让消费线程可以获取该锁，然后获取队列里面元素</span><br><span class="line">            queue.wait(); </span><br><span class="line">        &#125; catch (Exception ex) &#123; </span><br><span class="line">            ex.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空闲则生成元素，并通知消费线程</span><br><span class="line">    queue.add(ele); </span><br><span class="line">    queue.notifyAll(); </span><br><span class="line">&#125;</span><br><span class="line">//消费线程</span><br><span class="line">synchronized (queue) &#123; </span><br><span class="line"></span><br><span class="line">    //消费队列为空</span><br><span class="line">    while (queue.size() == 0) &#123; </span><br><span class="line">        try</span><br><span class="line">            //挂起当前线程，并释放通过同步块获取的queue上面的锁，让生产线程可以获取该锁，生产元素放入队列</span><br><span class="line">            queue.wait(); </span><br><span class="line">        &#125; catch (Exception ex) &#123; </span><br><span class="line">            ex.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费元素，并通知唤醒生产线程</span><br><span class="line">    queue.take(); </span><br><span class="line">    queue.notifyAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借上述代码来说明下对调用共享变量 wait() 方法后当前线程会释放持有的共享变量的锁的理解。假如生产线程 A 首先通过 synchronized 获取到了 queue 上的锁，那么其它生产线程和所有消费线程都会被阻塞，线程 A 获取锁后发现当前队列已满会调用 queue.wait() 方法阻塞自己，然后会释放获取的 queue 上面的锁，这里考虑下为何要释放该锁？如果不释放，由于其它生产线程和所有消费线程已经被阻塞挂起，而线程 A 也被挂起，这就处于了死锁状态。这里线程 A 挂起自己后释放共享变量上面的锁就是为了打破死锁必要条件之一的<strong>持有并等待原则</strong>。关于死锁下面章节会有讲到，线程 A 释放锁后其它生产线程和所有消费线程中会有一个线程获取 queue 上的锁进而进入同步块，这就打破了死锁。</p>
<p>例4 - InterruptedException：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyInterupt &#123;</span><br><span class="line"></span><br><span class="line">    static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建线程</span><br><span class="line">        Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;---begin---&quot;);</span><br><span class="line">                    //阻塞当前线程</span><br><span class="line">                    obj.wait();</span><br><span class="line">                    System.out.println(&quot;---end---&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---begin interrupt threadA---&quot;);</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">        System.out.println(&quot;---end interrupt threadA---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">---begin---</span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	at java.lang.Object.wait(Object.java:502)</span><br><span class="line">	at com.tallate.localcache.WaitNotifyInterupt$1.run(WaitNotifyInterupt.java:15)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">---begin interrupt threadA---</span><br><span class="line">---end interrupt threadA---</span><br></pre></td></tr></table></figure>
<p>如上代码threadA调用了共享对象obj的wait()方法后阻塞挂起了自己，然后主线程在休眠1s后中断了 threadA 线程，可知中断后 threadA 在 obj.wait() 处抛出了 java.lang.IllegalMonitorStateException 异常后返回后终止。</p>
<p>例5 - notify() 和 notifyAll()的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Object resourceA = new Object();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    // 创建线程</span><br><span class="line">    Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            // 获取resourceA共享资源的监视器锁</span><br><span class="line">            synchronized (resourceA) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;threadA get resourceA lock&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;threadA begin wait&quot;);</span><br><span class="line">                    resourceA.wait();</span><br><span class="line">                    System.out.println(&quot;threadA end wait&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建线程</span><br><span class="line">    Thread threadB = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (resourceA) &#123;</span><br><span class="line">                System.out.println(&quot;threadB get resourceA lock&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;threadB begin wait&quot;);</span><br><span class="line">                    resourceA.wait();</span><br><span class="line">                    System.out.println(&quot;threadB end wait&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建线程</span><br><span class="line">    Thread threadC = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (resourceA) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;threadC begin notify&quot;);</span><br><span class="line">                // 如果有多个线程在等待，则notify只能唤醒其中一个，而notifyAll能唤醒全部</span><br><span class="line">                // resourceA.notify();</span><br><span class="line">                resourceA.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 启动线程</span><br><span class="line">    threadA.start();</span><br><span class="line">    threadB.start();</span><br><span class="line"></span><br><span class="line">    // 等待一会，让线程 A 和 B 全部执行到调用 wait 方法后在调用线程 C 的 notify 方法</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    threadC.start();</span><br><span class="line"></span><br><span class="line">    // 等待线程结束</span><br><span class="line">    threadA.join();</span><br><span class="line">    threadB.join();</span><br><span class="line">    threadC.join();</span><br><span class="line">    System.out.println(&quot;main over&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">threadA get resourceA lock</span><br><span class="line">threadA begin wait</span><br><span class="line">threadB get resourceA lock</span><br><span class="line">threadB begin wait</span><br><span class="line">threadC begin notify</span><br><span class="line">threadB end wait</span><br><span class="line">threadA end wait</span><br><span class="line">main over</span><br></pre></td></tr></table></figure>
<p>从结果来看，这次线程调度器先调度了线程A占用CPU来运行，线程A首先获取了resourceA上的锁，然后调用resourceA的wait()方法挂起当前线程并释放获取到的锁，然后线程B获取到resourceA上面的锁并调用了resourceA的wait()，此时线程B也被阻塞挂起并释放resourceA上的锁。<br>
注意线程C中的notify和notifyAll，如果调用了 notify() 方法，则会激活 resourceA 的阻塞集合里面的一个线程，如果是notifyAll则会激活所有，只是线程B先获取到了resourceA上面的锁然后从wait()方法返回，待B执行完毕后，线程A又获取到resourceA上面的锁，然后从wait()方法返回，等A也执行完毕后，由主线程打印结果。</p>
<h3 id="线程优先级"><a class="header-anchor" href="#线程优先级">¶</a>线程优先级</h3>
<p><strong>setPriority()/getPriority()</strong><br>
设置/获取线程优先级，Runnable的多个线程中优先级高的会被线程调度器优先分配时间片</p>
<h3 id="join-等待线程执行终止"><a class="header-anchor" href="#join-等待线程执行终止">¶</a>join 等待线程执行终止</h3>
<p>在项目实践时候经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程去加载资源，当多个线程全部加载完毕后在汇总处理，Thread 类中有个静态的 join 方法就可以做这个事情。<br>
前面介绍的等待通知方法是属于 Object 类的，而 join 方法则是直接在 Thread 类里面提供的，下面简单介绍其使用方法：</p>
<p>例1 - join的简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread threadOne = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;child threadOne over!&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread threadTwo = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;child threadTwo over!&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //启动子线程</span><br><span class="line">    threadOne.start();</span><br><span class="line">    threadTwo.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;wait all child thread over!&quot;);</span><br><span class="line"></span><br><span class="line">    //等待子线程执行完毕，返回</span><br><span class="line">    threadOne.join();</span><br><span class="line">    threadTwo.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;all child thread over!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2 - 线程join()时被interrupt会抛出InterruptedException：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    //线程one</span><br><span class="line">    Thread threadOne = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;threadOne begin run!&quot;);</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //获取主线程</span><br><span class="line">    final Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    //线程two</span><br><span class="line">    Thread threadTwo = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //休眠1s</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //中断主线程</span><br><span class="line">            mainThread.interrupt();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 启动子线程</span><br><span class="line">    threadOne.start();</span><br><span class="line"></span><br><span class="line">    // 延迟1s启动线程</span><br><span class="line">    threadTwo.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123; //等待线程one执行结束</span><br><span class="line">        threadOne.join();</span><br><span class="line"></span><br><span class="line">    &#125; catch(InterruptedException e)&#123;</span><br><span class="line">        System.out.println(&quot;main thread:&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sleep-线程睡眠"><a class="header-anchor" href="#sleep-线程睡眠">¶</a>sleep 线程睡眠</h3>
<ul>
<li>sleep 会让调用线程暂时让出指定时间的 CPU 执行权；</li>
<li>但是该线程所拥有的监视器资源，比如锁还是持有不让出的。</li>
</ul>
<p>当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。当指定的睡眠时间到了该函数会正常返回，线程就处于就绪状态，然后参与 CPU 的调度，当获取到了 CPU 资源就可以继续运行了。<br>
如果在睡眠期间其它线程调用了该线程的 interrupt() 方法中断了该线程,该线程会在调用 sleep 的地方抛出 InterruptedException 异常返回。</p>
<p>例1 - 线程sleep时不会释放监视器锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;-&gt; t1&quot;);</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                    System.out.println(&quot;&lt;- t1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;-&gt; t2&quot;);</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                    System.out.println(&quot;&lt;- t2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-&gt; t1</span><br><span class="line">&lt;- t1</span><br><span class="line">-&gt; t2</span><br><span class="line">&lt;- t2</span><br></pre></td></tr></table></figure>
<p>要么是线程1先获取到锁，要么是线程2，获取锁后调用sleep挂起，此时不会释放锁，体现到输出里就是二者不会出现交叉打印的情况。</p>
<h3 id="interrupt-线程中断"><a class="header-anchor" href="#interrupt-线程中断">¶</a>interrupt 线程中断</h3>
<ul>
<li>中断一个线程仅仅是设置了该线程的中断标志，也就是设置了线程里面的一个变量的值，本身是不能终止当前线程运行的。</li>
<li>一般程序里面是检查这个标志的状态来判断是否需要终止当前线程。</li>
</ul>
<p>Java 中线程中断是一种线程间协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是需要被中断的线程根据中断状态自行处理。</p>
<ul>
<li>void interrupt()<br>
中断线程，例如当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。<strong>interrupt 仅仅是设置标志，线程 A 并没有实际被中断，会继续往下执行</strong>。如果线程 A 因为调用了 <strong>wait</strong> 系列函数或者 <strong>join</strong> 方法或者 <strong>sleep</strong> 函数而被阻塞挂起，这时候线程 B 调用了线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。</li>
<li>boolean isInterrupted()<br>
检测当前线程是否被中断，如果是返回 true，否者返回 false。</li>
<li>boolean interrupted()<br>
检测当前线程是否被中断，如果是返回 true，否者返回 false，与 isInterrupted 不同的是该方法如果发现当前线程被中断后会清除中断标志。<br>
并且，该函数是 static 方法，可以通过 Thread 类直接调用。</li>
</ul>
<p>例1 - 使用 Interrupted 优雅退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run()&#123;    </span><br><span class="line">    try&#123;    </span><br><span class="line">         ....    </span><br><span class="line">         //线程退出条件，需要额外判断线程是否被中断</span><br><span class="line">         while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do) &#123;    </span><br><span class="line">             // do more work;    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">        // thread was interrupted during sleep or wait    </span><br><span class="line">    &#125; finally &#123;    </span><br><span class="line">        // cleanup, if required    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ul>
<li>什么是线程？线程和进程的关系。</li>
<li>线程几种状态之间的转换</li>
<li>线程之间如何协调</li>
<li>线程创建与运行，创建一个线程有哪几种方式？有何区别？</li>
<li>线程安全问题</li>
<li>线程通知与等待，多线程同步的基础设施。</li>
<li>线程的虚假唤醒，以及如何避免。</li>
<li>等待线程执行终止的 join 方法。想让主线程在子线程执行完毕后在做一点事情？</li>
<li>让线程睡眠的 sleep 方法，sleep 的线程会释放持有的监视器锁？</li>
<li>线程中断。中断一个线程，被中断的线程会自己终止？</li>
<li>理解线程上下文切换。线程多了一定好？</li>
<li>线程死锁，以及如何避免。</li>
<li>守护线程与用户线程。当 main 函数执行完毕，但是还有用户线程存在的时候，JVM 进程会退出？</li>
</ul>
<ol>
<li>今有线程执行synchronized(this)，另一线程后到，他们分别属于什么状态？</li>
<li>今有线程调用interrupt()，它属于什么状态？</li>
<li>当线程wait()时，也可以通过interrupt()中断，此时它不会马上抛出异常，而是会先获取锁，在得到锁后再抛出异常</li>
<li>什么情况下会发生虚假唤醒？</li>
<li>stop为什么被Deprecated了？</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  183 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="无锁栈"><a class="header-anchor" href="#无锁栈">¶</a>无锁栈</h2>
<h3 id="treiber-stack"><a class="header-anchor" href="#treiber-stack">¶</a>Treiber Stack</h3>
<h2 id="无锁队列"><a class="header-anchor" href="#无锁队列">¶</a>无锁队列</h2>
<h3 id="arrayblockingqueue-和-linkedblockingqueue"><a class="header-anchor" href="#arrayblockingqueue-和-linkedblockingqueue">¶</a>ArrayBlockingQueue 和 LinkedBlockingQueue</h3>
<h3 id="disruptor"><a class="header-anchor" href="#disruptor">¶</a>Disruptor</h3>
<ul>
<li>
<p>无锁内存队列</p>
</li>
<li>
<p>优化CPU伪共享</p>
</li>
<li>
<p>RingBuffer<br>
环形队列，使用定长数组存储，长度是2^N，可以使用位运算提升性能。<br>
无锁：无锁设计减少了竞争。<br>
预热：预先填充好任务/事件，不需要像链表那样每次添加/删除节点时去创建/回收节点，从而可以避免一定的垃圾回收。<br>
缓存行填充解决了CPU伪共享问题。</p>
</li>
<li>
<p>WorkPool<br>
存储WorkProcessor的池子，Disruptor可以通过Executor并发启动每一个WorkProcessor</p>
</li>
<li>
<p>WorkProcessor<br>
从RindBuffer消费事件/任务，并交由WorkHandler处理。</p>
</li>
<li>
<p>WorkHandler<br>
处理任务的工作者，根据任务类型委托给不同的EventHandler。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="url"><a class="header-anchor" href="#url">¶</a>URL</h2>
<ol>
<li><a href="https://leetcode-cn.com/problemset/top/" target="_blank" rel="noopener">LeetCode - 精选 TOP 面试题</a></li>
<li><a href="https://projecteuler.net/archives" target="_blank" rel="noopener">Project Euler</a></li>
<li><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=22" target="_blank" rel="noopener">ICPC Live Archive</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  74 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.programcreek.com/java-api-examples/index.php" target="_blank" rel="noopener">Java Code Examples</a></li>
<li><a href="https://blog.csdn.net/x5fnncxzq4/article/details/83110446" target="_blank" rel="noopener">Java 应用中的日志</a></li>
<li><a href="https://juejin.im/pin/5cc56f7b6fb9a02f00fc869e" target="_blank" rel="noopener">错误处理的推荐实践</a></li>
<li><a href="http://tech.it168.com/a2013/0829/1527/000001527360.shtml" target="_blank" rel="noopener">Java开发中10个最为微妙的最佳编程实践</a></li>
<li>《Effective Java》</li>
<li><a href="https://edu.aliyun.com/course/417?spm=5176.10731542.0.0.akyXwK" target="_blank" rel="noopener">阿里巴巴编码规范（Java）</a></li>
<li><a href="https://blog.csdn.net/xx326664162/article/details/52175283" target="_blank" rel="noopener">Java泛型中的PECS原则</a></li>
</ol>
<h3 id="jni"><a class="header-anchor" href="#jni">¶</a>JNI</h3>
<ol>
<li><a href="http://tldp.org/HOWTO/Program-Library-HOWTO/index.html" target="_blank" rel="noopener">Program Library HOWTO (how to create and use program libraries on Linux)</a></li>
<li><a href="https://devarea.com/java-and-cc-jni-guide/" target="_blank" rel="noopener">Java and C/C++: JNI Guide</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="索引"><a class="header-anchor" href="#索引">¶</a>索引</h2>
<h3 id="索引底层数据结构"><a class="header-anchor" href="#索引底层数据结构">¶</a>索引底层数据结构</h3>
<p>可以用于提高读写效率的数据结构很多，其中三种比较简单的如<strong>哈希表</strong>、<strong>有序数组</strong>和<strong>搜索树</strong>。<br>
<strong>哈希表</strong>的思路非常简单，在设计合理的前提下也能保证较高的效率，但是因为不是有序的，所以不适合范围查询，<strong>只适用于只有等值查询的场景</strong>。<br>
<strong>有序数组</strong>在等值查询和范围查询场景中的性能就都非常优秀，但是更新操作需要挪动后面所有的记录、成本太高，所以<strong>有序数组索引只适用于静态存储引擎</strong>。<br>
<strong>二叉树</strong>的搜索效率是最高的，但是考虑到磁盘读取速度，实际数据库中存储一般会选择<strong>N叉树</strong>结构，N取决于数据块的大小，</p>
<blockquote>
<p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的。</p>
</blockquote>
<h3 id="索引类型"><a class="header-anchor" href="#索引类型">¶</a>索引类型</h3>
<p>Mysql 支持多种索引类型，如 <strong>Btree 索引</strong>、<strong>哈希索引</strong>、<strong>全文索引</strong>等。常用的为 Btree 索引。<br>
一条索引记录包含的基本信息包括：键值(我们定义索引时指定的所有字段的值)+逻辑指针(指向数据页或者是另一索引页)。</p>
<h4 id="btree-索引和-hash-索引"><a class="header-anchor" href="#btree-索引和-hash-索引">¶</a>BTree 索引和 hash 索引</h4>
<p>索引的两种主要存储结构</p>
<ul>
<li>BTree索引：按 key 进行检索，首先从根节点进行二分查找，如果找到返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针。<br>
前者查找成功，后者查找失败。</li>
<li>hash索引：比主键为 id 为例，那么随着 id 的增长，id 对应的行，在磁盘上随机放置。 无法对范围查询进行优化。</li>
</ul>
<h4 id="聚集索引-聚簇索引-和非聚集索引"><a class="header-anchor" href="#聚集索引-聚簇索引-和非聚集索引">¶</a>聚集索引（聚簇索引）和非聚集索引</h4>
<ul>
<li>聚集索引：表数据按照索引的顺序来存储。叶子节点存储了真实的数据行，不再有另外单独的数据页。</li>
<li>非聚集索引：表数据的存储顺序与索引顺序无关。叶节点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据页一致。</li>
<li>主码索引：又称聚集主码。</li>
</ul>
<p>他们之间的区别：</p>
<ol>
<li>聚集索引不仅存储了索引的数据，还在叶子节点中存储了对应的 table 中的数据，记录的索引顺序与物理顺序相同。</li>
<li>通过聚集索引可以一次拿到自己想要的记录，而非聚集索引需要两次。</li>
</ol>
<p>myisam 使用的堆组织表 ( Heap Organize Table，HOT)，没有聚集索引的概念,使用B-tree索引的存储格式，显示都是随机顺序。<br>
innodb 表是索引组织表 ( Index Organized Table，IOT )，它的索引则是采用 clustered index 方式，因此主键会按照顺序存储，每次有记录有更新时，会重新整理更新其主键。<br>
因此无论是直接从 myisam 表转换过来的，还是后来插入的记录，显示时都会按照主键的顺序。</p>
<h3 id="b-树"><a class="header-anchor" href="#b-树">¶</a>B+树</h3>
<p>索引底层实现使用了B+tree，具有如下特点：</p>
<ul>
<li>非叶子结点的子树指针与关键字个数相同 为所有叶子结点增加一个链指针 所有关键字都在叶子结点出现</li>
<li>在 B + Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B + Tree。</li>
<li>做这个优化的目的是为了提高区间访问的性能，如下图中如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</li>
<li>索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</li>
</ul>
<p><img src="http://47.88.24.11/imgs/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E5%99%A8/B+%E6%A0%91.png" alt="B+树" title="B+树"><br>
如上图所示，最外层磁盘块 1 里有数据 17、35和指针 P1、P2、P3。<br>
P1 指针表示小于 17 的磁盘块，P2 是在 17 - 35 之间，P3 指向大于 35 的磁盘块。真实数据存在于子叶节点也就是最底下的一层 3、5、9、10、13 … 非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如 17、35。<br>
查找过程：例如搜索 28 数据项，首先加载磁盘块 1 到内存中，发生一次 I/O，用二分查找确定在 P2 指针。接着发现 28 在 26 和 30 之间，通过 P2 指针的地址加载磁盘块 3 到内存，发生第二次 I/O。<br>
用同样的方式找到磁盘块 8，发生第三次 I/O。<br>
真实的情况是，上面 3 层的 B + Tree 可以表示上百万的数据，上百万的数据只发生了三次 I/O 而不是上百万次 I/O，时间提升是巨大的。<br>
上文提到的磁盘块，那么一个磁盘块可以存储多少数据呢，每个磁盘块根据系统的不同，文件系统的不同可能会不一样大。<br>
可能是有的是 512 byte，或者 2 k。那么如果知道一个索引字段的大小是多少，就可以知道一个磁盘块上可以有多少个索引了。</p>
<h3 id="myisam存储引擎中的索引结构"><a class="header-anchor" href="#myisam存储引擎中的索引结构">¶</a>MyISAM存储引擎中的索引结构</h3>
<p><img src="http://47.88.24.11/imgs/MySQL%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="MyISAM索引结构" title="MyISAM索引结构"></p>
<ul>
<li>有单独的区域存储记录（record）；</li>
<li>主键索引和普通索引结构相同，都是非聚集索引，都存储记录的指针，实际上也可以没有PK；</li>
</ul>
<h3 id="innodb存储引擎中的索引结构"><a class="header-anchor" href="#innodb存储引擎中的索引结构">¶</a>InnoDB存储引擎中的索引结构</h3>
<p><img src="http://47.88.24.11/imgs/MySQL%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="InnoDB索引结构.png" title="InnoDB索引结构"></p>
<ul>
<li>主键索引（聚集索引）和记录存储在一起；</li>
</ul>
<blockquote>
<p>主键索引和记录存储在一起，所以又被称为聚集索引，因此InnoDB一定会有聚集索引。</p>
</blockquote>
<ul>
<li>普通索引（非聚集索引）存储主键而不是指针，通过普通索引查询时会先查询出主键，再从主键索引上二次遍历索引树；</li>
</ul>
<h3 id="最佳实践"><a class="header-anchor" href="#最佳实践">¶</a>最佳实践</h3>
<ol>
<li>InnoDB主键长度不要过长<br>
否则MySQL缓冲区有限，存储的索引与数据会减少，磁盘IO的概率会增加；同时，索引占用的磁盘空间也会增加。<br>
此时，可以新增一个无业务含义的id自增列。</li>
</ol>
<h2 id="锁"><a class="header-anchor" href="#锁">¶</a>锁</h2>
<h3 id="表锁"><a class="header-anchor" href="#表锁">¶</a>表锁</h3>
<p>现在MySQL中，除了InnoDB支持行锁外，MySQL的其他存储引擎均只使用表锁，包括MyISAM、MEMORY、MERGE等。</p>
<h4 id="表锁的优势"><a class="header-anchor" href="#表锁的优势">¶</a>表锁的优势</h4>
<ul>
<li>占用内存少<br>
行锁的数量和表中的行数成正比，非常耗内存；</li>
<li>如果业务经常需要读取表中很大一部分数据时，表锁效率会更高<br>
因为此时只涉及一个锁，而不是同时管理多个锁。</li>
<li>如果业务经常使用<code>group by</code>，表锁会更快<br>
原因同上。</li>
</ul>
<h4 id="表锁运行原理"><a class="header-anchor" href="#表锁运行原理">¶</a>表锁运行原理</h4>
<p>和读写锁类似。</p>
<ul>
<li>写时要加写锁：如果表没有锁（包括读锁和写锁），对表加写锁，否则，入写锁队列。</li>
<li>读时要加读锁：如果表没有写锁，对表加读锁，否则，入读锁队列。</li>
<li>表锁释放时：如果写锁队列和读锁队列里都有锁，写有更高的优先级，即写锁队列先出列。这么做的原因是，如果有“大查询”，可能会导致写锁被批量&quot;饿死&quot;，而写锁往往释放很快。换句话说，如果有大量并发update请求，select会等所有update请求执行完才执行。</li>
</ul>
<h4 id="查看表锁"><a class="header-anchor" href="#查看表锁">¶</a>查看表锁</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;Table%&apos;;</span><br><span class="line"></span><br><span class="line">Variable_name,Value</span><br><span class="line">&apos;Table_locks_immediate&apos;,&apos;953&apos;</span><br><span class="line">&apos;Table_locks_waited&apos;,&apos;0&apos;</span><br><span class="line">&apos;Table_open_cache_hits&apos;,&apos;28&apos;</span><br><span class="line">&apos;Table_open_cache_misses&apos;,&apos;121&apos;</span><br><span class="line">&apos;Table_open_cache_overflows&apos;,&apos;121&apos;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>Table_locks_immediate：立刻获得表锁的次数；</li>
<li>Table_locks_waited：需要等待表锁的次数，如果等待表锁的次数占比较大，说明表锁可能是潜在瓶颈。；</li>
</ul>
<h4 id="使用表锁的时机"><a class="header-anchor" href="#使用表锁的时机">¶</a>使用表锁的时机</h4>
<ul>
<li>并发插入量比较大的情况下<br>
MyISAM的索引与记录存储分离，有单独的区域存储行记录，PK是非聚集索引。<br>
MyISAM表，如果数据文件(data file)紧密存储，中间没有空闲块(free blocks)，数据总是插入到数据文件的尾部(end)，就如同追加日志一样，性能很高，此时的并发insert与select是不加锁的(lock free)，并发insert无表锁争抢（只需插入队列保证并发安全）。<br>
MyISAM表，如果数据文件(data file)中间有空洞(hole)或称之为空闲快（free blocks），上述机制会失效，直到空洞被新数据填满，又会启用不加锁机制。空洞是怎么导致的？删除或者修改数据，都可能导致空洞。当有空洞时，select和insert会有表锁冲突，无法并发。</li>
</ul>
<h2 id="事务"><a class="header-anchor" href="#事务">¶</a>事务</h2>
<h3 id="事务和锁"><a class="header-anchor" href="#事务和锁">¶</a>事务和锁</h3>
<p>在read uncommitted(未提交读)级别中，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这种也可以叫脏读，这个级别其实会导致很多问题，从性能上讲，未提交读不会比其他级别好太多，但却缺乏其他级别的好处，除非真的非常有必要，在实际中一般不使用的。<br>
mysql有个多版本控制MVCC，可以认为MVCC是行级锁的一个变种，但他在很多情况下避免了加锁操作，因此开销更低。MVCC实际上是乐观并发控制的，通过每行的记录后面保存两个隐藏的列实现，一个是创建时间，一个是删除时间，当然实际存储的不是时间值，而是版本号。<br>
MVCC只在repeatable read和read committed两个级别下工作，其他隔离级别都和MVCC不兼容，因为read uncommitted总是读到最新数据，而不是符合当前事务版本的数据行。<br>
综上所述，乐观锁是和读已提交搭配使用是可以的</p>
<h2 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h2>
<h3 id="关系数据库基本结构"><a class="header-anchor" href="#关系数据库基本结构">¶</a>关系数据库基本结构</h3>
<ol>
<li>保存位置<br>
文本文件<br>
2.存储格式<br>
B树，尽量将相关数据集中在一起，一个节点可以容纳多个值，一个节点存放在磁盘的一个扇区中，一层只需要读取一次，而B树的层数又被压缩得很低。<br>
3.索引<br>
B树本身只能根据主键进行查询，如果想要支持对某一字段的查询，就需要建立索引，也就是以某些别的字段作为关键字构造B树，储存到一个索引文件中。<br>
存在一些B树索引操作库，比如C-Isam。<br>
4.其他功能</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="索引-v2"><a class="header-anchor" href="#索引-v2">¶</a>索引</h3>
<ol>
<li><a href="https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A" target="_blank" rel="noopener">数据库索引，到底是什么做的？</a></li>
<li><a href="https://blog.csdn.net/Sunmeok/article/details/82965805" target="_blank" rel="noopener">MYSQL中为什么索引不宜建在重复数据多的列上</a></li>
<li><a href="http://www.cnblogs.com/gossip/p/9237686.html" target="_blank" rel="noopener">为什么重复值高的字段不能建索引（比如性别字段等)</a></li>
</ol>
<h3 id="实现-v2"><a class="header-anchor" href="#实现-v2">¶</a>实现</h3>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html" target="_blank" rel="noopener">数据库的最简单实现</a></li>
<li><a href="https://www.reddit.com/r/Database/comments/27u6dy/how_do_you_build_a_database/ciggal8/" target="_blank" rel="noopener">how_do_you_build_a_database</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么要使用nginx"><a class="header-anchor" href="#为什么要使用nginx">¶</a>为什么要使用Nginx</h2>
<h3 id="nginx优点"><a class="header-anchor" href="#nginx优点">¶</a>Nginx优点</h3>
<ol>
<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>
<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>
<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>
<li>nginx 的设计高度模块化，编写模块相对简单</li>
<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>
<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>
<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>
<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ol>
<h3 id="nginx优点-说出原因"><a class="header-anchor" href="#nginx优点-说出原因">¶</a>Nginx优点（说出原因）</h3>
<ol>
<li>Nginx在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了Nginx的可移植性。</li>
<li>非阻塞、高并发连接：处理2-3万并发连接数，官方监测能支持5万并发</li>
<li>内存消耗小：开启10个nginx才占150M内存，Nginx采取了分阶段资源分配技术<br>
nginx处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。<br>
节省宽带：支持GZIP压缩，可以添加浏览器本地缓存<br>
稳定性高：宕机的概率非常小</li>
<li>master/worker结构：一个master进程，生成一个或者多个worker进程<br>
接收用户请求是异步的：浏览器将请求发送到nginx服务器，它先将用户请求全部接收下来，再一次性发送给后端web服务器，极大减轻了web服务器的压力<br>
一边接收web服务器的返回数据，一边发送给浏览器客户端<br>
网络依赖性比较低，只要ping通就可以负载均衡<br>
可以有多台nginx服务器</li>
<li>事件驱动：通信机制采用epoll模型</li>
</ol>
<h3 id="apache优点"><a class="header-anchor" href="#apache优点">¶</a>Apache优点</h3>
<ol>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 超稳定</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<h3 id="nginx和apache区别总结"><a class="header-anchor" href="#nginx和apache区别总结">¶</a>Nginx和Apache区别总结</h3>
<p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程<br>
一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。<br>
更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>
<h2 id="使用nginx"><a class="header-anchor" href="#使用nginx">¶</a>使用Nginx</h2>
<h3 id="手动安装nginx"><a class="header-anchor" href="#手动安装nginx">¶</a>手动安装Nginx</h3>
<ol>
<li>配置<br>
创建目录<code>/var/temp/nginx</code><br>
这个目录保存临时文件，在安装配置中指定：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure>
<ol>
<li>配置环境变量<br>
在<code>/etc/profile</code>中编辑，这样就可以直接使用nginx命令启动了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure>
<ol>
<li>启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line"># 指定配置文件</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（–conf-path= 指向配置文件（nginx.conf））</p>
<ol>
<li>停止</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop # 相当于先查出nginx进程id再kill</span><br><span class="line">nginx -s quit # 建议使用，这种方法是等nginx进程的任务处理完毕后再停止</span><br></pre></td></tr></table></figure>
<ol>
<li>重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>要想在修改配置文件nginx.conf后生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h3 id="开机自启"><a class="header-anchor" href="#开机自启">¶</a>开机自启</h3>
<ol>
<li>创建<code>/etc/init.d/nginx</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&apos;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<ol>
<li>设置文件访问权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<ol>
<li>设置开机加载<br>
在<code>/etc/rc.local</code>中加入一行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure>
<h3 id="通过docker运行nginx"><a class="header-anchor" href="#通过docker运行nginx">¶</a>通过Docker运行Nginx</h3>
<p>手动进行Nginx配置十分繁琐，可以使用Docker来简化部署流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<h2 id="优化linux最大连接数"><a class="header-anchor" href="#优化linux最大连接数">¶</a>优化Linux最大连接数</h2>
<h3 id="查看linux连接数"><a class="header-anchor" href="#查看linux连接数">¶</a>查看Linux连接数</h3>
<p>默认配置下，Linux只支持有限的连接数。<br>
Linux的线程其实是一个进程，所以java的也是，具体来说，叫做“light weight process(LWP)”—轻量级进程。<br>
LWP与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个LWP，这样它们共享大部分资源；LWP有它自己的进程标识符，并和其他进程有着父子关系；。LWP由内核管理并像普通进程一样被调度<br>
使用以下命令可以看到某个用户使用了多少进程资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep xjjbot(uid)  | wc -l</span><br></pre></td></tr></table></figure>
<p>使用下面命令可以查看具体每个进程开启了多少线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u xjjbot(uid)  | sort -n</span><br></pre></td></tr></table></figure>
<p>根据linux一切都是文件的规则，首先想到的，是修改ulimit的参数，然而也不是，因为它已经足够大了。交叉回想一下elasticsearch，在安装的时候，需要配置一个叫做nproc的东西，问题大概就出在这，是进程资源不够用啦。<br>
相关的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>在不同的内核版本上，也有一些小差异。比如：/etc/security/limits.d/*<br>
下的文件，会在某些时候覆盖limits.conf的配置。所以配置不生效的情况下，记得检查一下。<br>
鉴于以上原因，可以将limits.d中的配置全部注释掉，统一在limits.conf中配置。<br>
以下是原始配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<p>将4096改为大点的数字，或者直接改成unlimited就可以了。</p>
<p>单机支持100万连接是可行的，但带宽问题会成为显著的瓶颈。启用压缩的二进制协议会节省部分带宽，但开发难度增加。</p>
<h3 id="操作系统优化"><a class="header-anchor" href="#操作系统优化">¶</a>操作系统优化</h3>
<p>更改进程最大文件句柄数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1048576</span><br></pre></td></tr></table></figure>
<p>复制代码修改单个进程可分配的最大文件数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2097152 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>
<p>复制代码修改/etc/security/limits.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   soft nofile  1048576</span><br><span class="line">*   hard nofile 1048576</span><br><span class="line">*   soft nproc unlimited</span><br><span class="line">root soft nproc unlimited</span><br></pre></td></tr></table></figure>
<p>复制代码记得清理掉/etc/security/limits.d/*下的配置</p>
<h3 id="网络优化"><a class="header-anchor" href="#网络优化">¶</a>网络优化</h3>
<p>打开/etc/sysctl.conf，添加配置然后执行，使用sysctl生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#单个进程可分配的最大文件数</span><br><span class="line">fs.nr_open=2097152</span><br><span class="line"></span><br><span class="line">#系统最大文件句柄数</span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line">#backlog 设置</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">net.core.netdev_max_backlog=16384</span><br><span class="line"></span><br><span class="line">#可用知名端口范围配置</span><br><span class="line">net.ipv4.ip_local_port_range=&apos;1000 65535&apos;</span><br><span class="line"></span><br><span class="line">#TCP Socket 读写 Buffer 设置</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.optmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=&apos;1024 4096 16777216&apos;</span><br><span class="line">net.ipv4.tcp_wmem=&apos;1024 4096 16777216&apos;</span><br><span class="line"></span><br><span class="line">#TCP 连接追踪设置</span><br><span class="line">net.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait=30</span><br><span class="line"></span><br><span class="line">#TIME-WAIT Socket 最大数量、回收与重用设置</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line"></span><br><span class="line"># FIN-WAIT-2 Socket 超时设置</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure>
<h2 id="接入层演进"><a class="header-anchor" href="#接入层演进">¶</a>接入层演进</h2>
<p>通过研究接入层的发展历程，我们可以一窥Nginx在互联网架构中的地位。</p>
<h3 id="接入层结构"><a class="header-anchor" href="#接入层结构">¶</a>接入层结构</h3>
<p><img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%85%A5%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="接入层结构" title="接入层结构"><br>
可以看到，每一个下游都有多个上游调用，只需要做到，<strong>每一个上游都均匀访问每一个下游</strong>，就能实现整体的均匀分摊。</p>
<ol>
<li>客户端层-&gt;反向代理层<br>
DNS轮询<br>
DNS-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问DNS-server，会轮询返回这些ip，保证每个ip的解析概率是相同的。这些ip就是nginx的外网ip，以做到每台nginx的请求分配也是均衡的。</li>
<li>反向代理层-&gt;站点层<br>
反向代理层到站点层的负载均衡，是通过“nginx”实现的。<br>
修改nginx.conf，可以实现多种均衡策略：<br>
2.1 请求轮询：和DNS轮询类似，请求依次路由到各个web-server；<br>
2.2 最少连接路由：哪个web-server的连接少，路由到哪个web-server；<br>
2.3 ip哈希：按照访问用户的ip哈希值来路由web-server，只要用户的ip分布是均匀的，请求理论上也是均匀的，ip哈希均衡方法可以做到，同一个用户的请求固定落到同一台web-server上，此策略适合有状态服务，例如session；</li>
</ol>
<blockquote>
<p>session不推荐放到站点层，后期扩展会有问题，更好的方案是放到数据层。</p>
</blockquote>
<ol start="3">
<li>站点层-&gt;服务层<br>
站点层到服务层的负载均衡，是通过“服务连接池”实现的。<br>
上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。除了负载均衡，服务连接池还能够实现故障转移、超时处理、限流限速、ID串行化等诸多功能。</li>
<li>服务层-&gt;数据层<br>
在数据量很大的情况下，由于数据层（db/cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<br>
<strong>数据的均衡</strong>是指：水平切分后的每个服务（db/cache），数据量是均匀的。<br>
<strong>请求的均衡</strong>是指：水平切分后的每个服务（db/cache），请求量是均匀的。</li>
</ol>
<h3 id="接入层演进-v2"><a class="header-anchor" href="#接入层演进-v2">¶</a>接入层演进</h3>
<ol>
<li>单机架构<br>
客户端用DNS解析出来的IP就是web服务器的地址。<br>
缺点：
<ul>
<li>单点；</li>
<li>扩展性差。</li>
</ul>
</li>
<li>DNS轮询<br>
在DNS服务器上多配几个IP，由域名服务器的解析策略实现负载均衡。<br>
缺点：
<ul>
<li>非高可用，因为一个web服务器挂掉后DNS服务器仍然会将请求解析到该服务器对应的IP上；</li>
<li>扩容非实时，DNS服务器有一个配置生效的延时时间；</li>
<li>暴露太多外网IP。</li>
</ul>
</li>
<li>反向代理Nginx<br>
DNS解析到Nginx的IP，然后由Nginx将请求负载均衡到web服务器。<br>
缺点：基本解决了上一个架构存在的问题，且可以利用Nginx的探活机制实现web服务器的高可用，但是此时Nginx也会成为一个单点。</li>
<li>keepalived<br>
两台Nginx组成集群，分别部署上keepalived，设置成相同的虚IP，保证Nginx的高可用。当一台Nginx挂了，keepalived能够探测到并将流量迁移到另一台Nginx上，整个过程对调用方透明。<br>
缺点：
<ul>
<li>资源利用率低；</li>
<li>扩容不方便，如果吞吐量超过Nginx性能上线，要加机器配置起来比较麻烦。</li>
</ul>
</li>
<li>lvs/f5<br>
DNS解析出来的IP是lvs的地址。由lvs反向代理Nginx服务器，lvs的机器上部署keepalived+VIP实现高可用；<br>
f5的性能比lvs更高，但是成本也会更高。</li>
<li>DNS轮询<br>
水平扩展才是解决性能问题的根本方案，能够通过加机器扩充性能的方案才具备最好的扩展性。<br>
<img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8E%A5%E5%85%A5%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="可扩展高可用接入层架构" title="可扩展高可用接入层架构">
<ul>
<li>通过DNS轮询来线性扩展入口lvs层的性能；</li>
<li>通过keepalived保证高可用；</li>
<li>通过lvs来扩展多个Nginx；</li>
<li>通过Nginx实现对业务服务器的七层负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="nginx原理-进程"><a class="header-anchor" href="#nginx原理-进程">¶</a>Nginx原理 - 进程</h2>
<h3 id="nginx代码的模块化结构"><a class="header-anchor" href="#nginx代码的模块化结构">¶</a>Nginx代码的模块化结构</h3>
<p>Nginx的代码是由一个核心和一系列的模块组成的。<br>
<strong>核心</strong>主要用于提供 WebServer 的基本功能，以及 Web 和 Mail 反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。<br>
不过，大多跟协议相关的功能和应用特有的功能都是由 nginx 的模块实现的。<br>
换句话说， <strong>每一个功能或操作都由一个模块来实现</strong>。<br>
这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream 和负载均衡几个类别，这些共同组成了 nginx 的 http 功能。<br>
<strong>事件模块</strong>主要用于提供 OS 独立的(不同操作系统的事件机制有所不同)事件通知机制如 kqueue 或 epoll 等。<br>
<strong>协议模块</strong>则负责实现 nginx 通过 http、tls/ssl、smtp、pop3 以及 imap 与对应的客户端建立会话。<br>
在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的。<br>
换句话说，每一个功能或操作都由一个模块来实现。例如：压缩、通过 FastCGI 或 uwsgi 协议与 upstream 服务器通信、以及与 memcached 建立会话等。</p>
<h3 id="进程结构"><a class="header-anchor" href="#进程结构">¶</a>进程结构</h3>
<p>一个Nginx服务器实例由一个master进程和多个worker进程组成。<br>
<img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"><br>
<strong>master</strong>进程主要用来管理worker进程，还有一些对整个服务器的初始化和日志记录等工作。<br>
<strong>管理worker的过程</strong>：接收来自外界的信号，向各 worker 进程发送 <strong>信号</strong> ，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动（fork）新的 worker 进程。</p>
<p><strong>master主要功能</strong>：</p>
<ul>
<li>读取并验证配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止 worker 进程及维护 worker 进程的个数；</li>
<li>无须中止服务而重新配置工作；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式 perl 脚本</li>
</ul>
<p>对请求的实际处理由 <strong>worker</strong> 负责，且每个请求只能由一个 worker 负责（一对一）。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。</p>
<p><strong>worker主要功能</strong>：</p>
<ul>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx 任何能完成的其它任务</li>
</ul>
<h3 id="nginx的启动"><a class="header-anchor" href="#nginx的启动">¶</a>Nginx的启动</h3>
<p>nginx 启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程（你可以理解为工人和管理员）。</p>
<h3 id="nginx处理连接过程"><a class="header-anchor" href="#nginx处理连接过程">¶</a>Nginx处理连接过程</h3>
<p>nginx 不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的 <strong>循环</strong> 来处理数千个连接。<br>
Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。 <strong>监听套接字</strong> 在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。</p>
<p>一次请求过程大概执行过程为：</p>
<ol>
<li>nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面先初始化好这个监控的socket，再进行listen（listenfd）；</li>
<li>由master进程 fork 出多个 worker 进程；</li>
<li>此时客户端可以向nginx发起连接了，客户端会与nginx进行三次握手（TCP），与nginx建立好一个连接；</li>
<li>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接</li>
<li>当一个 worker 进程在 accept 这个连接之后，然后创建nginx对连接的封装，即ngx_connection_t结构体，就开始读取请求、解析请求、处理请求（ <strong>异步非阻塞</strong> ），主要是根据事件调用相应的事件处理模块，如http模块与客户端进行数据的交换</li>
<li>产生数据后，再返回给客户端，最后才断开连接，或者由客户端主动关闭连接。</li>
</ol>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h3>
<p>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的，其原理是<strong>信号机制</strong>，master对worker进程采用信号进行控制。</p>
<h3 id="事件驱动"><a class="header-anchor" href="#事件驱动">¶</a>事件驱动</h3>
<p>所谓<strong>事件驱动</strong>架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会“消费”这些事件。nginx不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。<br>
传统web服务器（如Apache）的所谓事件局限在TCP连接建立、关闭上，其他读写都不再是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu等资源。并且把一个进程或线程作为事件消费者。 传统Web服务器每个事件消费者独占一个进程资源，相对来说，Nginx只是被事件分发者进程短期调用而已。<br>
nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限，多少个worker就能处理多少个并发，那么何来的高并发呢？<br>
其实，Nginx是采用了<strong>异步非阻塞</strong>的IO模型来处理请求的（epoll），异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。<br>
请求的<strong>多阶段异步处理</strong>只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll等）来触发。比如一个http请求可以分为七个阶段。<br>
每种事件都有一个事件队列，按触发的先后顺序处理。</p>
<h3 id="惊群现象"><a class="header-anchor" href="#惊群现象">¶</a>惊群现象</h3>
<p>惊群是多个子进程在同一时刻监听同一个端口引起的；<br>
Nginx解决方法：同一个时刻只能有唯一一个worker子进程监听web端口，此时新连接事件只能唤醒唯一正在监听端口的worker子进程。这可以通过锁或互斥量实现。</p>
<h3 id="为什么不使用多线程？"><a class="header-anchor" href="#为什么不使用多线程？">¶</a>为什么不使用多线程？</h3>
<ul>
<li>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配cpu和内存（线程要比进程小的多，所以worker支持比perfork高的并发），并发过大会榨干服务器资源。</li>
<li>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置Nginx主进程的工作进程的数量）(epoll)，不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。</li>
</ul>
<h2 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h2>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.shiyanlou.com/courses/95" target="_blank" rel="noopener">Linux Web运维（Nginx）实战 </a></li>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx开发从入门到精通</a></li>
<li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">nginx documentation</a></li>
</ol>
<h3 id="nginx原理"><a class="header-anchor" href="#nginx原理">¶</a>Nginx原理</h3>
<ol>
<li><a href="https://segmentfault.com/q/1010000003901360?_ea=416091" target="_blank" rel="noopener">Nginx内部有使用多线程吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1）</a></li>
</ol>
<h3 id="模块-v2"><a class="header-anchor" href="#模块-v2">¶</a>模块</h3>
<ol>
<li>log<br>
<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">Module ngx_http_log_module</a><br>
<a href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html#log_format" target="_blank" rel="noopener">Module ngx_stream_log_module</a><br>
<a href="http://blog.chinaunix.net/uid-29179844-id-4433640.html" target="_blank" rel="noopener">nginx日志格式及自定义日志配置</a></li>
<li>proxy<br>
<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">Module ngx_http_proxy_module</a></li>
<li>TCP / UDP<br>
<a href="http://nginx.org/en/docs/stream/stream_processing.html" target="_blank" rel="noopener">How nginx processes a TCP/UDP session</a></li>
</ol>
<h3 id="tengine"><a class="header-anchor" href="#tengine">¶</a>Tengine</h3>
<ol>
<li><a href="http://tengine.taobao.org/documentation.html" target="_blank" rel="noopener">Documentation</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
