<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="url"><a class="header-anchor" href="#url">¶</a>URL</h2>
<ol>
<li><a href="https://leetcode-cn.com/problemset/top/" target="_blank" rel="noopener">LeetCode - 精选 TOP 面试题</a></li>
<li><a href="https://projecteuler.net/archives" target="_blank" rel="noopener">Project Euler</a></li>
<li><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=22" target="_blank" rel="noopener">ICPC Live Archive</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/0.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/0.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T10:52:33+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/96760946.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/96760946.html" itemprop="url">分布式系统基础总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-02T11:20:06+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="http://web.mit.edu/6.033/www/" target="_blank" rel="noopener">6.033: Computer System Engineering</a></li>
<li><a href="https://pdos.csail.mit.edu/6.824/" target="_blank" rel="noopener">6.824: Distributed Systems</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3a140985.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/3a140985.html" itemprop="url">异步任务和同步策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T23:54:49+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用锁来同步线程"><a class="header-anchor" href="#使用锁来同步线程">¶</a>使用锁来同步线程</h2>
<h3 id="线程同步和锁"><a class="header-anchor" href="#线程同步和锁">¶</a>线程同步和锁</h3>
<p>线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。<br>
线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：</p>
<ul>
<li>内存<br>
共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（Atomic）、阻塞队列（BlockingQueue）等。</li>
<li>磁盘<br>
共享文件、消息队列等。</li>
<li>网络<br>
Socket等。</li>
</ul>
<p>像Java中Thread的wait、notify的实现基本也可以使用内存共享来解释，只不过它们是native方法，实现由平台说了算；volatile关键字不能算是同步机制，因为它实际上无法保证线程安全性。</p>
<h3 id="乐观锁和悲观锁"><a class="header-anchor" href="#乐观锁和悲观锁">¶</a>乐观锁和悲观锁</h3>
<p>乐观锁和悲观锁是在数据库中使用的名词。</p>
<ul>
<li>悲观锁<br>
悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，数据库中实现是对数据记录操作前给记录加<strong>排它锁</strong>。如果获取锁失败，则说明数据正在被其它线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>
使用悲观锁的一个常用的例子： <code>select * from 表 where .. for update;</code>。</li>
<li>乐观锁<br>
乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。具体说是根据 update 返回的行数让用户决定如何去做。<br>
例如：<code>update 表 set comment='***',status='operator',version=version+1 where version = 1 and id = 1;</code><br>
乐观锁并不会使用数据库提供的锁机制，一般在表添加 version 字段或者使用业务状态来做。乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。</li>
</ul>
<h3 id="死锁"><a class="header-anchor" href="#死锁">¶</a>死锁</h3>
<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p>
<h4 id="死锁产生的条件"><a class="header-anchor" href="#死锁产生的条件">¶</a>死锁产生的条件</h4>
<p>死锁的产生必须满足以下4个必要条件：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其它进行请求获取该资源，则请求者只能等待，直至占有资源的线程用毕释放。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源；T1 正在等待 T2 占用的资源，……Tn正在等待已被 T0 占用的资源。</li>
</ul>
<p>举个形象的例子，两辆车在窄道上相向而行，他们占着道不肯退开，又希望对方能让开，最终形成了死锁。<br>
例1 - 死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程A：</span><br><span class="line">synchronized(resourceA) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceB) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程B：</span><br><span class="line">synchronized(resourceB) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceA) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先资源 resourceA 和 resourceB 都是互斥资源，当线程 A 调用 synchronized(resourceA) 获取到 resourceA 上的监视器锁后释放前，线程 B 在调用 synchronized(resourceA) 尝试获取该资源会被阻塞，只有线程 A 主动释放该锁，线程 B 才能获得，这满足了<strong>资源互斥条件</strong>。<br>
线程 A 首先通过 synchronized(resourceA) 获取到 resourceA 上的监视器锁资源，然后通过 synchronized(resourceB) 等待获取到 resourceB 上的监视器锁资源，这就满足了<strong>持有并等待</strong>。<br>
线程 A 在获取 resourceA 上的监视器锁资源后，不会被线程 B 掠夺走，只有线程 A 自己主动释放 resourceA 的资源时候，才会放弃对该资源的持有权，这满足了资源的<strong>不可剥夺条件</strong>。<br>
线程 A 持有 objectA 资源并等待获取 objectB 资源，而线程 B 持有 objectB 资源并等待 objectA 资源，这满足了<strong>循环等待条件</strong>。<br>
所以线程 A 和 B 就形成了死锁状态。</p>
<h4 id="死锁避免"><a class="header-anchor" href="#死锁避免">¶</a>死锁避免</h4>
<p>要想避免死锁，需要破坏构造死锁必要条件的至少一个即可，但是目前只有持有并等待和循环等待是可以被破坏的。<br>
其实，实现死锁避免最简单的方案就是控制资源申请的有序性。</p>
<h3 id="阻塞锁"><a class="header-anchor" href="#阻塞锁">¶</a>阻塞锁</h3>
<p>阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。<br>
JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有：synchronized 关键字（其中的重量锁）, ReentrantLock, Object.wait() / notify(), LockSupport.park() / unpart()</p>
<p>阻塞锁的优势在于，阻塞的线程不会占用cpu时间，不会导致 CPU 占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。<br>
在竞争激烈的情况下阻塞锁的性能要明显高于自旋锁。<br>
理想的情况：在线程竞争不激烈的情况下使用自旋锁，竞争激烈的情况下使用阻塞锁。</p>
<h3 id="独占锁和共享锁"><a class="header-anchor" href="#独占锁和共享锁">¶</a>独占锁和共享锁</h3>
<p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁分为独占锁和共享锁。<br>
独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock 就是以独占方式实现的。共享锁则同时有多个线程可以持有，例如 ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。<br>
独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其它线程必须等待当前线程释放锁才能进行读取。<br>
共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<h3 id="公平性"><a class="header-anchor" href="#公平性">¶</a>公平性</h3>
<p>锁有公平和非公平之分：</p>
<ul>
<li>公平锁：每个线程按调用lock的顺序来获取锁，不可插队；</li>
<li>非公平锁：每个线程获取锁的顺序不确定，存在插队的问题。</li>
</ul>
<p>平时使用的 ReentrantLock 默认的lock()就是非公平锁，它会先尝试用CAS获取一次锁，若获取不到才进入一个队列等待锁的释放。<br>
Semaphore中，tryAcquire是非公平的而acquire是公平的。<br>
在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。</p>
<h3 id="可重入性"><a class="header-anchor" href="#可重入性">¶</a>可重入性</h3>
<p>当一个线程要获取一个被其它线程持有的独占锁时候，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限制次数（高级篇我们会知道严格来说是有限次数）进入被该锁锁住的代码。</p>
<h4 id="可重入锁原理"><a class="header-anchor" href="#可重入锁原理">¶</a>可重入锁原理</h4>
<p>可重入锁的原理是在锁内部维护了一个线程标示，用来标示该锁目前被那个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其它线程在获取该锁时候发现锁的所有者不是自己就会被阻塞挂起。<br>
但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己，就会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为 null，这时候阻塞的线程会获取被唤醒来竞争获取该锁。</p>
<h4 id="synchronized-监视器锁-是可重入的"><a class="header-anchor" href="#synchronized-监视器锁-是可重入的">¶</a>synchronized（监视器锁）是可重入的</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reentrantlock是可重入的"><a class="header-anchor" href="#reentrantlock是可重入的">¶</a>ReentrantLock是可重入的</h4>
<blockquote>
<p>废话，名字里Reentrant就是可重入的意思。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h4 id="reentrantreadwritelock"><a class="header-anchor" href="#reentrantreadwritelock">¶</a>ReentrantReadWriteLock</h4>
<p>加锁分三种情况：</p>
<ul>
<li>
<p>读锁本身定义就支持重入；</p>
</li>
<li>
<p>写锁支持重入</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读锁和写锁同时使用会死锁</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.readLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抢占"><a class="header-anchor" href="#抢占">¶</a>抢占</h3>
<p>TODO</p>
<h3 id="spinlock-自旋锁"><a class="header-anchor" href="#spinlock-自旋锁">¶</a>SpinLock（自旋锁）</h3>
<p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class SpinLock &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; sign = new AtomicReference&lt;&gt;();</span><br><span class="line">    public void lock()&#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        // 当sign的值为null时才设置为current</span><br><span class="line">        while(!sign .compareAndSet(null, current))&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock ()&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        sign .compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LockTest &#123;</span><br><span class="line">    SpinLock spinLock = new SpinLock();</span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。<br>
但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。<br>
如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。<br>
该例子为非公平锁，获得锁的先后顺序不会按照进入lock的先后顺序进行。</p>
<h3 id="锁算法-clhlock-craig-landin-and-hagersten-locks"><a class="header-anchor" href="#锁算法-clhlock-craig-landin-and-hagersten-locks">¶</a>锁算法 - CLHLock（Craig, Landin, and Hagersten locks）</h3>
<p>使用链表协调每个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CLHLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class CLHNode &#123;</span><br><span class="line">        // 刚开始当前线程是锁住的</span><br><span class="line">        private volatile Thread isLocked;</span><br><span class="line">        // boolean方案、private volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile CLHNode tail;</span><br><span class="line">    private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;();</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        CLHNode node = new CLHNode();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        // 原子更新当前CLHLock对应的值，并返回旧值</span><br><span class="line">        // getAndSet使自己成为队列的尾部，同时获取其前驱节点的引用</span><br><span class="line">        // 如果是第一个调用lock的，直接返回，如果不是，则等待上一个unlock</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(this, node);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            // boolean方案：while(preNode.isLocked) &#123;&#125;</span><br><span class="line">            preNode.isLocked = Thread.currentThread();</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            preNode = null;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        CLHNode node = LOCAL.get();</span><br><span class="line">        if (!UPDATER.compareAndSet(this, node, null)) &#123;</span><br><span class="line">            // boolean方案：node.isLocked = false;</span><br><span class="line">            System.out.println(&quot;unlock\t&quot; + node.isLocked.getName());</span><br><span class="line">            LockSupport.unpark(node.isLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        node = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中注明了另一种boolean实现方案，boolean方案看起来会直观一点。</p>
<p>JUC ReentrantLock 默认内部使用的锁 即是 CLH 锁（有很多改进的地方，将自旋锁换成了阻塞锁等等）。<br>
CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O(L+n)，n个线程有n个Node，L个锁有L个tail），CLH的一种变体被应用在了JAVA并发框架中（AbstractQueuedSynchronizer.Node）。<br>
CLH在SMP系统结构下是非常有效的，但在NUMA系统结构下，每个线程有自己的内存，而CLHLock会不停地查询前驱变量，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，一种解决NUMA系统结构的思路是MCS队列锁。</p>
<h3 id="锁算法-mcslock"><a class="header-anchor" href="#锁算法-mcslock">¶</a>锁算法 - MCSLock</h3>
<p>MCSLock则是对本地变量的节点进行循环，不会出现CLHLock的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MCSLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class MCSNode &#123;</span><br><span class="line"></span><br><span class="line">        volatile MCSNode next;</span><br><span class="line">        volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;MCSNode&gt;();</span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile MCSNode queue;</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class,</span><br><span class="line">            MCSNode.class, &quot;queue&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        MCSNode currentNode = new MCSNode();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        MCSNode preNode = UPDATER.getAndSet(this, currentNode);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            while (currentNode.isLocked) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        MCSNode currentNode = NODE.get();</span><br><span class="line">        if (currentNode.next == null) &#123;</span><br><span class="line">            if (!UPDATER.compareAndSet(this, currentNode, null)) &#123;</span><br><span class="line">                while (currentNode.next == null) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.next.isLocked = false;</span><br><span class="line">            currentNode.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLH 的队列是隐式的队列，没有真实的后继结点属性。<br>
MCS 的队列是显式的队列，有真实的后继结点属性。</p>
<h3 id="锁算法-ticketlock"><a class="header-anchor" href="#锁算法-ticketlock">¶</a>锁算法 - TicketLock</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class TicketLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger serviceNum = new AtomicInteger();</span><br><span class="line">    private AtomicInteger ticketNum = new AtomicInteger();</span><br><span class="line">    private static final ThreadLocal&lt;Integer&gt; LOCAL =</span><br><span class="line">            new ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        // 得到门票</span><br><span class="line">        int myticket = ticketNum.getAndIncrement();</span><br><span class="line">        LOCAL.set(myticket);</span><br><span class="line">        // 如果当前叫票和自己的票号不同</span><br><span class="line">        while (myticket != serviceNum.get()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int myticket = LOCAL.get();</span><br><span class="line">        // compareAndSet内部会循环判断当前值是否为myticket，然后才执行赋值操作</span><br><span class="line">        serviceNum.compareAndSet(myticket, myticket + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        // TicketLock保存在主线程内，子线程每次lock拿到一张票，</span><br><span class="line">        // 此时别的线程unlock，直到票数增长到自己的票号</span><br><span class="line">        TicketLock ticketLock = new TicketLock();</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            ticketLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            ticketLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            // 线程的执行顺序和每个线程调用lock的顺序相同</span><br><span class="line">            new Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TicketLock，主要解决的是访问顺序的问题，主要的问题是在多核cpu上。<br>
缺点是每次都要查询一个serviceNum 服务号，影响性能（必须要到主内存读取，并阻止其他cpu修改）。</p>
<h3 id="互斥锁-reentrantlock"><a class="header-anchor" href="#互斥锁-reentrantlock">¶</a>互斥锁 - ReentrantLock</h3>
<h3 id="读写锁-reentrantreadwritelock"><a class="header-anchor" href="#读写锁-reentrantreadwritelock">¶</a>读写锁 - ReentrantReadWriteLock</h3>
<h3 id="条件-condition"><a class="header-anchor" href="#条件-condition">¶</a>条件 - Condition</h3>
<p>实例 - Condition的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock l = new ReentrantLock();</span><br><span class="line">// Condition相当于一个0-1信号量</span><br><span class="line">// （其实是使用了一个叫AbstractQueuedSynchronizer.Node等待队列）</span><br><span class="line">Condition c = l.newCondition();</span><br><span class="line">c.await(); // 信号量-1</span><br><span class="line">c.signal(); // 信号量+1</span><br><span class="line">c.signalAll(); // 所有信号量+1</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<p>实例 - 多线程下的缓冲区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();//锁对象  </span><br><span class="line">    final Condition notFull = lock.newCondition();//写线程条件   </span><br><span class="line">    final Condition notEmpty = lock.newCondition();//读线程条件   </span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[100];//缓存队列  </span><br><span class="line">    int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;</span><br><span class="line"></span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)//如果队列满了   </span><br><span class="line">            &#123;</span><br><span class="line">                notFull.await();//阻塞写线程  </span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;//赋值   </span><br><span class="line">            if (++putptr == items.length) &#123;</span><br><span class="line">                putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            ++count;//个数++  </span><br><span class="line">            notEmpty.signal();//唤醒读线程  </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)//如果队列为空  </span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty.await();//阻塞读线程  </span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];//取值   </span><br><span class="line">            if (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            --count;//个数--  </span><br><span class="line">            notFull.signal();//唤醒写线程  </span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程调度-和-locksupport"><a class="header-anchor" href="#线程调度-和-locksupport">¶</a>线程调度 和 LockSupport</h3>
<p>挂起和唤醒是线程调度中和锁的实现最密切的操作，juc中通过一个LockSupport来抽象这两种操作，它是创建锁和其它同步类的基础。</p>
<ul>
<li>LockSupport 类与每个使用它的线程都会关联一个许可证,默认调用LockSupport 类的方法的线程是不持有许可证的</li>
<li>LockSupport 内部使用 Unsafe 类实现</li>
</ul>
<h4 id="void-park"><a class="header-anchor" href="#void-park">¶</a>void park()</h4>
<p>如果调用 park() 的线程已经拿到了与 LockSupport 关联的<strong>permit（许可证）</strong>，则调用 LockSupport.park() 会马上返回，否者调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;begin park&quot;);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(&quot;end park&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>在其它线程调用 unpark(Thread thread)方法并且当前线程作为参数时候，调用park方法被阻塞的线程会返回；</li>
<li>其他线程调用interrupt()设置中断标识后可以返回，不会抛出InterruptedException异常；</li>
<li>由于线程的虚假唤醒也会导致阻塞的线程返回，所以调用park()最好也用循环条件判断方式。</li>
</ul>
<h3 id="锁实现的基础-abstractqueuedsynchronizer-aqs"><a class="header-anchor" href="#锁实现的基础-abstractqueuedsynchronizer-aqs">¶</a>锁实现的基础 - AbstractQueuedSynchronizer（AQS）</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/AQS%E7%B1%BB%E5%9B%BE.png" alt="AQS类图" title="AQS类图"><br>
虽然AQS本质上是一个双向队列，是juc中大部分并发安全组件的实现基础。</p>
<p>AQS 是一个 FIFO 的双向队列，内部通过节点 <code>head</code> 和 <code>tail</code> 记录队首和队尾元素，队列元素类型为 <code>Node</code>。</p>
<ul>
<li>其中 Node 中 <code>thread</code> 变量用来存放进入 AQS 队列里面的线程；</li>
<li>Node 节点内部 <code>SHARED</code> 用来标记该线程是获取共享资源时候被阻塞挂起后放入 AQS 队列，<code>EXCLUSIVE</code> 标示线程是获取独占资源时候被挂起后放入 AQS 队列；</li>
<li><code>waitStatus</code> 记录当前线程等待状态，分别为 <code>CANCELLED</code>（线程被取消了），<code>SIGNAL</code>（线程需要被唤醒），<code>CONDITION</code>（线程在条件队列里面等待），<code>PROPAGATE</code>（释放共享资源时候需要通知其它节点）；</li>
<li><code>prev</code> 记录当前节点的前驱节点，<code>next</code> 记录当前节点后继节点。</li>
</ul>
<p>AQS 中维持了一个单一的状态信息 <code>state</code>, 可以通过 getState, setState, compareAndSetState 函数修改其值</p>
<ul>
<li>对于 ReentrantLock 的实现来说，state 可以用来表示当前线程获取锁的可重入次数；</li>
<li>对应读写锁 ReentrantReadWriteLock 来说 state 的高 16 位表示读状态也就是获取该读锁的次数，低 16 位表示获取到写锁的线程的可重入次数；</li>
<li>对于 semaphore 来说 state 用来表示当前可用信号的个数；</li>
<li>对于 FutuerTask 来说，state 用来表示任务状态（例如还没开始，运行，完成，取消）；</li>
</ul>
<blockquote>
<p>1.8版本中FutuerTask取消了对AQS的依赖，改为通过CAS跟踪状态、Treiber stack管理等待中的线程，是因为通过AQS的实现存在，这篇文章的最后提到了这个问题：<a href="https://www.jianshu.com/p/16d6f0a22111" target="_blank" rel="noopener">线程阻塞(三)，FutureTask</a>，官方有一个Bug Report：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8016247" target="_blank" rel="noopener">JDK-8016247 : ThreadPoolExecutor may interrupt the wrong task</a>。</p>
</blockquote>
<ul>
<li>对应 CountDownlatch 和 CyclicBarrie 来说 state 用来表示计数器当前的值。</li>
</ul>
<p>AQS 有个内部类 <code>ConditionObject</code> 是用来结合锁实现线程同步，ConditionObject 可以直接访问 AQS 对象内部的变量，比如 state 状态值和 AQS 队列；<br>
ConditionObject 是条件变量，每个条件变量对应着一个条件队列 (单向链表队列)，用来存放调用条件变量的 await() 方法后被阻塞的线程，如类图，这个条件队列的头尾元素分别为 <code>firstWaiter</code> 和 <code>lastWaiter</code>。</p>
<h2 id="同步工具类"><a class="header-anchor" href="#同步工具类">¶</a>同步工具类</h2>
<p>JDK1.5之前Java中如果需要令多个线程互相协作，必须使用wait/notify/join方法簇，这些API容易出错而且可扩展性差，所以后来JDK提供了更多的工具类来处理线程协作的场景。</p>
<h3 id="闭锁-countdownlatch"><a class="header-anchor" href="#闭锁-countdownlatch">¶</a>闭锁 - CountDownLatch</h3>
<p>日常开发中经常会遇到需要在主线程中开启多线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后在进行汇总的场景，在 CountDownLatch 出现之前一般都是使用线程的 join() 方法来实现，但是 join 不够灵活，不能够满足不同场景的需要。</p>
<blockquote>
<p>join相对CountDownLatch来说有以下两点劣势：<br>
调用一个线程的join后，该线程会一直被阻塞直到该线程运行完毕，而 CountDownLatch 则可以在子线程运行完毕或运行过程中递减计数器，从而让await返回。<br>
另外，使用线程池来管理线程时候一般都是直接添加一个 Runable 实例到线程池，这时就不方便再调用线程的join方法了。</p>
</blockquote>
<h4 id="类图"><a class="header-anchor" href="#类图">¶</a>类图</h4>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/CountDownLatch%E7%B1%BB%E5%9B%BE.png" alt="CountDownLatch类图" title="CountDownLatch类图"></p>
<ul>
<li>CountDownLatch是公平的，其实现基础同样是AQS。</li>
</ul>
<h4 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h4>
<p>构造方法中初始化Sync时把计数器的值赋值给了 AQS 的状态值 state，也就是这里 AQS 的状态值来表示计数器值。</p>
<h4 id="void-await"><a class="header-anchor" href="#void-await">¶</a>void await()</h4>
<p>挂起当前线程，直到下面情况之一发生时才返回：</p>
<ul>
<li>当所有线程都调用了 CountDownLatch 对象的 <code>countDown()</code> 方法后，也就是计时器值为 0 的时候；</li>
<li>其它线程调用了当前线程的 <code>interrupt()</code> 方法中断了当前线程，当前线程会抛出 InterruptedException 异常后返回</li>
</ul>
<p>CountDownLatch.await()<br>
-&gt; AbstractQueuedSynchronizer.acquireSharedInterruptibly：获取共享资源，且可中断<br>
&gt; 为什么是acquireSharedInterruptibly而不是获取独占资源的acquireInterruptibly？因为这里状态值需要的并不是非 0 即 1 的效果，而是和初始化时候指定的计数器值有关系，比如你初始化时候计数器值为 8，那么 state 的值应该就有 0 到 8 的状态，而不是只有 0 和 1 的情况下的独占效果。<br>
1. 先调用Thread.interrupted()判断一下线程的中断状态，若被中断则抛出异常<br>
1. 尝试看当前是否计数值为0，为0则直接返回，否则进入AQS的队列等待<br>
-&gt; AbstractQueuedSynchronizer.doAcquireSharedInterruptibly</p>
<h4 id="boolean-await-long-timeout-timeunit-unit"><a class="header-anchor" href="#boolean-await-long-timeout-timeunit-unit">¶</a>boolean await(long timeout, TimeUnit unit)</h4>
<p>比起await多了个返回条件：</p>
<ul>
<li>超时后返回false。</li>
</ul>
<h4 id="void-countdown"><a class="header-anchor" href="#void-countdown">¶</a>void countDown()</h4>
<p>递减计数器的值，递减后如果计数器为 0 则会唤醒所有调用 await 方法而被阻塞的线程。</p>
<p>CountDownLatch.countDown<br>
-&gt; AbstractQueuedSynchronizer.releaseShared<br>
-&gt; CountDownLatch.Sync.tryReleaseShared：循环CAS设置状态值，返回值表示当前线程是否为第一个将状态值设置为0的，当前状态值已经为0则返回false，或者当前线程成功完成cas使计数值（状态值state）减一并更新到state并返回，如果当前状态值为0返回true<br>
-&gt; AbstractQueuedSynchronizer.doReleaseShared</p>
<h4 id="long-getcount"><a class="header-anchor" href="#long-getcount">¶</a>long getCount()</h4>
<p>获取当前计数器的值，也就是AQS的state的值，一般在 debug 测试时候使用。</p>
<h4 id="实例-模拟并发请求"><a class="header-anchor" href="#实例-模拟并发请求">¶</a>实例 - 模拟并发请求</h4>
<p>如果要用Java模拟并发请求，最基本的方案就是创建多个线程然后一一启动，但是如此一来请求就会带上先后顺序了，一种解决办法是通过CountDownLatch来同步多个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">CountDownLatch end = new CountDownLatch(10);</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            start.await();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                end.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">start.countDown();</span><br><span class="line">end.await();</span><br></pre></td></tr></table></figure>
<h3 id="栅栏-cyclicbarrier"><a class="header-anchor" href="#栅栏-cyclicbarrier">¶</a>栅栏 - CyclicBarrier</h3>
<h3 id="futuretask"><a class="header-anchor" href="#futuretask">¶</a>FutureTask</h3>
<p>TODO</p>
<h3 id="completablefuture"><a class="header-anchor" href="#completablefuture">¶</a>CompletableFuture</h3>
<h3 id="guava-listenablefuture"><a class="header-anchor" href="#guava-listenablefuture">¶</a>Guava - ListenableFuture</h3>
<h3 id="semaphore"><a class="header-anchor" href="#semaphore">¶</a>Semaphore</h3>
<h3 id="phase"><a class="header-anchor" href="#phase">¶</a>Phase</h3>
<p>相对CountDownLatch和CyclicBarrier来说，Phase支持多阶段协同；</p>
<ul>
<li>Phase表示当前阶段，最多可以有(2^32 - 1)个阶段；</li>
<li>Parties表示参与此次过程的参与者（不一定是线程）数量，最多65535个。</li>
</ul>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ol>
<li>什么是 Java 中原子性操作？</li>
<li>什么是 Java 中的 CAS 操作，AtomicLong 的实现原理？</li>
<li>什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？</li>
<li>抽象同步队列 AQS (AbstractQueuedSynchronizer) 概述，AQS 是实现同步的基础组件，并发包中锁的实现底层就是使用 AQS 实现，虽然大多数开发者可能从来不会直接用到 AQS，但是知道其原理对于架构设计还是很有帮助的。</li>
<li>独占锁 ReentrantLock 原理探究，ReentrantLock 是可重入的独占锁或者叫做排它锁，同时只能有一个线程可以获取该锁，其实现分为公平与非公平的独占锁。</li>
<li>读写锁 ReentrantReadWriteLock 原理，ReentrantLock 是独占锁，同时只有一个线程可以获取该锁，而实际情况下会有写少读多的场景，显然 ReentrantLock 满足不了需求，所以 ReentrantReadWriteLock 应运而生，本文来介绍读写分离锁的实现。</li>
<li>JUC 中倒数计数器 CountDownLatch 的使用与原理分析，当需要等待多个线程执行完毕后在做一件事情时候 CountDownLatch 是比调用线程的 join 方法更好的选择，CountDownLatch 与 线程的 join 方法区别是什么？</li>
<li>JUC 中 回环屏障 CyclicBarrier 的使用与分析，它也可以实现像 CountDownLatch 一样让一组线程全部到达一个状态后再全部同时执行，但是 CyclicBarrier 可以被复用。那么 CyclicBarrier 内部的实现与 CountDownLatch 有何不同那？</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3b3d260d.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/3b3d260d.html" itemprop="url">异步任务和协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-22T21:07:49+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字节码插桩<br>
atach</p>
<p>协程<br>
arthas<br>
pinpoint</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/df2941e1.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/df2941e1.html" itemprop="url">Redis原理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-22T12:21:48+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="io模型"><a class="header-anchor" href="#io模型">¶</a>IO模型</h2>
<h3 id="为什么是nio？"><a class="header-anchor" href="#为什么是nio？">¶</a>为什么是NIO？</h3>
<p>对于优化单个server节点的网络层，多使用NIO方式，server端与client端在多次通讯的情况下使用TCP长连接维持会话，比如 Redis epoll模型，RocketMq的netty模型<br>
对于高性能Server节点，在处理好网络请求同时，还要保证server端逻辑可以快速执行完成，这就涉及到合理的数据结构与线程模型</p>
<h3 id="大key问题"><a class="header-anchor" href="#大key问题">¶</a>大Key问题</h3>
<blockquote>
<p>也可以叫大Value问题。</p>
</blockquote>
<p>大Key有两种状况：</p>
<ol>
<li>Redis中单个简单的Key存储的value很大</li>
<li>hash、set、zset、list中存储的元素过多（以万为单位）。</li>
</ol>
<p>由于Redis的单线程模型，读写大Key时服务器的耗时可能会比较长、甚至阻塞。</p>
<p>解决方案一般是能拆则拆，对于单个大Key的情况：<br>
1.1 将大Key进行分割，拆成几个小的key-value，使用multiGet获取值。<br>
这样分拆的意义是将单次操作的压力分摊到多个Redis实例上，降低对单个Redis的IO影响，而且大Key拆分之后每次只查询一部分，减小了IO阻塞的风险。<br>
为了均匀分割，可以对field进行hash并通过质数N取余，将余数加到key上面。<br>
1.2 将大Key拆分成多个key-value，并将这些存储在一个hash中，每个field代表一个具体的属性，使用hget、hmget来获取部分的value，使用hset、hmset来更新部分属性</p>
<p>对于hash、set、zset、list中存储的元素过多的情况，可以控制将field分散到多个集合内。<br>
比如以下代码将属于一个大hash内的field分散到10000个拆分后的小hash内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newHashKey = hashKey + (hash(field) % 10000)</span><br><span class="line">hset(newHashKey, field, value)</span><br><span class="line">hget(newHashKey, field)</span><br></pre></td></tr></table></figure>
<p>对于一些需要考虑顺序的场景，比如lpop、zrange，需要在hash函数上做些文章，比如按照时间来拆分。</p>
<h2 id="redis优化"><a class="header-anchor" href="#redis优化">¶</a>Redis优化</h2>
<ul>
<li>单进程单线程，无法充分发挥服务器多核cpu的性能；大流量下造成IO阻塞，同样是由于单进程单线程, cpu在处理业务逻辑的时候,网络IO被阻塞住, 造成无法处理更多的请求.<br>
多线程master + N<em>work 工作模式.master线程负责监听网络事件, 在接收到一个新的连接后, master会把新的fd注册到worker的epoll事件中, 交由worker处理这个fd的所有读写事件, 这样master线程就可以完全被释放出来接收更多的连接, 同时又不妨碍worker处理业务逻辑和IO读写.<br>
采用这种master + N</em>worker的网络层事件模型,可以实现redis性能的平行扩展. 真正的让redis在面临高并发请求时可以丛容面对.</li>
<li>维护成本高, 如果想要充分发挥服务器的所有资源包括cpu, 网络io等, 就必须建立多个instance, 但此时不可避免会增加维护成本. 拿24核服务器举例来讲, 如果部署24个单机版的instance,理论上可以实现10w*24core= 240wQPS的总体性能.但是每个 instance 有各自独立的数据,占用资源如内存也会同比上升,反过来制约一台服务器又未必能支持这么多的 instance. 如果部署24个Instance来构成单机集群, 虽然可以共享数据，但是因为节点增加, redis的状态通讯更加频繁和费时,性能也下会降很多. 并且两种方式都意味着要维护24个Instance，运维成本都会成倍增加.</li>
<li>持久化：redis提供了两种save方式 1)save触发. 2)bgsave. 当然也可以使用3)aof来实现持久化, 但是这3点都有弊端.
<ul>
<li>save: 由于是单进程单线程, redis会阻塞住所有请求, 来遍历所有redisDB, 把key-val写入dump.rdb. 如果内存数据量过大, 会造成短时间几秒到几十秒甚至更长的时间停止服务, 这种方案对于twitter, taobao等大流量的网站, 显然是不可取的.</li>
<li>bgsave: 在触发bgsave时, redis会fork自身, child进程会进入1)的处理方式,这意味着服务器内存要有一半的冗余才可以, 如今内存已变得越来越廉价, 但是对于存储海量数据的情况,内存以及服务器的成本还是不容忽视的.</li>
<li>aof: 说到持久化, redis提供的aof算是最完美的方案了, 但是有得必有失, 严重影响性能! 因为redis每接收到一条请求, 就要把命令内容完整的写到磁盘文件, 且不说频繁读写会影响磁盘寿命,写磁盘的时间足以拖垮redis整体性能 . 当然熟悉redis的开发者会想到用appendfsync等参数来调整, 但都不是完美.即使使用 SSD，性能也只是略有提升，并且性价比不高。</li>
</ul>
</li>
<li>优化jemalloc, 采用大内存页. Redis在使用内存方面可谓苛刻至极, 压缩, string转number等, 能省就省, 但是在实际生产环境中, 为了追求性能, 对于内存的使用可以适度（不至于如bgsave般浪费）通融处理, 因此AliRedis对jemalloc做了微调, 通过调整pagesize来让一次je_malloc分配更多run空间来储备更多的用户态可用内存, 同时可以减轻换页表的负载, 降低user sys的切换频率, 来提高申请内存的性能, 对jemalloc有兴趣的开发者可以参考jemalloc源码中的bin, run, chunk数据结构进行分析.</li>
</ul>
<h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2>
<h3 id="内存"><a class="header-anchor" href="#内存">¶</a>内存</h3>
<p>因为系统的内存大小有限，所以我们在使用Redis的时候可以配置Redis能使用的最大的内存大小。<br>
redis.conf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Redis最大占用内存大小</span><br><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure>
<p>通过命令修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set maxmemory 100mb</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br></pre></td></tr></table></figure>
<p>如果不设置最大内存大小或设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最大使用3GB内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/7731e967.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/7731e967.html" itemprop="url">发号器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T23:51:08+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>发号器几乎是最简单的一个中间件了，它旨在生成一个全局唯一ID，用于在业务领域内标识一个对象。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/7731e967.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/bcd62ed6.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bcd62ed6.html" itemprop="url">异步任务和常见并发问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T21:07:49+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发问题解题模型"><a class="header-anchor" href="#并发问题解题模型">¶</a>并发问题解题模型</h2>
<ol>
<li>寻找角色，每个角色对应一个独立线程；</li>
<li>寻找共享资源，每个共享资源对应一个信号量（或其他并发控制类）；</li>
<li>按场景描述进行模拟；</li>
</ol>
<h2 id="卖票问题"><a class="header-anchor" href="#卖票问题">¶</a>卖票问题</h2>
<p>一个火车站有多个窗口，它们同时卖票，而票数使用一个ticket变量进行计算，对票数有查询和修改两个操作，这两个操作不能同时进行，并且写操作可能不是原子的，两个写操作也不能同时进行</p>
<ul>
<li>使用Atom类型来保存票数，这样写之间就不需要进行同步了</li>
</ul>
<h2 id="producer-consumer"><a class="header-anchor" href="#producer-consumer">¶</a>Producer-Consumer</h2>
<p>解决生产者/消费者问题需要维护一个队列，生产者向队列添加，消费者从队列获取，同步问题出现在队列为空或满的情况，因此我们需要对队列进行同步化。<br>
为了简化问题，可以使用juc引入的BlockingQueue（阻塞队列），这种数据结构能在下面两种情况下阻塞当前线程</p>
<ul>
<li>当队列为空时，调用take或poll</li>
<li>当队列满时，调用put或offer</li>
</ul>
<p>下面是使用BlockingQueue实现的生产者/消费者代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                queue.put(&quot;Course&quot; + (i + 1));</span><br><span class="line">                System.out.println(&quot;Complete production:Course&quot; + (i + 1));</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String course = queue.take();</span><br><span class="line">                System.out.println(&quot;Complete consumption:&quot; + course);</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(2);</span><br><span class="line">        Thread t1 = new Thread(new Producer(queue));</span><br><span class="line">        Thread t2 = new Thread(new Consumer(queue));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="readers-writers"><a class="header-anchor" href="#readers-writers">¶</a>Readers-writers</h2>
<h2 id="dining-philosophers-哲学家就餐"><a class="header-anchor" href="#dining-philosophers-哲学家就餐">¶</a>Dining philosophers（哲学家就餐）</h2>
<h2 id="cigarette-smokers"><a class="header-anchor" href="#cigarette-smokers">¶</a>Cigarette smokers</h2>
<h2 id="the-dining-savages-野人就餐"><a class="header-anchor" href="#the-dining-savages-野人就餐">¶</a>The dining savages（野人就餐）</h2>
<h2 id="the-barbershop-理发师问题"><a class="header-anchor" href="#the-barbershop-理发师问题">¶</a>The barbershop（理发师问题）</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#define N 10 //最多10个顾客</span><br><span class="line">typedef struct queue&#123;</span><br><span class="line">    int nums[N];</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">&#125;queue;</span><br><span class="line">int isFull(queue *q)&#123;</span><br><span class="line">    return q-&gt;front + 1 == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">int isEmpty(queue *q)&#123;</span><br><span class="line">    return q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">//返回顾客标志</span><br><span class="line">int dequeue(queue *q)&#123;</span><br><span class="line">    if(isEmpty(q))&#123;</span><br><span class="line">        puts(&quot;error: empty!&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int num = q-&gt;nums[q-&gt;rear];</span><br><span class="line">        q-&gt;rear = (q-&gt;rear + 1) % N;</span><br><span class="line"></span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q, int num)&#123;</span><br><span class="line">    if(isFull(q))&#123;</span><br><span class="line">        puts(&quot;error: full queue!&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        q-&gt;nums[q-&gt;front] = num;</span><br><span class="line">        q-&gt;front = (q-&gt;front + 1) % N;</span><br><span class="line">        q-&gt;front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顾客每次等待，若队列已满将会被忽略</span><br><span class="line">void customerWait(semaphore *barber, int num)&#123;</span><br><span class="line">    if(barber-&gt;busy == no)&#123;</span><br><span class="line">        barber-&gt;busy = yes;</span><br><span class="line">        enqueue(&amp;barber-&gt;customers, num);</span><br><span class="line">        printf(&quot;这个顾客开始接受服务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //将当前顾客加入等待队列，似乎不是原子操作？</span><br><span class="line">        enqueue(&amp;barber-&gt;customers, num);</span><br><span class="line">        printf(&quot;加入顾客%d&quot;, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//理发师每次等待新用户，</span><br><span class="line">void barberSignal(semaphore *barber)&#123;</span><br><span class="line">    if(isEmpty(&amp;barber-&gt;customers))&#123;</span><br><span class="line">        barber-&gt;busy = no;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int num = dequeue(&amp;barber-&gt;customers);</span><br><span class="line">        printf(&quot;顾客%d开始交易&quot;, num);</span><br><span class="line">        sleep(3000);//每个顾客睡三秒</span><br><span class="line">        printf(&quot;结束交易&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    用一个主函数开启一个理发师进程，理发师进程等待新顾客，对每一个顾客sleep(3000)作为服务时间，然后signal，</span><br><span class="line">    主函数等待用户输入用户id，对每一个用户id开启一个进程，</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">semaphore barber;</span><br><span class="line">void simulate()&#123;</span><br><span class="line">    barber.busy = no;</span><br><span class="line">    barber.customers.front = barber.customers.rear = 0;</span><br><span class="line">    </span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line">        //说明是理发师</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            barberSignal(&amp;barber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int num;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">            printf(&quot;%d&quot;, num);</span><br><span class="line">            //int pid1 = fork();</span><br><span class="line">            //if(pid1 != 0)&#123;</span><br><span class="line">                //顾客进程</span><br><span class="line">                customerWait(&amp;barber, num);</span><br><span class="line">            //  printf(&quot;哈哈哈&quot;);</span><br><span class="line">            //  return ;</span><br><span class="line">            //&#125;</span><br><span class="line">            //父进程继续运行</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 10 //最多10个顾客</span><br><span class="line">/***********************信号量**************************/</span><br><span class="line">sem_t barbers;</span><br><span class="line">sem_t customers;</span><br><span class="line">sem_t mutex;</span><br><span class="line">int customerCount = 0;</span><br><span class="line"></span><br><span class="line">void haircut()&#123;</span><br><span class="line">	printf(&quot;理发师剪头中\n&quot;);</span><br><span class="line">	sleep(3);//服务时间</span><br><span class="line">&#125;</span><br><span class="line">void get_haircut()&#123;</span><br><span class="line">	sleep(3);</span><br><span class="line">&#125;</span><br><span class="line">void *barber(void *arg)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		if(customerCount == 0)&#123;</span><br><span class="line">			printf(&quot;理发师打瞌睡\n&quot;);</span><br><span class="line">			sem_wait(&amp;customers);//等顾客</span><br><span class="line">			printf(&quot;理发师被叫醒了\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sem_wait(&amp;customers);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sem_post(&amp;barbers);//唤醒理发师</span><br><span class="line">		haircut();//开始服务</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void *customer(void *arg)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		if(customerCount &gt; 0)&#123;</span><br><span class="line">			printf(&quot;顾客等理发师\n&quot;);</span><br><span class="line">			sem_wait(&amp;barbers);//等理发师	</span><br><span class="line">			</span><br><span class="line">			sem_wait(&amp;mutex);</span><br><span class="line">			customerCount--;	</span><br><span class="line">			sem_post(&amp;mutex);</span><br><span class="line">			</span><br><span class="line">			get_haircut();//接受服务			</span><br><span class="line">			printf(&quot;理完头这个顾客离开了\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void *customer_arrive(void *arg)&#123;</span><br><span class="line">	int num;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">		printf(&quot;来了一个顾客\n&quot;);</span><br><span class="line">		sem_wait(&amp;mutex);</span><br><span class="line">		if(customerCount &lt; N)&#123;//如果还有空位</span><br><span class="line">		sem_post(&amp;mutex);</span><br><span class="line">			sem_post(&amp;customers);//添加一个顾客资源</span><br><span class="line">			customerCount++;//顾客增加</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">		sem_post(&amp;mutex);</span><br><span class="line">			printf(&quot;没椅子了，顾客离开了\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void simulate()&#123;</span><br><span class="line">	pthread_t barber_t, customer_t, customer_arrive_t;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(sem_init(&amp;barbers, 0, 1) != 0)&#123;</span><br><span class="line">		printf(&quot;sem init failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(sem_init(&amp;customers, 0, 0) != 0)&#123;</span><br><span class="line">		printf(&quot;sem init failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(sem_init(&amp;mutex, 0, 1) != 0)&#123;</span><br><span class="line">		printf(&quot;sem init failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;begin barber_t\n&quot;);</span><br><span class="line">	pthread_create(&amp;barber_t, NULL, barber, NULL);</span><br><span class="line">	printf(&quot;begin customer_t\n&quot;);</span><br><span class="line">	pthread_create(&amp;customer_t, NULL, customer, NULL);</span><br><span class="line">	printf(&quot;begin customer_arrive_t\n&quot;);</span><br><span class="line">	pthread_create(&amp;customer_arrive_t, NULL, customer_arrive, NULL);</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void )&#123;</span><br><span class="line">	simulate();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://greenteapress.com/wp/semaphores/" target="_blank" rel="noopener">The Little Book of Semaphores</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b631dcab.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b631dcab.html" itemprop="url">异步任务和线程内存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T15:26:49+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>只要使用到异步功能就不得不处理并发问题，而在Java体系中，提到并发就不得不提到JMM，因为所有并发安全都是围绕内存来展开的，可以说不懂内存结构就不懂并发。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/b631dcab.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/92a28d62.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/92a28d62.html" itemprop="url">SpringCloud配置总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。<br>
Spring Cloud常常被拿来和Dubbo比较，实际上Dubbo只实现了服务治理，接入Dubbo的服务能够实现自动上下线、能通过Dubbo协议（其实Dubbo还支持其他很多协议）互联，但是Dubbo并不提供网关、配置中心、链路追踪等一系列微服务架构常用的技术，需要单独引入。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/92a28d62.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
