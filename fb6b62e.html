<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Redis,">










<meta name="description" content="¶Redis Cluster介绍 ¶Cluster 优势  线性的可扩展性：扩容即迁移槽，已有很多迁移案例； 没有合并操作：因为 Redis 中的 List 和 Set 中保存的 Value 通常是比较大的，可能会达数以百万计的元素，而它们可能被存储到了不同的 Redis 实例上，传输和合并这样的值将很容易称为一个主要的性能瓶颈； 写入安全（Write Safety）：只有在非常少见的 Maste">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis高可用方案Cluster">
<meta property="og:url" content="https://tallate.github.io/fb6b62e.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="¶Redis Cluster介绍 ¶Cluster 优势  线性的可扩展性：扩容即迁移槽，已有很多迁移案例； 没有合并操作：因为 Redis 中的 List 和 Set 中保存的 Value 通常是比较大的，可能会达数以百万计的元素，而它们可能被存储到了不同的 Redis 实例上，传输和合并这样的值将很容易称为一个主要的性能瓶颈； 写入安全（Write Safety）：只有在非常少见的 Maste">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://47.88.24.11/imgs/Redis/Cluster.png">
<meta property="og:image" content="http://47.88.24.11/imgs/Redis/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA.png">
<meta property="og:image" content="http://47.88.24.11/imgs/Redis/ConsistentHashLoadBalance.png">
<meta property="og:updated_time" content="2020-11-06T06:34:03.941Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis高可用方案Cluster">
<meta name="twitter:description" content="¶Redis Cluster介绍 ¶Cluster 优势  线性的可扩展性：扩容即迁移槽，已有很多迁移案例； 没有合并操作：因为 Redis 中的 List 和 Set 中保存的 Value 通常是比较大的，可能会达数以百万计的元素，而它们可能被存储到了不同的 Redis 实例上，传输和合并这样的值将很容易称为一个主要的性能瓶颈； 写入安全（Write Safety）：只有在非常少见的 Maste">
<meta name="twitter:image" content="http://47.88.24.11/imgs/Redis/Cluster.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/fb6b62e.html">







  <title>Redis高可用方案Cluster | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fb6b62e.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis高可用方案Cluster</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-22T12:21:48+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  15.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  69 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="redis-cluster介绍"><a class="header-anchor" href="#redis-cluster介绍">¶</a>Redis Cluster介绍</h2>
<h3 id="cluster-优势"><a class="header-anchor" href="#cluster-优势">¶</a>Cluster 优势</h3>
<ol>
<li>线性的可扩展性：扩容即迁移槽，已有很多迁移案例；</li>
<li>没有合并操作：因为 Redis 中的 List 和 Set 中保存的 Value 通常是比较大的，可能会达数以百万计的元素，而它们可能被存储到了不同的 Redis 实例上，传输和合并这样的值将很容易称为一个主要的性能瓶颈；</li>
<li>写入安全（Write Safety）：只有在非常少见的 Master 宕机的情况下，写入才会失败，并且这个失败的时间窗口不大（由一个 Slave 顶替上来）；</li>
<li>可用性（Availability）：就算有部分 Master 不可用了，它们的 Slave 仍然可以通过选举提升为 Master。</li>
</ol>
<h3 id="cluster-缺点"><a class="header-anchor" href="#cluster-缺点">¶</a>Cluster 缺点</h3>
<ol>
<li>Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同的节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误。</li>
<li>Redis 集群不像单机版本的 Redis 那样支持多个数据库，集群只有数据库 0，而且也不支持 SELECT 命令。</li>
</ol>
<h3 id="cluster的去中心化架构"><a class="header-anchor" href="#cluster的去中心化架构">¶</a>Cluster的去中心化架构</h3>
<p><img src="http://47.88.24.11/imgs/Redis/Cluster.png" alt="Cluster" title="Cluster"><br>
redis cluster在设计的时候，就考虑到了<strong>去中心化</strong>，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。<strong>所有的 redis 节点彼此互联(PING-PONG 机制)</strong>，内部使用<strong>二进制协议</strong>优化传输速度和带宽，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。客户端与 redis 节点直连，不需要中间 proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p>
<h3 id="一致性"><a class="header-anchor" href="#一致性">¶</a>一致性</h3>
<p>Redis 不能保证强一致性，因为：</p>
<ol>
<li>异步复制：写操作会被异步复制到 slave 节点，但可能由于出现网络分区、脑裂而导致数据丢失。<br>
<img src="http://47.88.24.11/imgs/Redis/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA.png" alt="网络分区" title="网络分区"><br>
如上图所示，客户端 Z1 向 Master-B 写入数据后，集群出现了网络分区，且分区持续的时间足够长导致此时 B1 被选举为新的 Master，则在此期间 Z1 向 B 写入的数据就都丢失了。</li>
</ol>
<blockquote>
<p>网络分区出现期间，客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项。</p>
</blockquote>
<h2 id="数据分布-分区-和查询路由"><a class="header-anchor" href="#数据分布-分区-和查询路由">¶</a>数据分布（分区）和查询路由</h2>
<h3 id="分区策略"><a class="header-anchor" href="#分区策略">¶</a>分区策略</h3>
<p>分区将原来比较大的数据集分离存储到多个存储媒介上，分区后Redis可以管理更大的内存空间和计算能力，但同时多主机又会面临很多分布式集群的可用性、一致性等问题。<br>
分区策略：</p>
<ol>
<li>范围分区<br>
将不同范围的对象映射到不同的Redis实例，比如用户ID为0到10000的存储到R0,10001到20000的存储到R1，以此类推。<br>
缺点是需要建立一张映射表，谨小甚微地维护ID和Redis实例之间的映射关系，而且由于需要维护表，导致效率不如其他方案。</li>
<li>散列分区<br>
使用散列函数（如CRC32）将key转换为一个数字，取模得到一个0到3的数字（假设Redis服务器有4台），这个数字即对应服务器的序号。</li>
<li>一致性哈希<br>
一致性哈希的一种示例实现可以参考Dubbo中的实现：<code>com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</code><br>
关键代码如下：<br>
<img src="http://47.88.24.11/imgs/Redis/ConsistentHashLoadBalance.png" alt="ConsistentHashLoadBalance" title="ConsistentHashLoadBalance"></li>
<li>哈希槽<br>
Redis Cluster采用的是哈希槽的方式。<br>
Redis 集群没有并使用传统的<strong>一致性哈希</strong>来分配数据，而是采用另外一种叫做<strong>哈希槽 (hash slot)<strong>的方式来分配的。redis cluster 默认分配了 16384 个 slot，当我们 set 一个 key 时，会用</strong>CRC16</strong>算法来取模得到所属的 slot，然后将这个 key 分到哈希槽区间的节点上，具体算法就是：<code>CRC16(key) % 16384</code>。所以我们在测试的时候看到 set 和 get 的时候，直接跳转到了 7000 端口的节点。<br>
客户端在接收到重定向错误（redirections errors） -MOVED 和 -ASK 的时候， 将命令重定向到其他节点。客户端不需要存储集群信息（槽所在位置），但是如何客户端可以缓存键值和节点之间的映射关系，就可以明显提高命令执行的效率了（Redisson 中就是这么做的）。<br>
在 Cluster 架构中，slave 节点不分配槽，只拥有读权限，但是在代码中 cluster 执行读写操作的都是 master 节点，并不是读就是从节点、写就是主节点。</li>
</ol>
<p>源码中，Redis采用一个大小固定为<code>CLUSTER_SLOTS</code>的clusterNode数组<code>slots</code>来保存每个桶的负责节点，这是个字节数组，每个位表示当前节点是否负责这个槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">// 节点状态</span><br><span class="line">struct clusterNode &#123;</span><br><span class="line"></span><br><span class="line">    // 创建节点的时间</span><br><span class="line">    mstime_t ctime; /* Node object creation time. */</span><br><span class="line"></span><br><span class="line">    // 节点的名字，由 40 个十六进制字符组成</span><br><span class="line">    // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff</span><br><span class="line">    char name[REDIS_CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */</span><br><span class="line"></span><br><span class="line">    // 节点标识</span><br><span class="line">    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span><br><span class="line">    // 以及节点目前所处的状态（比如在线或者下线）。</span><br><span class="line">    int flags;      /* REDIS_NODE_... */</span><br><span class="line"></span><br><span class="line">    // 节点当前的配置纪元，用于实现故障转移</span><br><span class="line">    uint64_t configEpoch; /* Last configEpoch observed for this node */</span><br><span class="line"></span><br><span class="line">    // 由这个节点负责处理的槽</span><br><span class="line">    // 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长</span><br><span class="line">    // 每个字节的每个位记录了一个槽的保存状态</span><br><span class="line">    // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理</span><br><span class="line">    // 比如 slots[0] 的第一个位保存了槽 0 的保存情况</span><br><span class="line">    // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推</span><br><span class="line">    unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */</span><br><span class="line"></span><br><span class="line">    // 该节点负责处理的槽数量</span><br><span class="line">    int numslots;   /* Number of slots handled by this node */</span><br><span class="line"></span><br><span class="line">    // 如果本节点是主节点，那么用这个属性记录从节点的数量</span><br><span class="line">    int numslaves;  /* Number of slave nodes, if this is a master */</span><br><span class="line"></span><br><span class="line">    // 指针数组，指向各个从节点</span><br><span class="line">    struct clusterNode **slaves; /* pointers to slave nodes */</span><br><span class="line"></span><br><span class="line">    // 如果这是一个从节点，那么指向主节点</span><br><span class="line">    struct clusterNode *slaveof; /* pointer to the master node */</span><br><span class="line"></span><br><span class="line">    // 最后一次发送 PING 命令的时间</span><br><span class="line">    mstime_t ping_sent;      /* Unix time we sent latest ping */</span><br><span class="line"></span><br><span class="line">    // 最后一次接收 PONG 回复的时间戳</span><br><span class="line">    mstime_t pong_received;  /* Unix time we received the pong */</span><br><span class="line"></span><br><span class="line">    // 最后一次被设置为 FAIL 状态的时间</span><br><span class="line">    mstime_t fail_time;      /* Unix time when FAIL flag was set */</span><br><span class="line"></span><br><span class="line">    // 最后一次给某个从节点投票的时间</span><br><span class="line">    mstime_t voted_time;     /* Last time we voted for a slave of this master */</span><br><span class="line"></span><br><span class="line">    // 最后一次从这个节点接收到复制偏移量的时间</span><br><span class="line">    mstime_t repl_offset_time;  /* Unix time we received offset for this node */</span><br><span class="line"></span><br><span class="line">    // 这个节点的复制偏移量</span><br><span class="line">    long long repl_offset;      /* Last known repl offset for this node. */</span><br><span class="line"></span><br><span class="line">    // 节点的 IP 地址</span><br><span class="line">    char ip[REDIS_IP_STR_LEN];  /* Latest known IP address of this node */</span><br><span class="line"></span><br><span class="line">    // 节点的端口号</span><br><span class="line">    int port;                   /* Latest known port of this node */</span><br><span class="line"></span><br><span class="line">    // 保存连接节点所需的有关信息</span><br><span class="line">    clusterLink *link;          /* TCP/IP link with this node */</span><br><span class="line"></span><br><span class="line">    // 一个链表，记录了所有其他节点对该节点的下线报告</span><br><span class="line">    list *fail_reports;         /* List of nodes signaling this as failing */</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">typedef struct clusterNode clusterNode;</span><br><span class="line"></span><br><span class="line">// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。</span><br><span class="line">// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，</span><br><span class="line">// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count </span><br><span class="line">// 也被放到了这个结构里面。</span><br><span class="line">typedef struct clusterState &#123;</span><br><span class="line"></span><br><span class="line">    // 指向当前节点的指针</span><br><span class="line">    clusterNode *myself;  /* This node */</span><br><span class="line"></span><br><span class="line">    // 集群当前的配置纪元，用于实现故障转移</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line"></span><br><span class="line">    // 集群当前的状态：是在线还是下线</span><br><span class="line">    int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */</span><br><span class="line"></span><br><span class="line">    // 集群中至少处理着一个槽的节点的数量。</span><br><span class="line">    int size;             /* Num of master nodes with at least one slot */</span><br><span class="line"></span><br><span class="line">    // 集群节点名单（包括 myself 节点）</span><br><span class="line">    // 字典的键为节点的名字，字典的值为 clusterNode 结构</span><br><span class="line">    dict *nodes;          /* Hash table of name -&gt; clusterNode structures */</span><br><span class="line"></span><br><span class="line">    // 节点黑名单，用于 CLUSTER FORGET 命令</span><br><span class="line">    // 防止被 FORGET 的命令重新被添加到集群里面</span><br><span class="line">    // （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）</span><br><span class="line">    dict *nodes_black_list; /* Nodes we don&apos;t re-add for a few seconds. */</span><br><span class="line"></span><br><span class="line">    // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点</span><br><span class="line">    // migrating_slots_to[i] = NULL 表示槽 i 未被迁移</span><br><span class="line">    // migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A</span><br><span class="line">    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点</span><br><span class="line">    // importing_slots_from[i] = NULL 表示槽 i 未进行导入</span><br><span class="line">    // importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i</span><br><span class="line">    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    // 负责处理各个槽的节点</span><br><span class="line">    // 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理</span><br><span class="line">    clusterNode *slots[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序</span><br><span class="line">    // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便</span><br><span class="line">    // 具体操作定义在 db.c 里面</span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line"></span><br><span class="line">    /* The following fields are used to take the slave state on elections. */</span><br><span class="line">    // 以下这些域被用于进行故障转移选举</span><br><span class="line"></span><br><span class="line">    // 上次执行选举或者下次执行选举的时间</span><br><span class="line">    mstime_t failover_auth_time; /* Time of previous or next election. */</span><br><span class="line"></span><br><span class="line">    // 节点获得的投票数量</span><br><span class="line">    int failover_auth_count;    /* Number of votes received so far. */</span><br><span class="line"></span><br><span class="line">    // 如果值为 1 ，表示本节点已经向其他节点发送了投票请求</span><br><span class="line">    int failover_auth_sent;     /* True if we already asked for votes. */</span><br><span class="line"></span><br><span class="line">    int failover_auth_rank;     /* This slave rank for current auth request. */</span><br><span class="line"></span><br><span class="line">    uint64_t failover_auth_epoch; /* Epoch of the current election. */</span><br><span class="line"></span><br><span class="line">    /* Manual failover state in common. */</span><br><span class="line">    /* 共用的手动故障转移状态 */</span><br><span class="line"></span><br><span class="line">    // 手动故障转移执行的时间限制</span><br><span class="line">    mstime_t mf_end;            /* Manual failover time limit (ms unixtime).</span><br><span class="line">                                   It is zero if there is no MF in progress. */</span><br><span class="line">    /* Manual failover state of master. */</span><br><span class="line">    /* 主服务器的手动故障转移状态 */</span><br><span class="line">    clusterNode *mf_slave;      /* Slave performing the manual failover. */</span><br><span class="line">    /* Manual failover state of slave. */</span><br><span class="line">    /* 从服务器的手动故障转移状态 */</span><br><span class="line">    long long mf_master_offset; /* Master offset the slave needs to start MF</span><br><span class="line">                                   or zero if stil not received. */</span><br><span class="line">    // 指示手动故障转移是否可以开始的标志值</span><br><span class="line">    // 值为非 0 时表示各个主服务器可以开始投票</span><br><span class="line">    int mf_can_start;           /* If non-zero signal that the manual failover</span><br><span class="line">                                   can start requesting masters vote. */</span><br><span class="line"></span><br><span class="line">    /* The followign fields are uesd by masters to take state on elections. */</span><br><span class="line">    /* 以下这些域由主服务器使用，用于记录选举时的状态 */</span><br><span class="line"></span><br><span class="line">    // 集群最后一次进行投票的纪元</span><br><span class="line">    uint64_t lastVoteEpoch;     /* Epoch of the last vote granted. */</span><br><span class="line"></span><br><span class="line">    // 在进入下个事件循环之前要做的事情，以各个 flag 来记录</span><br><span class="line">    int todo_before_sleep; /* Things to do in clusterBeforeSleep(). */</span><br><span class="line"></span><br><span class="line">    // 通过 cluster 连接发送的消息数量</span><br><span class="line">    long long stats_bus_messages_sent;  /* Num of msg sent via cluster bus. */</span><br><span class="line"></span><br><span class="line">    // 通过 cluster 接收到的消息数量</span><br><span class="line">    long long stats_bus_messages_received; /* Num of msg rcvd via cluster bus.*/</span><br><span class="line"></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="分区的实现层次"><a class="header-anchor" href="#分区的实现层次">¶</a>分区的实现层次</h3>
<p>分区可以在程序的不同层次实现。</p>
<ul>
<li><strong>客户端分区</strong><br>
就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li><strong>代理分区</strong><br>
意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li><strong>查询路由(Query routing)</strong><br>
意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<p>Redis Cluster采用的是<strong>查询路由</strong>的方式。<br>
在Cluster模式下，Redis接收任何命令都会首先计算键对应的桶编号，再根据桶找出所对应的节点，如果节点是自身，则处理键命令；否则回复<code>MOVED</code>重定向错误，通知客户端请求正确的节点，这个过程称为MOVED重定向。<br>
在客户端初次连接Redis集群时，如果客户端是<strong>Smart Client</strong>，它会获取集群的节点信息及slot的分布信息，并在本地缓存一份 hash slot 与node关系的路由表，这样不必每次访问服务器时都因为重定向而经过多次网络调用。<br>
redis-cli不是smart client，它没有缓存路由表的功能；Java客户端Redisson是smart client，它在初始化时会调用redis实例的<code>CLUSTER NODES</code>命令来获取集群中每个Master负责的slot范围，并启动一个定时任务来每秒刷新本地缓存的集群状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动时查询集群状态</span><br><span class="line"> */</span><br><span class="line">public ClusterConnectionManager(ClusterServersConfig cfg, Config config) &#123;</span><br><span class="line">    super(config);</span><br><span class="line"></span><br><span class="line">    this.config = create(cfg);</span><br><span class="line">    initTimer(this.config);</span><br><span class="line"></span><br><span class="line">    Throwable lastException = null;</span><br><span class="line">    List&lt;String&gt; failedMasters = new ArrayList&lt;String&gt;();</span><br><span class="line">    for (URI addr : cfg.getNodeAddresses()) &#123;</span><br><span class="line">        RFuture&lt;RedisConnection&gt; connectionFuture = connect(cfg, addr);</span><br><span class="line">        try &#123;</span><br><span class="line">            RedisConnection connection = connectionFuture.syncUninterruptibly().getNow();</span><br><span class="line">            </span><br><span class="line">            // 发送cluster nodes命令</span><br><span class="line">            </span><br><span class="line">            clusterNodesCommand = RedisCommands.CLUSTER_NODES;</span><br><span class="line">            if (&quot;rediss&quot;.equals(addr.getScheme())) &#123;</span><br><span class="line">                clusterNodesCommand = RedisCommands.CLUSTER_NODES_SSL;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;ClusterNodeInfo&gt; nodes = connection.sync(clusterNodesCommand);</span><br><span class="line">            </span><br><span class="line">            StringBuilder nodesValue = new StringBuilder();</span><br><span class="line">            for (ClusterNodeInfo clusterNodeInfo : nodes) &#123;</span><br><span class="line">                nodesValue.append(clusterNodeInfo.getNodeInfo()).append(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(&quot;Redis cluster nodes configuration got from &#123;&#125;:\n&#123;&#125;&quot;, connection.getRedisClient().getAddr(), nodesValue);</span><br><span class="line"></span><br><span class="line">            lastClusterNode = addr;</span><br><span class="line">            </span><br><span class="line">            // 读取每个节点的分区配置</span><br><span class="line">            </span><br><span class="line">            Collection&lt;ClusterPartition&gt; partitions = parsePartitions(nodes);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">            log.warn(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // 每秒定时刷新本地缓存的cluster状态，包括每个Master节点负责的slot范围</span><br><span class="line">    scheduleClusterChangeCheck(cfg, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取key所处的节点</span><br><span class="line"> */</span><br><span class="line">private NodeSource getNodeSource(String key) &#123;</span><br><span class="line">    int slot = connectionManager.calcSlot(key);</span><br><span class="line">    MasterSlaveEntry entry = connectionManager.getEntry(slot);</span><br><span class="line">    return new NodeSource(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取key所处的节点</span><br><span class="line"> */</span><br><span class="line">protected &lt;V, R&gt; void async(final boolean readOnlyMode, final NodeSource source, final Codec codec,</span><br><span class="line">    // 建立连接、发送命令</span><br><span class="line">    final RFuture&lt;RedisConnection&gt; connectionFuture;</span><br><span class="line">    if (readOnlyMode) &#123;</span><br><span class="line">        connectionFuture = connectionManager.connectionReadOp(source, command);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        connectionFuture = connectionManager.connectionWriteOp(source, command);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    connectionFuture.addListener(new FutureListener&lt;RedisConnection&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void operationComplete(Future&lt;RedisConnection&gt; connFuture) throws Exception &#123;</span><br><span class="line">            if (connFuture.isCancelled()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果执行不成功，则设置异常信息</span><br><span class="line">            if (!connFuture.isSuccess()) &#123;</span><br><span class="line">                connectionManager.getShutdownLatch().release();</span><br><span class="line">                details.setException(convertException(connectionFuture));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果执行OK，释放连接</span><br><span class="line">            if (details.getAttemptPromise().isDone() || details.getMainPromise().isDone()) &#123;</span><br><span class="line">                releaseConnection(source, connectionFuture, details.isReadOnlyMode(), details.getAttemptPromise(), details);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            final RedisConnection connection = connFuture.getNow();</span><br><span class="line">            // 响应ASK的情况</span><br><span class="line">            if (details.getSource().getRedirect() == Redirect.ASK) &#123;</span><br><span class="line">                List&lt;CommandData&lt;?, ?&gt;&gt; list = new ArrayList&lt;CommandData&lt;?, ?&gt;&gt;(2);</span><br><span class="line">                RPromise&lt;Void&gt; promise = connectionManager.newPromise();</span><br><span class="line">                list.add(new CommandData&lt;Void, Void&gt;(promise, details.getCodec(), RedisCommands.ASKING, new Object[]&#123;&#125;));</span><br><span class="line">                list.add(new CommandData&lt;V, R&gt;(details.getAttemptPromise(), details.getCodec(), details.getCommand(), details.getParams()));</span><br><span class="line">                RPromise&lt;Void&gt; main = connectionManager.newPromise();</span><br><span class="line">                ChannelFuture future = connection.send(new CommandsData(main, list));</span><br><span class="line">                details.setWriteFuture(future);</span><br><span class="line">            &#125;</span><br><span class="line">            // 响应MOVED的情况</span><br><span class="line">            else &#123;</span><br><span class="line">                if (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(&quot;acquired connection for command &#123;&#125; and params &#123;&#125; from slot &#123;&#125; using node &#123;&#125;... &#123;&#125;&quot;,</span><br><span class="line">                            details.getCommand(), Arrays.toString(details.getParams()), details.getSource(), connection.getRedisClient().getAddr(), connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ChannelFuture future = connection.send(new CommandData&lt;V, R&gt;(details.getAttemptPromise(), details.getCodec(), details.getCommand(), details.getParams()));</span><br><span class="line">                details.setWriteFuture(future);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            details.getWriteFuture().addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    checkWriteFuture(details, connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            releaseConnection(source, connectionFuture, details.isReadOnlyMode(), details.getAttemptPromise(), details);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是手动调用<code>cluster nodes</code>可以得到的响应，从中可以看到每个master所负责的slot范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hgc@hgc-X555LD:~$ redis-cli -h 10.32.64.12 -p 16371 -c</span><br><span class="line">10.32.64.12:16371&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">10.32.64.12:16371&gt; cluster nodes</span><br><span class="line">d0af93527054ae3713c6ae82f4f58e016c4968d7 10.32.64.161:16371@26371 slave dbf60db7dc4c2d8ea944481d162bf6be7ef48f5a 0 1604569999114 28 connected</span><br><span class="line">20def2dff31ba78c04f72431a51054def2120638 10.32.64.161:16372@26372 master - 0 1604569998112 31 connected 0-5460</span><br><span class="line">b0c86436cd4cf6d2240faf01b45735616b82cae8 10.32.64.12:16371@26371 myself,slave 20def2dff31ba78c04f72431a51054def2120638 0 1604569995000 30 connected</span><br><span class="line">dbf60db7dc4c2d8ea944481d162bf6be7ef48f5a 10.32.64.162:16372@26372 master - 0 1604569996000 28 connected 5461-10922</span><br><span class="line">005c670071b5dab4ef085613f0ca6666fc5bcbce 10.32.64.12:16373@26373 slave df7f690feee2ad536f2573b55190e0f8d576779e 0 1604569998000 25 connected</span><br><span class="line">df7f690feee2ad536f2573b55190e0f8d576779e 10.32.64.162:16373@26373 master - 0 1604569997000 25 connected 10923-16383</span><br></pre></td></tr></table></figure>
<p>如果Cluster发生了扩容缩容或failover导致客户端缓存的信息过期，客户端只需要MOVED时重新更新本地缓存即可。<br>
但是这里有一个问题，如果扩容缩容时正在发生槽迁移，这时正在迁移中的槽在哪个节点是不确定的，可能会导致客户端本地缓存的频繁更新。因此，Redis迁移过程中，会对正在迁移的槽打标记（<code>server.cluster-&gt;migrating_slots_to</code>），如果客户端访问的key命中了正在迁移中的槽，则服务器会返回<code>ASK</code>而不是<code>MOVED</code>，客户端接收到<code>ASK</code>后不会重新更新本地的槽缓存。<br>
代码：<code>redis.c/processCommand</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/* If cluster is enabled perform the cluster redirection here.</span><br><span class="line"> *</span><br><span class="line"> * 如果开启了集群模式，那么在这里进行转向操作。</span><br><span class="line"> *</span><br><span class="line"> * However we don&apos;t perform the redirection if:</span><br><span class="line"> *</span><br><span class="line"> * 不过，如果有以下情况出现，那么节点不进行转向：</span><br><span class="line"> *</span><br><span class="line"> * 1) The sender of this command is our master.</span><br><span class="line"> *    命令的发送者是本节点的主节点</span><br><span class="line"> *</span><br><span class="line"> * 2) The command has no key arguments. </span><br><span class="line"> *    命令没有 key 参数</span><br><span class="line"> */</span><br><span class="line">if (server.cluster_enabled &amp;&amp;</span><br><span class="line">    !(c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</span><br><span class="line">    !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0))</span><br><span class="line">&#123;</span><br><span class="line">    int hashslot;</span><br><span class="line"></span><br><span class="line">    // 集群已下线</span><br><span class="line">    if (server.cluster-&gt;state != REDIS_CLUSTER_OK) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplySds(c,sdsnew(&quot;-CLUSTERDOWN The cluster is down. Use CLUSTER INFO for more information\r\n&quot;));</span><br><span class="line">        return REDIS_OK;</span><br><span class="line"></span><br><span class="line">    // 集群运作正常</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,&amp;hashslot,&amp;error_code);</span><br><span class="line">        // 不能执行多键处理命令</span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            if (error_code == REDIS_CLUSTER_REDIR_CROSS_SLOT) &#123;</span><br><span class="line">                addReplySds(c,sdsnew(&quot;-CROSSSLOT Keys in request don&apos;t hash to the same slot\r\n&quot;));</span><br><span class="line">            &#125; else if (error_code == REDIS_CLUSTER_REDIR_UNSTABLE) &#123;</span><br><span class="line">                /* The request spawns mutliple keys in the same slot,</span><br><span class="line">                 * but the slot is not &quot;stable&quot; currently as there is</span><br><span class="line">                 * a migration or import in progress. */</span><br><span class="line">                addReplySds(c,sdsnew(&quot;-TRYAGAIN Multiple keys request during rehashing of slot\r\n&quot;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                redisPanic(&quot;getNodeByQuery() unknown error.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return REDIS_OK;</span><br><span class="line"></span><br><span class="line">        // 命令针对的槽和键不是本节点处理的，进行转向</span><br><span class="line">        &#125; else if (n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            // -&lt;ASK or MOVED&gt; &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">            // 例如 -ASK 10086 127.0.0.1:12345</span><br><span class="line">            addReplySds(c,sdscatprintf(sdsempty(),</span><br><span class="line">                &quot;-%s %d %s:%d\r\n&quot;,</span><br><span class="line">                (error_code == REDIS_CLUSTER_REDIR_ASK) ? &quot;ASK&quot; : &quot;MOVED&quot;,</span><br><span class="line">                hashslot,n-&gt;ip,n-&gt;port));</span><br><span class="line"></span><br><span class="line">            return REDIS_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果执行到这里，说明键 key 所在的槽由本节点处理</span><br><span class="line">        // 或者客户端执行的是无参数命令</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分区的缺点"><a class="header-anchor" href="#分区的缺点">¶</a>分区的缺点</h3>
<p>有些特性在分区的情况下会受到限制：</p>
<ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。<br>
同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<p>当要把Redis当作持久化存储时，需要注意分区的性质</p>
<ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，现在Redis Cluster已经支持这种再平衡。</li>
</ul>
<h2 id="节点通信"><a class="header-anchor" href="#节点通信">¶</a>节点通信</h2>
<p>Redis Cluster采用Gossip协议完成集群状态数据及路由数据等元数据的管理。<br>
一种简单的集群内状态同步思路是：每次节点都将自己本地的集群状态数据广播到集群内所有N个节点，其他节点判断接收到的数据比本地的新则更新本地数据。但是这种方式的缺点是通信量剧增，网络带宽变得紧张。<br>
因此Redis采用Gossip协议来进行集群内元数据的同步，而且：<br>
1、每次只随机选择K（K &lt;&lt; N）个其他节点来同步状态；<br>
集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout/2，则立刻发送ping消息，防止该节点信息太长时间未更新。根据以上规则得出每个节点每秒需要发送ping消息的数量=1+10*num（node.pong_received&gt;cluster_node_timeout/2），因此cluster_node_timeout参数对消息发送的节点数量影响非常大。当我们的带宽资源紧张时，可以适当调大这个参数，如从默认15秒改为30秒来降低带宽占用率。过度调大cluster_node_timeout会影响消息交换的频率从而影响故障转移、槽信息更新、新节点发现的速度。因此需要根据业务容忍度和资源消耗进行平衡。同时整个集群消息总交换量也跟节点数成正比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line">/* This is executed 10 times every second */</span><br><span class="line">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span><br><span class="line">void clusterCron(void) &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    int update_state = 0;</span><br><span class="line">    int orphaned_masters; /* How many masters there are without ok slaves. */</span><br><span class="line">    int max_slaves; /* Max number of ok slaves for a single master. */</span><br><span class="line">    int this_slaves; /* Number of ok slaves for our master (if we are slave). */</span><br><span class="line">    mstime_t min_pong = 0, now = mstime();</span><br><span class="line">    clusterNode *min_pong_node = NULL;</span><br><span class="line">    // 迭代计数器，一个静态变量</span><br><span class="line">    static unsigned long long iteration = 0;</span><br><span class="line">    mstime_t handshake_timeout;</span><br><span class="line"></span><br><span class="line">    // 记录一次迭代</span><br><span class="line">    iteration++; /* Number of times this function was called so far. */</span><br><span class="line"></span><br><span class="line">    /* The handshake timeout is the time after which a handshake node that was</span><br><span class="line">     * not turned into a normal node is removed from the nodes. Usually it is</span><br><span class="line">     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use</span><br><span class="line">     * the value of 1 second. */</span><br><span class="line">    // 如果一个 handshake 节点没有在 handshake timeout 内</span><br><span class="line">    // 转换成普通节点（normal node），</span><br><span class="line">    // 那么节点会从 nodes 表中移除这个 handshake 节点</span><br><span class="line">    // 一般来说 handshake timeout 的值总是等于 NODE_TIMEOUT</span><br><span class="line">    // 不过如果 NODE_TIMEOUT 太少的话，程序会将值设为 1 秒钟</span><br><span class="line">    handshake_timeout = server.cluster_node_timeout;</span><br><span class="line">    if (handshake_timeout &lt; 1000) handshake_timeout = 1000;</span><br><span class="line"></span><br><span class="line">    /* Check if we have disconnected nodes and re-establish the connection. */</span><br><span class="line">    // 向集群中的所有断线或者未连接节点发送消息</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 跳过当前节点以及没有地址的节点</span><br><span class="line">        if (node-&gt;flags &amp; (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR)) continue;</span><br><span class="line"></span><br><span class="line">        /* A Node in HANDSHAKE state has a limited lifespan equal to the</span><br><span class="line">         * configured node timeout. */</span><br><span class="line">        // 如果 handshake 节点已超时，释放它</span><br><span class="line">        if (nodeInHandshake(node) &amp;&amp; now - node-&gt;ctime &gt; handshake_timeout) &#123;</span><br><span class="line">            freeClusterNode(node);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 为未创建连接的节点创建连接</span><br><span class="line">        if (node-&gt;link == NULL) &#123;</span><br><span class="line">            int fd;</span><br><span class="line">            mstime_t old_ping_sent;</span><br><span class="line">            clusterLink *link;</span><br><span class="line"></span><br><span class="line">            fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip,</span><br><span class="line">                node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.bindaddr_count ? server.bindaddr[0] : NULL);</span><br><span class="line">            if (fd == -1) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG, &quot;Unable to connect to &quot;</span><br><span class="line">                    &quot;Cluster Node [%s]:%d -&gt; %s&quot;, node-&gt;ip,</span><br><span class="line">                    node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.neterr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            link = createClusterLink(node);</span><br><span class="line">            link-&gt;fd = fd;</span><br><span class="line">            node-&gt;link = link;</span><br><span class="line">            aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE,</span><br><span class="line">                    clusterReadHandler,link);</span><br><span class="line">            /* Queue a PING in the new connection ASAP: this is crucial</span><br><span class="line">             * to avoid false positives in failure detection.</span><br><span class="line">             *</span><br><span class="line">             * If the node is flagged as MEET, we send a MEET message instead</span><br><span class="line">             * of a PING one, to force the receiver to add us in its node</span><br><span class="line">             * table. */</span><br><span class="line">            // 向新连接的节点发送 PING 命令，防止节点被识进入下线</span><br><span class="line">            // 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令</span><br><span class="line">            old_ping_sent = node-&gt;ping_sent;</span><br><span class="line">            clusterSendPing(link, node-&gt;flags &amp; REDIS_NODE_MEET ?</span><br><span class="line">                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);</span><br><span class="line"></span><br><span class="line">            // 这不是第一次发送 PING 信息，所以可以还原这个时间</span><br><span class="line">            // 等 clusterSendPing() 函数来更新它</span><br><span class="line">            if (old_ping_sent) &#123;</span><br><span class="line">                /* If there was an active ping before the link was</span><br><span class="line">                 * disconnected, we want to restore the ping time, otherwise</span><br><span class="line">                 * replaced by the clusterSendPing() call. */</span><br><span class="line">                node-&gt;ping_sent = old_ping_sent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can clear the flag after the first packet is sent.</span><br><span class="line">             *</span><br><span class="line">             * 在发送 MEET 信息之后，清除节点的 MEET 标识。</span><br><span class="line">             *</span><br><span class="line">             * If we&apos;ll never receive a PONG, we&apos;ll never send new packets</span><br><span class="line">             * to this node. Instead after the PONG is received and we</span><br><span class="line">             * are no longer in meet/handshake status, we want to send</span><br><span class="line">             * normal PING packets. </span><br><span class="line">             *</span><br><span class="line">             * 如果当前节点（发送者）没能收到 MEET 信息的回复，</span><br><span class="line">             * 那么它将不再向目标节点发送命令。</span><br><span class="line">             *</span><br><span class="line">             * 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，</span><br><span class="line">             * 并继续向目标节点发送普通 PING 命令。</span><br><span class="line">             */</span><br><span class="line">            node-&gt;flags &amp;= ~REDIS_NODE_MEET;</span><br><span class="line"></span><br><span class="line">            redisLog(REDIS_DEBUG,&quot;Connecting with Node %.40s at %s:%d&quot;,</span><br><span class="line">                    node-&gt;name, node-&gt;ip, node-&gt;port+REDIS_CLUSTER_PORT_INCR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    /* Ping some random node 1 time every 10 iterations, so that we usually ping</span><br><span class="line">     * one random node every second. */</span><br><span class="line">    // clusterCron() 每执行 10 次（至少间隔一秒钟），就向一个随机节点发送 gossip 信息</span><br><span class="line">    if (!(iteration % 10)) &#123;</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        /* Check a few random nodes and ping the one with the oldest</span><br><span class="line">         * pong_received time. */</span><br><span class="line">        // 随机 5 个节点，选出其中一个</span><br><span class="line">        for (j = 0; j &lt; 5; j++) &#123;</span><br><span class="line"></span><br><span class="line">            // 随机在集群中挑选节点</span><br><span class="line">            de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">            clusterNode *this = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            /* Don&apos;t ping nodes disconnected or with a ping currently active. */</span><br><span class="line">            // 不要 PING 连接断开的节点，也不要 PING 最近已经 PING 过的节点</span><br><span class="line">            if (this-&gt;link == NULL || this-&gt;ping_sent != 0) continue;</span><br><span class="line"></span><br><span class="line">            if (this-&gt;flags &amp; (REDIS_NODE_MYSELF|REDIS_NODE_HANDSHAKE))</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            // 选出 5 个随机节点中最近一次接收 PONG 回复距离现在最旧的节点</span><br><span class="line">            if (min_pong_node == NULL || min_pong &gt; this-&gt;pong_received) &#123;</span><br><span class="line">                min_pong_node = this;</span><br><span class="line">                min_pong = this-&gt;pong_received;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 向最久没有收到 PONG 回复的节点发送 PING 命令</span><br><span class="line">        if (min_pong_node) &#123;</span><br><span class="line">            redisLog(REDIS_DEBUG,&quot;Pinging node %.40s&quot;, min_pong_node-&gt;name);</span><br><span class="line">            clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历所有节点，检查是否需要将某个节点标记为下线</span><br><span class="line">    /* Iterate nodes to check if we need to flag something as failing.</span><br><span class="line">     * This loop is also responsible to:</span><br><span class="line">     * 1) Check if there are orphaned masters (masters without non failing</span><br><span class="line">     *    slaves).</span><br><span class="line">     * 2) Count the max number of non failing slaves for a single master.</span><br><span class="line">     * 3) Count the number of slaves for our master, if we are a slave. */</span><br><span class="line">    orphaned_masters = 0;</span><br><span class="line">    max_slaves = 0;</span><br><span class="line">    this_slaves = 0;</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); /* Use an updated time at every iteration. */</span><br><span class="line">        mstime_t delay;</span><br><span class="line"></span><br><span class="line">        // 跳过节点本身、无地址节点、HANDSHAKE 状态的节点</span><br><span class="line">        if (node-&gt;flags &amp;</span><br><span class="line">            (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR|REDIS_NODE_HANDSHAKE))</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">        /* Orphaned master check, useful only if the current instance</span><br><span class="line">         * is a slave that may migrate to another master. */</span><br><span class="line">        if (nodeIsSlave(myself) &amp;&amp; nodeIsMaster(node) &amp;&amp; !nodeFailed(node)) &#123;</span><br><span class="line">            int okslaves = clusterCountNonFailingSlaves(node);</span><br><span class="line"></span><br><span class="line">            if (okslaves == 0 &amp;&amp; node-&gt;numslots &gt; 0) orphaned_masters++;</span><br><span class="line">            if (okslaves &gt; max_slaves) max_slaves = okslaves;</span><br><span class="line">            if (nodeIsSlave(myself) &amp;&amp; myself-&gt;slaveof == node)</span><br><span class="line">                this_slaves = okslaves;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If we are waiting for the PONG more than half the cluster</span><br><span class="line">         * timeout, reconnect the link: maybe there is a connection</span><br><span class="line">         * issue even if the node is alive. */</span><br><span class="line">        // 如果等到 PONG 到达的时间超过了 node timeout 一半的连接</span><br><span class="line">        // 因为尽管节点依然正常，但连接可能已经出问题了</span><br><span class="line">        if (node-&gt;link &amp;&amp; /* is connected */</span><br><span class="line">            now - node-&gt;link-&gt;ctime &gt;</span><br><span class="line">            server.cluster_node_timeout &amp;&amp; /* was not already reconnected */</span><br><span class="line">            node-&gt;ping_sent &amp;&amp; /* we already sent a ping */</span><br><span class="line">            node-&gt;pong_received &lt; node-&gt;ping_sent &amp;&amp; /* still waiting pong */</span><br><span class="line">            /* and we are waiting for the pong more than timeout/2 */</span><br><span class="line">            now - node-&gt;ping_sent &gt; server.cluster_node_timeout/2)</span><br><span class="line">        &#123;</span><br><span class="line">            /* Disconnect the link, it will be reconnected automatically. */</span><br><span class="line">            // 释放连接，下次 clusterCron() 会自动重连</span><br><span class="line">            freeClusterLink(node-&gt;link);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If we have currently no active ping in this instance, and the</span><br><span class="line">         * received PONG is older than half the cluster timeout, send</span><br><span class="line">         * a new ping now, to ensure all the nodes are pinged without</span><br><span class="line">         * a too big delay. */</span><br><span class="line">        // 如果目前没有在 PING 节点</span><br><span class="line">        // 并且已经有 node timeout 一半的时间没有从节点那里收到 PONG 回复</span><br><span class="line">        // 那么向节点发送一个 PING ，确保节点的信息不会太旧</span><br><span class="line">        // （因为一部分节点可能一直没有被随机中）</span><br><span class="line">        if (node-&gt;link &amp;&amp;</span><br><span class="line">            node-&gt;ping_sent == 0 &amp;&amp;</span><br><span class="line">            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/2)</span><br><span class="line">        &#123;</span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If we are a master and one of the slaves requested a manual</span><br><span class="line">         * failover, ping it continuously. */</span><br><span class="line">        // 如果这是一个主节点，并且有一个从服务器请求进行手动故障转移</span><br><span class="line">        // 那么向从服务器发送 PING 。</span><br><span class="line">        if (server.cluster-&gt;mf_end &amp;&amp;</span><br><span class="line">            nodeIsMaster(myself) &amp;&amp;</span><br><span class="line">            server.cluster-&gt;mf_slave == node &amp;&amp;</span><br><span class="line">            node-&gt;link)</span><br><span class="line">        &#123;</span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Check only if we have an active ping for this instance. */</span><br><span class="line">        // 以下代码只在节点发送了 PING 命令的情况下执行</span><br><span class="line">        if (node-&gt;ping_sent == 0) continue;</span><br><span class="line"></span><br><span class="line">        /* Compute the delay of the PONG. Note that if we already received</span><br><span class="line">         * the PONG, then node-&gt;ping_sent is zero, so can&apos;t reach this</span><br><span class="line">         * code at all. */</span><br><span class="line">        // 计算等待 PONG 回复的时长</span><br><span class="line">        delay = now - node-&gt;ping_sent;</span><br><span class="line"></span><br><span class="line">        // 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线）</span><br><span class="line">        if (delay &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            /* Timeout reached. Set the node as possibly failing if it is</span><br><span class="line">             * not already in this state. */</span><br><span class="line">            if (!(node-&gt;flags &amp; (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG,&quot;*** NODE %.40s possibly failing&quot;,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">                // 打开疑似下线标记</span><br><span class="line">                node-&gt;flags |= REDIS_NODE_PFAIL;</span><br><span class="line">                update_state = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    /* If we are a slave node but the replication is still turned off,</span><br><span class="line">     * enable it if we know the address of our master and it appears to</span><br><span class="line">     * be up. */</span><br><span class="line">    // 如果从节点没有在复制主节点，那么对从节点进行设置</span><br><span class="line">    if (nodeIsSlave(myself) &amp;&amp;</span><br><span class="line">        server.masterhost == NULL &amp;&amp;</span><br><span class="line">        myself-&gt;slaveof &amp;&amp;</span><br><span class="line">        nodeHasAddr(myself-&gt;slaveof))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationSetMaster(myself-&gt;slaveof-&gt;ip, myself-&gt;slaveof-&gt;port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Abourt a manual failover if the timeout is reached. */</span><br><span class="line">    manualFailoverCheckTimeout();</span><br><span class="line"></span><br><span class="line">    if (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">        /* If there are orphaned slaves, and we are a slave among the masters</span><br><span class="line">         * with the max number of non-failing slaves, consider migrating to</span><br><span class="line">         * the orphaned masters. Note that it does not make sense to try</span><br><span class="line">         * a migration if there is no master with at least *two* working</span><br><span class="line">         * slaves. */</span><br><span class="line">        if (orphaned_masters &amp;&amp; max_slaves &gt;= 2 &amp;&amp; this_slaves == max_slaves)</span><br><span class="line">            clusterHandleSlaveMigration(max_slaves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新集群状态</span><br><span class="line">    if (update_state || server.cluster-&gt;state == REDIS_CLUSTER_FAIL)</span><br><span class="line">        clusterUpdateState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、状态信息并不是全量同步，而是随机选M（M &lt;&lt; N）个节点的状态同步到其他节点。<br>
M值最小为3，最大为<code>N - 2</code>，一般情况下<code>M = N / 10</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/* Send a PING or PONG packet to the specified node, making sure to add enough</span><br><span class="line"> * gossip informations. */</span><br><span class="line">// 向指定节点发送一条 MEET 、 PING 或者 PONG 消息</span><br><span class="line">void clusterSendPing(clusterLink *link, int type) &#123;</span><br><span class="line">    unsigned char buf[sizeof(clusterMsg)];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    int gossipcount = 0, totlen;</span><br><span class="line">    /* freshnodes is the number of nodes we can still use to populate the</span><br><span class="line">     * gossip section of the ping packet. Basically we start with the nodes</span><br><span class="line">     * we have in memory minus two (ourself and the node we are sending the</span><br><span class="line">     * message to). Every time we add a node we decrement the counter, so when</span><br><span class="line">     * it will drop to &lt;= zero we know there is no more gossip info we can</span><br><span class="line">     * send. */</span><br><span class="line">    // freshnodes 是用于发送 gossip 信息的计数器</span><br><span class="line">    // 每次发送一条信息时，程序将 freshnodes 的值减一</span><br><span class="line">    // 当 freshnodes 的数值小于等于 0 时，程序停止发送 gossip 信息</span><br><span class="line">    // freshnodes 的数量是节点目前的 nodes 表中的节点数量减去 2 </span><br><span class="line">    // 这里的 2 指两个节点，一个是 myself 节点（也即是发送信息的这个节点）</span><br><span class="line">    // 另一个是接受 gossip 信息的节点</span><br><span class="line">    int freshnodes = dictSize(server.cluster-&gt;nodes)-2;</span><br><span class="line"></span><br><span class="line">    // 如果发送的信息是 PING ，那么更新最后一次发送 PING 命令的时间戳</span><br><span class="line">    if (link-&gt;node &amp;&amp; type == CLUSTERMSG_TYPE_PING)</span><br><span class="line">        link-&gt;node-&gt;ping_sent = mstime();</span><br><span class="line"></span><br><span class="line">    // 将当前节点的信息（比如名字、地址、端口号、负责处理的槽）记录到消息里面</span><br><span class="line">    clusterBuildMessageHdr(hdr,type);</span><br><span class="line"></span><br><span class="line">    /* Populate the gossip fields */</span><br><span class="line">    // 从当前节点已知的节点中随机选出两个节点</span><br><span class="line">    // 并通过这条消息捎带给目标节点，从而实现 gossip 协议</span><br><span class="line"></span><br><span class="line">    // 每个节点有 freshnodes 次发送 gossip 信息的机会</span><br><span class="line">    // 每次向目标节点发送 2 个被选中节点的 gossip 信息（gossipcount 计数）</span><br><span class="line">    while(freshnodes &gt; 0 &amp;&amp; gossipcount &lt; 3) &#123;</span><br><span class="line">        // 从 nodes 字典中随机选出一个节点（被选中节点）</span><br><span class="line">        dictEntry *de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">        clusterNode *this = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        clusterMsgDataGossip *gossip;</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        /* In the gossip section don&apos;t include:</span><br><span class="line">         * 以下节点不能作为被选中节点：</span><br><span class="line">         * 1) Myself.</span><br><span class="line">         *    节点本身。</span><br><span class="line">         * 2) Nodes in HANDSHAKE state.</span><br><span class="line">         *    处于 HANDSHAKE 状态的节点。</span><br><span class="line">         * 3) Nodes with the NOADDR flag set.</span><br><span class="line">         *    带有 NOADDR 标识的节点</span><br><span class="line">         * 4) Disconnected nodes if they don&apos;t have configured slots.</span><br><span class="line">         *    因为不处理任何槽而被断开连接的节点 </span><br><span class="line">         */</span><br><span class="line">        if (this == myself ||</span><br><span class="line">            this-&gt;flags &amp; (REDIS_NODE_HANDSHAKE|REDIS_NODE_NOADDR) ||</span><br><span class="line">            (this-&gt;link == NULL &amp;&amp; this-&gt;numslots == 0))</span><br><span class="line">        &#123;</span><br><span class="line">                freshnodes--; /* otherwise we may loop forever. */</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Check if we already added this node */</span><br><span class="line">        // 检查被选中节点是否已经在 hdr-&gt;data.ping.gossip 数组里面</span><br><span class="line">        // 如果是的话说明这个节点之前已经被选中了</span><br><span class="line">        // 不要再选中它（否则就会出现重复）</span><br><span class="line">        for (j = 0; j &lt; gossipcount; j++) &#123;</span><br><span class="line">            if (memcmp(hdr-&gt;data.ping.gossip[j].nodename,this-&gt;name,</span><br><span class="line">                    REDIS_CLUSTER_NAMELEN) == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j != gossipcount) continue;</span><br><span class="line"></span><br><span class="line">        /* Add it */</span><br><span class="line"></span><br><span class="line">        // 这个被选中节点有效，计数器减一</span><br><span class="line">        freshnodes--;</span><br><span class="line"></span><br><span class="line">        // 指向 gossip 信息结构</span><br><span class="line">        gossip = &amp;(hdr-&gt;data.ping.gossip[gossipcount]);</span><br><span class="line"></span><br><span class="line">        // 将被选中节点的名字记录到 gossip 信息</span><br><span class="line">        memcpy(gossip-&gt;nodename,this-&gt;name,REDIS_CLUSTER_NAMELEN);</span><br><span class="line">        // 将被选中节点的 PING 命令发送时间戳记录到 gossip 信息</span><br><span class="line">        gossip-&gt;ping_sent = htonl(this-&gt;ping_sent);</span><br><span class="line">        // 将被选中节点的 PING 命令回复的时间戳记录到 gossip 信息</span><br><span class="line">        gossip-&gt;pong_received = htonl(this-&gt;pong_received);</span><br><span class="line">        // 将被选中节点的 IP 记录到 gossip 信息</span><br><span class="line">        memcpy(gossip-&gt;ip,this-&gt;ip,sizeof(this-&gt;ip));</span><br><span class="line">        // 将被选中节点的端口号记录到 gossip 信息</span><br><span class="line">        gossip-&gt;port = htons(this-&gt;port);</span><br><span class="line">        // 将被选中节点的标识值记录到 gossip 信息</span><br><span class="line">        gossip-&gt;flags = htons(this-&gt;flags);</span><br><span class="line"></span><br><span class="line">        // 这个被选中节点有效，计数器增一</span><br><span class="line">        gossipcount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算信息长度</span><br><span class="line">    totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);</span><br><span class="line">    totlen += (sizeof(clusterMsgDataGossip)*gossipcount);</span><br><span class="line">    // 将被选中节点的数量（gossip 信息中包含了多少个节点的信息）</span><br><span class="line">    // 记录在 count 属性里面</span><br><span class="line">    hdr-&gt;count = htons(gossipcount);</span><br><span class="line">    // 将信息的长度记录到信息里面</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line"></span><br><span class="line">    // 发送信息</span><br><span class="line">    clusterSendMessage(link,buf,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容-缩容"><a class="header-anchor" href="#扩容-缩容">¶</a>扩容 / 缩容</h2>
<p>当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。</p>
<h3 id="新节点加入流程"><a class="header-anchor" href="#新节点加入流程">¶</a>新节点加入流程</h3>
<p>新节点加入时，需要把一部分数据迁移到新节点来达到集群的负载均衡。<br>
在Redis集群中，数据的存储是以slot为单位的，因此：</p>
<ol>
<li>集群的伸缩本质上就是slot在不同机器节点之间的迁移；</li>
<li>迁移过程中，有的slot在老节点上，有的slot在新节点上，这时，客户端请求应该被重定向到正确的节点上。<br>
比如slot1从A迁移到B上时，请求A或B会怎么样？请求别的节点又会怎么样？</li>
</ol>
<p>节点的迁移过程主要分为3个步骤：</p>
<ol>
<li>准备新节点</li>
<li>加入集群</li>
<li>迁移slot到新节点</li>
</ol>
<p>以下迁移过程的伪代码来自：<a href="https://zhuanlan.zhihu.com/p/105569485" target="_blank" rel="noopener">Redis集群详解（中）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def move_slot(source,target,slot):</span><br><span class="line">    # 目标节点准备导入槽</span><br><span class="line">    target.cluster(&quot;setslot&quot;,slot,&quot;importing&quot;,source.nodeId);</span><br><span class="line">    # 目标节点准备全出槽</span><br><span class="line">    source.cluster(&quot;setslot&quot;,slot,&quot;migrating&quot;,target.nodeId);</span><br><span class="line">    while true :</span><br><span class="line">        # 批量从源节点获取键</span><br><span class="line">        keys = source.cluster(&quot;getkeysinslot&quot;,slot,pipeline_size);</span><br><span class="line">        if keys.length == 0:</span><br><span class="line">            # 键列表为空时，退出循环</span><br><span class="line">            break;</span><br><span class="line">        # 批量迁移键到目标节点</span><br><span class="line">        source.call(&quot;migrate&quot;,target.host,target.port,&quot;&quot;,0,timeout,&quot;keys&quot;,keys);</span><br><span class="line">    # 向集群所有主节点通知槽被分配给目标节点</span><br><span class="line">    for node in nodes:</span><br><span class="line">        if node.flag == &quot;slave&quot;:</span><br><span class="line">            continue;</span><br><span class="line">        node.cluster(&quot;setslot&quot;,slot,&quot;node&quot;,target.nodeId);</span><br></pre></td></tr></table></figure>
<h4 id="节点迁移过程"><a class="header-anchor" href="#节点迁移过程">¶</a>节点迁移过程</h4>
<p>以下命令告知目标节点准备导入slot：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot &lt;slot&gt; IMPORTING &lt;nodeId&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令告知目标节点准备导出slot：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot &lt;slot&gt; MIGRATING &lt;nodeId&gt;</span><br></pre></td></tr></table></figure>
<p>每个节点保存的集群状态中记录了迁移中的slot，其中，迁出的slot放到<code>migrating_slots_to</code>中，迁入的slot放到<code>importing_slots_from</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line">    clusterNode *myself;  /* This node */</span><br><span class="line">    // 当前纪元</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line">    // 集群的状态</span><br><span class="line">    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */</span><br><span class="line">    // 集群中至少负责一个槽的主节点个数</span><br><span class="line">    int size;             /* Num of master nodes with at least one slot */</span><br><span class="line">    // 保存集群节点的字典，键是节点名字，值是clusterNode结构的指针</span><br><span class="line">    dict *nodes;          /* Hash table of name -&gt; clusterNode structures */</span><br><span class="line">    // 防止重复添加节点的黑名单</span><br><span class="line">    dict *nodes_black_list; /* Nodes we don&apos;t re-add for a few seconds. */</span><br><span class="line">    // 导入槽数据到目标节点，该数组记录这些节点</span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    // 导出槽数据到目标节点，该数组记录这些节点</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">    // 槽和负责槽节点的映射</span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    // 槽映射到键的有序集合</span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    </span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p>接下来，将待迁移slot中的key批量转移到目标节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回count个slot中的键</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</span><br><span class="line"># 需要对上面命令返回的每个键都发送以下命令，该命令会将所指定的键原子地从源节点移动到目标节点</span><br><span class="line">migrate &lt;host&gt; &lt;port&gt; key destination-db timeout</span><br></pre></td></tr></table></figure>
<p>migrate命令就是向节点发送了N个RESTORE-ASKING命令，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* Create RESTORE payload and generate the protocol to call the command. */</span><br><span class="line">for (j = 0; j &lt; num_keys; j++) &#123;</span><br><span class="line">    long long ttl = 0;</span><br><span class="line">    long long expireat = getExpire(c-&gt;db,kv[j]);</span><br><span class="line">    //检查键是不是已经过期</span><br><span class="line">    if (expireat != -1) &#123;</span><br><span class="line">        ttl = expireat-mstime();</span><br><span class="line">        if (ttl &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ttl &lt; 1) ttl = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    kv[non_expired++] = kv[j];</span><br><span class="line"></span><br><span class="line">    // 集群模式下写入RESTORE-ASKING命令，普通模式下写入RESTORE命令</span><br><span class="line">    if (server.cluster_enabled)</span><br><span class="line">        serverAssertWithInfo(c,NULL,</span><br><span class="line">            rioWriteBulkString(&amp;cmd,&quot;RESTORE-ASKING&quot;,14));</span><br><span class="line">    else</span><br><span class="line">        serverAssertWithInfo(c,NULL,rioWriteBulkString(&amp;cmd,&quot;RESTORE&quot;,7));</span><br><span class="line">    // 写入KEY，写入TTL</span><br><span class="line">    serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));</span><br><span class="line">    serverAssertWithInfo(c,NULL,rioWriteBulkString(&amp;cmd,kv[j]-&gt;ptr,</span><br><span class="line">            sdslen(kv[j]-&gt;ptr)));</span><br><span class="line">    serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&amp;cmd,ttl));</span><br><span class="line">    // 写入VALUE以及Redis版本校验码等信息</span><br><span class="line">    createDumpPayload(&amp;payload,ov[j],kv[j]);</span><br><span class="line">    serverAssertWithInfo(c,NULL,</span><br><span class="line">        rioWriteBulkString(&amp;cmd,payload.io.buffer.ptr,</span><br><span class="line">                           sdslen(payload.io.buffer.ptr)));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁入节点接收到restore-asking命令后，执行节点的恢复操作，即获取key，解析出value，然后写入数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* RESTORE key ttl serialized-value [REPLACE] */</span><br><span class="line">// 根据给定的 DUMP 数据，还原出一个键值对数据，并将它保存到数据库里面</span><br><span class="line">void restoreCommand(redisClient *c) &#123;</span><br><span class="line">    long long ttl;</span><br><span class="line">    rio payload;</span><br><span class="line">    int j, type, replace = 0;</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 读取 DUMP 数据，并反序列化出键值对的类型和值</span><br><span class="line">    rioInitWithBuffer(&amp;payload,c-&gt;argv[3]-&gt;ptr);</span><br><span class="line">    if (((type = rdbLoadObjectType(&amp;payload)) == -1) ||</span><br><span class="line">        ((obj = rdbLoadObject(type,&amp;payload)) == NULL))</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,&quot;Bad data format&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Remove the old key if needed. */</span><br><span class="line">    // 如果给定了 REPLACE 选项，那么先删除数据库中已存在的同名键</span><br><span class="line">    if (replace) dbDelete(c-&gt;db,c-&gt;argv[1]);</span><br><span class="line"></span><br><span class="line">    /* Create the key and set the TTL if any */</span><br><span class="line">    // 将键值对添加到数据库</span><br><span class="line">    dbAdd(c-&gt;db,c-&gt;argv[1],obj);</span><br><span class="line"></span><br><span class="line">    // 如果键带有 TTL 的话，设置键的 TTL</span><br><span class="line">    if (ttl) setExpire(c-&gt;db,c-&gt;argv[1],mstime()+ttl);</span><br><span class="line"></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);</span><br><span class="line"></span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁移过程中，在外部客户端的视角看来，在任意时间点上，key只会存在于某个节点上，而不会同时存在于两个节点上。</p>
<p>现在，待迁移槽中的key都已经被迁移了，但是对其他节点来说，该slot仍是由迁出节点负责的，它们接收到相关请求后仍然会路由到迁出节点，所以迁移的最后一步需要向集群中的所有主节点通知槽已经被分配给目标节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot &lt;slot&gt; node &lt;nodeId&gt;</span><br></pre></td></tr></table></figure>
<h4 id="迁移过程中对新请求的响应"><a class="header-anchor" href="#迁移过程中对新请求的响应">¶</a>迁移过程中对新请求的响应</h4>
<p>迁移过程中：</p>
<ul>
<li>如果迁出节点接收请求，迁出节点判断slot是否已迁出，若是则<strong>ASK重定向</strong>到迁入节点上，否则迁出节点自己负责处理请求；</li>
<li>如果迁入节点接收请求，会把请求重定向到迁出节点上，除非请求中包含<strong>ASKING</strong>命令；</li>
<li>其他节点接收到的相关请求会被重定向到迁出节点上；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">int processCommand(redisClient *c) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* If cluster is enabled perform the cluster redirection here.</span><br><span class="line">     *</span><br><span class="line">     * 如果开启了集群模式，那么在这里进行转向操作。</span><br><span class="line">     *</span><br><span class="line">     * However we don&apos;t perform the redirection if:</span><br><span class="line">     *</span><br><span class="line">     * 不过，如果有以下情况出现，那么节点不进行转向：</span><br><span class="line">     *</span><br><span class="line">     * 1) The sender of this command is our master.</span><br><span class="line">     *    命令的发送者是本节点的主节点</span><br><span class="line">     *</span><br><span class="line">     * 2) The command has no key arguments. </span><br><span class="line">     *    命令没有 key 参数</span><br><span class="line">     */</span><br><span class="line">    if (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0))</span><br><span class="line">    &#123;</span><br><span class="line">        int hashslot;</span><br><span class="line"></span><br><span class="line">        // 集群已下线</span><br><span class="line">        if (server.cluster-&gt;state != REDIS_CLUSTER_OK) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            addReplySds(c,sdsnew(&quot;-CLUSTERDOWN The cluster is down. Use CLUSTER INFO for more information\r\n&quot;));</span><br><span class="line">            return REDIS_OK;</span><br><span class="line"></span><br><span class="line">        // 集群运作正常</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int error_code;</span><br><span class="line">            clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,&amp;hashslot,&amp;error_code);</span><br><span class="line">            // 不能执行多键处理命令</span><br><span class="line">            if (n == NULL) &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">                if (error_code == REDIS_CLUSTER_REDIR_CROSS_SLOT) &#123;</span><br><span class="line">                    addReplySds(c,sdsnew(&quot;-CROSSSLOT Keys in request don&apos;t hash to the same slot\r\n&quot;));</span><br><span class="line">                &#125; else if (error_code == REDIS_CLUSTER_REDIR_UNSTABLE) &#123;</span><br><span class="line">                    /* The request spawns mutliple keys in the same slot,</span><br><span class="line">                     * but the slot is not &quot;stable&quot; currently as there is</span><br><span class="line">                     * a migration or import in progress. */</span><br><span class="line">                    addReplySds(c,sdsnew(&quot;-TRYAGAIN Multiple keys request during rehashing of slot\r\n&quot;));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    redisPanic(&quot;getNodeByQuery() unknown error.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return REDIS_OK;</span><br><span class="line"></span><br><span class="line">            // 命令针对的槽和键不是本节点处理的，进行转向</span><br><span class="line">            &#125; else if (n != server.cluster-&gt;myself) &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">                // -&lt;ASK or MOVED&gt; &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">                // 例如 -ASK 10086 127.0.0.1:12345</span><br><span class="line">                addReplySds(c,sdscatprintf(sdsempty(),</span><br><span class="line">                    &quot;-%s %d %s:%d\r\n&quot;,</span><br><span class="line">                    (error_code == REDIS_CLUSTER_REDIR_ASK) ? &quot;ASK&quot; : &quot;MOVED&quot;,</span><br><span class="line">                    hashslot,n-&gt;ip,n-&gt;port));</span><br><span class="line"></span><br><span class="line">                return REDIS_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果执行到这里，说明键 key 所在的槽由本节点处理</span><br><span class="line">            // 或者客户端执行的是无参数命令</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上边的<code>getNodeByQuery</code>根据key的散列结果查询命令应该被打到的节点，可以看到这个函数里有对ASKING标识的特殊处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">clusterNode *getNodeByQuery(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* If we are receiving the slot, and the client correctly flagged the</span><br><span class="line">     * request as &quot;ASKING&quot;, we can serve the request. However if the request</span><br><span class="line">     * involves multiple keys and we don&apos;t have them all, the only option is</span><br><span class="line">     * to send a TRYAGAIN error. */</span><br><span class="line">    if (importing_slot &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; REDIS_ASKING || cmd-&gt;flags &amp; REDIS_CMD_ASKING))</span><br><span class="line">    &#123;</span><br><span class="line">        if (multiple_keys &amp;&amp; missing_keys) &#123;</span><br><span class="line">            if (error_code) *error_code = REDIS_CLUSTER_REDIR_UNSTABLE;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return myself;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旧节点退出流程"><a class="header-anchor" href="#旧节点退出流程">¶</a>旧节点退出流程</h3>
<p>与新节点的加入相反的是，旧节点退出时需要把其上的数据迁移到其他节点上，确保该节点上的数据能够被正常访问。<br>
槽的迁移过程和上边扩容中描述的没有区别，主要区别是在迁移完毕后需要轮询每个节点发送<code>cluster forget</code>命令，让它们能忘记下线的节点。<br>
节点在接收<code>cluster forget</code>命令后，会将目标节点的状态从自己保存的集群状态中移除，并将其加入黑名单中60s，这期间其他节点不会再去更新自己维护的该节点的信息，也就是说这60秒内该节点无法重新加入集群内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def delnode_cluster_cmd(downNode):</span><br><span class="line">    # 下线节点不允许包含slots</span><br><span class="line">    if downNode.slots.length != 0</span><br><span class="line">        exit 1</span><br><span class="line">    end</span><br><span class="line">    # 向集群内节点发送cluster forget</span><br><span class="line">    for n in nodes:</span><br><span class="line">        if n.id == downNode.id:</span><br><span class="line">            # 不能对自己做forget操作</span><br><span class="line">            continue;</span><br><span class="line">        # 如果下线节点有从节点则把从节点指向其他主节点</span><br><span class="line">        if n.replicate &amp;&amp; n.replicate.nodeId == downNode.id :</span><br><span class="line">            # 指向拥有最少从节点的主节点</span><br><span class="line">            master = get_master_with_least_replicas();</span><br><span class="line">            n.cluster(&quot;replicate&quot;,master.nodeId);</span><br><span class="line">        #发送忘记节点命令</span><br><span class="line">        n.cluster(&apos;forget&apos;,downNode.id)</span><br><span class="line">    # 节点关闭</span><br><span class="line">    downNode.shutdown();</span><br></pre></td></tr></table></figure>
<h2 id="故障恢复-容错"><a class="header-anchor" href="#故障恢复-容错">¶</a>故障恢复（容错）</h2>
<p>Redis故障恢复主要分为以下3个步骤：</p>
<ol>
<li>故障发现<br>
采用多数派协议完成故障检测判断（即至少有半数以上节点认为某主节点故障后才真正判断节点故障）。</li>
<li>子节点选举<br>
Redis Cluster中每个Master都会有1至多个Slave，通过复制实现高可用（故障转移），当Master有多个Slave，会采用Raft实现选举出一个主节点以实现故障恢复。</li>
<li>配置更新<br>
故障转移后，那么之前的Master和其他Slave怎么处理？Redis会将这些节点成为新Master节点的子节点。</li>
</ol>
<h3 id="故障发现"><a class="header-anchor" href="#故障发现">¶</a>故障发现</h3>
<p>一些 CP 特性且中心化的集群来说，当出现节点宕机时经常需要选举新的 Leader 节点，但是 Redis-Cluster 是<strong>去中心化</strong>的，某个 Master 的宕机并不会影响其他节点的工作。但是，当节点失联时，需要考虑网络的抖动情况，毕竟不能因为某几个请求意外超时就推断集群失败了，部分节点判断一个节点失联只会标记这个节点状态为<strong>PFAIL（主观下线）</strong>，之后如果多数节点<strong>投票</strong>通过才会真正标记这个节点<strong>FAIL（下线）</strong>。<br>
投票过程是集群中所有 master 参与的，每个节点都存有整个集群所有主节点及从节点的信息，它们之间通过互相 ping-pong 来判断节点是否可以连上，如果半数以上 master 节点与当前 master 节点通信超时（cluster-node-timeout），则认为当前 master 节点挂掉，标记这个节点状态为<strong>FAIL</strong>。</p>
<p>当 master 挂掉时，并不意味着集群已无法再提供服务了，集群要进入<code>fail（不可用）</code>状态需要满足以下条件之一：</p>
<ol>
<li>集群的任意 master 挂掉，且该 master 没有 slave 或 slave 全挂掉了，则集群进入 fail 状态。<br>
这是因为，Cluster中所有slot是平均分配到每个Master的，如果有一个Master的slot不能用了、而且这个Master还没有Slave，那么集群就不能提供服务了，如果Master还有Slave，Slave可以代替Master继续向外提供服务，这个步骤称为<strong>slave promotion</strong>。<br>
单独的一对Master-Slave挂掉，Redis还提供一个叫 <strong>Replica Migration</strong> 的解决方案：当集群中的某个Master节点没有Slave节点时（称之为 Orphaned Master），其他有富余Slave节点的主节点会向该节点迁移一个Slave节点以防该节点下线之后没有子节点来替换从而导致整个集群下线。</li>
<li>集群超过半数以上 master 挂掉，无论有无 slave 都进入 fail 状态。</li>
</ol>
<p>当集群不可用时，任何操作都将返回<code>((error) CLUSTERDOWN The cluster is down)</code>错误。需要注意的是，必须要 3 个或以上的主节点，否则在创建集群时会失败。</p>
<h4 id="pfail"><a class="header-anchor" href="#pfail">¶</a>PFAIL</h4>
<p>1、Redis每个节点会不断向其他节点发送<code>PING</code>消息来检测其他节点是否可达，如果超时会先断开连接：<br>
代码：<code>cluster.c/clusterCron</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* This is executed 10 times every second */</span><br><span class="line">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span><br><span class="line">void clusterCron(void) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); /* Use an updated time at every iteration. */</span><br><span class="line">        mstime_t delay;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /* If we are waiting for the PONG more than half the cluster</span><br><span class="line">         * timeout, reconnect the link: maybe there is a connection</span><br><span class="line">         * issue even if the node is alive. */</span><br><span class="line">        // 判断连接的节点是否出事</span><br><span class="line">        if (node-&gt;link &amp;&amp; /* is connected */</span><br><span class="line">            now - node-&gt;link-&gt;ctime &gt;</span><br><span class="line">            server.cluster_node_timeout &amp;&amp; /* was not already reconnected */</span><br><span class="line">            // ping_sent记录发送命令的时间</span><br><span class="line">            node-&gt;ping_sent &amp;&amp; /* we already sent a ping */</span><br><span class="line">            node-&gt;pong_received &lt; node-&gt;ping_sent &amp;&amp; /* still waiting pong */</span><br><span class="line">            /* and we are waiting for the pong more than timeout/2 */</span><br><span class="line">            // PONG 到达的时间超过了 node_timeout 的一半</span><br><span class="line">            now - node-&gt;ping_sent &gt; server.cluster_node_timeout/2)</span><br><span class="line">        &#123;</span><br><span class="line">            /* Disconnect the link, it will be reconnected automatically. */</span><br><span class="line">            // 释放连接，此时node-&gt;link=NULL，下次 clusterCron() 会自动重连</span><br><span class="line">            freeClusterLink(node-&gt;link);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、此时节点A PING目标节点B失败，A会尝试重连，并将重连时间记录到ping_sent变量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/* This is executed 10 times every second */</span><br><span class="line">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span><br><span class="line">void clusterCron(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Check if we have disconnected nodes and re-establish the connection. */</span><br><span class="line">    // 向集群中的所有断线或者未连接节点发送消息</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 跳过当前节点以及没有地址的节点</span><br><span class="line">        if (node-&gt;flags &amp; (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR)) continue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 为未创建连接的节点创建连接</span><br><span class="line">        if (node-&gt;link == NULL) &#123;</span><br><span class="line">            int fd;</span><br><span class="line">            mstime_t old_ping_sent;</span><br><span class="line">            clusterLink *link;</span><br><span class="line"></span><br><span class="line">            fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip,</span><br><span class="line">                node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.bindaddr_count ? server.bindaddr[0] : NULL);</span><br><span class="line">            if (fd == -1) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG, &quot;Unable to connect to &quot;</span><br><span class="line">                    &quot;Cluster Node [%s]:%d -&gt; %s&quot;, node-&gt;ip,</span><br><span class="line">                    node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.neterr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            link = createClusterLink(node);</span><br><span class="line">            link-&gt;fd = fd;</span><br><span class="line">            node-&gt;link = link;</span><br><span class="line">            aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE,</span><br><span class="line">                    clusterReadHandler,link);</span><br><span class="line">            /* Queue a PING in the new connection ASAP: this is crucial</span><br><span class="line">             * to avoid false positives in failure detection.</span><br><span class="line">             *</span><br><span class="line">             * If the node is flagged as MEET, we send a MEET message instead</span><br><span class="line">             * of a PING one, to force the receiver to add us in its node</span><br><span class="line">             * table. */</span><br><span class="line">            // 向新连接的节点发送 PING 命令，防止节点被识进入下线</span><br><span class="line">            // 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令</span><br><span class="line">            old_ping_sent = node-&gt;ping_sent;</span><br><span class="line">            clusterSendPing(link, node-&gt;flags &amp; REDIS_NODE_MEET ?</span><br><span class="line">                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);</span><br><span class="line"></span><br><span class="line">            // 这不是第一次发送 PING 信息，所以可以还原这个时间</span><br><span class="line">            // 等 clusterSendPing() 函数来更新它</span><br><span class="line">            if (old_ping_sent) &#123;</span><br><span class="line">                /* If there was an active ping before the link was</span><br><span class="line">                 * disconnected, we want to restore the ping time, otherwise</span><br><span class="line">                 * replaced by the clusterSendPing() call. */</span><br><span class="line">                node-&gt;ping_sent = old_ping_sent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can clear the flag after the first packet is sent.</span><br><span class="line">             *</span><br><span class="line">             * 在发送 MEET 信息之后，清除节点的 MEET 标识。</span><br><span class="line">             *</span><br><span class="line">             * If we&apos;ll never receive a PONG, we&apos;ll never send new packets</span><br><span class="line">             * to this node. Instead after the PONG is received and we</span><br><span class="line">             * are no longer in meet/handshake status, we want to send</span><br><span class="line">             * normal PING packets. </span><br><span class="line">             *</span><br><span class="line">             * 如果当前节点（发送者）没能收到 MEET 信息的回复，</span><br><span class="line">             * 那么它将不再向目标节点发送命令。</span><br><span class="line">             *</span><br><span class="line">             * 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，</span><br><span class="line">             * 并继续向目标节点发送普通 PING 命令。</span><br><span class="line">             */</span><br><span class="line">            node-&gt;flags &amp;= ~REDIS_NODE_MEET;</span><br><span class="line"></span><br><span class="line">            redisLog(REDIS_DEBUG,&quot;Connecting with Node %.40s at %s:%d&quot;,</span><br><span class="line">                    node-&gt;name, node-&gt;ip, node-&gt;port+REDIS_CLUSTER_PORT_INCR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、节点A发现PING B的延时时间超过了node_timeout之后，就会标记该节点为PFAIL（Possible FAILure），即主观下线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void clusterCron(void) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 遍历所有节点，检查是否需要将某个节点标记为下线</span><br><span class="line">    /* Iterate nodes to check if we need to flag something as failing.</span><br><span class="line">     * This loop is also responsible to:</span><br><span class="line">     * 1) Check if there are orphaned masters (masters without non failing</span><br><span class="line">     *    slaves).</span><br><span class="line">     * 2) Count the max number of non failing slaves for a single master.</span><br><span class="line">     * 3) Count the number of slaves for our master, if we are a slave. */</span><br><span class="line">    orphaned_masters = 0;</span><br><span class="line">    max_slaves = 0;</span><br><span class="line">    this_slaves = 0;</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /* Check only if we have an active ping for this instance. */</span><br><span class="line">        // 以下代码只在节点发送了 PING 命令的情况下执行</span><br><span class="line">        if (node-&gt;ping_sent == 0) continue;</span><br><span class="line"></span><br><span class="line">        /* Compute the delay of the PONG. Note that if we already received</span><br><span class="line">         * the PONG, then node-&gt;ping_sent is zero, so can&apos;t reach this</span><br><span class="line">         * code at all. */</span><br><span class="line">        // 计算等待 PONG 回复的时长</span><br><span class="line">        delay = now - node-&gt;ping_sent;</span><br><span class="line"></span><br><span class="line">        // 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线）</span><br><span class="line">        if (delay &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            /* Timeout reached. Set the node as possibly failing if it is</span><br><span class="line">             * not already in this state. */</span><br><span class="line">            if (!(node-&gt;flags &amp; (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG,&quot;*** NODE %.40s possibly failing&quot;,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">                // 打开疑似下线标记</span><br><span class="line">                node-&gt;flags |= REDIS_NODE_PFAIL;</span><br><span class="line">                update_state = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fail"><a class="header-anchor" href="#fail">¶</a>FAIL</h4>
<p>1、A将B标记为PFAIL后，A会通过<strong>Gossip</strong>通知到其他节点。</p>
<p>2、所有节点会维护一个下线报告列表（Fail Report），主要维护一个节点被哪些节点报告处于下线状态，此时，C会记录“B被A报告下线了”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">int clusterProcessPacket(clusterLink *link) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Process packets by type. */</span><br><span class="line">    // 根据消息的类型，处理节点</span><br><span class="line"></span><br><span class="line">    // 这是一条 PING 消息或者 MEET 消息</span><br><span class="line">    if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">        redisLog(REDIS_DEBUG,&quot;Ping packet received: %p&quot;, (void*)link-&gt;node);</span><br><span class="line"></span><br><span class="line">        /* Add this node if it is new for us and the msg type is MEET.</span><br><span class="line">         *</span><br><span class="line">         * 如果当前节点是第一次遇见这个节点，并且对方发来的是 MEET 信息，</span><br><span class="line">         * 那么将这个节点添加到集群的节点列表里面。</span><br><span class="line">         *</span><br><span class="line">         * In this stage we don&apos;t try to add the node with the right</span><br><span class="line">         * flags, slaveof pointer, and so forth, as this details will be</span><br><span class="line">         * resolved when we&apos;ll receive PONGs from the node. </span><br><span class="line">         *</span><br><span class="line">         * 节点目前的 flag 、 slaveof 等属性的值都是未设置的，</span><br><span class="line">         * 等当前节点向对方发送 PING 命令之后，</span><br><span class="line">         * 这些信息可以从对方回复的 PONG 信息中取得。</span><br><span class="line">         */</span><br><span class="line">        if (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">            clusterNode *node;</span><br><span class="line"></span><br><span class="line">            // 创建 HANDSHAKE 状态的新节点</span><br><span class="line">            node = createClusterNode(NULL,REDIS_NODE_HANDSHAKE);</span><br><span class="line"></span><br><span class="line">            // 设置 IP 和端口</span><br><span class="line">            nodeIp2String(node-&gt;ip,link);</span><br><span class="line">            node-&gt;port = ntohs(hdr-&gt;port);</span><br><span class="line"></span><br><span class="line">            // 将新节点添加到集群</span><br><span class="line">            clusterAddNode(node);</span><br><span class="line"></span><br><span class="line">            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Get info from the gossip section */</span><br><span class="line">        // 分析并取出消息中的 gossip 节点信息</span><br><span class="line">        clusterProcessGossipSection(hdr,link);</span><br><span class="line"></span><br><span class="line">        /* Anyway reply with a PONG */</span><br><span class="line">        // 向目标节点返回一个 PONG</span><br><span class="line">        clusterSendPing(link,CLUSTERMSG_TYPE_PONG);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) &#123;</span><br><span class="line"></span><br><span class="line">    // 记录这条消息中包含了多少个节点的信息</span><br><span class="line">    uint16_t count = ntohs(hdr-&gt;count);</span><br><span class="line"></span><br><span class="line">    // 指向第一个节点的信息</span><br><span class="line">    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;</span><br><span class="line"></span><br><span class="line">    // 取出发送者</span><br><span class="line">    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">    // 遍历所有节点的信息</span><br><span class="line">    while(count--) &#123;</span><br><span class="line">        sds ci = sdsempty();</span><br><span class="line"></span><br><span class="line">        // 分析节点的 flag</span><br><span class="line">        uint16_t flags = ntohs(g-&gt;flags);</span><br><span class="line"></span><br><span class="line">        // 信息节点</span><br><span class="line">        clusterNode *node;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /* Update our state accordingly to the gossip sections */</span><br><span class="line">        // 使用消息中的信息对节点进行更新</span><br><span class="line">        node = clusterLookupNode(g-&gt;nodename);</span><br><span class="line">        // 节点已经存在于当前节点</span><br><span class="line">        if (node) &#123;</span><br><span class="line">            /* We already know this node.</span><br><span class="line">               Handle failure reports, only when the sender is a master. */</span><br><span class="line">            // 如果 sender 是一个主节点，那么我们需要处理下线报告</span><br><span class="line">            if (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;</span><br><span class="line">                // 节点处于 FAIL 或者 PFAIL 状态</span><br><span class="line">                if (flags &amp; (REDIS_NODE_FAIL|REDIS_NODE_PFAIL)) &#123;</span><br><span class="line"></span><br><span class="line">                    // 添加 sender 对 node 的下线报告</span><br><span class="line">                    if (clusterNodeAddFailureReport(node,sender)) &#123;</span><br><span class="line">                        redisLog(REDIS_VERBOSE,</span><br><span class="line">                            &quot;Node %.40s reported node %.40s as not reachable.&quot;,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 尝试将 node 标记为 FAIL</span><br><span class="line">                    markNodeAsFailingIfNeeded(node);</span><br><span class="line"></span><br><span class="line">                // 节点处于正常状态</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    // 如果 sender 曾经发送过对 node 的下线报告</span><br><span class="line">                    // 那么清除该报告</span><br><span class="line">                    if (clusterNodeDelFailureReport(node,sender)) &#123;</span><br><span class="line">                        redisLog(REDIS_VERBOSE,</span><br><span class="line">                            &quot;Node %.40s reported node %.40s is back online.&quot;,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* If we already know this node, but it is not reachable, and</span><br><span class="line">             * we see a different address in the gossip section, start an</span><br><span class="line">             * handshake with the (possibly) new address: this will result</span><br><span class="line">             * into a node address update if the handshake will be</span><br><span class="line">             * successful. */</span><br><span class="line">            // 如果节点之前处于 PFAIL 或者 FAIL 状态</span><br><span class="line">            // 并且该节点的 IP 或者端口号已经发生变化</span><br><span class="line">            // 那么可能是节点换了新地址，尝试对它进行握手</span><br><span class="line">            if (node-&gt;flags &amp; (REDIS_NODE_FAIL|REDIS_NODE_PFAIL) &amp;&amp;</span><br><span class="line">                (strcasecmp(node-&gt;ip,g-&gt;ip) || node-&gt;port != ntohs(g-&gt;port)))</span><br><span class="line">            &#123;</span><br><span class="line">                clusterStartHandshake(g-&gt;ip,ntohs(g-&gt;port));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        // 当前节点不认识 node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* If it&apos;s not in NOADDR state and we don&apos;t have it, we</span><br><span class="line">             * start a handshake process against this IP/PORT pairs.</span><br><span class="line">             *</span><br><span class="line">             * 如果 node 不在 NOADDR 状态，并且当前节点不认识 node </span><br><span class="line">             * 那么向 node 发送 HANDSHAKE 消息。</span><br><span class="line">             *</span><br><span class="line">             * Note that we require that the sender of this gossip message</span><br><span class="line">             * is a well known node in our cluster, otherwise we risk</span><br><span class="line">             * joining another cluster.</span><br><span class="line">             *</span><br><span class="line">             * 注意，当前节点必须保证 sender 是本集群的节点，</span><br><span class="line">             * 否则我们将有加入了另一个集群的风险。</span><br><span class="line">             */</span><br><span class="line">            if (sender &amp;&amp;</span><br><span class="line">                !(flags &amp; REDIS_NODE_NOADDR) &amp;&amp;</span><br><span class="line">                !clusterBlacklistExists(g-&gt;nodename))</span><br><span class="line">            &#123;</span><br><span class="line">                clusterStartHandshake(g-&gt;ip,ntohs(g-&gt;port));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Next node */</span><br><span class="line">        // 处理下个节点的信息</span><br><span class="line">        g++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、C添加下线报告之后，会进行B节点的客观下线状态（FAIL）判定。<br>
当集群中有超过半数的节点都认为节点B处于PFAIL后才会判断B为FAIL，且需要注意的是，A将PFAIL通知给C后，C自己本身也得认为B处于PFAIL状态才会开始客观下线判定。<br>
当C认为B正式FAIL后，它就会立刻向集群所有节点广播这个消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* This function checks if a given node should be marked as FAIL.</span><br><span class="line"> * It happens if the following conditions are met:</span><br><span class="line"> *</span><br><span class="line"> * 此函数用于判断是否需要将 node 标记为 FAIL 。</span><br><span class="line"> *</span><br><span class="line"> * 将 node 标记为 FAIL 需要满足以下两个条件：</span><br><span class="line"> *</span><br><span class="line"> * 1) We received enough failure reports from other master nodes via gossip.</span><br><span class="line"> *    Enough means that the majority of the masters signaled the node is</span><br><span class="line"> *    down recently.</span><br><span class="line"> *    有半数以上的主节点将 node 标记为 PFAIL 状态。</span><br><span class="line"> * 2) We believe this node is in PFAIL state.</span><br><span class="line"> *    当前节点也将 node 标记为 PFAIL 状态。</span><br><span class="line"> *</span><br><span class="line"> * If a failure is detected we also inform the whole cluster about this</span><br><span class="line"> * event trying to force every other node to set the FAIL flag for the node.</span><br><span class="line"> *</span><br><span class="line"> * 如果确认 node 已经进入了 FAIL 状态，</span><br><span class="line"> * 那么节点还会向其他节点发送 FAIL 消息，让其他节点也将 node 标记为 FAIL 。</span><br><span class="line"> *</span><br><span class="line"> * Note that the form of agreement used here is weak, as we collect the majority</span><br><span class="line"> * of masters state during some time, and even if we force agreement by</span><br><span class="line"> * propagating the FAIL message, because of partitions we may not reach every</span><br><span class="line"> * node. However:</span><br><span class="line"> *</span><br><span class="line"> * 注意，集群判断一个 node 进入 FAIL 所需的条件是弱（weak）的，</span><br><span class="line"> * 因为节点们对 node 的状态报告并不是实时的，而是有一段时间间隔</span><br><span class="line"> * （这段时间内 node 的状态可能已经发生了改变），</span><br><span class="line"> * 并且尽管当前节点会向其他节点发送 FAIL 消息，</span><br><span class="line"> * 但因为网络分裂（network partition）的问题，</span><br><span class="line"> * 有一部分节点可能还是会不知道将 node 标记为 FAIL 。</span><br><span class="line"> *</span><br><span class="line"> * 不过：</span><br><span class="line"> *</span><br><span class="line"> * 1) Either we reach the majority and eventually the FAIL state will propagate</span><br><span class="line"> *    to all the cluster.</span><br><span class="line"> *    只要我们成功将 node 标记为 FAIL ，</span><br><span class="line"> *    那么这个 FAIL 状态最终（eventually）总会传播至整个集群的所有节点。</span><br><span class="line"> * 2) Or there is no majority so no slave promotion will be authorized and the</span><br><span class="line"> *    FAIL flag will be cleared after some time.</span><br><span class="line"> *    又或者，因为没有半数的节点支持，当前节点不能将 node 标记为 FAIL ，</span><br><span class="line"> *    所以对 FAIL 节点的故障转移将无法进行， FAIL 标识可能会在之后被移除。</span><br><span class="line"> *    </span><br><span class="line"> */</span><br><span class="line">void markNodeAsFailingIfNeeded(clusterNode *node) &#123;</span><br><span class="line">    int failures;</span><br><span class="line"></span><br><span class="line">    // 标记为 FAIL 所需的节点数量，需要超过集群节点数量的一半</span><br><span class="line">    int needed_quorum = (server.cluster-&gt;size / 2) + 1;</span><br><span class="line"></span><br><span class="line">    if (!nodeTimedOut(node)) return; /* We can reach it. */</span><br><span class="line">    if (nodeFailed(node)) return; /* Already FAILing. */</span><br><span class="line"></span><br><span class="line">    // 统计将 node 标记为 PFAIL 或者 FAIL 的节点数量（不包括当前节点）</span><br><span class="line">    failures = clusterNodeFailureReportsCount(node);</span><br><span class="line"></span><br><span class="line">    /* Also count myself as a voter if I&apos;m a master. */</span><br><span class="line">    // 如果当前节点是主节点，那么将当前节点也算在 failures 之内</span><br><span class="line">    if (nodeIsMaster(myself)) failures++;</span><br><span class="line">    // 报告下线节点的数量不足节点总数的一半，不能将节点判断为 FAIL ，返回</span><br><span class="line">    if (failures &lt; needed_quorum) return; /* No weak agreement from masters. */</span><br><span class="line"></span><br><span class="line">    redisLog(REDIS_NOTICE,</span><br><span class="line">        &quot;Marking node %.40s as failing (quorum reached).&quot;, node-&gt;name);</span><br><span class="line"></span><br><span class="line">    /* Mark the node as failing. */</span><br><span class="line">    // 将 node 标记为 FAIL</span><br><span class="line">    node-&gt;flags &amp;= ~REDIS_NODE_PFAIL;</span><br><span class="line">    node-&gt;flags |= REDIS_NODE_FAIL;</span><br><span class="line">    node-&gt;fail_time = mstime();</span><br><span class="line"></span><br><span class="line">    /* Broadcast the failing node name to everybody, forcing all the other</span><br><span class="line">     * reachable nodes to flag the node as FAIL. */</span><br><span class="line">    // 如果当前节点是主节点的话，那么向其他节点发送报告 node 的 FAIL 信息</span><br><span class="line">    // 让其他节点也将 node 标记为 FAIL</span><br><span class="line">    if (nodeIsMaster(myself)) clusterSendFail(node-&gt;name);</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、当C标记了B为FAIL状态，则它会广播到整个集群中的所有节点（包括子节点），其他节点都会更新自己维护的节点B的状态信息为FAIL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* Send a FAIL message to all the nodes we are able to contact.</span><br><span class="line"> *</span><br><span class="line"> * 向当前节点已知的所有节点发送 FAIL 信息。</span><br><span class="line"> */</span><br><span class="line">void clusterSendFail(char *nodename) &#123;</span><br><span class="line">    unsigned char buf[sizeof(clusterMsg)];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg *) buf;</span><br><span class="line"></span><br><span class="line">    // 创建下线消息</span><br><span class="line">    clusterBuildMessageHdr(hdr, CLUSTERMSG_TYPE_FAIL);</span><br><span class="line"></span><br><span class="line">    // 记录命令</span><br><span class="line">    memcpy(hdr-&gt;data.fail.about.nodename, nodename, REDIS_CLUSTER_NAMELEN);</span><br><span class="line"></span><br><span class="line">    // 广播消息</span><br><span class="line">    clusterBroadcastMessage(buf, ntohl(hdr-&gt;totlen));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Send a message to all the nodes that are part of the cluster having</span><br><span class="line"> * a connected link.</span><br><span class="line"> *</span><br><span class="line"> * 向节点连接的所有其他节点发送信息。</span><br><span class="line"> */</span><br><span class="line">void clusterBroadcastMessage(void *buf, size_t len) &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    // 遍历所有已知节点</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while ((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 不向未连接节点发送信息</span><br><span class="line">        if (!node-&gt;link) continue;</span><br><span class="line"></span><br><span class="line">        // 不向节点自身或者 HANDSHAKE 状态的节点发送信息</span><br><span class="line">        if (node-&gt;flags &amp; (REDIS_NODE_MYSELF | REDIS_NODE_HANDSHAKE))</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        clusterSendMessage(node-&gt;link, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子节点选举-故障迁移"><a class="header-anchor" href="#子节点选举-故障迁移">¶</a>子节点选举（故障迁移）</h3>
<p>1、当B的两个子节点接收到B的FAIL状态消息时，它们会更新自己本地内存中的集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int clusterProcessPacket(clusterLink *link) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 这是一条 FAIL 消息： sender 告知当前节点，某个节点已经进入 FAIL 状态。</span><br><span class="line">    else if (type == CLUSTERMSG_TYPE_FAIL) &#123;</span><br><span class="line">        clusterNode *failing;</span><br><span class="line"></span><br><span class="line">        if (sender) &#123;</span><br><span class="line"></span><br><span class="line">            // 获取下线节点的消息</span><br><span class="line">            failing = clusterLookupNode(hdr-&gt;data.fail.about.nodename);</span><br><span class="line">            // 下线的节点既不是当前节点，也没有处于 FAIL 状态</span><br><span class="line">            if (failing &amp;&amp;</span><br><span class="line">                !(failing-&gt;flags &amp; (REDIS_NODE_FAIL | REDIS_NODE_MYSELF))) &#123;</span><br><span class="line">                redisLog(REDIS_NOTICE,</span><br><span class="line">                         &quot;FAIL message received from %.40s about %.40s&quot;,</span><br><span class="line">                         hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);</span><br><span class="line"></span><br><span class="line">                // 打开 FAIL 状态</span><br><span class="line">                failing-&gt;flags |= REDIS_NODE_FAIL;</span><br><span class="line">                failing-&gt;fail_time = mstime();</span><br><span class="line">                // 关闭 PFAIL 状态</span><br><span class="line">                failing-&gt;flags &amp;= ~REDIS_NODE_PFAIL;</span><br><span class="line">                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG |</span><br><span class="line">                                     CLUSTER_TODO_UPDATE_STATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            redisLog(REDIS_NOTICE,</span><br><span class="line">                     &quot;Ignoring FAIL message from unknonw node %.40s about %.40s&quot;,</span><br><span class="line">                     hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、<br>
随后，在clusterCron定时任务中就会开始发起故障迁移，竞选成为新的Master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">void clusterCron(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Abourt a manual failover if the timeout is reached. */</span><br><span class="line">    manualFailoverCheckTimeout();</span><br><span class="line"></span><br><span class="line">    // 如果当前节点是子节点</span><br><span class="line">    if (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        // 处理集群子节点的故障迁移</span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">        </span><br><span class="line">        /* If there are orphaned slaves, and we are a slave among the masters</span><br><span class="line">         * with the max number of non-failing slaves, consider migrating to</span><br><span class="line">         * the orphaned masters. Note that it does not make sense to try</span><br><span class="line">         * a migration if there is no master with at least *two* working</span><br><span class="line">         * slaves. */</span><br><span class="line">        if (orphaned_masters &amp;&amp; max_slaves &gt;= 2 &amp;&amp; this_slaves == max_slaves)</span><br><span class="line">            clusterHandleSlaveMigration(max_slaves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新集群状态</span><br><span class="line">    if (update_state || server.cluster-&gt;state == REDIS_CLUSTER_FAIL)</span><br><span class="line">        clusterUpdateState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This function is called if we are a slave node and our master serving</span><br><span class="line"> * a non-zero amount of hash slots is in FAIL state.</span><br><span class="line"> *</span><br><span class="line"> * 如果当前节点是一个从节点，并且它正在复制的一个负责非零个槽的主节点处于 FAIL 状态，</span><br><span class="line"> * 那么执行这个函数。</span><br><span class="line"> *</span><br><span class="line"> * The gaol of this function is:</span><br><span class="line"> *</span><br><span class="line"> * 这个函数有三个目标：</span><br><span class="line"> *</span><br><span class="line"> * 1) To check if we are able to perform a failover, is our data updated?</span><br><span class="line"> *    检查是否可以对主节点执行一次故障转移，节点的关于主节点的信息是否准确和最新（updated）？</span><br><span class="line"> * 2) Try to get elected by masters.</span><br><span class="line"> *    选举一个新的主节点</span><br><span class="line"> * 3) Perform the failover informing all the other nodes.</span><br><span class="line"> *    执行故障转移，并通知其他节点</span><br><span class="line"> */</span><br><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line">    mstime_t data_age;</span><br><span class="line">    mstime_t auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line">    int needed_quorum = (server.cluster-&gt;size / 2) + 1;</span><br><span class="line">    int manual_failover = server.cluster-&gt;mf_end != 0 &amp;&amp;</span><br><span class="line">                          server.cluster-&gt;mf_can_start;</span><br><span class="line">    int j;</span><br><span class="line">    mstime_t auth_timeout, auth_retry_time;</span><br><span class="line"></span><br><span class="line">    server.cluster-&gt;todo_before_sleep &amp;= ~CLUSTER_TODO_HANDLE_FAILOVER;</span><br><span class="line"></span><br><span class="line">    /* Compute the failover timeout (the max time we have to send votes</span><br><span class="line">     * and wait for replies), and the failover retry time (the time to wait</span><br><span class="line">     * before waiting again.</span><br><span class="line">     *</span><br><span class="line">     * Timeout is MIN(NODE_TIMEOUT*2,2000) milliseconds.</span><br><span class="line">     * Retry is two times the Timeout.</span><br><span class="line">     */</span><br><span class="line">    auth_timeout = server.cluster_node_timeout * 2;</span><br><span class="line">    if (auth_timeout &lt; 2000) auth_timeout = 2000;</span><br><span class="line">    auth_retry_time = auth_timeout * 2;</span><br><span class="line"></span><br><span class="line">    /* Pre conditions to run the function, that must be met both in case</span><br><span class="line">     * of an automatic or manual failover:</span><br><span class="line">     * 1) We are a slave.</span><br><span class="line">     * 2) Our master is flagged as FAIL, or this is a manual failover.</span><br><span class="line">     * 3) It is serving slots. */</span><br><span class="line">    if (nodeIsMaster(myself) ||</span><br><span class="line">        myself-&gt;slaveof == NULL ||</span><br><span class="line">        (!nodeFailed(myself-&gt;slaveof) &amp;&amp; !manual_failover) ||</span><br><span class="line">        myself-&gt;slaveof-&gt;numslots == 0)</span><br><span class="line">        return;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、</p>
<p>4、</p>
<h3 id="配置更新"><a class="header-anchor" href="#配置更新">¶</a>配置更新</h3>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://redissrc.readthedocs.io/en/latest/" target="_blank" rel="noopener">redis源码解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/104641341" target="_blank" rel="noopener">Redis集群详解（上）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/105569485" target="_blank" rel="noopener">Redis集群详解（中）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106110578" target="_blank" rel="noopener">Redis集群（终篇）</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/a2b16944.html" rel="next" title="Redis 持久化">
                <i class="fa fa-chevron-left"></i> Redis 持久化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/edd4cfac.html" rel="prev" title="Redis 复制">
                Redis 复制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-cluster介绍"><span class="nav-number">1.</span> <span class="nav-text">¶Redis Cluster介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-优势"><span class="nav-number">1.1.</span> <span class="nav-text">¶Cluster 优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-缺点"><span class="nav-number">1.2.</span> <span class="nav-text">¶Cluster 缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster的去中心化架构"><span class="nav-number">1.3.</span> <span class="nav-text">¶Cluster的去中心化架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性"><span class="nav-number">1.4.</span> <span class="nav-text">¶一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据分布-分区-和查询路由"><span class="nav-number">2.</span> <span class="nav-text">¶数据分布（分区）和查询路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区策略"><span class="nav-number">2.1.</span> <span class="nav-text">¶分区策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区的实现层次"><span class="nav-number">2.2.</span> <span class="nav-text">¶分区的实现层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区的缺点"><span class="nav-number">2.3.</span> <span class="nav-text">¶分区的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点通信"><span class="nav-number">3.</span> <span class="nav-text">¶节点通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩容-缩容"><span class="nav-number">4.</span> <span class="nav-text">¶扩容 / 缩容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新节点加入流程"><span class="nav-number">4.1.</span> <span class="nav-text">¶新节点加入流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#节点迁移过程"><span class="nav-number">4.1.1.</span> <span class="nav-text">¶节点迁移过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迁移过程中对新请求的响应"><span class="nav-number">4.1.2.</span> <span class="nav-text">¶迁移过程中对新请求的响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旧节点退出流程"><span class="nav-number">4.2.</span> <span class="nav-text">¶旧节点退出流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#故障恢复-容错"><span class="nav-number">5.</span> <span class="nav-text">¶故障恢复（容错）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#故障发现"><span class="nav-number">5.1.</span> <span class="nav-text">¶故障发现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pfail"><span class="nav-number">5.1.1.</span> <span class="nav-text">¶PFAIL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail"><span class="nav-number">5.1.2.</span> <span class="nav-text">¶FAIL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子节点选举-故障迁移"><span class="nav-number">5.2.</span> <span class="nav-text">¶子节点选举（故障迁移）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置更新"><span class="nav-number">5.3.</span> <span class="nav-text">¶配置更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">¶参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
