---
title: 实现一个服务熔断器
abbrlink: 755a34bb
date: 2019-02-11 22:01:47
categories: 
tags: 
---

[TOC]

<!-- more -->

## 一、初衷
前不久公司核心业务遭遇“滑铁卢”，由于当时我对该项目仍处于熟悉中阶段，没能直接参与到故障的修复当中去，对事故只能给出一个大概的复述。该业务简而言之就是：1 用户请求下单结算 -> 2 更新订单状态 -> 3 扣钱包余额扣库存，第 2 步是一个写库操作，第 3 步需要异步发消息到另一个服务。当时运维同学对配置操作不当导致数据库连接拿不到，于是在事发的半个小时内，有百余单扣了款却没有正常交易成功，结果事后需要一笔一笔地检查订单，手动给用户赔罪退款。
事后反省时基本上也是围绕着要小心、要规范云云。其实我认为事故大大小小基本上无法完全避免，能控制事故的范围才是系统容错性能的硬指标。这一次事故发生前后经历的半个小时，服务即使在出错很多次后仍然能够继续接收请求，明显是没有做服务的熔断降级，导致影响范围不断扩大，后续需要花大量时间去弥补。
熔断本身属于一种兜底方案。在一个远程调用框架中，一个服务接口被调用时，如果出错应该优先采取重试的方案，如果多次超时——表明服务确实不可用之后——才会考虑熔断，以避免“灾害”进一步的扩大。
熔断本身没有特别难的算法，但是需要考虑比较多的细节。


## 二、熔断器的实现
待定...
### 与 Spring 框架的耦合


## 三、熔断器的使用
### 熔断粒度
服务一般是复杂的、有许多接口的，而且调用不同接口形成的链路结构可能并不一样，当某个接口出现故障时，很有可能并不影响其他接口的可用性，比如对下面两个链路：
* 服务 A 接口 1 -> 服务 B 接口 1
* 服务 A 接口 2 -> 服务 C 接口 1

如果服务 B 的接口 1（以下使用 B1 简称）不可用了，会导致 A1 不可用，但不影响 A2。
因此以接口作为熔断粒度更合适，服务熔断其实熔断的是服务中有问题的那部分接口。

### 降级

### 恢复

### 熔断和服务发现是一对搭档

### 上游 Or 下游
正如之前所示，一条服务链路可能是复杂的、多级的，如下图所示：
* 服务 A 接口 1 -> 服务 B 接口 1X
                 ^
* 服务 A 接口 2 -----|

如上图所示，熔断规则的添加方式可以有以下 3 种：
1. 仅在 A1 和 A2 上添加熔断规则。如果 B1 不可用了，会触发 A1 的降级，但是 A2 并不知道，于是又会对 B 发起无用的调用。其实当下游的某个服务不可用之后，以该服务为下游的所有链路其实都报废掉了，所以这里在 A1 已经试出 B1 的问题后 A2 再去请求已经没有意义了。
1. 仅在 B1 上添加熔断规则。此时如果 A1 不可用了，仍然会导致请求超时的现象，影响用户体验。
1. 同时都加上熔断规则。这样其实会在熔断恢复时引起一点小麻烦：如果 A1 率先进入 `Recovering` 状态，此时 B1 仍不可用，反过来又会把 A1 带回到降级状态，直到 B1 进入 `Recovering` 状态；如果 B1 率先进入 `Recovering` 状态则不会有这样的问题。

总而言之，在为上下游服务接口添加熔断规则时，能都加则都加，如果不能则尽量在容易出错的接口处添加熔断规则。

### 异步请求 Or 同步请求
服务接口可以分为同步的和异步的，我们说的服务不可用其实都发生在同步调用中，而异步请求一般都是非阻塞的，不可能出现超时现象。
> 异步请求一般通过消息队列来实现，消息队列可以持久化消息，并通过不断重拾来实现至少一次的消费，因此异步请求不会影响链路的可用性。
> 异步和非阻塞没有必然关联，异步表达的是一种“被动的”通信模式（由操作系统来通知应用程序请求已返回），非阻塞指的是调用方法会立刻返回，换句话说，我们完全可以实现一种异步阻塞的 IO 模型。



## 四、参考
1. [漫画：什么是服务熔断？](https://blog.csdn.net/bjweimengshu/article/details/79441695)
