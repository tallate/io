---
title: 实现一个服务熔断器
abbrlink: 755a34bb
date: 2019-02-11 22:01:47
categories: 
tags: 
---


前不久公司核心业务遭遇“滑铁卢”，由于当时我对该项目仍处于熟悉中阶段，没能直接参与到故障的修复当中去，对事故只能给出一个大概的复述。该业务简而言之就是：1 用户请求下单结算 -> 2 更新订单状态 -> 3 扣钱包余额扣库存，第 2 步是一个写库操作，第 3 步需要异步发消息到另一个服务。当时运维同学对配置操作不当导致数据库连接拿不到，于是在事发的半个小时内，有百余单扣了款却没有正常交易成功，结果事后需要一笔一笔地检查订单，手动给用户赔罪退款。
事后反省时基本上也是围绕着要小心、要规范云云。其实我认为事故大大小小基本上无法完全避免，能控制事故的范围才是系统容错性能的硬指标。这一次事故发生前后经历的半个小时，服务即使在出错很多次后仍然能够继续接收请求，明显是没有做服务的熔断降级，导致影响范围不断扩大，后续需要花大量时间去弥补。
熔断本身属于一种兜底方案。在一个远程调用框架中，一个服务接口被调用时，如果出错应该优先采取重试的方案，如果多次超时——表明服务确实不可用之后——才会考虑熔断，以避免“灾害”进一步的扩大。
熔断本身没有特别难的算法，但是需要考虑比较多的细节。

* [ ] 熔断降级机制
* [ ] 恢复机制
* [ ] 熔断器 + Spring
* [ ] Dubbo 中的熔断降级机制
* [ ] Hystrix 中的熔断降级机制
* [ ] Sentinel （阿里）中的熔断机制

<!-- more -->

## 二、熔断器的实现
### 降级
待定...

### 恢复
待定...

### 与 Spring 框架的耦合
待定...


## 三、熔断器的使用
### 熔断粒度
服务一般是复杂的、有许多接口的，而且调用不同接口形成的链路结构可能并不一样，当某个接口出现故障时，很有可能并不影响其他接口的可用性，比如对下面两个链路：
* 服务 A 接口 1 -> 服务 B 接口 1
* 服务 A 接口 2 -> 服务 C 接口 1

如果服务 B 的接口 1（以下使用 B1 简称）不可用了，会导致 A1 不可用，但不影响 A2。
因此以接口作为熔断粒度更合适，服务熔断其实熔断的是服务中有问题的那部分接口。

### 添加熔断的位置——上游 Or 下游
正如之前所示，一条服务链路可能是复杂的、多级的，如下图所示：
![链路示例](http://47.88.24.11/实现一个服务熔断器/链路示例.png "链路示例")

如上图所示，熔断规则的添加方式可以有以下 3 种：
1. 仅在 A1 和 A2 上添加熔断规则。如果 B1 不可用了，会触发 A1 的降级，但是 A2 并不知道，于是又会对 B 发起无用的调用。其实当下游的某个服务不可用之后，以该服务为下游的所有链路其实都报废掉了，所以这里在 A1 已经试出 B1 的问题后 A2 再去请求已经没有意义了。
1. 仅在 B1 上添加熔断规则。此时如果 A1 不可用了，仍然会导致请求超时的现象，影响用户体验。
1. 同时都加上熔断规则。这样其实会在熔断恢复时引起一点小麻烦：如果 A1 率先进入 `Recovering` 状态，此时 B1 仍不可用，反过来又会把 A1 带回到降级状态，直到 B1 进入 `Recovering` 状态；如果 B1 率先进入 `Recovering` 状态则不会有这样的问题。

总而言之，在为上下游服务接口添加熔断规则时，能都加则都加，如果不能则尽量在容易出错的接口处添加熔断规则。

### 熔断与服务发现是一对搭档——下游有多个实例的情况
在分布式系统里，我们默认网络是不稳定的、容易发生抖动的，有时候请求一时不能正常地打到目标服务器上，但是可以通过重试来达到目的，一般这样的情况会比较少，所以我们会定一个`调用成功率`来决定是否开启熔断模式将这条链路降级，那么这个成功率应该怎么设定呢？
我们先考虑最简单的情况——下游服务只有一个实例，如果这个实例挂掉，那么对其的请求就都不好使了，因此`调用成功率`可以设置得比较大，比如约`80% ~ 90% / min`的一个数。
![下游多实例的链路](http://47.88.24.11/实现一个服务熔断器/下游多实例的链路.png "下游多实例的链路")
但是服务为了保证可用性，怎么可能只有一个副本？如上图所示，下游服务有多个副本的情况下，如果其中有一个副本出了问题，经过**服务发现**组件的刷新（Watch机制），A能够“感知”到下游服务结构的变动、忽略掉已经不可用的实例，当然这个“感知”有一定的延迟时间，如果我们容忍这样的延迟，那么`调用成功率`的值也可以相对设置得大胆一些，比如约`60% ~ 70% / min`；反过来说，如果我们希望熔断器更严格，则会导致熔断器将整个下游服务的流量阻断掉，这是一个需要权衡的设计问题。

### 异步请求 Or 同步请求
服务接口可以分为同步的和异步的，我们说的服务不可用其实都发生在同步调用中，而异步请求一般都是非阻塞的，不可能出现超时现象。
> 异步请求一般通过消息队列来实现，消息队列可以持久化消息，并通过不断重拾来实现至少一次的消费，因此异步请求不会影响链路的可用性。
> 异步和非阻塞没有必然关联，异步表达的是一种“被动的”通信模式（由操作系统来通知应用程序请求已返回），非阻塞指的是调用方法会立刻返回，换句话说，我们完全可以实现一种异步阻塞的 IO 模型。



## 参考
1. [漫画：什么是服务熔断？](https://blog.csdn.net/bjweimengshu/article/details/79441695)
