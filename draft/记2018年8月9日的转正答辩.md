---
title: 记 2018 年 8 月 9 日的转正答辩
abbrlink: b868cbc8
date: 2018-08-10 23:33:05
categories: 技术点总结
tags: 答辩
---

## 参考
1. [想了解 Aio 与 Nio 的利弊，为什么 Netty 没有采用 Aio 实现？](https://segmentfault.com/q/1010000010446129)

## 由来
因为毕设的关系，在用友实习了整整半年，在这期间参与了司库云这个项目的开发，因此在试用期最后的转正答辩中我就这段经历进行了一些分享和延伸。
<!-- more -->

## 转正答辩过程
答辩主要分 4 个阶段：准备 5 分钟、PPT 展示 15 分钟、成果展示（代码）10 分钟、QA10 分钟、评委讨论反馈 5 分钟。

### 自我介绍
我给出了一张自己的照片，希望能拉近和评委之间的距离。

### 工作内容及成果
讲学了些什么、工作内容及成果。

### 部分功能分析和代码演示
我讲解了每个功能实现起来有哪些难点，并对主要流程给出了流程图进行描述。

### 总结与展望
这部分的内容就比较有意思了：

#### 涉及到的设计模式
根据业务进行分析，可以加入下面这些设计模式进行优化：
1. 工厂模式
普通重算还款计划和展期重算还款计划的算法有些不同（展期业务后来取消掉了）。
使用工厂模式后，方法名相对构造器来说可读性更高，且多了一层包装，减少了暴露、更容易后来修改。
1. 策略模式
发起参照的位置可能有多个，每个位置发起参照的过滤条件可能不同，可以将他们包装到单独的类中，客户端使用一个 srcType 参数调用不同的算法。
使用策略模式后，可以减少算法之间的耦合、方便后续加入新的算法。

#### 跨服务通信——RMI 框架
1. 要区分业务异常和 RMI 框架抛出的异常
    * 使用返回值表示业务异常（接口本身没有返回值的情况下）
        ```java
        try {
          // ...业务操作
        } catch (Exception e) {
          return "外部放款单出现错误：" + e.getMessage();
        } finally {
          // 释放锁
          infinance.setId(infinance.getInfinancepayid());
          //new VOLockOperaor().unlock(infinance);
          infinance.setId(null);
        }
        ```
    * 分别定义业务一场和 RMI 框架异常，分别捕捉，分别记录到不同的 log 文件中，或后续使用 ELK 等系统进行分析
1. 不同服务内的代码无法同步更新
因为不同服务运行在不同的实例内，它们的代码无法像传统单体式架构软件那样可以同步更新所有代码，因此也给代码的调试带来了一些困难，调试的方法如下：
    * 细心编码、滴水不漏，这当然是不大可能的，不是每个人都是 Dijkstra；
    * 不厌其烦地测试，在发起远程调用的方法处打断点，把参数粘出来，再在另一个实例内调用对应的接口、将参数传进去调试；
    * 搭建私有化环境，将所有关联服务都放到 localhost 里调试，这样和生产环境的差异比较大，不适合进行性能测试，且当关联服务比较多时搭建私有化环境非常麻烦（因为要修改很多配置文件，而且配置文件很分散）；
    * 契约测试，将服务消费者与服务提供者解耦。
    ![X](http://47.88.24.11/imgs/记2018年8月9日的转正答辩/契约测试示意图.png)
    如上图所示，服务消费者（组件 A）会先运行一个单元测试，在这个单元测试中，用户需要给出接口的预计输入和预计输出，运行将会生成一份契约，这份契约既可以作为服务消费者调用该接口的默认行为，也可以作为单元测试用例供服务提供者（组件 B）进行功能测试。
1. 远程调用开销远高于本地调用
因为远程调用还需要付出网络请求的时间开销，且网络请求必然是不稳定（网络速度受网络情况限制）、不可靠（可能失败）、不安全的（受中间人攻击等），因此有下面这些优化方向：
    * 更合理的业务划分，减少远程调用，要做到这点必须深刻理解微服务和**DDD**的设计理念；
    * 更高效的通信协议，如果刚开始使用的是 HTTP，可以考虑改成 TCP 或自定义的协议，据说 QQ 的协议就是从 UDP 魔改而来的；
    * 更高效的通信模式，一般刚开始使用的是 BIO，可以考虑改为 NIO 或 AIO 来实现，比如 Netty 就是一种基于 NIO 实现的通信框架，而 AIO 没有特别靠谱的框架，Netty 曾去掉了 NIO.2（AIO），据说主要是因为效率并不比 NIO 高；
    * 更高效的序列化/反序列化协议，一般刚开始会使用 Java 的 ObjectInput/OutputStream，可以考虑根据需求改为使用 Kryo、Hessian、Protostuff 等协议实现对象的序列化。
1. 引入数据一致性风险
下面分出一章进行说明。

#### 保证数据一致性的 3 大法宝
数据满足一致性指的是数据按正常的程序逻辑受到修改，不会出现某处 update 逻辑没有生效的情况。
1. 时间戳/版本号（乐观锁）
    * 没有会怎么样
    ![X](http://47.88.24.11/imgs/记2018年8月9日的转正答辩/没有时间戳会怎么样？.png)
    如上图所示，两个人刚开始都手握数据相同的一份副本，第二个人先修改了数据中的属性 B 并保存，然后第一个人再修改属性 A 并保存，此时第一个人发现数据中的 B 也被修改了，但是却不知道是怎么发生的，这样的用户体验就不大好。
    单纯使用时间戳当然是不可能保证并发安全的，因为时间戳只是在进入业务逻辑处理前校验一下，对临界区没有任何限制，除非临界区只有一条原子语句。
    * 版本号更好？
    我认为版本号更好，因为可以和 ES（Elasticsearch）兼容，ES 使用版本号来控制并发。
    * 司库云中的实现
    司库云中为每个实体类添加了一个时间戳字段。
1. 分布式锁
    * 没有会怎么样？
    会产生并发风险。
    ![X](http://47.88.24.11/imgs/记2018年8月9日的转正答辩/没有分布式锁会怎么样？.png)
    如上图所示，在失去分布式锁之后，两者执行更新命令，但指令执行先后顺序是不确定的，因此某些结果会丢失。
    * 服务端要求
    需要有一个高一致性的存储系统。
    * 客户端要求
    对客户端的要求比较多，包括 lock/unlock 操作必须是原子的、无死锁、“解铃还需系铃人”（不会解锁其他人上的锁），因此必须小心实现，当然也可以使用现成的，比如 Curator 中的实现。
    * 司库云中的实现
    司库云中实现了一个给予 ZooKeeper 的分布式锁，但是没有使用 Curator，而是直接使用 ZooKeeper 客户端操作节点实现的，使用下面的代码来调用。
        ```Java
        Boolean locked = false;
        try {
          locked = lock(vo)
          checkVersion(vo)
          save(vo)
        } catch(VersionException e) {
          throw new Exception(“”);
        } catch(LockException e) {
          throw new RuntimeException();
        } finally {
          if(locked) releaseLock(vo);
        }
        ```
1. 分布式事务
    * 没有会怎么样？
    执行跨多个库的写操作时会有并发风险。
    ![X](http://47.88.24.11/imgs/记2018年8月9日的转正答辩/没有分布式事务会怎么样？.png)
    如上图所示，在调用 updateB 并返回后服务 1 内出错了，由于本地事务的存在服务 1 会回滚，但是服务 2 就没有办法回滚了。
    * 分布式事务实现要点
    需要有一个事务协调者记录执行路径，且分布式事务框架必须记录好事务日志用于出错时的手动回滚。
    * 司库云中的实现
    司库云中使用的是事务补偿机制来实现的，示例代码如下。
        ```Java
        Service.approve(vo);
        try {
          // ...业务操作
        } catch(Exception e) {
          // …记录日志
          service.unapproved(vo);
        }
        ```
        
#### 编码工作总结
1. 分析
仔细分析功能，多听取有经验的前辈的意见。
对问题建模，将设计落实到纸上、做好记录。
1. 编码
使用设计模式、数据结构和算法原理来优化设计。
在实际提交给测试人员之前尽可能列出可能出现的 Bug、并做好自测。
1. 维护
枚举测试没考虑到的细节，不让问题死灰复燃。
思考问题原因，不让问题再次出现。
追究相关场景，不让问题反复出现。

#### 学习与工作量
学了些什么，做了些什么

#### 展望下一个一年
1. 深入学习云计算相关技术
分布式系统、中间件等原理
实际开发框架
1. 改善拖延症、提高工作效率
每日笔记
记录做每件事所消耗的时间
1. 提升身体素质
与所有地球人共勉。

### 代码展示
这个环节没把握好节奏，我把所有代码都粗略演示了一遍，实际上把某个比较熟悉的功能演示一遍就可以了。

### QA
1. 这个方法的参数为什么没有做非空校验？
答：传入的参数不可能为 null（保证为空字符串数组、空 List 等）。
1. 精度怎么控制的？
答：在 Controller 方法返回之前（指出在哪个方法里）。
1. 这个参照（当 A 需要关联 B 时从 B 的所有记录中找出一条，称为 A 对 B 有参照，引用了一条 B）是整表查询，有经过性能测试吗？
答：没有做测试，这个发债模块的数据量不是特别大，而且性能测试这些一般是交给测试部做的。
补充：对参照的优化可以参照台账。
1. 已经被修改过的数据怎么防止被另一个用户修改？
答（不满意）：这是通过时间戳来实现的，首先两个人都手握同一条数据，一个人修改后会更新数据库里这条数据的时间戳，另一个人对老的数据进行修改时，将数据发到后台，后台会将其和数据库中的相应数据的时间戳进行比较，若小于数据库中的时间则提醒：“该 xx 已被修改，请刷新后重试。”。
1. 这个时间戳是服务器时间还是客户端时间？
答：我认为都可以，因为客户无法感知这个时间。
补充：应该是取服务器时间，在新增的时候取服务器时间作为初始值，之后由客户端将时间戳原封不动地传到后台，后台先跟数据库里的值进行比对，如果无误再用服务器的时间更新时间戳。
补充 2：客户发起修改请求的时候篡改时间戳怎么办？给他篡改吧，本身时间戳的目的就是提升用户体验，如果用户知道会发生什么事情，这么做也没什么影响。
1. 你刚才在远程调用那里说应该区分框架异常和业务异常，但是你在 Sdk 方法（远程调用方法）里面却一块捕捉了？对于异常处理你有什么想法吗？
答：我在后来做毕设的时候就是为不同的情况定义了不同的异常类，分别进行捕捉（说明我后来思考过这个问题）。我认为框架异常和业务异常应该区分开来，他们应该交给不同的人进行分析。
1. 两个人同时对一笔单据推单，怎么控制并发？应该在上游还是下游做控制？
答（不满意）：^*^#@&*$（没反应过来推单业务的执行流程）。
补充（一位评委老哥给出了具体解答，点个赞，但是这里记不大清了）：多个服务器实例的情况下应该在上游加锁，下游再校验一下上游是否已经正确做了操作。
补充 2：如果是单服务器实例的情况下直接用内存锁其实就够了。下游的校验主要是为了保证只能推出来一条。
补充 3：应用可能复制、数据库可能复制，需要分别进行讨论。在应用层，可以在上游进行加锁、下游校验是否重复操作。单库下的 DB 层，可以使用行锁锁定该笔数据（有分布式锁的情况下数据库内加锁其实没有什么意义）。多库下的 DB 层，因为一个业务操作可能涉及到写多个库，一般情况下需要使用分布式事务来保证原子性。拆库后的 DB 层，根据拆库方式的不同需要进行各数据库副本之间的同步。
补充 4：性能、伸缩性...，问题很多，需要另外讨论了。
1. 分布式事务相对补偿事务有什么好处？
答：有一次平台那边的审批出错，没有生成对应的流程实例，后面业务报错的时候直接调用逆操作方法，结果前端报的错是“取消审批失败”，就比较荒唐（解释补偿事务有什么问题）。淘宝就提出了一种分布式事务 TCC，它把每个业务操作分为 Try-Confirm-Cancel 三个阶段，其中 Try 阶段可以锁定资源，还能检验链路是否畅通，我觉得这是优于补偿事务的比较好的地方。
1. （HRBP 问）能说明一下微服务的好处吗？
答（答得比较乱）：微服务有一个相近的概念是 SOA，它们之间的主要区别是治理方式，SOA 依赖消息总线（ESB）来注册所有的服务，当一个服务需要调用另一个服务的时候它需要从消息总线里获取那个服务的地址等信息，但微服务架构则没有这个概念，服务之间通过 REST 协议进行通信，没有 ESB 的概念。
相对单体式架构来说，微服务将软件划分成一个个相对独立的服务，每个服务负责的业务范围都是足够小的，这样不会给开发带来太多的负担，服务启动速度更快、某个服务出错也不会导致整个应用不可用，缺点是服务之间的调用需要付出网络请求的代价，且涉及跨库写的业务操作会产生不一致的风险。

## 遗憾
因为某些不可抗力的关系（其实是拖延症犯了），我的转正答辩准备得非常仓促，从准备材料到准备答辩不过 2 天时间，所以答辩过程中出现了很多问题，其中比较严重的被当场指出了，有下面几点：
1. 理论没有落地。
比如对分布式事务的论述，答辩委员更多看的是代码的规范与否，插入一些没有什么关联的东西多少会给评委留下装逼的印象。我计划以后多看一些开源项目的源码，明白它们的原理，这样在讲的时候才不会显得那么浮。
1. 代码没有经过严格性能测试。
这个问题比较严重，主要是当时小组成员中途流失了很多，有些节点的任务直接掉到了我头上，几个前端又催得紧，回去又要准备毕设的东西，所以性能测试基本是没有测的。我计划以后学一些 JMeter、ab 这样的工具。
1. 代码不够规范。
代码规范是程序员的节操，平时我看过类似介绍代码规范的文章，也在 IDEA 中装了相关的插件（findbugs、alibaba 规范插件），却在公司代码中没做好，不是节操掉了，而是也和时间匆忙有关系，其实没有多少时间去考虑规范不规范的问题，甚至在台账 Service 中出现了达到 300 行的方法。为此我打算接下来学习一下阿里的 Java 编码规范，考个证，应该不会花费太多时间，做题也比干读公司发的规范强。
对于这种演讲的场合，最好还是捡自己满意的一两个功能讲一下代码，我把大部分代码都展示了一下，既浪费时间、又讲不明白。
1. 超时了。
因为没有事先模拟答辩，最后这 30 页 PPT 讲得太久了，结果把后面那个人给挤延期了，抱歉。