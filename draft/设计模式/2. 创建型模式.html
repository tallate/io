<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="[TOC] ¶创建型模式 ¶工厂模式（Factory Pattern） 工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 ¶意图 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 ¶">
<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/draft/设计模式/2. 创建型模式.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="[TOC] ¶创建型模式 ¶工厂模式（Factory Pattern） 工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 ¶意图 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 ¶">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tallate.github.io/draft/设计模式/37bbfecb-95b9-481a-a101-544796dedbbd.png">
<meta property="og:updated_time" content="2020-11-10T00:24:42.809Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">
<meta name="twitter:description" content="[TOC] ¶创建型模式 ¶工厂模式（Factory Pattern） 工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 ¶意图 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 ¶">
<meta name="twitter:image" content="https://tallate.github.io/draft/设计模式/37bbfecb-95b9-481a-a101-544796dedbbd.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/draft/设计模式/2. 创建型模式.html">







  <title> | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">


	<h1 class="post-title" itemprop="name headline"></h1>








</header>






      
      
      
      <div class="post-body">
        
        
          <p>[TOC]</p>
<h2 id="创建型模式"><a class="header-anchor" href="#创建型模式">¶</a>创建型模式</h2>
<h3 id="工厂模式-factory-pattern"><a class="header-anchor" href="#工厂模式-factory-pattern">¶</a>工厂模式（Factory Pattern）</h3>
<p>工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h4 id="意图"><a class="header-anchor" href="#意图">¶</a>意图</h4>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<h4 id="主要解决"><a class="header-anchor" href="#主要解决">¶</a>主要解决</h4>
<p>主要解决接口选择的问题。</p>
<h4 id="何时使用"><a class="header-anchor" href="#何时使用">¶</a>何时使用</h4>
<p>我们明确地计划不同条件下创建不同实例时。</p>
<h4 id="如何解决"><a class="header-anchor" href="#如何解决">¶</a>如何解决</h4>
<p>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<h4 id="关键代码"><a class="header-anchor" href="#关键代码">¶</a>关键代码</h4>
<p>创建过程在其子类执行。</p>
<h4 id="应用实例"><a class="header-anchor" href="#应用实例">¶</a>应用实例</h4>
<p>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<h4 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h4>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<h4 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h4>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4>
<ol>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li>
<li>设计一个连接服务器的框架，需要三个协议，“POP3”、</li>
</ol>
<p>“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<h4 id="注意"><a class="header-anchor" href="#注意">¶</a>注意</h4>
<p>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用 工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h4 id="示例实现"><a class="header-anchor" href="#示例实现">¶</a>示例实现</h4>
<p>![2d413f72-9f98-4d19-aa6e-1b782138ea6c.png](2. 创建型模式_files/2d413f72-9f98-4d19-aa6e-1b782138ea6c.png)<br>
通过传入的字符串来判断应该实例化哪个Shape的子类（工厂类也可以有一个基类称为抽象工厂，在下面讨论），具体代码就不给出了。</p>
<h3 id="抽象工厂模式-abstract-factory-pattern"><a class="header-anchor" href="#抽象工厂模式-abstract-factory-pattern">¶</a>抽象工厂模式（Abstract Factory Pattern）</h3>
<p>抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h4 id="意图-v2"><a class="header-anchor" href="#意图-v2">¶</a>意图</h4>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h4 id="主要解决-v2"><a class="header-anchor" href="#主要解决-v2">¶</a>主要解决</h4>
<p>主要解决接口选择的问题。</p>
<h4 id="何时使用-v2"><a class="header-anchor" href="#何时使用-v2">¶</a>何时使用</h4>
<p>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品</p>
<h4 id="如何解决-v2"><a class="header-anchor" href="#如何解决-v2">¶</a>如何解决</h4>
<p>在一个产品族里面，定义多个产品</p>
<h4 id="关键代码-v2"><a class="header-anchor" href="#关键代码-v2">¶</a>关键代码</h4>
<p>在一个工厂里聚合多个同类产品。</p>
<h4 id="应用实例-v2"><a class="header-anchor" href="#应用实例-v2">¶</a>应用实例</h4>
<p>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体 产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的， 要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次 拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这 些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<h4 id="优点-v2"><a class="header-anchor" href="#优点-v2">¶</a>优点</h4>
<p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<h4 id="缺点-v2"><a class="header-anchor" href="#缺点-v2">¶</a>缺点</h4>
<p>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<h4 id="使用场景-v2"><a class="header-anchor" href="#使用场景-v2">¶</a>使用场景</h4>
<ol>
<li>QQ 换皮肤，一整套一起换。</li>
<li>生成不同操作系统的程序。</li>
</ol>
<h4 id="注意-v2"><a class="header-anchor" href="#注意-v2">¶</a>注意</h4>
<p>产品族难扩展，产品等级易扩展。</p>
<h4 id="示例实现-v2"><a class="header-anchor" href="#示例实现-v2">¶</a>示例实现</h4>
<p>![d90c54b4-8bbc-4ef4-bd55-3d895d3342ca.png](2. 创建型模式_files/d90c54b4-8bbc-4ef4-bd55-3d895d3342ca.png)<br>
代码逻辑比较简单：</p>
<ol>
<li>FactoryProducer通过传入的参数来判断应该实例化哪个工厂类；</li>
<li>客户端使用返回的工厂类来批量实例化对应的Shape或Color。</li>
<li>工厂类使用（普通）工厂模式实现。</li>
</ol>
<h3 id="单例模式-singleton-pattern"><a class="header-anchor" href="#单例模式-singleton-pattern">¶</a>单例模式（Singleton Pattern）</h3>
<p>单例模式是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h4 id="注意-v3"><a class="header-anchor" href="#注意-v3">¶</a>注意</h4>
<p>1、单例类只能有一个实例<br>
2、单例类必须自己创建自己的唯一实例<br>
3、单例类必须给所有其他对象提供这一实例。</p>
<h4 id="意图-v3"><a class="header-anchor" href="#意图-v3">¶</a>意图</h4>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h4 id="主要解决-v3"><a class="header-anchor" href="#主要解决-v3">¶</a>主要解决</h4>
<p>一个全局使用的类频繁地创建与销毁。</p>
<h4 id="何时使用-v3"><a class="header-anchor" href="#何时使用-v3">¶</a>何时使用</h4>
<p>当您想控制实例数目，节省系统资源的时候。</p>
<h4 id="如何解决-v3"><a class="header-anchor" href="#如何解决-v3">¶</a>如何解决</h4>
<p>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<h4 id="关键代码-v3"><a class="header-anchor" href="#关键代码-v3">¶</a>关键代码</h4>
<p>构造函数是私有的。</p>
<h4 id="应用实例-v3"><a class="header-anchor" href="#应用实例-v3">¶</a>应用实例</h4>
<ol>
<li>一个党只能有一个主席。</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ol>
<h4 id="优点-v3"><a class="header-anchor" href="#优点-v3">¶</a>优点</h4>
<ol>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ol>
<h4 id="缺点-v3"><a class="header-anchor" href="#缺点-v3">¶</a>缺点</h4>
<p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h4 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h4>
<p><img src="/draft/设计模式/37bbfecb-95b9-481a-a101-544796dedbbd.png" alt="37bbfecb-95b9-481a-a101-544796dedbbd.png"></p>
<ol>
<li>构造方法是private的</li>
<li>获取实例的唯一入口getInstance()是静态的，对对象的实例化存在多种方式，包括懒汉式、饿汉式、双检锁、静态内部类、枚举等方式，在线程安全、是否懒加载、实现难度上存在区别，以下分别进行讨论。</li>
</ol>
<h4 id="懒汉式-线程不安全"><a class="header-anchor" href="#懒汉式-线程不安全">¶</a>懒汉式（线程不安全）</h4>
<p>是否 Lazy 初始化：是<br>
是否多线程安全：否<br>
实现难度：易<br>
描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒汉式-线程安全"><a class="header-anchor" href="#懒汉式-线程安全">¶</a>懒汉式（线程安全）</h4>
<p>是否 Lazy 初始化：是<br>
是否多线程安全：是<br>
实现难度：易<br>
描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="饿汉式"><a class="header-anchor" href="#饿汉式">¶</a>饿汉式</h4>
<p>是否 Lazy 初始化：否<br>
是否多线程安全：是<br>
实现难度：易<br>
描述：这种方式比较常用，但容易产生垃圾对象。<br>
优点：没有加锁，执行效率会提高。<br>
缺点：类加载时就初始化，浪费内存。<br>
它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    private static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双检锁-双重校验锁-dcl-即-double-checked-locking"><a class="header-anchor" href="#双检锁-双重校验锁-dcl-即-double-checked-locking">¶</a>双检锁/双重校验锁（DCL，即 double-checked locking）</h4>
<p>JDK 版本：JDK1.5 起<br>
是否 Lazy 初始化：是<br>
是否多线程安全：是<br>
实现难度：较复杂<br>
描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            synchronized(Singleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式需要注意的是对volatile的使用。</p>
<h4 id="登记式-静态内部类"><a class="header-anchor" href="#登记式-静态内部类">¶</a>登记式/静态内部类</h4>
<p>是否 Lazy 初始化：是<br>
是否多线程安全：是<br>
实现难度：一般<br>
描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Single();</span><br><span class="line">    &#125;</span><br><span class="line">    private Single() &#123;&#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。只有第一次调用<code>getInstance</code>时虚拟机才会去加载SingletonHolder类。<br>
而虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。因此可以认为静态内部类中的单例是线程安全的。</clinit></clinit></clinit></p>
<h4 id="枚举"><a class="header-anchor" href="#枚举">¶</a>枚举</h4>
<p>JDK 版本：JDK1.5 起<br>
是否 Lazy 初始化：否<br>
是否多线程安全：是<br>
实现难度：易<br>
描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4>
<p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>
<h3 id="建造者模式-builder-pattern"><a class="header-anchor" href="#建造者模式-builder-pattern">¶</a>建造者模式（Builder Pattern）</h3>
<p>建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h4 id="意图-v4"><a class="header-anchor" href="#意图-v4">¶</a>意图</h4>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<h4 id="主要解决-v4"><a class="header-anchor" href="#主要解决-v4">¶</a>主要解决</h4>
<p>主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<h4 id="何时使用-v4"><a class="header-anchor" href="#何时使用-v4">¶</a>何时使用</h4>
<p>一些基本部件不会变，而其组合经常变化的时候。</p>
<h4 id="如何解决-v4"><a class="header-anchor" href="#如何解决-v4">¶</a>如何解决</h4>
<p>将变与不变分离开。</p>
<h4 id="关键代码-v4"><a class="header-anchor" href="#关键代码-v4">¶</a>关键代码</h4>
<p>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<h4 id="应用实例-v4"><a class="header-anchor" href="#应用实例-v4">¶</a>应用实例</h4>
<p>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&quot;套餐&quot;。</p>
<h4 id="优点-v4"><a class="header-anchor" href="#优点-v4">¶</a>优点</h4>
<p>1、建造者独立，易扩展。<br>
2、便于控制细节风险。</p>
<h4 id="缺点-v4"><a class="header-anchor" href="#缺点-v4">¶</a>缺点</h4>
<p>1、产品必须有共同点，范围有限制。<br>
2、如内部变化复杂，会有很多的建造类。</p>
<h4 id="使用场景-v3"><a class="header-anchor" href="#使用场景-v3">¶</a>使用场景</h4>
<p>1、需要生成的对象具有复杂的内部结构。<br>
2、需要生成的对象内部属性本身相互依赖。</p>
<h4 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h4>
<p>与工厂模式的区别是：建造者模式更加关注于零件装配的顺序。</p>
<h4 id="示例实现-v3"><a class="header-anchor" href="#示例实现-v3">¶</a>示例实现</h4>
<p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。       我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。       然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br>
![2ea49d95-c0fa-4441-8a3a-3a10cef751aa.png](2. 创建型模式_files/2ea49d95-c0fa-4441-8a3a-3a10cef751aa.png)<br>
上面的类图看起来可能会有些乱，这也是建造者所关注的问题：某个复合对象由多个相对简单的对象组合而成，我们亟需提供一个统一的接口来简化这个复合对象的构建过程。</p>
<h3 id="原型模式-prototype-pattern"><a class="header-anchor" href="#原型模式-prototype-pattern">¶</a>原型模式（Prototype Pattern）</h3>
<p>原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h4 id="意图-v5"><a class="header-anchor" href="#意图-v5">¶</a>意图</h4>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h4 id="主要解决-v5"><a class="header-anchor" href="#主要解决-v5">¶</a>主要解决</h4>
<p>在运行期建立和删除原型。</p>
<h4 id="何时使用-v5"><a class="header-anchor" href="#何时使用-v5">¶</a>何时使用</h4>
<p>1、当一个系统应该独立于它的产品创建，构成和表示时。<br>
2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。<br>
3、为了避免创建一个与产品类层次平行的工厂类层次时。<br>
4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>
<h4 id="如何解决-v5"><a class="header-anchor" href="#如何解决-v5">¶</a>如何解决</h4>
<p>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<h4 id="关键代码-v5"><a class="header-anchor" href="#关键代码-v5">¶</a>关键代码</h4>
<p>1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。<br>
2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些&quot;易变类&quot;拥有稳定的接口。</p>
<h4 id="应用实例-v5"><a class="header-anchor" href="#应用实例-v5">¶</a>应用实例</h4>
<p>1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p>
<h4 id="优点-v5"><a class="header-anchor" href="#优点-v5">¶</a>优点</h4>
<p>1、性能提高。 2、逃避构造函数的约束。</p>
<h4 id="缺点-v5"><a class="header-anchor" href="#缺点-v5">¶</a>缺点</h4>
<p>1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。</p>
<h4 id="使用场景-v4"><a class="header-anchor" href="#使用场景-v4">¶</a>使用场景</h4>
<p>1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<h4 id="注意事项-v2"><a class="header-anchor" href="#注意事项-v2">¶</a>注意事项</h4>
<p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h4 id="如何解决-v6"><a class="header-anchor" href="#如何解决-v6">¶</a>如何解决</h4>
<p>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<h4 id="关键代码-v6"><a class="header-anchor" href="#关键代码-v6">¶</a>关键代码</h4>
<p>1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。</p>
<p>2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些&quot;易变类&quot;拥有稳定的接口。</p>
<h4 id="应用实例-v6"><a class="header-anchor" href="#应用实例-v6">¶</a>应用实例</h4>
<p>1、细胞分裂。</p>
<p>2、JAVA 中的 Object clone() 方法。</p>
<h4 id="优点-v6"><a class="header-anchor" href="#优点-v6">¶</a>优点</h4>
<p>1、性能提高。</p>
<p>2、逃避构造函数的约束。</p>
<h4 id="缺点-v6"><a class="header-anchor" href="#缺点-v6">¶</a>缺点</h4>
<p>1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</p>
<p>2、必须实现 Cloneable 接口。</p>
<p>3、逃避构造函数的约束。</p>
<h4 id="使用场景-v5"><a class="header-anchor" href="#使用场景-v5">¶</a>使用场景</h4>
<p>1、资源优化场景。<br>
2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。<br>
3、性能和安全要求的场景。<br>
4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>
5、一个对象多个修改者的场景。<br>
6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。<br>
7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<h4 id="注意事项-v3"><a class="header-anchor" href="#注意事项-v3">¶</a>注意事项</h4>
<p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h4 id="示例实现-v4"><a class="header-anchor" href="#示例实现-v4">¶</a>示例实现</h4>
<p>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>
我们的演示类使用 ShapeCache 类来获取 Shape 对象。</p>
<p>![c4d7a42a-a42b-4a0b-8751-10e740d5e90c.png](2. 创建型模式_files/c4d7a42a-a42b-4a0b-8751-10e740d5e90c.png)<br>
注意上边的抽象类Shape需要实现Clonable接口并重写clone()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">    Object obj = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        obj = super.clone();</span><br><span class="line">    &#125; catch(CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShapeCache使用一个shapeMap来缓存形状对象，初始化时需要调用loadCache()来加载预置对象，调用getShape()时会根据shapeId来获取对应的对象的克隆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeCache &#123;</span><br><span class="line">    private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;();</span><br><span class="line">    public static Shape getShape(String shapeId) &#123;</span><br><span class="line">        Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">        return (Shape) cachedShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public static vlod loadCache() &#123;</span><br><span class="line">        Circle circle = new Circle();</span><br><span class="line">        circle.setId(&quot;1&quot;);</span><br><span class="line">        shapeMap.put(circle.getId().circle);</span><br><span class="line"></span><br><span class="line">        Square aquare = new Square();</span><br><span class="line">        square.setId(&quot;2&quot;);</span><br><span class="line">        shapeMap.put(square.getId(), square);</span><br><span class="line">        </span><br><span class="line">        Rectangle rectangle = new Rectangle();</span><br><span class="line">        rectangle.setId(&quot;3&quot;);</span><br><span class="line">        shapeMap.put(rectangle.getId(), rectangle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">122</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建型模式"><span class="nav-number">1.</span> <span class="nav-text">¶创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式-factory-pattern"><span class="nav-number">1.1.</span> <span class="nav-text">¶工厂模式（Factory Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图"><span class="nav-number">1.1.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决"><span class="nav-number">1.1.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用"><span class="nav-number">1.1.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决"><span class="nav-number">1.1.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码"><span class="nav-number">1.1.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例"><span class="nav-number">1.1.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">1.1.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">1.1.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">1.1.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意"><span class="nav-number">1.1.10.</span> <span class="nav-text">¶注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现"><span class="nav-number">1.1.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象工厂模式-abstract-factory-pattern"><span class="nav-number">1.2.</span> <span class="nav-text">¶抽象工厂模式（Abstract Factory Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v2"><span class="nav-number">1.2.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v2"><span class="nav-number">1.2.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v2"><span class="nav-number">1.2.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v2"><span class="nav-number">1.2.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v2"><span class="nav-number">1.2.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v2"><span class="nav-number">1.2.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v2"><span class="nav-number">1.2.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v2"><span class="nav-number">1.2.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v2"><span class="nav-number">1.2.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意-v2"><span class="nav-number">1.2.10.</span> <span class="nav-text">¶注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v2"><span class="nav-number">1.2.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式-singleton-pattern"><span class="nav-number">1.3.</span> <span class="nav-text">¶单例模式（Singleton Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意-v3"><span class="nav-number">1.3.1.</span> <span class="nav-text">¶注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v3"><span class="nav-number">1.3.2.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v3"><span class="nav-number">1.3.3.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v3"><span class="nav-number">1.3.4.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v3"><span class="nav-number">1.3.5.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v3"><span class="nav-number">1.3.6.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v3"><span class="nav-number">1.3.7.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v3"><span class="nav-number">1.3.8.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v3"><span class="nav-number">1.3.9.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">1.3.10.</span> <span class="nav-text">¶实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#懒汉式-线程不安全"><span class="nav-number">1.3.11.</span> <span class="nav-text">¶懒汉式（线程不安全）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#懒汉式-线程安全"><span class="nav-number">1.3.12.</span> <span class="nav-text">¶懒汉式（线程安全）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#饿汉式"><span class="nav-number">1.3.13.</span> <span class="nav-text">¶饿汉式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双检锁-双重校验锁-dcl-即-double-checked-locking"><span class="nav-number">1.3.14.</span> <span class="nav-text">¶双检锁/双重校验锁（DCL，即 double-checked locking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#登记式-静态内部类"><span class="nav-number">1.3.15.</span> <span class="nav-text">¶登记式/静态内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举"><span class="nav-number">1.3.16.</span> <span class="nav-text">¶枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.3.17.</span> <span class="nav-text">¶总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建造者模式-builder-pattern"><span class="nav-number">1.4.</span> <span class="nav-text">¶建造者模式（Builder Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v4"><span class="nav-number">1.4.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v4"><span class="nav-number">1.4.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v4"><span class="nav-number">1.4.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v4"><span class="nav-number">1.4.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v4"><span class="nav-number">1.4.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v4"><span class="nav-number">1.4.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v4"><span class="nav-number">1.4.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v4"><span class="nav-number">1.4.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v3"><span class="nav-number">1.4.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-number">1.4.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v3"><span class="nav-number">1.4.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型模式-prototype-pattern"><span class="nav-number">1.5.</span> <span class="nav-text">¶原型模式（Prototype Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v5"><span class="nav-number">1.5.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v5"><span class="nav-number">1.5.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v5"><span class="nav-number">1.5.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v5"><span class="nav-number">1.5.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v5"><span class="nav-number">1.5.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v5"><span class="nav-number">1.5.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v5"><span class="nav-number">1.5.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v5"><span class="nav-number">1.5.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v4"><span class="nav-number">1.5.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v2"><span class="nav-number">1.5.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v6"><span class="nav-number">1.5.11.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v6"><span class="nav-number">1.5.12.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v6"><span class="nav-number">1.5.13.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v6"><span class="nav-number">1.5.14.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v6"><span class="nav-number">1.5.15.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v5"><span class="nav-number">1.5.16.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v3"><span class="nav-number">1.5.17.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v4"><span class="nav-number">1.5.18.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
