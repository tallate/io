<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="[TOC] ¶结构型模式 ¶适配器模式（Adapter Pattern） 适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实">
<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/draft/设计模式/3. 结构型模式.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="[TOC] ¶结构型模式 ¶适配器模式（Adapter Pattern） 适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-09-28T13:11:01.965Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">
<meta name="twitter:description" content="[TOC] ¶结构型模式 ¶适配器模式（Adapter Pattern） 适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/draft/设计模式/3. 结构型模式.html">







  <title> | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">


	<h1 class="post-title" itemprop="name headline"></h1>








</header>






      
      
      
      <div class="post-body">
        
        
          <p>[TOC]</p>
<h2 id="结构型模式"><a class="header-anchor" href="#结构型模式">¶</a>结构型模式</h2>
<h3 id="适配器模式-adapter-pattern"><a class="header-anchor" href="#适配器模式-adapter-pattern">¶</a>适配器模式（Adapter Pattern）</h3>
<p>适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>
这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>
我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p>
<h4 id="意图"><a class="header-anchor" href="#意图">¶</a>意图</h4>
<p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h4 id="主要解决"><a class="header-anchor" href="#主要解决">¶</a>主要解决</h4>
<p>主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<h4 id="何时使用"><a class="header-anchor" href="#何时使用">¶</a>何时使用</h4>
<p>1、系统需要使用现有的类，而此类的接口不符合系统的需要。<br>
2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。<br>
3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<h4 id="如何解决"><a class="header-anchor" href="#如何解决">¶</a>如何解决</h4>
<p>继承或依赖（推荐）。</p>
<h4 id="关键代码"><a class="header-anchor" href="#关键代码">¶</a>关键代码</h4>
<p>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<h4 id="应用实例"><a class="header-anchor" href="#应用实例">¶</a>应用实例</h4>
<p>1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。<br>
2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。<br>
3、在 LINUX 上运行 WINDOWS 程序。<br>
4、JAVA 中的 jdbc。</p>
<h4 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h4>
<p>1、可以让任何两个没有关联的类一起运行。<br>
2、提高了类的复用。<br>
3、增加了类的透明度。<br>
4、灵活性好。</p>
<h4 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h4>
<p>1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。<br>
2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4>
<p>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<h4 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h4>
<p>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h4 id="示例实现"><a class="header-anchor" href="#示例实现">¶</a>示例实现</h4>
<p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。<br>
我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p>
<p>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>
AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。<br>
AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。</p>
<p>![cf796c31-1e93-46b6-9637-7bebc8540348.png](3. 结构型模式_files/cf796c31-1e93-46b6-9637-7bebc8540348.png)<br>
MediaAdapter是一个适配器，AudioPlayer需要通过MediaAdapter来间接操作AdvancedMediaPlayer进行VLC或Mp4的播放，注意它们都实现了MediaPlayer接口，这意味着对客户端来说操作MediaAdapter和AudioPlayer没有什么区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MediaAdapter implements MediaPlayer &#123;</span><br><span class="line">    AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line">    public MediaAdapter(String audioType) &#123;</span><br><span class="line">        if(audioType.equalsIgnoreCase(&quot;vlc&quot;)) &#123;</span><br><span class="line">            advancedMusicPlayer = new VlcPlayer();</span><br><span class="line">        &#125; else if(audioType.equalsIgnoreCase(&quot;mp4&quot;)) &#123;</span><br><span class="line">            advancedMusicPlayer = new Mp4Player();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void play(String audioType, String fileName) &#123;</span><br><span class="line">        if(audioType.equalsIgnoreCase(&quot;vlc&quot;)) &#123;</span><br><span class="line">            advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">        &#125; else if(audioType.equalsIgnoreCase(&quot;mp4&quot;)) &#123;</span><br><span class="line">            advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AudioPlayer implements MediaPlayer &#123;</span><br><span class="line">    MediaAdapter mediaAdapter;</span><br><span class="line">    @Override</span><br><span class="line">    public void play(String audioType, String fileName) &#123;</span><br><span class="line">        if(audioType.equalsIgnoreCase(&quot;mp3&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Playing mp3 file. Name: &quot; + fileName);</span><br><span class="line">        &#125; else if(audioType.equalsIgnoreCase(&quot;vlc&quot;)</span><br><span class="line">                || audioType.equalsIgnoreCase(&quot;mp4&quot;)) &#123;</span><br><span class="line">            mediaAdapter = new MediaAdapter(audioType);</span><br><span class="line">            mediaAdapter.play(audioType, fileName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Invalid media. &quot; + audioType + &quot; format not supported&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桥接模式-bridge"><a class="header-anchor" href="#桥接模式-bridge">¶</a>桥接模式（Bridge）</h3>
<p>桥接是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>
这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>
我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<h4 id="意图-v2"><a class="header-anchor" href="#意图-v2">¶</a>意图</h4>
<p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<h4 id="主要解决-v2"><a class="header-anchor" href="#主要解决-v2">¶</a>主要解决</h4>
<p>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<h4 id="何时使用-v2"><a class="header-anchor" href="#何时使用-v2">¶</a>何时使用</h4>
<p>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<h4 id="如何解决-v2"><a class="header-anchor" href="#如何解决-v2">¶</a>如何解决</h4>
<p>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<h4 id="关键代码-v2"><a class="header-anchor" href="#关键代码-v2">¶</a>关键代码</h4>
<p>抽象类依赖实现类。</p>
<h4 id="应用实例-v2"><a class="header-anchor" href="#应用实例-v2">¶</a>应用实例</h4>
<p>1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。<br>
2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
<h4 id="优点-v2"><a class="header-anchor" href="#优点-v2">¶</a>优点</h4>
<p>1、抽象和实现的分离。<br>
2、优秀的扩展能力。</p>
<p>3、实现细节对客户透明。</p>
<h4 id="缺点-v2"><a class="header-anchor" href="#缺点-v2">¶</a>缺点</h4>
<p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<h4 id="使用场景-v2"><a class="header-anchor" href="#使用场景-v2">¶</a>使用场景</h4>
<p>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。<br>
2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。<br>
3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<h4 id="注意事项-v2"><a class="header-anchor" href="#注意事项-v2">¶</a>注意事项</h4>
<p>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h4 id="示例实现-v2"><a class="header-anchor" href="#示例实现-v2">¶</a>示例实现</h4>
<p>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。<br>
我们的演示类使用 Shape 类来画出不同颜色的圆。</p>
<p>![fbe6f597-3498-496e-ad21-a507b10243c6.png](3. 结构型模式_files/fbe6f597-3498-496e-ad21-a507b10243c6.png)<br>
Shape定义了图形的参数，需要利用DrawAPI来进行图形的绘制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Shape &#123;</span><br><span class="line">    protected DrawAPI drawAPI;</span><br><span class="line">    protected Shape(DrawAPI drawAPI) &#123;</span><br><span class="line">        this.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">    private int x, y, radius;</span><br><span class="line">    public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        drawAPI.drawCircle(radius, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DrawAPI负责图形的实际绘制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface DrawAPI &#123;</span><br><span class="line">    public void drawCircle(int radius, int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class RedCircle implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void drawCircle(int radius, int x, int y) &#123;</span><br><span class="line">        // &gt;&gt; 画红圈代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤器模式-filter-pattern"><a class="header-anchor" href="#过滤器模式-filter-pattern">¶</a>过滤器模式（Filter Pattern）</h3>
<p>过滤器模式或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。<br>
这种类型的设计模式属于 结构型模式，它结合多个标准来获得单一标准。</p>
<h4 id="示例实现-v3"><a class="header-anchor" href="#示例实现-v3">¶</a>示例实现</h4>
<p>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。<br>
我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。</p>
<p>![186528d0-5265-4256-b094-1025293764d9.png](3. 结构型模式_files/186528d0-5265-4256-b094-1025293764d9.png)<br>
下面以或逻辑的过滤实现类OrCriteria为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Criteria &#123;</span><br><span class="line">    public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);</span><br><span class="line">&#125;</span><br><span class="line">public class OrCriteria implements Criteria &#123;</span><br><span class="line">    private Criteria criteria;</span><br><span class="line">    private Criteria otherCriteria;</span><br><span class="line">    public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123;</span><br><span class="line">        this.criteria = criteria;</span><br><span class="line">        this.otherCriteria = otherCriteria;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123;</span><br><span class="line">        List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</span><br><span class="line">        List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</span><br><span class="line">        for(Person person: otherCriteriaItems) &#123;</span><br><span class="line">            if(!firstCriteriaItems.contains(person)) &#123;</span><br><span class="line">                firstCriteriaItems.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return firstCriteriaItems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();</span><br><span class="line">        persons.add(new Person(&quot;Robert&quot;, &quot;Male&quot;, &quot;Single&quot;));</span><br><span class="line">        ...添加其他人</span><br><span class="line">        Criteria single = new CriterlaSingle();</span><br><span class="line">        Criterla female = new CriteriaFemale();</span><br><span class="line">        Criteria singleOrFemale = new OrCriteria(single, female);</span><br><span class="line">        singleOrFemale.meetCriteria(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合模式-composite-pattern"><a class="header-anchor" href="#组合模式-composite-pattern">¶</a>组合模式（Composite Pattern）</h3>
<p>组合模式，又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。<br>
这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。<br>
我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p>
<h4 id="意图-v3"><a class="header-anchor" href="#意图-v3">¶</a>意图</h4>
<p>将对象组合成树形结构以表示&quot;部分-整体&quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h4 id="主要解决-v3"><a class="header-anchor" href="#主要解决-v3">¶</a>主要解决</h4>
<p>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<h4 id="何时使用-v3"><a class="header-anchor" href="#何时使用-v3">¶</a>何时使用</h4>
<p>1、您想表示对象的部分-整体层次结构（树形结构）。<br>
2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<h4 id="如何解决-v3"><a class="header-anchor" href="#如何解决-v3">¶</a>如何解决</h4>
<p>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<h4 id="关键代码-v3"><a class="header-anchor" href="#关键代码-v3">¶</a>关键代码</h4>
<p>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<h4 id="应用实例-v3"><a class="header-anchor" href="#应用实例-v3">¶</a>应用实例</h4>
<p>1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。<br>
2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
<h4 id="优点-v3"><a class="header-anchor" href="#优点-v3">¶</a>优点</h4>
<p>1、高层模块调用简单。<br>
2、节点自由增加。</p>
<h4 id="缺点-v3"><a class="header-anchor" href="#缺点-v3">¶</a>缺点</h4>
<p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<h4 id="使用场景-v3"><a class="header-anchor" href="#使用场景-v3">¶</a>使用场景</h4>
<p>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<h4 id="注意事项-v3"><a class="header-anchor" href="#注意事项-v3">¶</a>注意事项</h4>
<p>定义时为具体类。</p>
<h4 id="示例实现-v4"><a class="header-anchor" href="#示例实现-v4">¶</a>示例实现</h4>
<p>我们有一个类 Employee，该类被当作组合模型类。<br>
我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。</p>
<p>![a3aa4911-dda6-42a9-8461-54e314b97757.png](3. 结构型模式_files/a3aa4911-dda6-42a9-8461-54e314b97757.png)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String dept;</span><br><span class="line">    private int salary;</span><br><span class="line">    private List&lt;Employee&gt; subordinates;</span><br><span class="line"></span><br><span class="line">    public Employee(String name, String dept, int sal) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.dept = dept;</span><br><span class="line">        this.salary = sal;</span><br><span class="line">        subordinates = new ArrayList&lt;Employee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰器模式-decorator-pattern"><a class="header-anchor" href="#装饰器模式-decorator-pattern">¶</a>装饰器模式（Decorator Pattern）</h3>
<p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>
我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p>
<h4 id="意图-v4"><a class="header-anchor" href="#意图-v4">¶</a>意图</h4>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<h4 id="主要解决-v4"><a class="header-anchor" href="#主要解决-v4">¶</a>主要解决</h4>
<p>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<h4 id="何时使用-v4"><a class="header-anchor" href="#何时使用-v4">¶</a>何时使用</h4>
<p>在不想增加很多子类的情况下扩展类。</p>
<h4 id="如何解决-v4"><a class="header-anchor" href="#如何解决-v4">¶</a>如何解决</h4>
<p>将具体功能职责划分，同时继承装饰者模式。</p>
<h4 id="关键代码-v4"><a class="header-anchor" href="#关键代码-v4">¶</a>关键代码</h4>
<p>1、Component 类充当抽象角色，不应该具体实现。<br>
2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<h4 id="应用实例-v4"><a class="header-anchor" href="#应用实例-v4">¶</a>应用实例</h4>
<p>1、孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。<br>
2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>
<h4 id="优点-v4"><a class="header-anchor" href="#优点-v4">¶</a>优点</h4>
<p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<h4 id="缺点-v4"><a class="header-anchor" href="#缺点-v4">¶</a>缺点</h4>
<p>多层装饰比较复杂。</p>
<h4 id="使用场景-v4"><a class="header-anchor" href="#使用场景-v4">¶</a>使用场景</h4>
<p>1、扩展一个类的功能。<br>
2、动态增加功能，动态撤销。</p>
<h4 id="注意事项-v4"><a class="header-anchor" href="#注意事项-v4">¶</a>注意事项</h4>
<p>可代替继承。</p>
<h4 id="示例实现-v5"><a class="header-anchor" href="#示例实现-v5">¶</a>示例实现</h4>
<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。<br>
RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p>
<p>我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<p>![c40b1358-c985-480e-b9fe-3089f18fc4d2.png](3. 结构型模式_files/c40b1358-c985-480e-b9fe-3089f18fc4d2.png)<br>
下面的装饰器使用传入的Shape作为被装饰的目标，在原有方法的基础上还会调用装饰方法setRedBorder()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class RedShapeDecorator extends ShapeDecorator &#123;</span><br><span class="line">    public RedShapeDecorator(Shape decoratedShape) &#123;</span><br><span class="line">        super(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">        setRedBorder(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line">    private void setRedBorder(Shape decoratedShape) &#123;</span><br><span class="line">        System.out.println(&quot;Border Color: Red&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外观模式-facade-pattern"><a class="header-anchor" href="#外观模式-facade-pattern">¶</a>外观模式（Facade Pattern）</h3>
<p>外观模式隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它<strong>向现有的系统添加一个接口，来隐藏系统的复杂性</strong>。<br>
这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<h4 id="意图-v5"><a class="header-anchor" href="#意图-v5">¶</a>意图</h4>
<p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<h4 id="主要解决-v5"><a class="header-anchor" href="#主要解决-v5">¶</a>主要解决</h4>
<p>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<h4 id="何时使用-v5"><a class="header-anchor" href="#何时使用-v5">¶</a>何时使用</h4>
<p>1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个&quot;接待员&quot;即可。<br>
2、定义系统的入口。</p>
<h4 id="如何解决-v5"><a class="header-anchor" href="#如何解决-v5">¶</a>如何解决</h4>
<p>客户端不与系统耦合，外观类与系统耦合。</p>
<h4 id="关键代码-v5"><a class="header-anchor" href="#关键代码-v5">¶</a>关键代码</h4>
<p>在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。</p>
<h4 id="应用实例-v5"><a class="header-anchor" href="#应用实例-v5">¶</a>应用实例</h4>
<p>1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。<br>
2、JAVA 的三层开发模式。</p>
<h4 id="优点-v5"><a class="header-anchor" href="#优点-v5">¶</a>优点</h4>
<p>1、减少系统相互依赖。<br>
2、提高灵活性。<br>
3、提高了安全性。</p>
<h4 id="缺点-v5"><a class="header-anchor" href="#缺点-v5">¶</a>缺点</h4>
<p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<h4 id="使用场景-v5"><a class="header-anchor" href="#使用场景-v5">¶</a>使用场景</h4>
<p>1、为复杂的模块或子系统提供外界访问的模块。<br>
2、子系统相对独立。<br>
3、预防低水平人员带来的风险。</p>
<h4 id="注意事项-v5"><a class="header-anchor" href="#注意事项-v5">¶</a>注意事项</h4>
<p>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<h4 id="示例实现-v6"><a class="header-anchor" href="#示例实现-v6">¶</a>示例实现</h4>
<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。<br>
ShapeMaker 类使用实体类来代表用户对这些类的调用。我们的演示类使用 ShapeMaker 类来显示结果。</p>
<p>![9318eb09-fc24-4006-a44c-b3c1cc7e6d83.png](3. 结构型模式_files/9318eb09-fc24-4006-a44c-b3c1cc7e6d83.png)</p>
<h3 id="享元模式-flyweight-pattern"><a class="header-anchor" href="#享元模式-flyweight-pattern">¶</a>享元模式（Flyweight Pattern）</h3>
<p>享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。<br>
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。</p>
<h4 id="意图-v6"><a class="header-anchor" href="#意图-v6">¶</a>意图</h4>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<h4 id="主要解决-v6"><a class="header-anchor" href="#主要解决-v6">¶</a>主要解决</h4>
<p>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<h4 id="何时使用-v6"><a class="header-anchor" href="#何时使用-v6">¶</a>何时使用</h4>
<p>1、系统中有大量对象<br>
2、这些对象消耗大量内存<br>
3、这些对象的状态大部分可以外部化<br>
4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替<br>
5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<h4 id="如何解决-v6"><a class="header-anchor" href="#如何解决-v6">¶</a>如何解决</h4>
<p>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<h4 id="关键代码-v6"><a class="header-anchor" href="#关键代码-v6">¶</a>关键代码</h4>
<p>用 HashMap 存储这些对象。</p>
<h4 id="应用实例-v6"><a class="header-anchor" href="#应用实例-v6">¶</a>应用实例</h4>
<p>1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p>
<p>2、数据库的数据池。</p>
<h4 id="优点-v6"><a class="header-anchor" href="#优点-v6">¶</a>优点</h4>
<p>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<h4 id="缺点-v6"><a class="header-anchor" href="#缺点-v6">¶</a>缺点</h4>
<p>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<h4 id="使用场景-v6"><a class="header-anchor" href="#使用场景-v6">¶</a>使用场景</h4>
<p>1、系统有大量相似对象。<br>
2、需要缓冲池的场景。</p>
<h4 id="注意事项-v6"><a class="header-anchor" href="#注意事项-v6">¶</a>注意事项</h4>
<p>1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。</p>
<p>2、这些类必须有一个工厂对象加以控制。</p>
<h4 id="示例实现-v7"><a class="header-anchor" href="#示例实现-v7">¶</a>示例实现</h4>
<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。</p>
<p>ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。<br>
FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。</p>
<p>![a86e995f-c35b-4685-b815-41050f83eca3.png](3. 结构型模式_files/a86e995f-c35b-4685-b815-41050f83eca3.png)<br>
享元模式和工厂模式有些像，但享元模式的关键是池的构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap();</span><br><span class="line">    public static Shape getCircle(String color) &#123;</span><br><span class="line">        Circle circle = (Circle) circleMap.get(color);</span><br><span class="line">        if(circle == null) &#123;</span><br><span class="line">            circle = new Circle(color);</span><br><span class="line">            circleMap.put(color, circle);</span><br><span class="line">            System.out.println(&quot;Creating circle of color: &quot; + color);</span><br><span class="line">        &#125;</span><br><span class="line">        return circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理模式-proxy"><a class="header-anchor" href="#代理模式-proxy">¶</a>代理模式（Proxy）</h3>
<h4 id="意图-v7"><a class="header-anchor" href="#意图-v7">¶</a>意图</h4>
<p>为其他对象提供一种代理以控制对这个对象的访问（访问控制）。</p>
<h4 id="主要解决-v7"><a class="header-anchor" href="#主要解决-v7">¶</a>主要解决</h4>
<p>对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行</p>
<p>创建和初始化。我们考虑一个可以在文档中嵌入图形对象的文档编辑器。有些图形对象(如</p>
<p>大型光栅图像)的创建开销很大。但是打开文档必须很迅速,因此我们在打开文档时应避免</p>
<p>一次性创建所有开销很大的对象。因为并非所有这些对象在文档中都同时可见,所以也没有</p>
<p>必要同时创建这些对象。</p>
<h4 id="何时使用-v7"><a class="header-anchor" href="#何时使用-v7">¶</a>何时使用</h4>
<ol>
<li>需要进行访问控制；</li>
<li>需要延迟创建目标对象，因为目标对象的生命周期由代理对象管理；</li>
</ol>
<h4 id="如何解决-v7"><a class="header-anchor" href="#如何解决-v7">¶</a>如何解决</h4>
<p>使代理类继承目标类或实现目标类的父接口，这样客户端在使用代理类时和使用目标类时是一样的。</p>
<h4 id="关键代码-v7"><a class="header-anchor" href="#关键代码-v7">¶</a>关键代码</h4>
<p>在客户端和目标对象之间添加一层代理，代理类可以继承目标类（类代理，CGLIB）或实现目标类的接口（接口代理，JkdProxy）。</p>
<h4 id="应用实例-v7"><a class="header-anchor" href="#应用实例-v7">¶</a>应用实例</h4>
<p>动机一节中 virtual proxy的例子来自于E T + +的文本构建块类。<br>
N E X T S T E P [ A d d 9 4 ]使用代理 (类N X P r o x y的实例 )作为可分布对象的本地代表,当客户请<br>
求远程对象时,服务器为这些对象创建代理。收到消息后,代理对消息和它的参数进行编码,<br>
并将编码后的消息传递给远程实体。类似的,实体对所有的返回结果编码,并将它们返回给<br>
N X P r o x y对象。<br>
McCullough [McC87]讨论了在S m a l l t a l k中用代理访问远程对象的问题。 Pascoe [Pas86]讨<br>
论了如何用“封装器”(E n c a p s u l a t o r s)控制方法调用的副作用以及进行访问控制。</p>
<h4 id="优点-v7"><a class="header-anchor" href="#优点-v7">¶</a>优点</h4>
<p>P r o x y模式在访问对象时引入了一定程度的间接性。根据代理的类型,附加的间接性有多<br>
种用途:<br>
1 ) Remote Proxy可以隐藏一个对象存在于不同地址空间的事实。</p>
<ol start="2">
<li>Virtual Proxy 可以进行最优化,例如根据要求创建对象。</li>
<li>Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理<br>
(Housekeeping task)。<br>
P r o x y模式还可以对用户隐藏另一种称之为 c o p y - o n - w r i t e的优化方式,该优化与根据需要<br>
创建对象有关。拷贝一个庞大而复杂的对象是一种开销很大的操作,如果这个拷贝根本没有<br>
被修改,那么这些开销就没有必要。用代理延迟这一拷贝过程,我们可以保证只有当这个对<br>
象被修改的时候才对它进行拷贝。<br>
在实现 C o p y - o n - w r i t e时必须对实体进行引用计数。拷贝代理仅会增加引用计数。只有当<br>
用户请求一个修改该实体的操作时,代理才会真正的拷贝它。在这种情况下,代理还必须减<br>
少实体的引用计数。当引用的数目为零时,这个实体将被删除。<br>
C o p y - o n - Wr i t e可以大幅度的降低拷贝庞大实体时的开销。</li>
</ol>
<h4 id="缺点-v7"><a class="header-anchor" href="#缺点-v7">¶</a>缺点</h4>
<p>过多的代理类容易使得程序过于复杂。</p>
<h4 id="使用场景-v7"><a class="header-anchor" href="#使用场景-v7">¶</a>使用场景</h4>
<p>在需要用比较通用和复杂的对象指针代替简单的指针的时候,使用 P r o x y模式。下面是一<br>
些可以使用 P r o x y模式常见情况:</p>
<ol>
<li>远 程 代 理 ( Remote Proxy ) 为 一 个 对 象在 不 同 的 地 址 空间 提 供 局 部 代 表。<br>
NEXTSTEP[Add94] 使用N X P r o x y类实现了这一目的。 Coplien[Cop92] 称这种代理为“大使”<br>
(A m b a s s a d o r)。</li>
<li>虚代理(Virtual Proxy)根据需要创建开销很大的对象。在动机一节描述的 I m a g e P r o x y<br>
就是这样一种代理的例子。</li>
<li>保护代理(Protection Proxy)控制对原始对象的访问。保护代理用于对象应该有不同<br>
的访问权限的时候。例如,在 C h o i c e s操作系统 [ C I R M 9 3 ]中K e m e l P r o x i e s为操作系统对象提供<br>
了访问保护。</li>
<li>智能指引 (Smart Reference)取代了简单的指针,它在访问对象时执行一些附加操作。<br>
它的典型用途包括:
<ul>
<li>对指向实际对象的引用计数,这样当该对象没有引用时,可以自动释放它 (也称为S m a r t<br>
P o i n t e r s[ E d e 9 2 ] )。</li>
<li>当第一次引用一个持久对象时,将它装入内存。</li>
<li>在访问一个实际对象前,检查是否已经锁定了它,以确保其他对象不能改变它。</li>
</ul>
</li>
</ol>
<h4 id="注意事项-v7"><a class="header-anchor" href="#注意事项-v7">¶</a>注意事项</h4>
<p>代理模式有多种实现方式</p>
<h4 id="相关模式"><a class="header-anchor" href="#相关模式">¶</a>相关模式</h4>
<p>Adapter: 适配器Adapter为它所适配的对象提供了一个不同的接口。相反,代理提供<br>
了与它的实体相同的接口。然而,用于访问保护的代理可能会拒绝执行实体会执行的操作,<br>
因此,它的接口实际上可能只是实体接口的一个子集。<br>
D e c o r a t o r: 尽管 d e c o r a t o r的实现部分与代理相似,但 d e c o r a t o r的目的不一样。<br>
D e c o r a t o r为对象添加一个或多个功能,而代理则控制对对象的访问。<br>
代理的实现与 d e c o r a t o r的实现类似,但是在相似的程度上有所差别。 Protection Proxy的<br>
实现可能与 d e c o r a t o r的实现差不多。另一方面, Remote Proxy不包含对实体的直接引用,而<br>
只是一个间接引用,如“主机 I D,主机上的局部地址。”Virtual Proxy开始的时候使用一个间<br>
接引用,例如一个文件名,但最终将获取并使用一个直接引用。</p>
<h4 id="示例实现-v8"><a class="header-anchor" href="#示例实现-v8">¶</a>示例实现</h4>
<p>以下以静态接口代理为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Inter &#123;</span><br><span class="line">    void print();</span><br><span class="line">&#125;</span><br><span class="line">class Target implements Inter &#123;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;Target&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Proxy implements Inter &#123;</span><br><span class="line">    private Inter target;</span><br><span class="line">    public Proxy(Inter target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt; Proxy&quot;);</span><br><span class="line">        target.print();</span><br><span class="line">        System.out.println(&quot;&lt;&lt; Proxy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Inter target = new Target();</span><br><span class="line">        Inter proxy = new Proxy(target);</span><br><span class="line">        proxy.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">122</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构型模式"><span class="nav-number">1.</span> <span class="nav-text">¶结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#适配器模式-adapter-pattern"><span class="nav-number">1.1.</span> <span class="nav-text">¶适配器模式（Adapter Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图"><span class="nav-number">1.1.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决"><span class="nav-number">1.1.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用"><span class="nav-number">1.1.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决"><span class="nav-number">1.1.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码"><span class="nav-number">1.1.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例"><span class="nav-number">1.1.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">1.1.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">1.1.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">1.1.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-number">1.1.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现"><span class="nav-number">1.1.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桥接模式-bridge"><span class="nav-number">1.2.</span> <span class="nav-text">¶桥接模式（Bridge）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v2"><span class="nav-number">1.2.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v2"><span class="nav-number">1.2.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v2"><span class="nav-number">1.2.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v2"><span class="nav-number">1.2.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v2"><span class="nav-number">1.2.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v2"><span class="nav-number">1.2.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v2"><span class="nav-number">1.2.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v2"><span class="nav-number">1.2.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v2"><span class="nav-number">1.2.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v2"><span class="nav-number">1.2.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v2"><span class="nav-number">1.2.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤器模式-filter-pattern"><span class="nav-number">1.3.</span> <span class="nav-text">¶过滤器模式（Filter Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v3"><span class="nav-number">1.3.1.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合模式-composite-pattern"><span class="nav-number">1.4.</span> <span class="nav-text">¶组合模式（Composite Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v3"><span class="nav-number">1.4.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v3"><span class="nav-number">1.4.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v3"><span class="nav-number">1.4.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v3"><span class="nav-number">1.4.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v3"><span class="nav-number">1.4.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v3"><span class="nav-number">1.4.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v3"><span class="nav-number">1.4.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v3"><span class="nav-number">1.4.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v3"><span class="nav-number">1.4.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v3"><span class="nav-number">1.4.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v4"><span class="nav-number">1.4.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器模式-decorator-pattern"><span class="nav-number">1.5.</span> <span class="nav-text">¶装饰器模式（Decorator Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v4"><span class="nav-number">1.5.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v4"><span class="nav-number">1.5.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v4"><span class="nav-number">1.5.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v4"><span class="nav-number">1.5.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v4"><span class="nav-number">1.5.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v4"><span class="nav-number">1.5.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v4"><span class="nav-number">1.5.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v4"><span class="nav-number">1.5.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v4"><span class="nav-number">1.5.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v4"><span class="nav-number">1.5.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v5"><span class="nav-number">1.5.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外观模式-facade-pattern"><span class="nav-number">1.6.</span> <span class="nav-text">¶外观模式（Facade Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v5"><span class="nav-number">1.6.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v5"><span class="nav-number">1.6.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v5"><span class="nav-number">1.6.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v5"><span class="nav-number">1.6.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v5"><span class="nav-number">1.6.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v5"><span class="nav-number">1.6.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v5"><span class="nav-number">1.6.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v5"><span class="nav-number">1.6.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v5"><span class="nav-number">1.6.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v5"><span class="nav-number">1.6.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v6"><span class="nav-number">1.6.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#享元模式-flyweight-pattern"><span class="nav-number">1.7.</span> <span class="nav-text">¶享元模式（Flyweight Pattern）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v6"><span class="nav-number">1.7.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v6"><span class="nav-number">1.7.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v6"><span class="nav-number">1.7.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v6"><span class="nav-number">1.7.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v6"><span class="nav-number">1.7.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v6"><span class="nav-number">1.7.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v6"><span class="nav-number">1.7.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v6"><span class="nav-number">1.7.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v6"><span class="nav-number">1.7.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v6"><span class="nav-number">1.7.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v7"><span class="nav-number">1.7.11.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理模式-proxy"><span class="nav-number">1.8.</span> <span class="nav-text">¶代理模式（Proxy）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#意图-v7"><span class="nav-number">1.8.1.</span> <span class="nav-text">¶意图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要解决-v7"><span class="nav-number">1.8.2.</span> <span class="nav-text">¶主要解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时使用-v7"><span class="nav-number">1.8.3.</span> <span class="nav-text">¶何时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决-v7"><span class="nav-number">1.8.4.</span> <span class="nav-text">¶如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键代码-v7"><span class="nav-number">1.8.5.</span> <span class="nav-text">¶关键代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例-v7"><span class="nav-number">1.8.6.</span> <span class="nav-text">¶应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-v7"><span class="nav-number">1.8.7.</span> <span class="nav-text">¶优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-v7"><span class="nav-number">1.8.8.</span> <span class="nav-text">¶缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-v7"><span class="nav-number">1.8.9.</span> <span class="nav-text">¶使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-v7"><span class="nav-number">1.8.10.</span> <span class="nav-text">¶注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关模式"><span class="nav-number">1.8.11.</span> <span class="nav-text">¶相关模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例实现-v8"><span class="nav-number">1.8.12.</span> <span class="nav-text">¶示例实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
