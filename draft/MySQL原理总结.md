---
title: MySQL原理总结
categories: 技术点总结
tags:
  - MySQL
  - SQL
  - 事务
abbrlink: a0dfca4c
date: 2019-07-11 09:13:18
---


## 索引
### 索引底层数据结构
可以用于提高读写效率的数据结构很多，其中三种比较简单的如**哈希表**、**有序数组**和**搜索树**。
**哈希表**的思路非常简单，在设计合理的前提下也能保证较高的效率，但是因为不是有序的，所以不适合范围查询，**只适用于只有等值查询的场景**。
**有序数组**在等值查询和范围查询场景中的性能就都非常优秀，但是更新操作需要挪动后面所有的记录、成本太高，所以**有序数组索引只适用于静态存储引擎**。
**二叉树**的搜索效率是最高的，但是考虑到磁盘读取速度，实际数据库中存储一般会选择**N叉树**结构，N取决于数据块的大小，
> 你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的。

### 索引类型
Mysql 支持多种索引类型，如 **Btree 索引**、**哈希索引**、**全文索引**等。常用的为 Btree 索引。
一条索引记录包含的基本信息包括：键值(我们定义索引时指定的所有字段的值)+逻辑指针(指向数据页或者是另一索引页)。
#### BTree 索引和 hash 索引
索引的两种主要存储结构
* BTree索引：按 key 进行检索，首先从根节点进行二分查找，如果找到返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针。
前者查找成功，后者查找失败。
* hash索引：比主键为 id 为例，那么随着 id 的增长，id 对应的行，在磁盘上随机放置。 无法对范围查询进行优化。
#### 聚集索引（聚簇索引）和非聚集索引
* 聚集索引：表数据按照索引的顺序来存储。叶子节点存储了真实的数据行，不再有另外单独的数据页。
* 非聚集索引：表数据的存储顺序与索引顺序无关。叶节点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据页一致。
* 主码索引：又称聚集主码。

他们之间的区别：
1. 聚集索引不仅存储了索引的数据，还在叶子节点中存储了对应的 table 中的数据，记录的索引顺序与物理顺序相同。
2. 通过聚集索引可以一次拿到自己想要的记录，而非聚集索引需要两次。

myisam 使用的堆组织表 ( Heap Organize Table，HOT)，没有聚集索引的概念,使用B-tree索引的存储格式，显示都是随机顺序。
innodb 表是索引组织表 ( Index Organized Table，IOT )，它的索引则是采用 clustered index 方式，因此主键会按照顺序存储，每次有记录有更新时，会重新整理更新其主键。
因此无论是直接从 myisam 表转换过来的，还是后来插入的记录，显示时都会按照主键的顺序。
### B+树
索引底层实现使用了B+tree，具有如下特点：
* 非叶子结点的子树指针与关键字个数相同 为所有叶子结点增加一个链指针 所有关键字都在叶子结点出现
* 在 B + Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B + Tree。
* 做这个优化的目的是为了提高区间访问的性能，如下图中如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。
* 索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。

![B+树](http://tallate.top/imgs/实现一个分布式限流器/B+树.png "B+树")
如上图所示，最外层磁盘块 1 里有数据 17、35和指针 P1、P2、P3。
P1 指针表示小于 17 的磁盘块，P2 是在 17 - 35 之间，P3 指向大于 35 的磁盘块。真实数据存在于子叶节点也就是最底下的一层 3、5、9、10、13 ...... 非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如 17、35。
查找过程：例如搜索 28 数据项，首先加载磁盘块 1 到内存中，发生一次 I/O，用二分查找确定在 P2 指针。接着发现 28 在 26 和 30 之间，通过 P2 指针的地址加载磁盘块 3 到内存，发生第二次 I/O。
用同样的方式找到磁盘块 8，发生第三次 I/O。
真实的情况是，上面 3 层的 B + Tree 可以表示上百万的数据，上百万的数据只发生了三次 I/O 而不是上百万次 I/O，时间提升是巨大的。
上文提到的磁盘块，那么一个磁盘块可以存储多少数据呢，每个磁盘块根据系统的不同，文件系统的不同可能会不一样大。
可能是有的是 512 byte，或者 2 k。那么如果知道一个索引字段的大小是多少，就可以知道一个磁盘块上可以有多少个索引了。

### MyISAM存储引擎中的索引结构
![MyISAM索引结构](http://tallate.top/imgs/MySQL原理总结/MyISAM索引结构.png "MyISAM索引结构")
* 有单独的区域存储记录（record）；
* 主键索引和普通索引结构相同，都是非聚集索引，都存储记录的指针，实际上也可以没有PK；

### InnoDB存储引擎中的索引结构
![InnoDB索引结构.png](http://tallate.top/imgs/MySQL原理总结/InnoDB索引结构.png "InnoDB索引结构")
* 主键索引（聚集索引）和记录存储在一起；
> 主键索引和记录存储在一起，所以又被称为聚集索引，因此InnoDB一定会有聚集索引。
* 普通索引（非聚集索引）存储主键而不是指针，通过普通索引查询时会先查询出主键，再从主键索引上二次遍历索引树；

### 唯一索引
唯一索引相对普通索引来说，性能会有所降低，因为为了保证唯一性，需要额外的扫描，这个过程无法使用缓存。

还要注意的是唯一索引常被用于实现数据库层的幂等，下面的示例表`user`有一个由name字段构成的唯一索引：
```
insert into user ( name, pwd )
values ( 'Mike', 'pwd' )
on duplicate key set
pwd = value(pwd)
```


### 最佳实践
1. InnoDB主键长度不要过长
否则MySQL缓冲区有限，存储的索引与数据会减少，磁盘IO的概率会增加；同时，索引占用的磁盘空间也会增加。
此时，可以新增一个无业务含义的id自增列。


## 锁
### 表锁
现在MySQL中，除了InnoDB支持行锁外，MySQL的其他存储引擎均只使用表锁，包括MyISAM、MEMORY、MERGE等。
#### 表锁的优势
* 占用内存少
行锁的数量和表中的行数成正比，非常耗内存；
* 如果业务经常需要读取表中很大一部分数据时，表锁效率会更高
因为此时只涉及一个锁，而不是同时管理多个锁。
* 如果业务经常使用`group by`，表锁会更快
原因同上。
#### 表锁运行原理
和读写锁类似。
* 写时要加写锁：如果表没有锁（包括读锁和写锁），对表加写锁，否则，入写锁队列。
* 读时要加读锁：如果表没有写锁，对表加读锁，否则，入读锁队列。
* 表锁释放时：如果写锁队列和读锁队列里都有锁，写有更高的优先级，即写锁队列先出列。这么做的原因是，如果有“大查询”，可能会导致写锁被批量"饿死"，而写锁往往释放很快。换句话说，如果有大量并发update请求，select会等所有update请求执行完才执行。
#### 查看表锁
```
mysql> show status like 'Table%';

Variable_name,Value
'Table_locks_immediate','953'
'Table_locks_waited','0'
'Table_open_cache_hits','28'
'Table_open_cache_misses','121'
'Table_open_cache_overflows','121'
```

其中：
* Table_locks_immediate：立刻获得表锁的次数；
* Table_locks_waited：需要等待表锁的次数，如果等待表锁的次数占比较大，说明表锁可能是潜在瓶颈。；
#### 使用表锁的时机
* 并发插入量比较大的情况下
MyISAM的索引与记录存储分离，有单独的区域存储行记录，PK是非聚集索引。
MyISAM表，如果数据文件(data file)紧密存储，中间没有空闲块(free blocks)，数据总是插入到数据文件的尾部(end)，就如同追加日志一样，性能很高，此时的并发insert与select是不加锁的(lock free)，并发insert无表锁争抢（只需插入队列保证并发安全）。
MyISAM表，如果数据文件(data file)中间有空洞(hole)或称之为空闲快（free blocks），上述机制会失效，直到空洞被新数据填满，又会启用不加锁机制。空洞是怎么导致的？删除或者修改数据，都可能导致空洞。当有空洞时，select和insert会有表锁冲突，无法并发。


## 事务
### 事务和锁
在read uncommitted(未提交读)级别中，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这种也可以叫脏读，这个级别其实会导致很多问题，从性能上讲，未提交读不会比其他级别好太多，但却缺乏其他级别的好处，除非真的非常有必要，在实际中一般不使用的。
mysql有个多版本控制MVCC，可以认为MVCC是行级锁的一个变种，但他在很多情况下避免了加锁操作，因此开销更低。MVCC实际上是乐观并发控制的，通过每行的记录后面保存两个隐藏的列实现，一个是创建时间，一个是删除时间，当然实际存储的不是时间值，而是版本号。
MVCC只在repeatable read和read committed两个级别下工作，其他隔离级别都和MVCC不兼容，因为read uncommitted总是读到最新数据，而不是符合当前事务版本的数据行。
综上所述，乐观锁是和读已提交搭配使用是可以的


## 实现
### 关系数据库基本结构
1. 保存位置
文本文件
2.存储格式
B树，尽量将相关数据集中在一起，一个节点可以容纳多个值，一个节点存放在磁盘的一个扇区中，一层只需要读取一次，而B树的层数又被压缩得很低。
3.索引
B树本身只能根据主键进行查询，如果想要支持对某一字段的查询，就需要建立索引，也就是以某些别的字段作为关键字构造B树，储存到一个索引文件中。
存在一些B树索引操作库，比如C-Isam。
4.其他功能


## 参考
### 索引
1. [数据库索引，到底是什么做的？](https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A)
1. [MYSQL中为什么索引不宜建在重复数据多的列上](https://blog.csdn.net/Sunmeok/article/details/82965805)
1. [为什么重复值高的字段不能建索引（比如性别字段等)](http://www.cnblogs.com/gossip/p/9237686.html)
### 实现
1. [数据库的最简单实现](http://www.ruanyifeng.com/blog/2014/07/database_implementation.html)
1. [how_do_you_build_a_database](https://www.reddit.com/r/Database/comments/27u6dy/how_do_you_build_a_database/ciggal8/)
