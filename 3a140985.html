<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Distributed System,">










<meta name="description" content="¶使用锁来同步线程 ¶线程同步和锁 线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。 线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：  内存 共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（">
<meta name="keywords" content="Distributed System">
<meta property="og:type" content="article">
<meta property="og:title" content="异步任务和同步策略">
<meta property="og:url" content="https://tallate.github.io/3a140985.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="¶使用锁来同步线程 ¶线程同步和锁 线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。 线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：  内存 共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/AQS%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/CountDownLatch%E7%B1%BB%E5%9B%BE.png">
<meta property="og:updated_time" content="2019-10-07T17:10:11.754Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="异步任务和同步策略">
<meta name="twitter:description" content="¶使用锁来同步线程 ¶线程同步和锁 线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。 线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：  内存 共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（">
<meta name="twitter:image" content="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/AQS%E7%B1%BB%E5%9B%BE.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/3a140985.html">







  <title>异步任务和同步策略 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3a140985.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">异步任务和同步策略</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T23:54:49+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="使用锁来同步线程"><a class="header-anchor" href="#使用锁来同步线程">¶</a>使用锁来同步线程</h2>
<h3 id="线程同步和锁"><a class="header-anchor" href="#线程同步和锁">¶</a>线程同步和锁</h3>
<p>线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。<br>
线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：</p>
<ul>
<li>内存<br>
共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（Atomic）、阻塞队列（BlockingQueue）等。</li>
<li>磁盘<br>
共享文件、消息队列等。</li>
<li>网络<br>
Socket等。</li>
</ul>
<p>像Java中Thread的wait、notify的实现基本也可以使用内存共享来解释，只不过它们是native方法，实现由平台说了算；volatile关键字不能算是同步机制，因为它实际上无法保证线程安全性。</p>
<h3 id="乐观锁和悲观锁"><a class="header-anchor" href="#乐观锁和悲观锁">¶</a>乐观锁和悲观锁</h3>
<p>乐观锁和悲观锁是在数据库中使用的名词。</p>
<ul>
<li>悲观锁<br>
悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，数据库中实现是对数据记录操作前给记录加<strong>排它锁</strong>。如果获取锁失败，则说明数据正在被其它线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>
使用悲观锁的一个常用的例子： <code>select * from 表 where .. for update;</code>。</li>
<li>乐观锁<br>
乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。具体说是根据 update 返回的行数让用户决定如何去做。<br>
例如：<code>update 表 set comment='***',status='operator',version=version+1 where version = 1 and id = 1;</code><br>
乐观锁并不会使用数据库提供的锁机制，一般在表添加 version 字段或者使用业务状态来做。乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。</li>
</ul>
<h3 id="死锁"><a class="header-anchor" href="#死锁">¶</a>死锁</h3>
<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p>
<h4 id="死锁产生的条件"><a class="header-anchor" href="#死锁产生的条件">¶</a>死锁产生的条件</h4>
<p>死锁的产生必须满足以下4个必要条件：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其它进行请求获取该资源，则请求者只能等待，直至占有资源的线程用毕释放。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源；T1 正在等待 T2 占用的资源，……Tn正在等待已被 T0 占用的资源。</li>
</ul>
<p>举个形象的例子，两辆车在窄道上相向而行，他们占着道不肯退开，又希望对方能让开，最终形成了死锁。<br>
例1 - 死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程A：</span><br><span class="line">synchronized(resourceA) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceB) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程B：</span><br><span class="line">synchronized(resourceB) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceA) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先资源 resourceA 和 resourceB 都是互斥资源，当线程 A 调用 synchronized(resourceA) 获取到 resourceA 上的监视器锁后释放前，线程 B 在调用 synchronized(resourceA) 尝试获取该资源会被阻塞，只有线程 A 主动释放该锁，线程 B 才能获得，这满足了<strong>资源互斥条件</strong>。<br>
线程 A 首先通过 synchronized(resourceA) 获取到 resourceA 上的监视器锁资源，然后通过 synchronized(resourceB) 等待获取到 resourceB 上的监视器锁资源，这就满足了<strong>持有并等待</strong>。<br>
线程 A 在获取 resourceA 上的监视器锁资源后，不会被线程 B 掠夺走，只有线程 A 自己主动释放 resourceA 的资源时候，才会放弃对该资源的持有权，这满足了资源的<strong>不可剥夺条件</strong>。<br>
线程 A 持有 objectA 资源并等待获取 objectB 资源，而线程 B 持有 objectB 资源并等待 objectA 资源，这满足了<strong>循环等待条件</strong>。<br>
所以线程 A 和 B 就形成了死锁状态。</p>
<h4 id="死锁避免"><a class="header-anchor" href="#死锁避免">¶</a>死锁避免</h4>
<p>要想避免死锁，需要破坏构造死锁必要条件的至少一个即可，但是目前只有持有并等待和循环等待是可以被破坏的。<br>
其实，实现死锁避免最简单的方案就是控制资源申请的有序性。</p>
<h3 id="阻塞锁"><a class="header-anchor" href="#阻塞锁">¶</a>阻塞锁</h3>
<p>阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。<br>
JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有：synchronized 关键字（其中的重量锁）, ReentrantLock, Object.wait() / notify(), LockSupport.park() / unpart()</p>
<p>阻塞锁的优势在于，阻塞的线程不会占用cpu时间，不会导致 CPU 占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。<br>
在竞争激烈的情况下阻塞锁的性能要明显高于自旋锁。<br>
理想的情况：在线程竞争不激烈的情况下使用自旋锁，竞争激烈的情况下使用阻塞锁。</p>
<h3 id="独占锁和共享锁"><a class="header-anchor" href="#独占锁和共享锁">¶</a>独占锁和共享锁</h3>
<p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁分为独占锁和共享锁。<br>
独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock 就是以独占方式实现的。共享锁则同时有多个线程可以持有，例如 ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。<br>
独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其它线程必须等待当前线程释放锁才能进行读取。<br>
共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<h3 id="公平性"><a class="header-anchor" href="#公平性">¶</a>公平性</h3>
<p>锁有公平和非公平之分：</p>
<ul>
<li>公平锁：每个线程按调用lock的顺序来获取锁，不可插队；</li>
<li>非公平锁：每个线程获取锁的顺序不确定，存在插队的问题。</li>
</ul>
<p>平时使用的 ReentrantLock 默认的lock()就是非公平锁，它会先尝试用CAS获取一次锁，若获取不到才进入一个队列等待锁的释放。<br>
Semaphore中，tryAcquire是非公平的而acquire是公平的。<br>
在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。</p>
<h3 id="可重入性"><a class="header-anchor" href="#可重入性">¶</a>可重入性</h3>
<p>当一个线程要获取一个被其它线程持有的独占锁时候，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限制次数（高级篇我们会知道严格来说是有限次数）进入被该锁锁住的代码。</p>
<h4 id="可重入锁原理"><a class="header-anchor" href="#可重入锁原理">¶</a>可重入锁原理</h4>
<p>可重入锁的原理是在锁内部维护了一个线程标示，用来标示该锁目前被那个线程占用，然后关联一个计数器。一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其它线程在获取该锁时候发现锁的所有者不是自己就会被阻塞挂起。<br>
但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己，就会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为 null，这时候阻塞的线程会获取被唤醒来竞争获取该锁。</p>
<h4 id="synchronized-监视器锁-是可重入的"><a class="header-anchor" href="#synchronized-监视器锁-是可重入的">¶</a>synchronized（监视器锁）是可重入的</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reentrantlock是可重入的"><a class="header-anchor" href="#reentrantlock是可重入的">¶</a>ReentrantLock是可重入的</h4>
<blockquote>
<p>废话，名字里Reentrant就是可重入的意思。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h4 id="reentrantreadwritelock"><a class="header-anchor" href="#reentrantreadwritelock">¶</a>ReentrantReadWriteLock</h4>
<p>加锁分三种情况：</p>
<ul>
<li>
<p>读锁本身定义就支持重入；</p>
</li>
<li>
<p>写锁支持重入</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.writeLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读锁和写锁同时使用会死锁</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.readLock().unlock();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抢占"><a class="header-anchor" href="#抢占">¶</a>抢占</h3>
<p>TODO</p>
<h3 id="spinlock-自旋锁"><a class="header-anchor" href="#spinlock-自旋锁">¶</a>SpinLock（自旋锁）</h3>
<p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class SpinLock &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; sign = new AtomicReference&lt;&gt;();</span><br><span class="line">    public void lock()&#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        // 当sign的值为null时才设置为current</span><br><span class="line">        while(!sign .compareAndSet(null, current))&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock ()&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        sign .compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LockTest &#123;</span><br><span class="line">    SpinLock spinLock = new SpinLock();</span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。<br>
但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。<br>
如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。<br>
该例子为非公平锁，获得锁的先后顺序不会按照进入lock的先后顺序进行。</p>
<h3 id="锁算法-clhlock-craig-landin-and-hagersten-locks"><a class="header-anchor" href="#锁算法-clhlock-craig-landin-and-hagersten-locks">¶</a>锁算法 - CLHLock（Craig, Landin, and Hagersten locks）</h3>
<p>使用链表协调每个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CLHLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class CLHNode &#123;</span><br><span class="line">        // 刚开始当前线程是锁住的</span><br><span class="line">        private volatile Thread isLocked;</span><br><span class="line">        // boolean方案、private volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile CLHNode tail;</span><br><span class="line">    private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;();</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        CLHNode node = new CLHNode();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        // 原子更新当前CLHLock对应的值，并返回旧值</span><br><span class="line">        // getAndSet使自己成为队列的尾部，同时获取其前驱节点的引用</span><br><span class="line">        // 如果是第一个调用lock的，直接返回，如果不是，则等待上一个unlock</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(this, node);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            // boolean方案：while(preNode.isLocked) &#123;&#125;</span><br><span class="line">            preNode.isLocked = Thread.currentThread();</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            preNode = null;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        CLHNode node = LOCAL.get();</span><br><span class="line">        if (!UPDATER.compareAndSet(this, node, null)) &#123;</span><br><span class="line">            // boolean方案：node.isLocked = false;</span><br><span class="line">            System.out.println(&quot;unlock\t&quot; + node.isLocked.getName());</span><br><span class="line">            LockSupport.unpark(node.isLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        node = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中注明了另一种boolean实现方案，boolean方案看起来会直观一点。</p>
<p>JUC ReentrantLock 默认内部使用的锁 即是 CLH 锁（有很多改进的地方，将自旋锁换成了阻塞锁等等）。<br>
CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O(L+n)，n个线程有n个Node，L个锁有L个tail），CLH的一种变体被应用在了JAVA并发框架中（AbstractQueuedSynchronizer.Node）。<br>
CLH在SMP系统结构下是非常有效的，但在NUMA系统结构下，每个线程有自己的内存，而CLHLock会不停地查询前驱变量，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，一种解决NUMA系统结构的思路是MCS队列锁。</p>
<h3 id="锁算法-mcslock"><a class="header-anchor" href="#锁算法-mcslock">¶</a>锁算法 - MCSLock</h3>
<p>MCSLock则是对本地变量的节点进行循环，不会出现CLHLock的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MCSLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class MCSNode &#123;</span><br><span class="line"></span><br><span class="line">        volatile MCSNode next;</span><br><span class="line">        volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;MCSNode&gt;();</span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile MCSNode queue;</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class,</span><br><span class="line">            MCSNode.class, &quot;queue&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        MCSNode currentNode = new MCSNode();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        MCSNode preNode = UPDATER.getAndSet(this, currentNode);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            while (currentNode.isLocked) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        MCSNode currentNode = NODE.get();</span><br><span class="line">        if (currentNode.next == null) &#123;</span><br><span class="line">            if (!UPDATER.compareAndSet(this, currentNode, null)) &#123;</span><br><span class="line">                while (currentNode.next == null) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.next.isLocked = false;</span><br><span class="line">            currentNode.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLH 的队列是隐式的队列，没有真实的后继结点属性。<br>
MCS 的队列是显式的队列，有真实的后继结点属性。</p>
<h3 id="锁算法-ticketlock"><a class="header-anchor" href="#锁算法-ticketlock">¶</a>锁算法 - TicketLock</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class TicketLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger serviceNum = new AtomicInteger();</span><br><span class="line">    private AtomicInteger ticketNum = new AtomicInteger();</span><br><span class="line">    private static final ThreadLocal&lt;Integer&gt; LOCAL =</span><br><span class="line">            new ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        // 得到门票</span><br><span class="line">        int myticket = ticketNum.getAndIncrement();</span><br><span class="line">        LOCAL.set(myticket);</span><br><span class="line">        // 如果当前叫票和自己的票号不同</span><br><span class="line">        while (myticket != serviceNum.get()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int myticket = LOCAL.get();</span><br><span class="line">        // compareAndSet内部会循环判断当前值是否为myticket，然后才执行赋值操作</span><br><span class="line">        serviceNum.compareAndSet(myticket, myticket + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        // TicketLock保存在主线程内，子线程每次lock拿到一张票，</span><br><span class="line">        // 此时别的线程unlock，直到票数增长到自己的票号</span><br><span class="line">        TicketLock ticketLock = new TicketLock();</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            ticketLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            ticketLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            // 线程的执行顺序和每个线程调用lock的顺序相同</span><br><span class="line">            new Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TicketLock，主要解决的是访问顺序的问题，主要的问题是在多核cpu上。<br>
缺点是每次都要查询一个serviceNum 服务号，影响性能（必须要到主内存读取，并阻止其他cpu修改）。</p>
<h3 id="互斥锁-reentrantlock"><a class="header-anchor" href="#互斥锁-reentrantlock">¶</a>互斥锁 - ReentrantLock</h3>
<h3 id="读写锁-reentrantreadwritelock"><a class="header-anchor" href="#读写锁-reentrantreadwritelock">¶</a>读写锁 - ReentrantReadWriteLock</h3>
<h3 id="条件-condition"><a class="header-anchor" href="#条件-condition">¶</a>条件 - Condition</h3>
<p>实例 - Condition的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock l = new ReentrantLock();</span><br><span class="line">// Condition相当于一个0-1信号量</span><br><span class="line">// （其实是使用了一个叫AbstractQueuedSynchronizer.Node等待队列）</span><br><span class="line">Condition c = l.newCondition();</span><br><span class="line">c.await(); // 信号量-1</span><br><span class="line">c.signal(); // 信号量+1</span><br><span class="line">c.signalAll(); // 所有信号量+1</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<p>实例 - 多线程下的缓冲区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();//锁对象  </span><br><span class="line">    final Condition notFull = lock.newCondition();//写线程条件   </span><br><span class="line">    final Condition notEmpty = lock.newCondition();//读线程条件   </span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[100];//缓存队列  </span><br><span class="line">    int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;</span><br><span class="line"></span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)//如果队列满了   </span><br><span class="line">            &#123;</span><br><span class="line">                notFull.await();//阻塞写线程  </span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;//赋值   </span><br><span class="line">            if (++putptr == items.length) &#123;</span><br><span class="line">                putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            ++count;//个数++  </span><br><span class="line">            notEmpty.signal();//唤醒读线程  </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)//如果队列为空  </span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty.await();//阻塞读线程  </span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];//取值   </span><br><span class="line">            if (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            --count;//个数--  </span><br><span class="line">            notFull.signal();//唤醒写线程  </span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程调度-和-locksupport"><a class="header-anchor" href="#线程调度-和-locksupport">¶</a>线程调度 和 LockSupport</h3>
<p>挂起和唤醒是线程调度中和锁的实现最密切的操作，juc中通过一个LockSupport来抽象这两种操作，它是创建锁和其它同步类的基础。</p>
<ul>
<li>LockSupport 类与每个使用它的线程都会关联一个许可证,默认调用LockSupport 类的方法的线程是不持有许可证的</li>
<li>LockSupport 内部使用 Unsafe 类实现</li>
</ul>
<h4 id="void-park"><a class="header-anchor" href="#void-park">¶</a>void park()</h4>
<p>如果调用 park() 的线程已经拿到了与 LockSupport 关联的<strong>permit（许可证）</strong>，则调用 LockSupport.park() 会马上返回，否者调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;begin park&quot;);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(&quot;end park&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>在其它线程调用 unpark(Thread thread)方法并且当前线程作为参数时候，调用park方法被阻塞的线程会返回；</li>
<li>其他线程调用interrupt()设置中断标识后可以返回，不会抛出InterruptedException异常；</li>
<li>由于线程的虚假唤醒也会导致阻塞的线程返回，所以调用park()最好也用循环条件判断方式。</li>
</ul>
<h3 id="锁实现的基础-abstractqueuedsynchronizer-aqs"><a class="header-anchor" href="#锁实现的基础-abstractqueuedsynchronizer-aqs">¶</a>锁实现的基础 - AbstractQueuedSynchronizer（AQS）</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/AQS%E7%B1%BB%E5%9B%BE.png" alt="AQS类图" title="AQS类图"><br>
虽然AQS本质上是一个双向队列，是juc中大部分并发安全组件的实现基础。</p>
<p>AQS 是一个 FIFO 的双向队列，内部通过节点 <code>head</code> 和 <code>tail</code> 记录队首和队尾元素，队列元素类型为 <code>Node</code>。</p>
<ul>
<li>其中 Node 中 <code>thread</code> 变量用来存放进入 AQS 队列里面的线程；</li>
<li>Node 节点内部 <code>SHARED</code> 用来标记该线程是获取共享资源时候被阻塞挂起后放入 AQS 队列，<code>EXCLUSIVE</code> 标示线程是获取独占资源时候被挂起后放入 AQS 队列；</li>
<li><code>waitStatus</code> 记录当前线程等待状态，分别为 <code>CANCELLED</code>（线程被取消了），<code>SIGNAL</code>（线程需要被唤醒），<code>CONDITION</code>（线程在条件队列里面等待），<code>PROPAGATE</code>（释放共享资源时候需要通知其它节点）；</li>
<li><code>prev</code> 记录当前节点的前驱节点，<code>next</code> 记录当前节点后继节点。</li>
</ul>
<p>AQS 中维持了一个单一的状态信息 <code>state</code>, 可以通过 getState, setState, compareAndSetState 函数修改其值</p>
<ul>
<li>对于 ReentrantLock 的实现来说，state 可以用来表示当前线程获取锁的可重入次数；</li>
<li>对应读写锁 ReentrantReadWriteLock 来说 state 的高 16 位表示读状态也就是获取该读锁的次数，低 16 位表示获取到写锁的线程的可重入次数；</li>
<li>对于 semaphore 来说 state 用来表示当前可用信号的个数；</li>
<li>对于 FutuerTask 来说，state 用来表示任务状态（例如还没开始，运行，完成，取消）；</li>
</ul>
<blockquote>
<p>1.8版本中FutuerTask取消了对AQS的依赖，改为通过CAS跟踪状态、Treiber stack管理等待中的线程，是因为通过AQS的实现存在，这篇文章的最后提到了这个问题：<a href="https://www.jianshu.com/p/16d6f0a22111" target="_blank" rel="noopener">线程阻塞(三)，FutureTask</a>，官方有一个Bug Report：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8016247" target="_blank" rel="noopener">JDK-8016247 : ThreadPoolExecutor may interrupt the wrong task</a>。</p>
</blockquote>
<ul>
<li>对应 CountDownlatch 和 CyclicBarrie 来说 state 用来表示计数器当前的值。</li>
</ul>
<p>AQS 有个内部类 <code>ConditionObject</code> 是用来结合锁实现线程同步，ConditionObject 可以直接访问 AQS 对象内部的变量，比如 state 状态值和 AQS 队列；<br>
ConditionObject 是条件变量，每个条件变量对应着一个条件队列 (单向链表队列)，用来存放调用条件变量的 await() 方法后被阻塞的线程，如类图，这个条件队列的头尾元素分别为 <code>firstWaiter</code> 和 <code>lastWaiter</code>。</p>
<h2 id="同步工具类"><a class="header-anchor" href="#同步工具类">¶</a>同步工具类</h2>
<p>JDK1.5之前Java中如果需要令多个线程互相协作，必须使用wait/notify/join方法簇，这些API容易出错而且可扩展性差，所以后来JDK提供了更多的工具类来处理线程协作的场景。</p>
<h3 id="闭锁-countdownlatch"><a class="header-anchor" href="#闭锁-countdownlatch">¶</a>闭锁 - CountDownLatch</h3>
<p>日常开发中经常会遇到需要在主线程中开启多线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后在进行汇总的场景，在 CountDownLatch 出现之前一般都是使用线程的 join() 方法来实现，但是 join 不够灵活，不能够满足不同场景的需要。</p>
<blockquote>
<p>join相对CountDownLatch来说有以下两点劣势：<br>
调用一个线程的join后，该线程会一直被阻塞直到该线程运行完毕，而 CountDownLatch 则可以在子线程运行完毕或运行过程中递减计数器，从而让await返回。<br>
另外，使用线程池来管理线程时候一般都是直接添加一个 Runable 实例到线程池，这时就不方便再调用线程的join方法了。</p>
</blockquote>
<h4 id="类图"><a class="header-anchor" href="#类图">¶</a>类图</h4>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/CountDownLatch%E7%B1%BB%E5%9B%BE.png" alt="CountDownLatch类图" title="CountDownLatch类图"></p>
<ul>
<li>CountDownLatch是公平的，其实现基础同样是AQS。</li>
</ul>
<h4 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h4>
<p>构造方法中初始化Sync时把计数器的值赋值给了 AQS 的状态值 state，也就是这里 AQS 的状态值来表示计数器值。</p>
<h4 id="void-await"><a class="header-anchor" href="#void-await">¶</a>void await()</h4>
<p>挂起当前线程，直到下面情况之一发生时才返回：</p>
<ul>
<li>当所有线程都调用了 CountDownLatch 对象的 <code>countDown()</code> 方法后，也就是计时器值为 0 的时候；</li>
<li>其它线程调用了当前线程的 <code>interrupt()</code> 方法中断了当前线程，当前线程会抛出 InterruptedException 异常后返回</li>
</ul>
<p>CountDownLatch.await()<br>
-&gt; AbstractQueuedSynchronizer.acquireSharedInterruptibly：获取共享资源，且可中断<br>
&gt; 为什么是acquireSharedInterruptibly而不是获取独占资源的acquireInterruptibly？因为这里状态值需要的并不是非 0 即 1 的效果，而是和初始化时候指定的计数器值有关系，比如你初始化时候计数器值为 8，那么 state 的值应该就有 0 到 8 的状态，而不是只有 0 和 1 的情况下的独占效果。<br>
1. 先调用Thread.interrupted()判断一下线程的中断状态，若被中断则抛出异常<br>
1. 尝试看当前是否计数值为0，为0则直接返回，否则进入AQS的队列等待<br>
-&gt; AbstractQueuedSynchronizer.doAcquireSharedInterruptibly</p>
<h4 id="boolean-await-long-timeout-timeunit-unit"><a class="header-anchor" href="#boolean-await-long-timeout-timeunit-unit">¶</a>boolean await(long timeout, TimeUnit unit)</h4>
<p>比起await多了个返回条件：</p>
<ul>
<li>超时后返回false。</li>
</ul>
<h4 id="void-countdown"><a class="header-anchor" href="#void-countdown">¶</a>void countDown()</h4>
<p>递减计数器的值，递减后如果计数器为 0 则会唤醒所有调用 await 方法而被阻塞的线程。</p>
<p>CountDownLatch.countDown<br>
-&gt; AbstractQueuedSynchronizer.releaseShared<br>
-&gt; CountDownLatch.Sync.tryReleaseShared：循环CAS设置状态值，返回值表示当前线程是否为第一个将状态值设置为0的，当前状态值已经为0则返回false，或者当前线程成功完成cas使计数值（状态值state）减一并更新到state并返回，如果当前状态值为0返回true<br>
-&gt; AbstractQueuedSynchronizer.doReleaseShared</p>
<h4 id="long-getcount"><a class="header-anchor" href="#long-getcount">¶</a>long getCount()</h4>
<p>获取当前计数器的值，也就是AQS的state的值，一般在 debug 测试时候使用。</p>
<h4 id="实例-模拟并发请求"><a class="header-anchor" href="#实例-模拟并发请求">¶</a>实例 - 模拟并发请求</h4>
<p>如果要用Java模拟并发请求，最基本的方案就是创建多个线程然后一一启动，但是如此一来请求就会带上先后顺序了，一种解决办法是通过CountDownLatch来同步多个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">CountDownLatch end = new CountDownLatch(10);</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            start.await();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                end.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">start.countDown();</span><br><span class="line">end.await();</span><br></pre></td></tr></table></figure>
<h3 id="栅栏-cyclicbarrier"><a class="header-anchor" href="#栅栏-cyclicbarrier">¶</a>栅栏 - CyclicBarrier</h3>
<h3 id="futuretask"><a class="header-anchor" href="#futuretask">¶</a>FutureTask</h3>
<p>TODO</p>
<h3 id="completablefuture"><a class="header-anchor" href="#completablefuture">¶</a>CompletableFuture</h3>
<h3 id="guava-listenablefuture"><a class="header-anchor" href="#guava-listenablefuture">¶</a>Guava - ListenableFuture</h3>
<h3 id="semaphore"><a class="header-anchor" href="#semaphore">¶</a>Semaphore</h3>
<h3 id="phase"><a class="header-anchor" href="#phase">¶</a>Phase</h3>
<p>相对CountDownLatch和CyclicBarrier来说，Phase支持多阶段协同；</p>
<ul>
<li>Phase表示当前阶段，最多可以有(2^32 - 1)个阶段；</li>
<li>Parties表示参与此次过程的参与者（不一定是线程）数量，最多65535个。</li>
</ul>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ol>
<li>什么是 Java 中原子性操作？</li>
<li>什么是 Java 中的 CAS 操作，AtomicLong 的实现原理？</li>
<li>什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？</li>
<li>抽象同步队列 AQS (AbstractQueuedSynchronizer) 概述，AQS 是实现同步的基础组件，并发包中锁的实现底层就是使用 AQS 实现，虽然大多数开发者可能从来不会直接用到 AQS，但是知道其原理对于架构设计还是很有帮助的。</li>
<li>独占锁 ReentrantLock 原理探究，ReentrantLock 是可重入的独占锁或者叫做排它锁，同时只能有一个线程可以获取该锁，其实现分为公平与非公平的独占锁。</li>
<li>读写锁 ReentrantReadWriteLock 原理，ReentrantLock 是独占锁，同时只有一个线程可以获取该锁，而实际情况下会有写少读多的场景，显然 ReentrantLock 满足不了需求，所以 ReentrantReadWriteLock 应运而生，本文来介绍读写分离锁的实现。</li>
<li>JUC 中倒数计数器 CountDownLatch 的使用与原理分析，当需要等待多个线程执行完毕后在做一件事情时候 CountDownLatch 是比调用线程的 join 方法更好的选择，CountDownLatch 与 线程的 join 方法区别是什么？</li>
<li>JUC 中 回环屏障 CyclicBarrier 的使用与分析，它也可以实现像 CountDownLatch 一样让一组线程全部到达一个状态后再全部同时执行，但是 CyclicBarrier 可以被复用。那么 CyclicBarrier 内部的实现与 CountDownLatch 有何不同那？</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Distributed-System/" rel="tag"># Distributed System</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/3b3d260d.html" rel="next" title="异步任务和协程">
                <i class="fa fa-chevron-left"></i> 异步任务和协程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用锁来同步线程"><span class="nav-number">1.</span> <span class="nav-text">¶使用锁来同步线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程同步和锁"><span class="nav-number">1.1.</span> <span class="nav-text">¶线程同步和锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-number">1.2.</span> <span class="nav-text">¶乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">1.3.</span> <span class="nav-text">¶死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁产生的条件"><span class="nav-number">1.3.1.</span> <span class="nav-text">¶死锁产生的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁避免"><span class="nav-number">1.3.2.</span> <span class="nav-text">¶死锁避免</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞锁"><span class="nav-number">1.4.</span> <span class="nav-text">¶阻塞锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独占锁和共享锁"><span class="nav-number">1.5.</span> <span class="nav-text">¶独占锁和共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公平性"><span class="nav-number">1.6.</span> <span class="nav-text">¶公平性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入性"><span class="nav-number">1.7.</span> <span class="nav-text">¶可重入性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入锁原理"><span class="nav-number">1.7.1.</span> <span class="nav-text">¶可重入锁原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-监视器锁-是可重入的"><span class="nav-number">1.7.2.</span> <span class="nav-text">¶synchronized（监视器锁）是可重入的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reentrantlock是可重入的"><span class="nav-number">1.7.3.</span> <span class="nav-text">¶ReentrantLock是可重入的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reentrantreadwritelock"><span class="nav-number">1.7.4.</span> <span class="nav-text">¶ReentrantReadWriteLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占"><span class="nav-number">1.8.</span> <span class="nav-text">¶抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spinlock-自旋锁"><span class="nav-number">1.9.</span> <span class="nav-text">¶SpinLock（自旋锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁算法-clhlock-craig-landin-and-hagersten-locks"><span class="nav-number">1.10.</span> <span class="nav-text">¶锁算法 - CLHLock（Craig, Landin, and Hagersten locks）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁算法-mcslock"><span class="nav-number">1.11.</span> <span class="nav-text">¶锁算法 - MCSLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁算法-ticketlock"><span class="nav-number">1.12.</span> <span class="nav-text">¶锁算法 - TicketLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁-reentrantlock"><span class="nav-number">1.13.</span> <span class="nav-text">¶互斥锁 - ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁-reentrantreadwritelock"><span class="nav-number">1.14.</span> <span class="nav-text">¶读写锁 - ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件-condition"><span class="nav-number">1.15.</span> <span class="nav-text">¶条件 - Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程调度-和-locksupport"><span class="nav-number">1.16.</span> <span class="nav-text">¶线程调度 和 LockSupport</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#void-park"><span class="nav-number">1.16.1.</span> <span class="nav-text">¶void park()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁实现的基础-abstractqueuedsynchronizer-aqs"><span class="nav-number">1.17.</span> <span class="nav-text">¶锁实现的基础 - AbstractQueuedSynchronizer（AQS）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步工具类"><span class="nav-number">2.</span> <span class="nav-text">¶同步工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭锁-countdownlatch"><span class="nav-number">2.1.</span> <span class="nav-text">¶闭锁 - CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类图"><span class="nav-number">2.1.1.</span> <span class="nav-text">¶类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">2.1.2.</span> <span class="nav-text">¶初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-await"><span class="nav-number">2.1.3.</span> <span class="nav-text">¶void await()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#boolean-await-long-timeout-timeunit-unit"><span class="nav-number">2.1.4.</span> <span class="nav-text">¶boolean await(long timeout, TimeUnit unit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-countdown"><span class="nav-number">2.1.5.</span> <span class="nav-text">¶void countDown()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#long-getcount"><span class="nav-number">2.1.6.</span> <span class="nav-text">¶long getCount()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-模拟并发请求"><span class="nav-number">2.1.7.</span> <span class="nav-text">¶实例 - 模拟并发请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栅栏-cyclicbarrier"><span class="nav-number">2.2.</span> <span class="nav-text">¶栅栏 - CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#futuretask"><span class="nav-number">2.3.</span> <span class="nav-text">¶FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#completablefuture"><span class="nav-number">2.4.</span> <span class="nav-text">¶CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#guava-listenablefuture"><span class="nav-number">2.5.</span> <span class="nav-text">¶Guava - ListenableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semaphore"><span class="nav-number">2.6.</span> <span class="nav-text">¶Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase"><span class="nav-number">2.7.</span> <span class="nav-text">¶Phase</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa"><span class="nav-number">3.</span> <span class="nav-text">¶QA</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
