<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="ElasticSearch,">










<meta name="description" content="分布式概念（Distribution） ¶集群 - Cluster 一个集群就是由一个或多个节点组织在一起，它们共同持有全部的数据。 一个集群有一个唯一的名字标识 cluster.name ，其节点只能通过指定某个集群的名字，来加入这个集群。 ¶节点 - Node 一个节点是集群中的一个服务器，即一个 Elasticsearch 实例。 作为集群的一部分，它存储数据，参与集群的索引和搜索功能。">
<meta name="keywords" content="ElasticSearch">
<meta property="og:type" content="article">
<meta property="og:title" content="ES集群">
<meta property="og:url" content="https://tallate.github.io/4e9d7784.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="分布式概念（Distribution） ¶集群 - Cluster 一个集群就是由一个或多个节点组织在一起，它们共同持有全部的数据。 一个集群有一个唯一的名字标识 cluster.name ，其节点只能通过指定某个集群的名字，来加入这个集群。 ¶节点 - Node 一个节点是集群中的一个服务器，即一个 Elasticsearch 实例。 作为集群的一部分，它存储数据，参与集群的索引和搜索功能。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tallate.top/imgs/ES/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://tallate.top/imgs/ES/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="https://tallate.top/imgs/ES/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B91.png">
<meta property="og:image" content="https://tallate.top/imgs/ES/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B92.png">
<meta property="og:image" content="https://tallate.top/imgs/ES/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png">
<meta property="og:updated_time" content="2020-12-19T11:58:31.968Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES集群">
<meta name="twitter:description" content="分布式概念（Distribution） ¶集群 - Cluster 一个集群就是由一个或多个节点组织在一起，它们共同持有全部的数据。 一个集群有一个唯一的名字标识 cluster.name ，其节点只能通过指定某个集群的名字，来加入这个集群。 ¶节点 - Node 一个节点是集群中的一个服务器，即一个 Elasticsearch 实例。 作为集群的一部分，它存储数据，参与集群的索引和搜索功能。">
<meta name="twitter:image" content="https://tallate.top/imgs/ES/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/4e9d7784.html">







  <title>ES集群 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4e9d7784.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES集群</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T09:03:54+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h1>分布式概念（Distribution）</h1>
<h2 id="集群-cluster"><a class="header-anchor" href="#集群-cluster">¶</a>集群 - Cluster</h2>
<p>一个集群就是由一个或多个节点组织在一起，它们共同持有全部的数据。<br>
一个集群有一个唯一的名字标识 <code>cluster.name</code> ，其节点只能通过指定某个集群的名字，来加入这个集群。</p>
<h2 id="节点-node"><a class="header-anchor" href="#节点-node">¶</a>节点 - Node</h2>
<p>一个节点是集群中的一个服务器，即一个 Elasticsearch 实例。<br>
作为集群的一部分，它存储数据，参与集群的索引和搜索功能。</p>
<h2 id="主节点-master"><a class="header-anchor" href="#主节点-master">¶</a>主节点 - Master</h2>
<p>当一个节点被选举成为主节点时，它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。<br>
主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量增加它也不会成为瓶颈。</p>
<h2 id="分片-shard"><a class="header-anchor" href="#分片-shard">¶</a>分片 - Shard</h2>
<p>一个 分片 是一个底层的 工作单元 ，它仅保存了 <strong>全部数据中的一部分</strong>，是一个 Lucene 的实例，所以它本身就是一个完整的搜索引擎。<br>
一个索引可以被划分成多个分片，创建索引时可指定分片数量，默认是 5。<br>
每个分片是一个 Lucene 实例，它本身也是一个功能完善并且独立的“索引”，这个“索引” 可以被放置到集群中的任何节点上。<br>
分片是 ES 中集群管理的最小单位，在此基础上，ES 允许：</p>
<ul>
<li>允许你水平分割/扩展你的内容容量</li>
<li>允许你在分片（位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量</li>
</ul>
<p>分片类似 DB 里的分库分表，是为了解决数据量很大查询效率低下的问题，同时突破单节点磁盘限制。<br>
集群的配置非常灵活，比如对于一个需要占据 100G 磁盘空间的索引，5 个分片每个分片大小 20G，假设单节点磁盘上限 100G，可以有以下几种方案：</p>
<ol>
<li>单节点一个分片：单次只能在 100G 数据里查询一条数据，磁盘占用率 100%。</li>
<li>单节点 5 个分片：每个分片存储 20G 数据，可以 5 个任务并行查询，磁盘占用率 100%，索引大小上限 100G，无法再插入新数据。</li>
<li>集群（2 个节点）5 个分片：一个节点 3 片，另一个节点 2 片，可以并行查找，同时单节点磁盘占用量 &lt;60%，索引最大存储上限为 200G。</li>
<li>集群（5 个节点）5 个分片：每个节点包含一个分片，单节点磁盘占用量 20%，索引最大存储上限为 500G。</li>
</ol>
<p>至于是否有最佳实践，我认为还是得根据实际场景来说话，比如就简单搭建一个开发环境来说，单节点（单分片或多分片）足够，当然，因为没有荣誉，硬件故障时会有数据丢失风险。</p>
<h2 id="主分片和副分片"><a class="header-anchor" href="#主分片和副分片">¶</a>主分片和副分片</h2>
<p>一个分片可以是 主分片 或者 副本分片。<br>
索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量，在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。<br>
一个副本分片只是一个主分片的拷贝。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<h2 id="索引-index"><a class="header-anchor" href="#索引-index">¶</a>索引（Index）</h2>
<p>索引实际上是指向一个或者多个物理 分片 的 <strong>逻辑命名空间</strong>。<br>
所以说一个节点包含多个分片没有问题，但是一个节点包含多个索引是不对的，因为索引包含的分片可以存在于多个节点内，且可以在后期添加。</p>
<h2 id="复制-replica"><a class="header-anchor" href="#复制-replica">¶</a>复制（Replica）</h2>
<p>Elasticsearch 允许创建分片的一份或多份拷贝（默认复制 1 份），这些拷贝叫做复制分片。<br>
在分片/节点失败的情况下，复制提供了高可用性。<br>
因为搜索可以在所有的复制上并行运行，复制可以扩展你的搜索量/吞吐量<br>
复制分片不与相同的主分片置于同一节点上，否则失去备份的意义。</p>
<p>总而言之：</p>
<ol>
<li>每个索引可以被分成多个分片。</li>
<li>一个索引也可以被复制 0 次（即没有复制） 或多次。</li>
<li>一旦复制了，每个索引就有了主分片（作为复制源的分片）和复制分片（主分片的拷贝）。</li>
<li>分片和复制的数量可以在索引创建的时候指定。在索引创建之后，可以在任何时候动态地改变复制的数量，但是不能再改变分片的数量。</li>
</ol>
<p>至于 ES 集群中如何分配分片与备份，都是 ES 内部维护管理的，对用户完全透明。</p>
<h1>单节点</h1>
<h2 id="检测外部环境"><a class="header-anchor" href="#检测外部环境">¶</a>检测外部环境</h2>
<p>Bootstrap#setup：初始化 node 时重写 validateNodeBeforeAcceptingRequests，在其中包含了检查逻辑<br>
-&gt; BootstrapChecks.check</p>
<h2 id="启动各模块"><a class="header-anchor" href="#启动各模块">¶</a>启动各模块</h2>
<p>Bootstrap#start<br>
-&gt; Node#start：调各子模块的 start 来初始化</p>
<h2 id="keepalive"><a class="header-anchor" href="#keepalive">¶</a>keepalive</h2>
<p>唯一的用户线程，作用是保持进程运行。</p>
<p>Bootstrap#keepAliveThread</p>
<h2 id="节点关闭"><a class="header-anchor" href="#节点关闭">¶</a>节点关闭</h2>
<p>Bootstrap#stop<br>
-&gt; IOUtils#close：关闭 node，注意 Node 实现了 Closable<br>
-&gt; Node#close</p>
<h1>主从</h1>
<h2 id="数据副本模型"><a class="header-anchor" href="#数据副本模型">¶</a>数据副本模型</h2>
<p>主从模型是分布式的经典模型之一，通过主节点的选举可以实现高可用。的那个然主从只能提高可用性，如果要性能上的可伸缩性，一般还会对数据进行 hash。<br>
主从模型实际上也是下面将要讨论的分布式文档存储、搜索的基础。</p>
<blockquote>
<p>HDFS、Cassandra 等使用的是对等模型。</p>
</blockquote>
<h3 id="pacifica-算法"><a class="header-anchor" href="#pacifica-算法">¶</a>PacificA 算法</h3>
<p>ES 的主副本模型的实现参考了微软的 PacificA 算法，下面是算法中涉及到的几个概念：</p>
<ul>
<li>Replica Group</li>
<li>Configuration</li>
<li>Configuration Version</li>
<li>Serial Number（SN）</li>
</ul>
<p>PacificA 算法运行在分布式系统之上，对系统有以下几项假设：</p>
<ul>
<li>节点可以失效，对消息延迟的上限不做假设；</li>
<li>消息可以丢失、乱序，但不能被篡改，即不存在<strong>拜占庭问题</strong>；</li>
</ul>
<blockquote>
<p>拜占庭问题</p>
</blockquote>
<ul>
<li>网络分区可以发生，系统时钟可以不同步，但<strong>漂移</strong>是有限度的。</li>
</ul>
<blockquote>
<p>漂移</p>
</blockquote>
<h3 id="存储管理-写入"><a class="header-anchor" href="#存储管理-写入">¶</a>存储管理 - 写入</h3>
<p>数据的读取和更新策略，及使用多副本方式保证数据的可靠性和可用性。<br>
数据写流程如下：<br>
<img src="https://tallate.top/imgs/ES/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png" alt="数据写入流程" title="数据写入流程"></p>
<ol>
<li>写请求进入主副本节点；</li>
<li>节点为该请求分配 SN，并使用该 SN 创建 UpdateRequest，然后将该 UpdateRequest 插入自己的 prepareList；</li>
<li>主副本将携带 SN 的 UpdateRequest 发往从副本节点，从节点收到后同样插入 prepareList；</li>
<li>主副本节点接收到所有从副本节点的 ACK 响应，确认该数据已经被写入到所有的从副本节点；</li>
<li>此时达到了可提交的状态，主副本将此 UpdateRequest 放入 committedList，committedList 向前移动；</li>
<li>主副本节点回复客户端更新成功。</li>
<li>主节点向从节点发送 commit 通知，告诉它们自己的 committed point 位置，从节点收到通知后根据指示来移动 committed point 到相同位置。</li>
</ol>
<p>数据存储流程中遵循不变式<code>Commit Invariant</code>：</p>
<ol>
<li>主节点 committedList 是任何一个从节点 prepareList 的前缀（子集）；</li>
<li>任一从节点上的 committedList 是主节点上 committedList 的前缀（子集）。</li>
</ol>
<h3 id="配置管理"><a class="header-anchor" href="#配置管理">¶</a>配置管理</h3>
<p>对配置信息进行管理，维护所有配置信息的一致性。<br>
配置同样遵循版本控制，由一个全局的配置管理器管理所有副本组的配置。<br>
当节点向管理器提出添加/移除副本的请求时，每次请求都需要附带当前配置版本号，只有这个版本号和管理器记录的版本号一致的情况下才能被执行，如果请求执行成功，则这个新配置会被赋予新的版本号。</p>
<h3 id="allocation-ids"><a class="header-anchor" href="#allocation-ids">¶</a>Allocation IDs</h3>
<p>TODO</p>
<h3 id="sequence-ids"><a class="header-anchor" href="#sequence-ids">¶</a>Sequence IDs</h3>
<p>TODO</p>
<h3 id="乐观并发控制"><a class="header-anchor" href="#乐观并发控制">¶</a>乐观并发控制</h3>
<p><img src="https://tallate.top/imgs/ES/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.png" alt="并发更新问题" title="并发更新问题"><br>
如上图所示 Web-2 不知道自己的对象拷贝已经过期，结果执行更新时会认为库存尚充足。<br>
像这样的变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。<br>
在数据库领域中，有两种策略通常被用来确保并发更新时变更不会丢失：</p>
<ul>
<li>悲观并发控制<br>
这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此<strong>阻塞访问资源以防止冲突</strong>。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</li>
<li>乐观并发控制<br>
Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，<strong>如果源数据在读写当中被修改，更新将会失败</strong>。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</li>
</ul>
<p>Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些<strong>复制请求被并行发送，并且到达目的地时也许 顺序是乱的</strong>。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p>
<ol>
<li>
<p>内部版本号<br>
当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。<br>
当我们在更新数据时，需要指定想要修改文档的_version，如果该版本不是当前版本号，我们的请求将会失败。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/1?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Starting to get the hang of this...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>外部版本号<br>
一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索，Elasticsearch 提供了一种机制来重用主数据库中已经存在的版本号字段。<br>
外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果是则请求成功，外部的版本号作为文档的新 _version 进行存储，这意味着每次请求必须先在主数据库中增加版本号的值，再将新版本的数据索引到 Elasticsearch 中。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first external blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Starting to get the hang of this...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>集群</h1>
<h2 id="选主"><a class="header-anchor" href="#选主">¶</a>选主</h2>
<p>ES 默认服务发现实现是内置的<code>Zen Discovery</code></p>
<h3 id="选举相关概念"><a class="header-anchor" href="#选举相关概念">¶</a>选举相关概念</h3>
<ul>
<li>选举（Election）</li>
<li>主从（主：Leader、Coordinator、Master，从：Follower、Slave）</li>
<li>分布式哈希表（DHT）</li>
<li>多数派（法定人数、Quorum）</li>
<li>分区和脑裂：集群中出现双主或多主。</li>
<li>Bully 算法</li>
<li>Paxos 算法</li>
</ul>
<h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3>
<ul>
<li>node.master：决定当前节点是否具备 Master 资格</li>
<li>discovery.zen.minimum_master_nodes</li>
<li>discovery.zen.ignore_non_master_pings</li>
</ul>
<h3 id="本地节点实例的创建"><a class="header-anchor" href="#本地节点实例的创建">¶</a>本地节点实例的创建</h3>
<p>管理节点配置<br>
Node#localNodeFactory</p>
<h3 id="选主流程"><a class="header-anchor" href="#选主流程">¶</a>选主流程</h3>
<p>ZenDiscovery 的选主流程如下：</p>
<ol>
<li>每个节点计算最小的已知节点 ID，该节点为临时 Master，向该节点发送领导投票；</li>
<li>如果一个节点收到足够多的票数，并且该节点也为自己投票，那么它将扮演领导者的角色，开始发布集群状态。</li>
</ol>
<h3 id="选举临时-master"><a class="header-anchor" href="#选举临时-master">¶</a>选举临时 Master</h3>
<p>Node#start<br>
-&gt; ZenDiscovery#startInitialJoin<br>
-&gt; ZenDiscovery#JoinThreadControl#startNewThreadIfNotRunning<br>
-&gt; threadPool.generic().execute：使用 generic 线程池执行选主流程<br>
-&gt; ZenDiscovery#innerJoinCluster：加入集群<br>
-&gt; ZenDiscovery#findMaster：查找当前集群的活跃 Master，或者从候选者中选择新的 Master<br>
-&gt; ZenDiscovery#pingAndWait：ping 一下所有节点（除了本节点），获取 pingResponses<br>
-&gt; 构建<strong>activeMasters</strong>列表，将每个节点所认为的当前 Master 节点加入 activeMasters 列表<br>
-&gt; 构建<strong>masterCandidates</strong>列表，从 pingResponses 列表中去掉不具备 Master 资格的节点<br>
-&gt; 如果 activeMasters 为空，则从 masterCandidates 中选举，否则从 activeMasters 中选择最合适的作为 Master</p>
<h3 id="从-mastercandidates-选主"><a class="header-anchor" href="#从-mastercandidates-选主">¶</a>从 masterCandidates 选主</h3>
<p>activeMasters 为空一般发生在集群刚启动或大规模重启的情况下。</p>
<p>ZenDiscovery#findMaster<br>
-&gt; ElectMasterService#hasEnoughCandidates：当前候选人数是否达到法定人数，若未达到则直接令选举失败<br>
-&gt; ElectMasterService#electMaster：当候选者达到法定人数后，从中选出一个作为 Master，选择前需要先用自定义比较函数进行排序<br>
-&gt; MasterCandidate.compare 自定义的排序逻辑</p>
<p>排序条件：</p>
<ol>
<li>版本号大的优先；</li>
<li>具备 Master 资格的优先；</li>
<li>节点 ID 小的优先。</li>
</ol>
<h3 id="从-activemasters-列表中选主"><a class="header-anchor" href="#从-activemasters-列表中选主">¶</a>从 activeMasters 列表中选主</h3>
<p>此时列表中存储着集群当前活跃的 Master，从这些已知的 Master 节点中选择一个作为选举结果。</p>
<p>ZenDiscovery#findMaster<br>
-&gt; ElectMasterService#tieBreakActiveMasters：使用自定义比较函数排序后取第一个<br>
-&gt; ElectMasterService#compareNodes</p>
<p>排序条件：</p>
<ol>
<li>具备 Master 资格的优先；</li>
<li>节点 ID 小的优先。</li>
</ol>
<h3 id="收集投票进行统计"><a class="header-anchor" href="#收集投票进行统计">¶</a>收集投票进行统计</h3>
<p>ZenDiscovery#handleJoinRequest<br>
-&gt; NodeJoinController#handleJoinRequest<br>
-&gt; NodeJoinController.ElectionContext#addIncomingJoin 将收到的连接存储到 NodeJoinController.ElectionContext#joinRequestAccumulator 中</p>
<p>NodeJoinController.ElectionContext#getPendingMasterJoinsCount：节点检查收到的投票是否足够时，就是检查加入它的连接数是否足够，其中会去掉没有 Master 资格节点的投票</p>
<h3 id="加入集群"><a class="header-anchor" href="#加入集群">¶</a>加入集群</h3>
<p>如果按以上逻辑选举出的临时 Master 是本节点：</p>
<ol>
<li>等待足够多的具备 Master 资格的节点加入本节点，直到投票达到法定人数，完成选举；</li>
<li>超时（默认 30 秒且可配置）后还没有满足数量的 join 请求，则选举失败，需要进行新一轮选举；</li>
<li>成功后发布新的 clusterState。</li>
</ol>
<p>ZenDiscovery#innerJoinCluster<br>
NodeJoinController#waitToBeElectedAsMaster</p>
<p>如果按以上逻辑选举出的临时 Master 并非本节点：</p>
<ol>
<li>不再接受其他节点的 join 请求；</li>
<li>向 Master 发送 join 请求，并等待回复。超时时间默认为 1 分钟（可配置），如果遇到异常，则默认重试 3 次（可配置）。</li>
<li>最终当选的 Master 会先发布集群状态，再确认客户的 join 请求，因此，joinElectedMaster 返回代表收到了 join 请求的确认，并且已经收到了集群状态。本步骤检查收到的集群状态中的 Master 节点如果为空，或者当选的 Master 不是之前选择的节点，则重新选举。</li>
</ol>
<p>ZenDiscovery#innerJoinCluster<br>
-&gt; ZenDiscovery#joinElectedMaster</p>
<h2 id="集群扩容"><a class="header-anchor" href="#集群扩容">¶</a>集群扩容</h2>
<h3 id="配置节点"><a class="header-anchor" href="#配置节点">¶</a>配置节点</h3>
<p>集群是由一个或者多个拥有相同 <strong><a href="http://cluster.name" target="_blank" rel="noopener">cluster.name</a></strong> 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会<strong>重新平均分布所有的数据</strong>。</p>
<h3 id="水平扩容"><a class="header-anchor" href="#水平扩容">¶</a>水平扩容</h3>
<p><img src="https://tallate.top/imgs/ES/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B91.png" alt="水平扩容1" title="水平扩容1"><br>
主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。但是，<strong>读操作</strong>——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。<br>
动态调整副本分片数目的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line">&#123;</span><br><span class="line">   &quot;number_of_replicas&quot; : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tallate.top/imgs/ES/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B92.png" alt="水平扩容2" title="水平扩容2"><br>
为了提高性能，要么是为已有的结点分配更多的资源，要么是分配更多的结点并扩展当前集群。但是不能通过为已有的分片分配更多的资源或者为一个结点分配更多的分片来提高性能，因为一个结点内的所有分片共享这个结点（JVM）的资源，最终还是必须增加更多的硬件资源来提升吞吐量。<br>
更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点的情况下不丢失任何数据（因为每个结点上要么存在一个分片要么存在一个分片的冗余）。</p>
<p>更多关于扩容的知识需要阅读相关文献，比如：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html" target="_blank" rel="noopener">扩容设计</a>。</p>
<h2 id="故障转移"><a class="header-anchor" href="#故障转移">¶</a>故障转移</h2>
<h3 id="同机多节点"><a class="header-anchor" href="#同机多节点">¶</a>同机多节点</h3>
<p>当在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 <a href="http://cluster.name" target="_blank" rel="noopener">cluster.name</a> 配置，它就会自动发现集群并加入到其中。</p>
<h3 id="不同机器多节点"><a class="header-anchor" href="#不同机器多节点">¶</a>不同机器多节点</h3>
<p>在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表，设置其他节点的 ip:port 列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="故障转移机制"><a class="header-anchor" href="#故障转移机制">¶</a>故障转移机制</h3>
<p><img src="https://tallate.top/imgs/ES/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png" alt="故障转移" title="故障转移"><br>
所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档，即使主分片不可用了，服务仍然可用。如上图所示。<br>
如果集群缺失主节点，集群不能正常工作。所以发生的第一件事情就是选举一个新的主节点。但是需要注意的是<strong>集群必须存在且仅存在一个主节点</strong>，否则会出现<strong>脑裂</strong>现象，因此 Elasticsearch 提供了很多参数来避免这个情况。<br>
如果索引缺失主分片，索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片<strong>提升</strong>为主分片， 此时集群的状态将会为 yellow ，因为在创建索引时设置了每个主分片需要对应 2 份副本分片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number_of_replicas : 2</span><br></pre></td></tr></table></figure>
<p>重启节点后，集群可以将缺失的副本分片再次进行分配，如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ElasticSearch/" rel="tag"># ElasticSearch</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/e0007243.html" rel="next" title="ES索引和文档存储">
                <i class="fa fa-chevron-left"></i> ES索引和文档存储
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/226416.html" rel="prev" title="使用 jq 解析 json 数据">
                使用 jq 解析 json 数据 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">135</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">分布式概念（Distribution）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#集群-cluster"><span class="nav-number">1.1.</span> <span class="nav-text">¶集群 - Cluster</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点-node"><span class="nav-number">1.2.</span> <span class="nav-text">¶节点 - Node</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主节点-master"><span class="nav-number">1.3.</span> <span class="nav-text">¶主节点 - Master</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分片-shard"><span class="nav-number">1.4.</span> <span class="nav-text">¶分片 - Shard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主分片和副分片"><span class="nav-number">1.5.</span> <span class="nav-text">¶主分片和副分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引-index"><span class="nav-number">1.6.</span> <span class="nav-text">¶索引（Index）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制-replica"><span class="nav-number">1.7.</span> <span class="nav-text">¶复制（Replica）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">单节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#检测外部环境"><span class="nav-number">2.1.</span> <span class="nav-text">¶检测外部环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动各模块"><span class="nav-number">2.2.</span> <span class="nav-text">¶启动各模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keepalive"><span class="nav-number">2.3.</span> <span class="nav-text">¶keepalive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点关闭"><span class="nav-number">2.4.</span> <span class="nav-text">¶节点关闭</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">主从</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据副本模型"><span class="nav-number">3.1.</span> <span class="nav-text">¶数据副本模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pacifica-算法"><span class="nav-number">3.1.1.</span> <span class="nav-text">¶PacificA 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储管理-写入"><span class="nav-number">3.1.2.</span> <span class="nav-text">¶存储管理 - 写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置管理"><span class="nav-number">3.1.3.</span> <span class="nav-text">¶配置管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#allocation-ids"><span class="nav-number">3.1.4.</span> <span class="nav-text">¶Allocation IDs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sequence-ids"><span class="nav-number">3.1.5.</span> <span class="nav-text">¶Sequence IDs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观并发控制"><span class="nav-number">3.1.6.</span> <span class="nav-text">¶乐观并发控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选主"><span class="nav-number">4.1.</span> <span class="nav-text">¶选主</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选举相关概念"><span class="nav-number">4.1.1.</span> <span class="nav-text">¶选举相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">4.1.2.</span> <span class="nav-text">¶配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地节点实例的创建"><span class="nav-number">4.1.3.</span> <span class="nav-text">¶本地节点实例的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选主流程"><span class="nav-number">4.1.4.</span> <span class="nav-text">¶选主流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选举临时-master"><span class="nav-number">4.1.5.</span> <span class="nav-text">¶选举临时 Master</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-mastercandidates-选主"><span class="nav-number">4.1.6.</span> <span class="nav-text">¶从 masterCandidates 选主</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-activemasters-列表中选主"><span class="nav-number">4.1.7.</span> <span class="nav-text">¶从 activeMasters 列表中选主</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收集投票进行统计"><span class="nav-number">4.1.8.</span> <span class="nav-text">¶收集投票进行统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加入集群"><span class="nav-number">4.1.9.</span> <span class="nav-text">¶加入集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群扩容"><span class="nav-number">4.2.</span> <span class="nav-text">¶集群扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置节点"><span class="nav-number">4.2.1.</span> <span class="nav-text">¶配置节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平扩容"><span class="nav-number">4.2.2.</span> <span class="nav-text">¶水平扩容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#故障转移"><span class="nav-number">4.3.</span> <span class="nav-text">¶故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同机多节点"><span class="nav-number">4.3.1.</span> <span class="nav-text">¶同机多节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同机器多节点"><span class="nav-number">4.3.2.</span> <span class="nav-text">¶不同机器多节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移机制"><span class="nav-number">4.3.3.</span> <span class="nav-text">¶故障转移机制</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
