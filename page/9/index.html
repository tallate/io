<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/9/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/9/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/a4caf2c1.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/a4caf2c1.html" itemprop="url">Nginx 原理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T11:32:43+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="为什么要使用-nginx"><a class="header-anchor" href="#为什么要使用-nginx">¶</a>为什么要使用 Nginx</h2>
<h3 id="nginx-优点"><a class="header-anchor" href="#nginx-优点">¶</a>Nginx 优点</h3>
<ol>
<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>
<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>
<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>
<li>nginx 的设计高度模块化，编写模块相对简单</li>
<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>
<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>
<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>
<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ol>
<h3 id="nginx-优点-说出原因"><a class="header-anchor" href="#nginx-优点-说出原因">¶</a>Nginx 优点（说出原因）</h3>
<ol>
<li>Nginx 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。</li>
<li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发</li>
<li>内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术<br>
nginx 处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。<br>
节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存<br>
稳定性高：宕机的概率非常小</li>
<li>master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程<br>
接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力<br>
一边接收 web 服务器的返回数据，一边发送给浏览器客户端<br>
网络依赖性比较低，只要 ping 通就可以负载均衡<br>
可以有多台 nginx 服务器</li>
<li>事件驱动：通信机制采用 epoll 模型</li>
</ol>
<h3 id="apache-优点"><a class="header-anchor" href="#apache-优点">¶</a>Apache 优点</h3>
<ol>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 超稳定</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<h3 id="nginx-和-apache-区别总结"><a class="header-anchor" href="#nginx-和-apache-区别总结">¶</a>Nginx 和 Apache 区别总结</h3>
<p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程<br>
一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。<br>
更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>
<h2 id="使用-nginx"><a class="header-anchor" href="#使用-nginx">¶</a>使用 Nginx</h2>
<h3 id="手动安装-nginx"><a class="header-anchor" href="#手动安装-nginx">¶</a>手动安装 Nginx</h3>
<ol>
<li>配置<br>
创建目录<code>/var/temp/nginx</code><br>
这个目录保存临时文件，在安装配置中指定：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure>
<ol>
<li>配置环境变量<br>
在<code>/etc/profile</code>中编辑，这样就可以直接使用 nginx 命令启动了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure>
<ol>
<li>启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line"># 指定配置文件</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>如果不指定-c，nginx 在启动时默认加载 conf/nginx.conf 文件，此文件的地址也可以在编译安装 nginx 时指定./configure 的参数（–conf-path= 指向配置文件（nginx.conf））</p>
<ol>
<li>停止</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop # 相当于先查出nginx进程id再kill</span><br><span class="line">nginx -s quit # 建议使用，这种方法是等nginx进程的任务处理完毕后再停止</span><br></pre></td></tr></table></figure>
<ol>
<li>重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>要想在修改配置文件 nginx.conf 后生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h3 id="开机自启"><a class="header-anchor" href="#开机自启">¶</a>开机自启</h3>
<ol>
<li>创建<code>/etc/init.d/nginx</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&apos;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<ol>
<li>设置文件访问权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<ol>
<li>设置开机加载<br>
在<code>/etc/rc.local</code>中加入一行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure>
<h3 id="通过-docker-运行-nginx"><a class="header-anchor" href="#通过-docker-运行-nginx">¶</a>通过 Docker 运行 Nginx</h3>
<p>手动进行 Nginx 配置十分繁琐，可以使用 Docker 来简化部署流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<h2 id="优化-linux-最大连接数"><a class="header-anchor" href="#优化-linux-最大连接数">¶</a>优化 Linux 最大连接数</h2>
<h3 id="查看-linux-连接数"><a class="header-anchor" href="#查看-linux-连接数">¶</a>查看 Linux 连接数</h3>
<p>默认配置下，Linux 只支持有限的连接数。<br>
Linux 的线程其实是一个进程，所以 java 的也是，具体来说，叫做“light weight process(LWP)”—轻量级进程。<br>
LWP 与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个 LWP，这样它们共享大部分资源；LWP 有它自己的进程标识符，并和其他进程有着父子关系；。LWP 由内核管理并像普通进程一样被调度<br>
使用以下命令可以看到某个用户使用了多少进程资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep xjjbot(uid)  | wc -l</span><br></pre></td></tr></table></figure>
<p>使用下面命令可以查看具体每个进程开启了多少线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u xjjbot(uid)  | sort -n</span><br></pre></td></tr></table></figure>
<p>根据 linux 一切都是文件的规则，首先想到的，是修改 ulimit 的参数，然而也不是，因为它已经足够大了。交叉回想一下 elasticsearch，在安装的时候，需要配置一个叫做 nproc 的东西，问题大概就出在这，是进程资源不够用啦。<br>
相关的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>在不同的内核版本上，也有一些小差异。比如：/etc/security/limits.d/*<br>
下的文件，会在某些时候覆盖 limits.conf 的配置。所以配置不生效的情况下，记得检查一下。<br>
鉴于以上原因，可以将 limits.d 中的配置全部注释掉，统一在 limits.conf 中配置。<br>
以下是原始配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<p>将 4096 改为大点的数字，或者直接改成 unlimited 就可以了。</p>
<p>单机支持 100 万连接是可行的，但带宽问题会成为显著的瓶颈。启用压缩的二进制协议会节省部分带宽，但开发难度增加。</p>
<h3 id="操作系统优化"><a class="header-anchor" href="#操作系统优化">¶</a>操作系统优化</h3>
<p>更改进程最大文件句柄数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1048576</span><br></pre></td></tr></table></figure>
<p>复制代码修改单个进程可分配的最大文件数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2097152 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>
<p>复制代码修改/etc/security/limits.conf 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   soft nofile  1048576</span><br><span class="line">*   hard nofile 1048576</span><br><span class="line">*   soft nproc unlimited</span><br><span class="line">root soft nproc unlimited</span><br></pre></td></tr></table></figure>
<p>复制代码记得清理掉/etc/security/limits.d/*下的配置</p>
<h3 id="网络优化"><a class="header-anchor" href="#网络优化">¶</a>网络优化</h3>
<p>打开/etc/sysctl.conf，添加配置然后执行，使用 sysctl 生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#单个进程可分配的最大文件数</span><br><span class="line">fs.nr_open=2097152</span><br><span class="line"></span><br><span class="line">#系统最大文件句柄数</span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line">#backlog 设置</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">net.core.netdev_max_backlog=16384</span><br><span class="line"></span><br><span class="line">#可用知名端口范围配置</span><br><span class="line">net.ipv4.ip_local_port_range=&apos;1000 65535&apos;</span><br><span class="line"></span><br><span class="line">#TCP Socket 读写 Buffer 设置</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.optmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=&apos;1024 4096 16777216&apos;</span><br><span class="line">net.ipv4.tcp_wmem=&apos;1024 4096 16777216&apos;</span><br><span class="line"></span><br><span class="line">#TCP 连接追踪设置</span><br><span class="line">net.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait=30</span><br><span class="line"></span><br><span class="line">#TIME-WAIT Socket 最大数量、回收与重用设置</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line"></span><br><span class="line"># FIN-WAIT-2 Socket 超时设置</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure>
<h2 id="接入层演进"><a class="header-anchor" href="#接入层演进">¶</a>接入层演进</h2>
<p>通过研究接入层的发展历程，我们可以一窥 Nginx 在互联网架构中的地位。</p>
<h3 id="接入层结构"><a class="header-anchor" href="#接入层结构">¶</a>接入层结构</h3>
<p><img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%85%A5%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="接入层结构" title="接入层结构"><br>
可以看到，每一个下游都有多个上游调用，只需要做到，<strong>每一个上游都均匀访问每一个下游</strong>，就能实现整体的均匀分摊。</p>
<ol>
<li>客户端层-&gt;反向代理层<br>
DNS 轮询<br>
DNS-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 DNS-server，会轮询返回这些 ip，保证每个 ip 的解析概率是相同的。这些 ip 就是 nginx 的外网 ip，以做到每台 nginx 的请求分配也是均衡的。</li>
<li>反向代理层-&gt;站点层<br>
反向代理层到站点层的负载均衡，是通过“nginx”实现的。<br>
修改 nginx.conf，可以实现多种均衡策略：<br>
2.1 请求轮询：和 DNS 轮询类似，请求依次路由到各个 web-server；<br>
2.2 最少连接路由：哪个 web-server 的连接少，路由到哪个 web-server；<br>
2.3 ip 哈希：按照访问用户的 ip 哈希值来路由 web-server，只要用户的 ip 分布是均匀的，请求理论上也是均匀的，ip 哈希均衡方法可以做到，同一个用户的请求固定落到同一台 web-server 上，此策略适合有状态服务，例如 session；</li>
</ol>
<blockquote>
<p>session 不推荐放到站点层，后期扩展会有问题，更好的方案是放到数据层。</p>
</blockquote>
<ol start="3">
<li>站点层-&gt;服务层<br>
站点层到服务层的负载均衡，是通过“服务连接池”实现的。<br>
上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。除了负载均衡，服务连接池还能够实现故障转移、超时处理、限流限速、ID 串行化等诸多功能。</li>
<li>服务层-&gt;数据层<br>
在数据量很大的情况下，由于数据层（db/cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<br>
<strong>数据的均衡</strong>是指：水平切分后的每个服务（db/cache），数据量是均匀的。<br>
<strong>请求的均衡</strong>是指：水平切分后的每个服务（db/cache），请求量是均匀的。</li>
</ol>
<h3 id="接入层演进-v2"><a class="header-anchor" href="#接入层演进-v2">¶</a>接入层演进</h3>
<ol>
<li>单机架构<br>
客户端用 DNS 解析出来的 IP 就是 web 服务器的地址。<br>
缺点：
<ul>
<li>单点；</li>
<li>扩展性差。</li>
</ul>
</li>
<li>DNS 轮询<br>
在 DNS 服务器上多配几个 IP，由域名服务器的解析策略实现负载均衡。<br>
缺点：
<ul>
<li>非高可用，因为一个 web 服务器挂掉后 DNS 服务器仍然会将请求解析到该服务器对应的 IP 上；</li>
<li>扩容非实时，DNS 服务器有一个配置生效的延时时间；</li>
<li>暴露太多外网 IP。</li>
</ul>
</li>
<li>反向代理 Nginx<br>
DNS 解析到 Nginx 的 IP，然后由 Nginx 将请求负载均衡到 web 服务器。<br>
缺点：基本解决了上一个架构存在的问题，且可以利用 Nginx 的探活机制实现 web 服务器的高可用，但是此时 Nginx 也会成为一个单点。</li>
<li>keepalived<br>
两台 Nginx 组成集群，分别部署上 keepalived，设置成相同的虚 IP，保证 Nginx 的高可用。当一台 Nginx 挂了，keepalived 能够探测到并将流量迁移到另一台 Nginx 上，整个过程对调用方透明。<br>
缺点：
<ul>
<li>资源利用率低；</li>
<li>扩容不方便，如果吞吐量超过 Nginx 性能上线，要加机器配置起来比较麻烦。</li>
</ul>
</li>
<li>lvs/f5<br>
DNS 解析出来的 IP 是 lvs 的地址。由 lvs 反向代理 Nginx 服务器，lvs 的机器上部署 keepalived+VIP 实现高可用；<br>
f5 的性能比 lvs 更高，但是成本也会更高。</li>
<li>DNS 轮询<br>
水平扩展才是解决性能问题的根本方案，能够通过加机器扩充性能的方案才具备最好的扩展性。<br>
<img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8E%A5%E5%85%A5%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="可扩展高可用接入层架构" title="可扩展高可用接入层架构">
<ul>
<li>通过 DNS 轮询来线性扩展入口 lvs 层的性能；</li>
<li>通过 keepalived 保证高可用；</li>
<li>通过 lvs 来扩展多个 Nginx；</li>
<li>通过 Nginx 实现对业务服务器的七层负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="nginx-原理-进程"><a class="header-anchor" href="#nginx-原理-进程">¶</a>Nginx 原理 - 进程</h2>
<h3 id="nginx-代码的模块化结构"><a class="header-anchor" href="#nginx-代码的模块化结构">¶</a>Nginx 代码的模块化结构</h3>
<p>Nginx 的代码是由一个核心和一系列的模块组成的。<br>
<strong>核心</strong>主要用于提供 WebServer 的基本功能，以及 Web 和 Mail 反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。<br>
不过，大多跟协议相关的功能和应用特有的功能都是由 nginx 的模块实现的。<br>
换句话说， <strong>每一个功能或操作都由一个模块来实现</strong>。<br>
这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream 和负载均衡几个类别，这些共同组成了 nginx 的 http 功能。<br>
<strong>事件模块</strong>主要用于提供 OS 独立的(不同操作系统的事件机制有所不同)事件通知机制如 kqueue 或 epoll 等。<br>
<strong>协议模块</strong>则负责实现 nginx 通过 http、tls/ssl、smtp、pop3 以及 imap 与对应的客户端建立会话。<br>
在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的。<br>
换句话说，每一个功能或操作都由一个模块来实现。例如：压缩、通过 FastCGI 或 uwsgi 协议与 upstream 服务器通信、以及与 memcached 建立会话等。</p>
<h3 id="进程结构"><a class="header-anchor" href="#进程结构">¶</a>进程结构</h3>
<p>一个 Nginx 服务器实例由一个 master 进程和多个 worker 进程组成。<br>
<img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"><br>
<strong>master</strong>进程主要用来管理 worker 进程，还有一些对整个服务器的初始化和日志记录等工作。<br>
<strong>管理 worker 的过程</strong>：接收来自外界的信号，向各 worker 进程发送 <strong>信号</strong> ，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动（fork）新的 worker 进程。</p>
<p><strong>master 主要功能</strong>：</p>
<ul>
<li>读取并验证配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止 worker 进程及维护 worker 进程的个数；</li>
<li>无须中止服务而重新配置工作；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式 perl 脚本</li>
</ul>
<p>对请求的实际处理由 <strong>worker</strong> 负责，且每个请求只能由一个 worker 负责（一对一）。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。</p>
<p><strong>worker 主要功能</strong>：</p>
<ul>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx 任何能完成的其它任务</li>
</ul>
<h3 id="nginx-的启动"><a class="header-anchor" href="#nginx-的启动">¶</a>Nginx 的启动</h3>
<p>nginx 启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程（你可以理解为工人和管理员）。</p>
<h3 id="nginx-处理连接过程"><a class="header-anchor" href="#nginx-处理连接过程">¶</a>Nginx 处理连接过程</h3>
<p>nginx 不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的 <strong>循环</strong> 来处理数千个连接。<br>
Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。 <strong>监听套接字</strong> 在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。</p>
<p>一次请求过程大概执行过程为：</p>
<ol>
<li>nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面先初始化好这个监控的 socket，再进行 listen（listenfd）；</li>
<li>由 master 进程 fork 出多个 worker 进程；</li>
<li>此时客户端可以向 nginx 发起连接了，客户端会与 nginx 进行三次握手（TCP），与 nginx 建立好一个连接；</li>
<li>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接</li>
<li>当一个 worker 进程在 accept 这个连接之后，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体，就开始读取请求、解析请求、处理请求（ <strong>异步非阻塞</strong> ），主要是根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换</li>
<li>产生数据后，再返回给客户端，最后才断开连接，或者由客户端主动关闭连接。</li>
</ol>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h3>
<p>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的，其原理是<strong>信号机制</strong>，master 对 worker 进程采用信号进行控制。</p>
<h3 id="事件驱动"><a class="header-anchor" href="#事件驱动">¶</a>事件驱动</h3>
<p>所谓<strong>事件驱动</strong>架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会“消费”这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。<br>
传统 web 服务器（如 Apache）的所谓事件局限在 TCP 连接建立、关闭上，其他读写都不再是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 Web 服务器每个事件消费者独占一个进程资源，相对来说，Nginx 只是被事件分发者进程短期调用而已。<br>
nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限，多少个 worker 就能处理多少个并发，那么何来的高并发呢？<br>
其实，Nginx 是采用了<strong>异步非阻塞</strong>的 IO 模型来处理请求的（epoll），异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。<br>
请求的<strong>多阶段异步处理</strong>只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段。<br>
每种事件都有一个事件队列，按触发的先后顺序处理。</p>
<h3 id="惊群现象"><a class="header-anchor" href="#惊群现象">¶</a>惊群现象</h3>
<p>惊群是多个子进程在同一时刻监听同一个端口引起的；<br>
Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。这可以通过锁或互斥量实现。</p>
<h3 id="为什么不使用多线程"><a class="header-anchor" href="#为什么不使用多线程">¶</a>为什么不使用多线程</h3>
<ul>
<li>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。</li>
<li>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</li>
</ul>
<h2 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h2>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.shiyanlou.com/courses/95" target="_blank" rel="noopener">Linux Web 运维（Nginx）实战</a></li>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx 开发从入门到精通</a></li>
<li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">nginx documentation</a></li>
</ol>
<h3 id="nginx-原理"><a class="header-anchor" href="#nginx-原理">¶</a>Nginx 原理</h3>
<ol>
<li><a href="https://segmentfault.com/q/1010000003901360?_ea=416091" target="_blank" rel="noopener">Nginx 内部有使用多线程吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清 epoll 的本质，那就过来掐死我吧！ （1）</a></li>
</ol>
<h3 id="模块-v2"><a class="header-anchor" href="#模块-v2">¶</a>模块</h3>
<ol>
<li>log<br>
<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">Module ngx_http_log_module</a><br>
<a href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html#log_format" target="_blank" rel="noopener">Module ngx_stream_log_module</a><br>
<a href="http://blog.chinaunix.net/uid-29179844-id-4433640.html" target="_blank" rel="noopener">nginx 日志格式及自定义日志配置</a></li>
<li>proxy<br>
<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">Module ngx_http_proxy_module</a></li>
<li>TCP / UDP<br>
<a href="http://nginx.org/en/docs/stream/stream_processing.html" target="_blank" rel="noopener">How nginx processes a TCP/UDP session</a></li>
</ol>
<h3 id="tengine"><a class="header-anchor" href="#tengine">¶</a>Tengine</h3>
<ol>
<li><a href="http://tengine.taobao.org/documentation.html" target="_blank" rel="noopener">Documentation</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d9054d7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/d9054d7.html" itemprop="url">Redis-Lua 应用总结（updating）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-06T09:42:14+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这一篇是对在公司内缓存代码应用 Redis-Lua 的一个总结，经过 benchmark 测试，这种方式效率更高，且理论上有更低的可能性。</p>
<blockquote>
<p>公司内的大部分代码都比较保守——能粘老代码就粘老代码，但是实际上很多老代码并没有做到特别严谨。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/d9054d7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4be4a53c.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/4be4a53c.html" itemprop="url">一些有价值的开源学习资料汇总（updating）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-05T21:37:14+08:00">
                2019-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  304 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>收集从网上找到的学习资料，大部分来自 Github。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/4be4a53c.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1840c3ba.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1840c3ba.html" itemprop="url">自适应负载均衡(20%)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T22:32:50+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>云环境下自适应负载均衡算法的设计。<br>
题目描述 -&gt; <a href="https://code.aliyun.com/middlewarerace2019/adaptive-loadbalance" target="_blank" rel="noopener">阿里巴巴 2019 中间件性能挑战赛-自适应负载均衡（初赛）赛题</a></p>
<p>抽不出时间，中途放弃了。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/1840c3ba.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/7d1f0594.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/7d1f0594.html" itemprop="url">Java 基础总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T17:23:14+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="java5"><a class="header-anchor" href="#java5">¶</a>Java5</h2>
<h3 id="语法-集合框架等"><a class="header-anchor" href="#语法-集合框架等">¶</a>语法、集合框架等</h3>
<ul>
<li>泛型</li>
<li>枚举</li>
<li>装箱拆箱</li>
<li>变长参数</li>
<li>注解</li>
<li>foreach 循环</li>
<li>静态导入</li>
<li>格式化</li>
<li>线程框架/数据结构</li>
<li>Arrays 工具类/StringBuilder/instrument</li>
</ul>
<h4 id="泛型"><a class="header-anchor" href="#泛型">¶</a>泛型</h4>
<p>不同于 C++中的泛型，Java 的泛型会在编译后被清除，这种机制被称为泛型擦除。</p>
<blockquote>
<p>java 的类型推断基本都在编译期完成</p>
</blockquote>
<p><strong>优点</strong>：可以免去大量的显式类型转换；<br>
<strong>缺点</strong>：由于泛型擦除的存在，在很多场合下容易引起误会：</p>
<ul>
<li>比如向 List<integer>类型的表里添加一个 String 类型对象就不会通过，因为在编译期间还需要进行类型检查。</integer></li>
<li>在继承重写方法时，若父类中被重写的方法中含有泛型，因为泛型擦除理应变成重载，但是 Java 编译器会在编译后的字节码中添加桥方法（已经被类型擦除）、桥方法再调用重写的方法来解决；</li>
<li>泛型类型参数不能使用基本类型，因为基本类型不是 Object 的子类；</li>
<li>其他一些注意事项…</li>
</ul>
<h4 id="枚举"><a class="header-anchor" href="#枚举">¶</a>枚举</h4>
<p>枚举可以使用 enum 声明，在 switch 中可以作为 case 后的标签。可以使用 EnumMap 来保存枚举到其他类型的映射或使用 EnumSet 保存枚举值的集合。<br>
<strong>优点</strong>：</p>
<ul>
<li>相对使用 int 或 String 当作枚举对象来说，Java 编译器本身提供了对 enum 的类型检查，可以更安全地使用；</li>
<li>可以用于声明单例对象。</li>
</ul>
<h4 id="装箱拆箱"><a class="header-anchor" href="#装箱拆箱">¶</a>装箱拆箱</h4>
<p>基本类型可以自动转换成对应的包装类型，比如 boolean 会被包装为 Boolean。<br>
<strong>优点</strong>：</p>
<ul>
<li>方便。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>注意拆箱时不能对 null 拆箱，不然会报空指针。</li>
</ul>
<h4 id="变长参数"><a class="header-anchor" href="#变长参数">¶</a>变长参数</h4>
<p>可以传入任意多个相同类型的参数。<br>
<strong>优点</strong>：</p>
<ul>
<li>提供了更多灵活性，比如编写输出方法时可以格式化多个参数。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要注意 null 值的传入。</li>
</ul>
<h4 id="注解"><a class="header-anchor" href="#注解">¶</a>注解</h4>
<p>注解需要和反射配合使用，JDK 提供了一些具有特定语义的注解：<br>
@Inherited：是否对类的子类继承的方法等起作用；<br>
@Target：作用目标；<br>
@Rentation：表示 annotation 是否保留在编译过的 class 文件中还是在运行时可读。</p>
<h4 id="for-in-循环"><a class="header-anchor" href="#for-in-循环">¶</a>for/in 循环</h4>
<p><strong>优点</strong>：</p>
<ul>
<li>方便</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>获取不到元素所在 index；</li>
<li>无法在遍历的时候删除元素；</li>
</ul>
<h4 id="静态-import"><a class="header-anchor" href="#静态-import">¶</a>静态 import</h4>
<p>可以直接使用一个类中的静态方法。<br>
<strong>缺点</strong>：</p>
<ul>
<li>如果有同名的容易引起混淆；</li>
</ul>
<h4 id="formatter"><a class="header-anchor" href="#formatter">¶</a>Formatter</h4>
<p>提供对日期、数字等的格式化支持</p>
<h4 id="线程框架-数据结构"><a class="header-anchor" href="#线程框架-数据结构">¶</a>线程框架/数据结构</h4>
<ol>
<li>
<p>在线程中可以设置 UncaughtExceptionHandler，当抛出异常后可以执行指定的逻辑；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadingTest extends Thread &#123;</span><br><span class="line">  private int[] numbers;</span><br><span class="line">  public ThreadingTest(int[] numbers) &#123;</span><br><span class="line">    setName(&quot;Simple Thread&quot;);</span><br><span class="line">    setUncaughtExceptionHandler(</span><br><span class="line">        new SimpleThreadExceptionHandler());</span><br><span class="line">    this.numbers = numbers;</span><br><span class="line">  &#125;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    int index = numbers.length;</span><br><span class="line">    boolean finished = false;</span><br><span class="line">    while (!finished) &#123;</span><br><span class="line">      index--;</span><br><span class="line">      finished = true;</span><br><span class="line">      for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">        // Create error condition</span><br><span class="line">        if (numbers[i + 1] &lt; 0) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;Cannot pass negative numbers into this thread!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (numbers[i] &gt; numbers[i + 1]) &#123;</span><br><span class="line">          // swap</span><br><span class="line">          int temp = numbers[i];</span><br><span class="line">          numbers[i] = numbers[i + 1];</span><br><span class="line">          numbers[i + 1] = temp;</span><br><span class="line">          finished = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] numbers = new int[]&#123;2, -1, 56, 4, 7&#125;;</span><br><span class="line">    ThreadingTest threadingTest = new ThreadingTest(numbers);</span><br><span class="line">    threadingTest.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SimpleThreadExceptionHandler implements</span><br><span class="line">    Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">  public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">    System.err.printf(&quot;%s: %s at line %d of %s%n&quot;,</span><br><span class="line">        t.getName(),</span><br><span class="line">        e.toString(),</span><br><span class="line">        e.getStackTrace()[0].getLineNumber(),</span><br><span class="line">        e.getStackTrace()[0].getFileName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引入 Queue、BlockingQueue、ConcurrentMap 数据结构；</p>
</li>
<li>
<p>引入 JUC 线程池；</p>
<ul>
<li>每次提交任务时，如果线程数还没达到 coreSize 就创建新线程并绑定该任务。 所以第 coreSize 次提交任务后线程总数必达到 coreSize，不会重用之前的空闲线程。</li>
<li>线程数达到 coreSize 后，新增的任务就放到工作队列里，而线程池里的线程则努力的使用 take()从工作队列里拉活来干。</li>
<li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li>
<li>临时线程使用 poll(keepAliveTime，timeUnit)来从工作队列拉活，如果时候到了仍然两手空空没拉到活，表明它太闲了，就会被解雇掉。</li>
<li>如果 core 线程数＋临时线程数 &gt;maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder。默认的 AbortPolicy 抛 RejectedExecutionException 异常，其他选择包括静默放弃当前任务(Discard)，放弃工作队列里最老的任务(DisacardOldest)，或由主线程来直接执行(CallerRuns)，或你自己发挥想象力写的一个。</li>
</ul>
</li>
<li>
<p>Arrays<br>
提供数组相关的一些工具类。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(myArray);</span><br><span class="line">Arrays.toString(myArray)</span><br><span class="line">Arrays.binarySearch(myArray, 98)</span><br><span class="line">Arrays.deepToString(ticTacToe)</span><br><span class="line">Arrays.deepEquals(ticTacToe, ticTacToe3)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="override-支持协变"><a class="header-anchor" href="#override-支持协变">¶</a>Override 支持协变</h4>
<p>返回类型可以是父类中相应类型或其子类。</p>
<h3 id="jvm"><a class="header-anchor" href="#jvm">¶</a>JVM</h3>
<h4 id="cds-class-data-sharing"><a class="header-anchor" href="#cds-class-data-sharing">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html" target="_blank" rel="noopener">CDS（Class Data Sharing）</a></h4>
<p>JRE installer 能将一些系统 jar 文件加载到一种私有内部表示方式，然后转储到一个文件内，称为“shared archive”，下次启动应用的时候可以直接使用这个包内的类数据，这样可以减少部分启动时间。</p>
<h4 id="自动检测服务器级机器"><a class="header-anchor" href="#自动检测服务器级机器">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html" target="_blank" rel="noopener">自动检测服务器级机器</a></h4>
<p>如果机器至少有 2 CPUs 和至少 2GB 物理内存，use the Java HotSpot Server Virtual Machine (server VM) instead of the Java HotSpot Client Virtual Machine (client VM).，The aim is to improve performance even if no one configures the VM to reflect the application it’s running. In general, the server VM starts up more slowly than the client VM, but over time runs more quickly.</p>
<h4 id="垃圾收集器自适应"><a class="header-anchor" href="#垃圾收集器自适应">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="noopener">垃圾收集器自适应</a></h4>
<p>服务器类机器默认垃圾回收器改为并行垃圾回收器。<br>
可以指定性能目标，并行收集器可以自动调整堆的大小，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeLimit=time-limit ：花费在GC上的时间上限，默认是98，当超过上限时，会抛出OutOfMemory(HeapSpace)的异常</span><br><span class="line">-XX:GCHeapFreeLimit=space-limit ：Heap空闲空间的最低比例下限，默认是2，当超过下限时，会抛出OutOfMemory(HeapSpace)的异常</span><br><span class="line">-XX:MaxGCPauseMillis=nnn ：最长的GC暂停时间，如果时间过长，会相应调整空间的大小（单位是毫秒）</span><br><span class="line">-XX:GCTimeRatio=nnn ：最大的GC占总可用时间的比例，如果时间过长，会相应调整空间的大小（花费在GC上的时间比例不超过1 / (1 + nnn)）</span><br></pre></td></tr></table></figure>
<h4 id="线程优先级"><a class="header-anchor" href="#线程优先级">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/thread-priorities.html" target="_blank" rel="noopener">线程优先级</a></h4>
<p>Thread 类中给出了三个线程优先级常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.MIN_PRIORITY = 1</span><br><span class="line">java.lang.Thread.NORM_PRIORITY = 5</span><br><span class="line">java.lang.Thread.MAX_PRIORITY = 10</span><br></pre></td></tr></table></figure>
<p>默认情况下线程优先级为 java.lang.Thread.NORM_PRIORITY，我们可以自定义设置在[1…10]内。<br>
JVM（Java HotSpot）将 Java 线程关联到唯一的一个 native thread。</p>
<h2 id="网络编程-socket"><a class="header-anchor" href="#网络编程-socket">¶</a>网络编程（Socket）</h2>
<h3 id="inetaddress"><a class="header-anchor" href="#inetaddress">¶</a>InetAddress</h3>
<p>IP 地址是在网络层封装上的，确定 Internet 上的一个唯一的地址，端口号是由传输层封装上的，标志主机上的一个服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class InetAddressTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        InetAddressTest.printAddress();</span><br><span class="line">    &#125;</span><br><span class="line">    static void printAddress()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(address);//输出：机器名/IP地址</span><br><span class="line">            address = InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            System.out.println(address);//输出：域名/IP地址</span><br><span class="line">            InetAddress[] addresses = InetAddress.getAllByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            for(InetAddress a : addresses)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(UnknownHostException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="url-和-urlconnection"><a class="header-anchor" href="#url-和-urlconnection">¶</a>URL 和 UrlConnection</h3>
<p>UrlConnection 可以从一个 URL 中打开流，可以方便地进行 Http 数据的收发。<br>
内部是使用 Socket 进行连接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取链接属性</span><br><span class="line">URL url = new URL(&quot;http://java.sun.com:80/docs/books/tutorial/index.html#DOWN&quot;);//#后面的DOWN是位置标识符，在获得网页后，浏览器将直接跳到网页的DOWN处读取</span><br><span class="line">String protocal = url.getProtocol();</span><br><span class="line">String host = url.getHost();</span><br><span class="line">String file = url.getFile();</span><br><span class="line">int port = url.getPort();</span><br><span class="line">String ref = url.getRef();//获得#后面的</span><br><span class="line">System.out.println(protocal + &quot;, &quot; + host + &quot;, &quot; + file + &quot;, &quot;</span><br><span class="line">        + port + &quot;, &quot; + ref);</span><br></pre></td></tr></table></figure>
<p>访问链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 访问链接读取数据</span><br><span class="line">URL url = new URL(&quot;http://www.cnblogs.com/mengdd/archive/2013/03/09/2951877.html&quot;);</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(url.openStream()));</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line">while((line = reader.readLine()) != null)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>
<p>下面是对 URLConnection 的测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class URLTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        URLTest c = new URLTest();</span><br><span class="line">        c.createURL();</span><br><span class="line">        c.printURLParam();</span><br><span class="line">        c.readURL();</span><br><span class="line">        c.printURL();</span><br><span class="line">    &#125;</span><br><span class="line">    void createURL()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://localhost:8080/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void printURLParam()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://java.sun.com:80/docs/books/tutorial/index.html#DOWN&quot;);//#后面的DOWN是位置标识符，在获得网页后，浏览器将直接跳到网页的DOWN处读取</span><br><span class="line">            String protocal = url.getProtocol();</span><br><span class="line">            String host = url.getHost();</span><br><span class="line">            String file = url.getFile();</span><br><span class="line">            int port = url.getPort();</span><br><span class="line">            String ref = url.getRef();//获得#后面的</span><br><span class="line">            System.out.println(protocal + &quot;, &quot; + host + &quot;, &quot; + file + &quot;, &quot;</span><br><span class="line">                    + port + &quot;, &quot; + ref);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void readURL()&#123;//将网页内容拷贝到本地</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">            URLConnection conn = url.openConnection();</span><br><span class="line">            InputStream is = conn.getInputStream();</span><br><span class="line">            //或者直接is = url.openStream();</span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;e:\\baidu.txt&quot;);</span><br><span class="line">            byte[] buffer = new byte[2048];</span><br><span class="line">            int length = 0;</span><br><span class="line">            while((length = is.read(buffer, 0, buffer.length)) != -1)&#123;</span><br><span class="line">                os.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void printURL()&#123;//读取网页内容到控制台</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">            BufferedReader reader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(url.openStream()));</span><br><span class="line">            String line;</span><br><span class="line">            while((line = reader.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tcp-和-udp"><a class="header-anchor" href="#tcp-和-udp">¶</a>TCP 和 UDP</h3>
<p>它们都是位于传输层的协议，为应用进程提供服务，根据不同的应用场景，会使用不同的协议。<br>
TCP 是基于连接的、面向流的协议，提供可靠通信，因此每次通信必须先建立连接，建立连接后可以分多次进行传输任务，并且保证数据的正确性。<br>
UDP 是基于无连接的、面向数据报的协议，提供不可靠通信，每次通信只需要发送一次数据报，可以分多次发送，但不保证能否到达、到达的顺序。</p>
<p>Socket 是 TCP 的应用编程接口，DatagramSocket 是 UDP 的应用编程接口，他们之间没有继承关系（都实现 Closeable 接口）。<br>
Socket 使用时需要先指定目标主机地址和端口号，然后打开 io 流进行操作<br>
1.服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 监听8080端口</span><br><span class="line">ServerSocket server = new ServerSocket(8080);</span><br><span class="line">// 等待请求</span><br><span class="line">Socket socket = server.accept();</span><br><span class="line">// 进行通信</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = reader.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">PrintWriter writer = new PrintWriter(socket.getOutputStream());</span><br><span class="line">writer.println(line);</span><br><span class="line">writer.flush(); // 不要忘了这个</span><br><span class="line">// 关闭资源</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure>
<p>2.客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 监听8080端口</span><br><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080);</span><br><span class="line">// 开始通信</span><br><span class="line">PrintWriter writer = new PrintWriter(socket.getOutputStream());</span><br><span class="line">writer.println(&quot;hello&quot;);</span><br><span class="line">writer.flush();</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = reader.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">// 关闭资源</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<h3 id="socketchannel-和-serversocketchannel"><a class="header-anchor" href="#socketchannel-和-serversocketchannel">¶</a>SocketChannel 和 ServerSocketChannel</h3>
<p>缓冲（Buffer）：相当于货物<br>
管道（Channel）：相当于配货车，支持同时装多件货物。<br>
选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况。相当于中转站的分拣员。</p>
<h3 id="使用-datagramsocket-进行-udp-通信"><a class="header-anchor" href="#使用-datagramsocket-进行-udp-通信">¶</a>使用 DatagramSocket 进行 UDP 通信</h3>
<h4 id="下面的代码使用-datagramsocket-实现-udp-通信"><a class="header-anchor" href="#下面的代码使用-datagramsocket-实现-udp-通信">¶</a>下面的代码使用 DatagramSocket 实现 UDP 通信</h4>
<p>服务端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建服务器socket，指定端口</span><br><span class="line">DatagramSocket socket = new DatagramSocket(7000);</span><br><span class="line">// 接收信息保存到一个缓冲区，DatagramPacket(bytes, len)</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket packet = new DatagramPacket(buffer, 1024);</span><br><span class="line">socket.receive(packet);</span><br><span class="line">System.out.println(new String(buffer, 0, packet.getLength()));</span><br><span class="line">// 响应信息，接收时需要指定地址和端口</span><br><span class="line">String str = &quot;Welcome!&quot;;</span><br><span class="line">DatagramPacket packet1 = new DatagramPacket(str.getBytes(),</span><br><span class="line">        str.length(), packet.getAddress(), packet.getPort());</span><br><span class="line">socket.send(packet1);</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket = new DatagramSocket();</span><br><span class="line">// 发送数据包</span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">DatagramPacket packet = new DatagramPacket(str.getBytes(),</span><br><span class="line">        str.length(), InetAddress.getByName(&quot;localhost&quot;), 7000);</span><br><span class="line">socket.send(packet);</span><br><span class="line">// 接收响应</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket packet1 = new DatagramPacket(buffer, 100);</span><br><span class="line">socket.receive(packet1);</span><br><span class="line">System.out.println(new String(buffer, 0, packet1.getLength()));</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<h4 id="下面的代码使用-nio-实现数据报协议"><a class="header-anchor" href="#下面的代码使用-nio-实现数据报协议">¶</a>下面的代码使用 NIO 实现数据报协议</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 发送</span><br><span class="line">public void send() throws IOException&#123;</span><br><span class="line">    // 打开数据报通道</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(false);</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">    Scanner scan = new Scanner(System.in);</span><br><span class="line">    while(scan.hasNext())&#123;</span><br><span class="line">        String str = scan.next();</span><br><span class="line">        buf.put((new Date().toString() + &quot;:\n&quot; + str).getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf, new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br><span class="line">// 接收</span><br><span class="line">public void receive() throws IOException&#123;</span><br><span class="line">    // 传送数据报通道</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(false);</span><br><span class="line">    dc.bind(new InetSocketAddress(9898));</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    dc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    while(selector.select() &gt; 0)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            if(sk.isReadable())&#123;</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(new String(buf.array(), 0, buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-nio-实现简易-httpserver"><a class="header-anchor" href="#使用-nio-实现简易-httpserver">¶</a>使用 NIO 实现简易 HttpServer</h3>
<p>主要思路很简单：<br>
(1) 服务器打开后首先为 Selector 注册一个 OP_ACCEPT 的 key，这样 select 时就能接收客户端请求了；<br>
(2) 每接收一个请求后即为该 key 创建一个线程，处理该 key 的操作，操作包括 accept 和 read，对于前者，只需为该 key 的 selector 再注册一个 OP_READ 用于准备接下来的读请求；<br>
(3) 读取时先读入一个 Buffer，首先解析请求头部分，直到遇到一个空行结束，因为这里只考虑 GET 请求，所以不必继续解析请求体了；<br>
(4) 返回时，首先构建响应头，同样使用一个空行结束，然后构建响应体，写回客户端，结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 监听8080端口</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line">        // 为server注册选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        // 创建处理器</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            // 等待请求，每次阻塞3s，若超过3s线程继续运行，</span><br><span class="line">            // select(0)或select()表示一直阻塞</span><br><span class="line">            if(selector.select(3000) == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取所有待处理的选择键</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line">            while(keyIter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIter.next();</span><br><span class="line">                // 启动新线程以处理SelectionKey</span><br><span class="line">                new Thread(new HttpHandler(key)).run();</span><br><span class="line">                // 处理完毕后，移除当前key</span><br><span class="line">                keyIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class HttpHandler implements Runnable &#123;</span><br><span class="line">        private int bufferSize = 1024;</span><br><span class="line">        private String localCharset = &quot;UTF-8&quot;;</span><br><span class="line">        private SelectionKey key;</span><br><span class="line"></span><br><span class="line">        public HttpHandler(SelectionKey key) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义操作</span><br><span class="line">        private void handleAccept() throws IOException &#123;</span><br><span class="line">            // 接受请求后，注册OP_READ选择键以等待下一次请求</span><br><span class="line">            SocketChannel clientChannel = ((ServerSocketChannel)key.channel()).accept();</span><br><span class="line">            clientChannel.configureBlocking(false);</span><br><span class="line">            // !!!请求报文被限制在1024个字节内</span><br><span class="line">            clientChannel.register(key.selector(),</span><br><span class="line">                    SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">        private void handleRead() throws IOException &#123;</span><br><span class="line">            // 获取</span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            // 获取Buffer并重置</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            // 读取，并判断内容是否为空，若是则关闭并退出</span><br><span class="line">            if(sc.read(buffer) == -1) &#123;</span><br><span class="line">               sc.close();</span><br><span class="line">               return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 接收请求数据</span><br><span class="line">            buffer.flip();</span><br><span class="line">            String receivedString = Charset.forName(localCharset).newDecoder().</span><br><span class="line">                    decode(buffer).toString();</span><br><span class="line"></span><br><span class="line">            // 打印请求报文头</span><br><span class="line">            String[] requestMessage = receivedString.split(&quot;\r\n&quot;);</span><br><span class="line">            for(String s: requestMessage) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                // 遇到空行说明报文头已经打印完</span><br><span class="line">                if(s.isEmpty()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 控制台打印首行信息</span><br><span class="line">            String[] firstLine = requestMessage[0].split(&quot; &quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;Method:\t&quot; + firstLine[0]);</span><br><span class="line">            System.out.println(&quot;url:\t&quot; + firstLine[1]);</span><br><span class="line">            System.out.println(&quot;HTTP Version:\t&quot; + firstLine[2]);</span><br><span class="line">            System.out.println();</span><br><span class="line">            // 返回客户端（!!!考虑对不同的Url和不同的请求方法进行不同的处理和响应）</span><br><span class="line">            StringBuilder sendString = new StringBuilder();</span><br><span class="line">            sendString.append(&quot;HTTP/1.1 200 OK\r\n&quot;); // 响应报文首行</span><br><span class="line">            sendString.append(&quot;Content-Type:text/html;charset=&quot; + // !!!如果要传输流数据必须修改Content-Type</span><br><span class="line">                    localCharset + &quot;\r\n&quot;);</span><br><span class="line">            sendString.append(&quot;\r\n&quot;); // 报文结束后加一空行</span><br><span class="line">            // 响应体</span><br><span class="line">            sendString.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;显示报文&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</span><br><span class="line">            sendString.append(&quot;接收到请求报文是: &lt;br/&gt;&quot;);</span><br><span class="line">            for(String s: requestMessage) &#123;</span><br><span class="line">                sendString.append(s + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sendString.append(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">            // 使用缓冲区写入channel</span><br><span class="line">            buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));</span><br><span class="line">            sc.write(buffer);</span><br><span class="line">            // 关闭资源</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 根据请求类型进行转发</span><br><span class="line">                if(key.isAcceptable()) &#123;</span><br><span class="line">                    handleAccept();</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable()) &#123;</span><br><span class="line">                    handleRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-nio-selector-实现简易聊天室"><a class="header-anchor" href="#使用-nio-selector-实现简易聊天室">¶</a>使用 NIO-Selector 实现简易聊天室</h3>
<h4 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h4>
<p>声明数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 管道、选择器、字符集</span><br><span class="line">private SocketChannel sc = null;</span><br><span class="line">private Selector selector = null;</span><br><span class="line">private Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<p>创建线程类用于从服务端获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class ClientThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 遍历所有选择键</span><br><span class="line">            while(selector.select() &gt; 0) &#123;</span><br><span class="line">                for(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">                    // 删除正在处理的</span><br><span class="line">                    selector.selectedKeys().remove(sk);</span><br><span class="line">                    // 如果该键对应的通道中有可读的数据</span><br><span class="line">                    if(sk.isReadable()) &#123;</span><br><span class="line">                        // 使用缓冲区读取管道内的数据</span><br><span class="line">                        SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">                        ByteBuffer buff = ByteBuffer.allocate(1024);</span><br><span class="line">                        String content = &quot;&quot;;</span><br><span class="line">                        while(sc.read(buff) &gt; 0) &#123;</span><br><span class="line">                            buff.flip();</span><br><span class="line">                            content += charset.decode(buff);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 打印</span><br><span class="line">                        System.out.println(&quot;聊天信息&quot; + content);</span><br><span class="line">                        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化SocketChannel</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">sc = SocketChannel.open(isa);</span><br><span class="line">sc.configureBlocking(false);</span><br><span class="line">// 注册选择器</span><br><span class="line">selector = Selector.open();</span><br><span class="line">sc.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>创建线程从服务端拉取数据，及不断从键盘读入发送到服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 启动线程不断从服务端拉取</span><br><span class="line">new ClientThread().start();</span><br><span class="line">// 读取键盘输入到通道</span><br><span class="line">Scanner reader = new Scanner(System.in);</span><br><span class="line">while(reader.hasNextLine()) &#123;</span><br><span class="line">    String line = reader.nextLine();</span><br><span class="line">    sc.write(charset.encode(line));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务端"><a class="header-anchor" href="#服务端">¶</a>服务端</h4>
<p>声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 选择器、字符集</span><br><span class="line">private Selector selector = null;</span><br><span class="line">private Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 打开管道</span><br><span class="line">ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">server.socket().bind(isa);</span><br><span class="line">server.configureBlocking(false);</span><br><span class="line">// 打开选择器</span><br><span class="line">selector = Selector.open();</span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>接受连接，读取及发送数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 依次处理选择器上的选择键</span><br><span class="line">while(selector.select() &gt; 0) &#123;</span><br><span class="line">    for(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">        selector.selectedKeys().remove(sk);</span><br><span class="line">        // 连接请求</span><br><span class="line">        if(sk.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel sc = server.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            sk.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;</span><br><span class="line">        // 存在可读取数据</span><br><span class="line">        if(sk.isReadable()) &#123;</span><br><span class="line">            // 使用缓冲区读取</span><br><span class="line">            SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">            ByteBuffer buff = ByteBuffer.allocate(1024);</span><br><span class="line">            String content = &quot;&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                while(sc.read(buff) &gt; 0) &#123;</span><br><span class="line">                    buff.flip();</span><br><span class="line">                    content += charset.decode(buff);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;=======&quot; + content);</span><br><span class="line">                // 将管道设置为准备下一次读取</span><br><span class="line">                sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125; catch(IOException e) &#123;</span><br><span class="line">                // 如果该sk对应的管道出现异常，表明管道的客户端出现异常，</span><br><span class="line">                // 所以从选择器中取消sk</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                sk.cancel();</span><br><span class="line">                if(sk.channel() != null) &#123;</span><br><span class="line">                    sk.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 说明聊天信息不为空</span><br><span class="line">            if(content.length() &gt; 0) &#123;</span><br><span class="line">                // 将聊天信息输入每个选择键对应的管道中</span><br><span class="line">                for(SelectionKey key : selector.keys()) &#123;</span><br><span class="line">                    Channel targetChannel = key.channel();</span><br><span class="line">                    if(targetChannel instanceof SocketChannel) &#123;</span><br><span class="line">                        SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                        dest.write(charset.encode(content));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h3>
<ol>
<li>为什么 Socket 可以通过流来“持续地”读写，而 DatagramSocket 却只能一个一个数据报发哩？<br>
这是由 TCP 和 UDP 的协议决定的，TCP 是面向流的协议，而 UDP 是面向数据报的协议。</li>
<li>可以用 TCP 客户端连接 UDP 服务器吗（或者反过来）？<br>
不能，实验过确实不行，但是我还是心存疑惑，我猜测是因为接收方可以判断数据包的协议类型来确定是否接收。</li>
<li>socket 是怎么实现&quot;全双工&quot;的？</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.programcreek.com/java-api-examples/index.php" target="_blank" rel="noopener">Java Code Examples</a></li>
<li><a href="https://blog.csdn.net/x5fnncxzq4/article/details/83110446" target="_blank" rel="noopener">Java 应用中的日志</a></li>
<li><a href="https://juejin.im/pin/5cc56f7b6fb9a02f00fc869e" target="_blank" rel="noopener">错误处理的推荐实践</a></li>
<li><a href="http://tech.it168.com/a2013/0829/1527/000001527360.shtml" target="_blank" rel="noopener">Java 开发中 10 个最为微妙的最佳编程实践</a></li>
<li>《Effective Java》</li>
<li><a href="https://edu.aliyun.com/course/417?spm=5176.10731542.0.0.akyXwK" target="_blank" rel="noopener">阿里巴巴编码规范（Java）</a></li>
<li><a href="https://blog.csdn.net/xx326664162/article/details/52175283" target="_blank" rel="noopener">Java 泛型中的 PECS 原则</a></li>
</ol>
<h3 id="jni"><a class="header-anchor" href="#jni">¶</a>JNI</h3>
<ol>
<li><a href="http://tldp.org/HOWTO/Program-Library-HOWTO/index.html" target="_blank" rel="noopener">Program Library HOWTO (how to create and use program libraries on Linux)</a></li>
<li><a href="https://devarea.com/java-and-cc-jni-guide/" target="_blank" rel="noopener">Java and C/C++: JNI Guide</a></li>
</ol>
<h3 id="java5-v2"><a class="header-anchor" href="#java5-v2">¶</a>Java5</h3>
<ol>
<li><a href="https://segmentfault.com/a/1190000004417288" target="_blank" rel="noopener">Java5 的新特性</a></li>
<li><a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html" target="_blank" rel="noopener">New Features and Enhancements J2SE 5.0</a></li>
<li><a href="https://www.cnblogs.com/xll1025/p/6489088.html" target="_blank" rel="noopener">java 泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></li>
</ol>
<h3 id="网络"><a class="header-anchor" href="#网络">¶</a>网络</h3>
<ol>
<li><a href="http://blog.csdn.net/wangpeng047/article/details/19624529" target="_blank" rel="noopener">HttpClient 使用详解</a></li>
<li><a href="http://blog.csdn.net/xietansheng/article/details/51673073" target="_blank" rel="noopener">基于 JavaMail 的 Java 邮件发送：简单邮件发送</a></li>
<li><a href="http://kf.qq.com/faq/120322fu63YV130422nqIrqu.html" target="_blank" rel="noopener">qq 邮箱服务器地址</a></li>
</ol>
<h3 id="工程"><a class="header-anchor" href="#工程">¶</a>工程</h3>
<ol>
<li><a href="https://www.jianshu.com/p/9c65b7613c30" target="_blank" rel="noopener">IntelliJ IDEA 使用教程(2019 图文版) – 从入门到上瘾</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/8ada3a78.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/8ada3a78.html" itemprop="url">JMM 应用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-02T17:22:14+08:00">
                2019-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>公司内接手的老项目近段时间遇到了内存瓶颈，新发版 GC 日志刷个不停，且集中在 YGC，显然有不自然的内存分配，看来内存优化是绕不过了。<br>
在 Java 技术栈内，对内存的分析优化主要集中在堆中，往往需要先使用一些内存分析工具导出堆的一份快照，然后查看是哪些对象在浪费空间，它们可能是非常大的、非常短命的。<br>
除了 JMM，对宿主机的内存管理原理也是有必要掌握的，这样能从底层的角度来进行解释 JMM 的原理，在针对 JMM 进行调参的时候也能更有把握（和运维撕的时候也更不容易被忽悠），鉴于现在的生产环境绝大多数都是 Linux，因此我也会对 Linux 的虚拟内存管理机制作一个简单分析。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/8ada3a78.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/cac7b0a4.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/cac7b0a4.html" itemprop="url">多级缓存原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T23:13:20+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>�</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/cac7b0a4.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/5ac9459.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/5ac9459.html" itemprop="url">多级缓存原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T23:13:20+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="本地缓存"><a class="header-anchor" href="#本地缓存">¶</a>本地缓存</h2>
<h3 id="由线上缓存-bug-引起的对本地缓存的思考"><a class="header-anchor" href="#由线上缓存-bug-引起的对本地缓存的思考">¶</a>由线上缓存 bug 引起的对本地缓存的思考</h3>
<p>LoadingCache 是 Guava 提供的一个本地缓存组件，但是我对它是又爱又恨，一方面因为 LoadingCache 比较完善，免去很多应用层缓存的细节问题（如何写出 GC 友好的缓存？），而另一方面如果对 LoadingCache 了解不够深入又容易出现奇奇怪怪的问题。下面就来描述一下之前碰到过的两个 LoadingCache 的坑，首先给出最简单的缓存配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, Object&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">        .expireAfterAccess(60 * 1000, MILLISECONDS) // 1</span><br><span class="line">        .maximumSize(500)</span><br><span class="line">        .build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object load(String id) throws Exception &#123;</span><br><span class="line">                return query(id); // 2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>在构建 LoadingCache 的时候可以配置缓存的过期策略，LoadingCache 其实有三种常用的过期策略：
<ul>
<li>expireAfterAccess：在最后一次访问后空闲一段时间才过期；</li>
<li>expireAfterWrite：在最后一次写后空闲一段时间才过期；</li>
<li>refreshAfterWrite：同样是写后空闲一段时间过期，和上一个的区别是不会阻塞过期时到达的请求，因为刷新一般需要请求远程服务来获取数据，会有比较长的延迟，refreshAfterWrite 会先返回旧数据，而 expireAfterWrite 会先阻塞这些请求。<br>
如果是为了吞吐量起见，一般使用 refreshAfterWrite 更多，如果是为了保证同步性，则是使用 expireAfterWrite 更多。<br>
因为我们使用缓存的场景是“读多写少的场景”，读端是提供给用户的，而写端由甲方客户控制，当它们更新了某个 id 的数据后，希望能够马上展示到用户眼前，换句话说，缓存应当能够被马上刷新，但是前面的配置中使用的是 expireAfterAccess，因为用户的访问非常频繁，所以缓存一直不能过期，上线的数据不能及时地生效，导致甲方爸爸非常生气。</li>
</ul>
</li>
<li>缓存更新的时候一般会从远程服务或数据库查询数据，这里没有考虑返回值为空的情况，为了保险起见，一般都是需要进行空值校验的，而且如果这里返回了空值，LoadingCache 会直接抛出异常。</li>
</ol>
<p>所以更合理的配置方式应该是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, Object&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">        .refreshAfterWrite(60 * 1000, MILLISECONDS) // 1</span><br><span class="line">        .maximumSize(500)</span><br><span class="line">        .build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object load(String id) throws Exception &#123;</span><br><span class="line">                Object res = query(id); // 2</span><br><span class="line">                return res == null ? DEFAULT_OBJ : res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>所以，当我们在使用缓存时，一般是事先考虑：</p>
<ul>
<li>dataSource：当没有命中时，从哪里获取数据？一般请求下会调用其他服务的远程接口，也可以直接从数据库、缓存中间件查询，但是要注意数据隔离性，比如权限服务就不适合直接到缓存或数据库中查询订单数据，因为这样不利于后期扩容，而且入口越多越不安全；</li>
<li>expire：定义淘汰策略，比如有一段时间没有访问就淘汰，比如容量限制，当超出容量的时候如何淘汰一般有 LRU（Least Recently Used）、LFU（Least Frequently Used），可以使用 weigher 设置每个 key 的权重；</li>
</ul>
<p>如果是一些要求不高的内部信息管理系统，这些属性不需要太关注，但是如果是对并发量有一定要求的系统，对自己所使用的工具知根知底是最低的要求。</p>
<h3 id="本地缓存是什么"><a class="header-anchor" href="#本地缓存是什么">¶</a>本地缓存是什么</h3>
<p>本地缓存的英文是 Local Cache，Cache、Buffer、Pool 是经常出现但又容易混淆的一组概念，它们都能存取数据，但是有本质上的区别：</p>
<ul>
<li>Cache 的主要功能是“将东西放到更容易拿到的地方”、从而加快速度，具有随机存取的功能，一般为了不导致内存溢出会设置数据的过期回收策略，比如计算机体系结构中的 L1、L2、L3 缓存；</li>
<li>Buffer 是为了缓冲、减少对脆弱系统的冲击，具有顺序访问的特点，比如每个 TCP Socket 都有的接收发送缓存区；</li>
<li>Pool 是为了缓存资源，它和 Cache 的主要区别是 Pool 中缓存的对象往往是同构而没有特殊价值的数据，比如连接池中存储的数据库连接，所以 Pool 不需要随机存取功能、随取随用即可。</li>
</ul>
<h3 id="本地缓存的优点"><a class="header-anchor" href="#本地缓存的优点">¶</a>本地缓存的优点</h3>
<ul>
<li>节省了了内⽹带宽。</li>
<li>响应时延会更低。</li>
</ul>
<h3 id="本地缓存的缺点"><a class="header-anchor" href="#本地缓存的缺点">¶</a>本地缓存的缺点</h3>
<p>⽆法保证⼀致性，解决办法是：</p>
<ol>
<li>单节点通知其他节点，但是会导致同⼀服务的多个节点相互耦合；</li>
<li>利用 mq 通知其他节点，但系统会变得更复杂；</li>
<li>使用 timer 定时从后端拉取更新内存缓存，但在更新数据后、访问其他节点会得到脏数据，直到其他节点 timer 拉取数据。</li>
</ol>
<h3 id="什么时候需要本地缓存"><a class="header-anchor" href="#什么时候需要本地缓存">¶</a>什么时候需要本地缓存</h3>
<p>分层架构设计，有⼀条准则：站点层、服务层要做到<strong>⽆数据</strong>、<strong>⽆状态</strong>，这样才能任意的加节点⽔平扩展，数据和状态尽量存储到后端的数据存储服务，例如数据库服务或者缓存服务。<br>
可以看到，站点与服务的进程内缓存，实际上违背了分层架构设计的⽆状态准则，故<strong>一般情况下并不推荐使用</strong>。<br>
在分布式缓存存在的情况下，一般本地缓存都是不必要的，一方面本地缓存会占用大量的堆空间，容易引起频繁的 GC；另一方面，因为是在局域网内，所以访问分布式缓存的网络开销不会太大。</p>
<p>那么，什么时候可以使⽤进程内缓存？以下情况，可以考虑使用进程内缓存，并且应该注意对过期策略、并发安全等的定义。</p>
<ol>
<li>只读数据，可以考虑在进程启动时加载到内存。</li>
</ol>
<blockquote>
<p>当然此时也可以把数据加载到 redis / memcache 等缓存中间件，进程外缓存同样能解决这个问题。</p>
</blockquote>
<ol>
<li>性能敏感、极其⾼并发的、如果透传对后端压力极大的场景，可以考虑使用进程内缓存。例如，首页列表、秒杀业务，并发量极高，需要站点层挡住流量，可以使⽤内存缓存。</li>
<li>一定程度上允许数据不一致的业务。<br>
例如，有一些计数场景，运营场景，⻚面对数据⼀致性要求较低，可以考虑使⽤进程内⻚面缓存。</li>
</ol>
<h3 id="避免过早优化"><a class="header-anchor" href="#避免过早优化">¶</a>避免过早优化</h3>
<p>后端开发基本都是完美主义者（粗心导致留下 Bug 可是会被产品、测试鄙视的），但是完美主义也有一个缺点——容易过早优化。<br>
比如，项目早期使用者不多、订单只有 10W～100W 的量级，但是开发刚上来在对行业知识、产品使用场景都没有深刻理解的情况下，直接决定对 id 散列来进行分表，这个对我们来说当然是无可厚非的，但是随着业务扩大、订单量增加到 100W～1000W，发现线上数据库中近期的订单被使用得更多（即热数据）、而老订单一般不被问津，所以原来那种新老混杂的分表就不合适了，但是现在再重构成按时间分表的方式就费事了。因此，更好的方式是刚开始仅用单表存就足够了，之后时刻关注线上使用的反馈，即时地进行优化。</p>
<h3 id="java-引用"><a class="header-anchor" href="#java-引用">¶</a>Java 引用</h3>
<p>Java 中除了基本类型外所有对象都是通过引用来使用的，引用分为强引用、软引用、弱引用和虚引用。<br>
对于一般的缓存场景来说，软引用是更好的选择，因为软引用可以避免内存用完而 GC 又回收不了内存进而导致的服务宕机，又不会像弱引用那样每次 GC 都会被回收掉、连带导致缓存被击穿。</p>
<h3 id="应用-失败次数统计"><a class="header-anchor" href="#应用-失败次数统计">¶</a>应用 - 失败次数统计</h3>
<p>一般调用 RPC 接口都会有重试逻辑，最简单的重试可以用一个局部变量记录失败次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int failedCount = 0;</span><br><span class="line">while(failedCount &lt; 3) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        rpcService.hello();</span><br><span class="line">        break;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.warn(&quot;调用失败 &quot; + failedCount + &quot; 次&quot;, e);</span><br><span class="line">        failedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是需要实时响应的功能，可以用一个队列缓存请求，然后用一个线程轮询，因为失败后需要重新丢进队列中等待，这时就不能单纯使用局部变量来保存失败次数了，可以使用一个 Cache&lt;string, AtomicInteger&gt;<strong>软引用</strong>缓存失败调用记录，成功后再使其失效。这种方式能控制失败重试次数，而且当内存不足时，缓存数据可以被 GC 回收以腾出一些空间。<br>
以 Guava 中的 LoadingCache 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private LoadingCache&lt;String, AtomicInteger&gt; failedCache = </span><br><span class="line">    CacheBuilder.newBuilder()</span><br><span class="line">        .softValues()</span><br><span class="line">        .maximumSize(10000)</span><br><span class="line">        .build(new CacheLoader&lt;String, AtomicInteger&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public AtomicInteger load(String id) throws Exception &#123;</span><br><span class="line">                return new AtomicInteger(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>当失败时，调用 failedCache.getUnchecked(id).incrementAndGet()增加失败次数。</li>
<li>当成功时，调用 failedCache.invalidate(id)使缓存失效。</li>
</ul>
<h3 id="gc-友好的缓存"><a class="header-anchor" href="#gc-友好的缓存">¶</a>GC 友好的缓存</h3>
<p>diff（在不等的情况下才 put 或直接修改已有对象，提高内存利用率，不然每次刷新缓存都要放到年轻代。不能用分离链接法实现，因为老的会引用年轻的(每次 put 到头部不就可以了？)，导致年轻代不能转移到老年代）</p>
<p>如何避免 OOM（弱引用）</p>
<p>缓存淘汰机制<br>
过期策略</p>
<h3 id="如何实现一个本地缓存-concurrenthashmap"><a class="header-anchor" href="#如何实现一个本地缓存-concurrenthashmap">¶</a>如何实现一个本地缓存 - ConcurrentHashMap</h3>
<ol>
<li>线程安全的 Map</li>
<li>回收机制<br>
如 LRU</li>
<li>软引用</li>
</ol>
<h2 id="分布式缓存"><a class="header-anchor" href="#分布式缓存">¶</a>分布式缓存</h2>
<h3 id="本地缓存和分布式缓存"><a class="header-anchor" href="#本地缓存和分布式缓存">¶</a>本地缓存和分布式缓存</h3>
<p>缓存一般分为本地缓存和分布式缓存两种。本地缓存指的是将数据存储在本机内存中，操作缓存数据的速度很快，但是缺点也很明显：第一，缓存数据的数量与大小受限于本地内存；第二，如果有多台应用服务器，可能所有应用服务器都要维护一份缓存，这样就占用了很多的内存。<br>
分布式缓存正好解决了这两个问题。首先，数据存储在了另外的机器上，理论上由于可以不断添加缓存机器，所以缓存的数据的数量是无限的；其次，缓存集中设置在远程的缓存服务器上，应用服务器不需要耗费空间来维护缓存。但是，分布式缓存也是有缺点的，比如由于是远程操作，所以操作缓存数据的速度相较于本地缓存慢很多。<br>
当前用得最多的本地缓存是 GoogleGuavache，用得最多的分布式缓存是 Memcached 和 Redis</p>
<h3 id="编码和压缩"><a class="header-anchor" href="#编码和压缩">¶</a>编码和压缩</h3>
<p>Redis 属于数据库家族中最简单的一类分支 - KV 数据库，它基本不能维护任何复杂的数据结构，也不能对值构建索引以供查询。为了提高操作效率，自然而然会想到对值进行压缩，额外的编码其实是为了调试时方便，能直接查看保存的数据的内容。除了这些之外，还和 Redis 本身对各对象类型的编码规则有关：</p>
<p>但是对数据进行压缩并不是银弹，对特别大的数据执行压缩需要占用不菲的 CPU 时间，所以需要作一个权衡。<br>
特别小、特别大的数据直接发，中间数据压缩再保存可以触发数据库使用更有效的结构来保存。</p>
<p>压缩算法：</p>
<ol>
<li>ZIP</li>
<li>GZIP（最常用）</li>
<li>LZF</li>
<li>zstd（Arch Linux）</li>
<li>…</li>
</ol>
<p>TODO:</p>
<h3 id="使用-watcher-实现-cas"><a class="header-anchor" href="#使用-watcher-实现-cas">¶</a>使用 Watcher 实现 CAS</h3>
<p>TODO:</p>
<h3 id="基于缓存的事务"><a class="header-anchor" href="#基于缓存的事务">¶</a>基于缓存的事务</h3>
<p>TODO:</p>
<h3 id="缓存穿透"><a class="header-anchor" href="#缓存穿透">¶</a>缓存穿透</h3>
<p>概念及场景：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。<br>
解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的<strong>bitmap</strong>中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>
总而言之，当通过一个 key 去数据库查询出来的数据结果为 null,缓存系统就不会缓存该数据,每次该 key 查询都会经过数据库层,造成没有必要的 DB 开销。这种情况下，我们可以将该 key 缓存至缓存系统中,value 为一个特殊值(^^,&amp;&amp;…)。</p>
<h3 id="缓存雪崩"><a class="header-anchor" href="#缓存雪崩">¶</a>缓存雪崩</h3>
<h4 id="概念及场景"><a class="header-anchor" href="#概念及场景">¶</a>概念及场景</h4>
<p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。<br>
key 缓存过期失效而新缓存未到期间,该 key 的查询所有请求都会去查询数据，造成 DB 压力上升，产生不必要的 DB 开销</p>
<h4 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h4>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就是将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>
解决方案总结：</p>
<ol>
<li>加锁排队重建,使请求可以串行化,而不用全部的请求都去查询数据库</li>
<li>假设 key 的过期时间是 A,创建一个 key_sign,它的过期时间比 A 小,查询 key 的时候检查 key_sign 是否已经过期,如果过期则加锁后台起一个线程异步去更新 key 的值,而实际的缓存没有过期(如果实际缓存已经过期,需要加锁排队重建),但是会浪费双份缓存</li>
<li>在原有的 value 中存一个过期值 B,B 比 A 小,取值的时候根据 B 判断 value 是否过期,如果过期,解决方案同上</li>
<li>牺牲用户体验,当发现缓存中没有对应的数据直接返回失败,并且把需要的数据放入一个分布式队列,后台通过异步线程更新队列中需要更新的缓存</li>
</ol>
<h3 id="缓存污染"><a class="header-anchor" href="#缓存污染">¶</a>缓存污染</h3>
<h4 id="概念和场景"><a class="header-anchor" href="#概念和场景">¶</a>概念和场景</h4>
<p>一些非正常操作（比如导出 excel 文件、运营偶发性访问）而导致内存中出现很多冷数据</p>
<h4 id="解决方案-v2"><a class="header-anchor" href="#解决方案-v2">¶</a>解决方案</h4>
<p>选取合适的缓存算法(LUR-N 算法)。</p>
<h3 id="缓存首次上线"><a class="header-anchor" href="#缓存首次上线">¶</a>缓存首次上线</h3>
<h4 id="概念及场景-v2"><a class="header-anchor" href="#概念及场景-v2">¶</a>概念及场景</h4>
<p>缓存首次上线,如果网站的访问量很大,所有的请求都经过数据库(如果访问量比较少,可以由用户访问自行缓存)</p>
<h4 id="解决方案-v3"><a class="header-anchor" href="#解决方案-v3">¶</a>解决方案</h4>
<p>缓存预热,在系统上线之前,所有的缓存都预先加载完毕(增加一个刷新缓存程序,上线后手动刷新或发布时自动调用刷用)</p>
<h3 id="缓存击穿"><a class="header-anchor" href="#缓存击穿">¶</a>缓存击穿</h3>
<p>概念及场景：对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一 key 缓存，前者则是很多 key。缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>
<h4 id="解决方案-v4"><a class="header-anchor" href="#解决方案-v4">¶</a>解决方案</h4>
<p>1.使用互斥锁(mutex key)<br>
业界比较常用的做法，是使用 mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。<br>
SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在 redis2.6.1 之前版本未实现 setnx 的过期时间，所以这里给出两种版本代码参考：<br>
<a href="//2.6.1">//2.6.1</a> 前单机版本锁<br>
String get(String key) {<br>
String value = redis.get(key);<br>
if (value == null) {<br>
if (redis.setnx(key_mutex, “1”)) {<br>
// 3 min timeout to avoid mutex holder crash<br>
redis.expire(key_mutex, 3 * 60)<br>
value = db.get(key);<br>
redis.set(key, value);<br>
redis.delete(key_mutex);<br>
} else {<br>
//其他线程休息 50 毫秒后重试<br>
Thread.sleep(50);<br>
get(key);<br>
}<br>
}<br>
}<br>
最新版本代码：<br>
public String get(key) {<br>
String value = redis.get(key);<br>
if (value == null) { //代表缓存值过期<br>
//设置 3min 的超时，防止 del 操作失败的时候，下次缓存过期一直不能 load db<br>
if (redis.setnx(key_mutex, 1, 3 * 60) == 1) { //代表设置成功<br>
value = db.get(key);<br>
redis.set(key, value, expire_secs);<br>
redis.del(key_mutex);<br>
} else { //这个时候代表同时候的其他线程已经 load db 并回设到缓存了，这时候重试获取缓存值即可<br>
sleep(50);<br>
get(key); //重试<br>
}<br>
} else {<br>
return value;<br>
}<br>
}<br>
memcache 代码：<br>
if (memcache.get(key) == null) {<br>
// 3 min timeout to avoid mutex holder crash<br>
if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {<br>
value = db.get(key);<br>
memcache.set(key, value);<br>
memcache.delete(key_mutex);<br>
} else {<br>
sleep(50);<br>
retry();<br>
}<br>
}</p>
<p>2.&quot;提前&quot;使用互斥锁(mutex key)：<br>
在 value 内部设置 1 个超时值(timeout1), timeout1 比实际的 memcache timeout(timeout2)小。当从 cache 读取到 timeout1 发现它已经过期时候，马上延长 timeout1 并重新设置到 cache。然后再从数据库加载数据并设置到 cache 中。伪代码如下：<br>
v = memcache.get(key);<br>
if (v == null) {<br>
if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {<br>
value = db.get(key);<br>
memcache.set(key, value);<br>
memcache.delete(key_mutex);<br>
} else {<br>
sleep(50);<br>
retry();<br>
}<br>
} else {<br>
if (v.timeout &lt;= now()) {<br>
if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {<br>
// extend the timeout for other threads<br>
v.timeout += 3 * 60 * 1000;<br>
memcache.set(key, v, KEY_TIMEOUT * 2);</p>
<pre><code>        // load the latest value from dbplainplainplainplainplainplainplainplainplainplainplainplainplainplainplainplainplain
        v = db.get(key);    
        v.timeout = KEY_TIMEOUT;    
        memcache.set(key, value, KEY_TIMEOUT * 2);    
        memcache.delete(key_mutex);    
    } else {    
        sleep(50);    
        retry();    
    }    
}    
</code></pre>
<p>}</p>
<p>3.“永远不过期”：<br>
这里的“永远不过期”包含两层意思：<br>
(1) 从 redis 上看，确实没有设置过期时间，这就保证了，不会出现热点 key 过期问题，也就是“物理”不过期。<br>
(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期<br>
从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。<br>
String get(final String key) {<br>
V v = redis.get(key);<br>
String value = v.getValue();<br>
long timeout = v.getTimeout();<br>
if (v.timeout &lt;= System.currentTimeMillis()) {<br>
// 异步更新后台异常执行<br>
threadPool.execute(new Runnable() {<br>
public void run() {<br>
String keyMutex = “mutex:” + key;<br>
if (redis.setnx(keyMutex, “1”)) {<br>
// 3 min timeout to avoid mutex holder crash<br>
redis.expire(keyMutex, 3 * 60);<br>
String dbValue = db.get(key);<br>
redis.set(key, dbValue);<br>
redis.delete(keyMutex);<br>
}<br>
}<br>
});<br>
}<br>
return value;<br>
}</p>
<ol start="4">
<li>资源保护：<br>
采用 netflix 的 hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单分布式互斥锁（mutex key）</td>
<td>1. 思路简单；2. 保证一致性</td>
<td>1. 代码复杂度增大；2. 存在死锁的风险；3. 存在线程池阻塞的风险</td>
</tr>
<tr>
<td>“提前”使用互斥锁</td>
<td>1. 保证一致性</td>
<td>同上</td>
</tr>
<tr>
<td>不过期(本文)</td>
<td>1. 异步构建缓存，不会阻塞线程池</td>
<td>1. 不保证一致性；2. 代码复杂度增大(每个 value 都要维护一个 timekey)；3. 占用一定的内存空间(每个 value 都要维护一个 timekey)。</td>
</tr>
<tr>
<td>资源隔离组件 hystrix(本文)</td>
<td>1. hystrix 技术成熟，有效保证后端；2. hystrix 监控强大。</td>
<td>1. 部分访问存在降级策略。</td>
</tr>
</tbody>
</table>
<h3 id="缓存失效"><a class="header-anchor" href="#缓存失效">¶</a>缓存失效</h3>
<p>一个经典问题：由于初始化的时候某些缓存过期时间设置的都一样,一段时间以后缓存全部失效,在这一瞬间的会增大 DB 的压力<br>
解决：在过期时间上加一个随机值;分析用户行为,尽量让失效时间均匀分布</p>
<p>下面是其他的一些策略：</p>
<h4 id="先失效缓存-后更新数据库数据"><a class="header-anchor" href="#先失效缓存-后更新数据库数据">¶</a>先失效缓存 -&gt; 后更新数据库数据</h4>
<ol>
<li>缺点<br>
如果缓存失效失败,根据策略可能会影响后续的正常的数据更新操作<br>
直接失效缓存会增加后续的一次缓存查询的 Miss</li>
<li>优点<br>
避免数据库更新成功,缓存失效失败,导致缓存中是旧数据</li>
<li>场景<br>
对缓存准确率要求比较高的业务</li>
<li>异常情况<br>
线程 A 需要更新数据库数据，失效缓存；<br>
线程 B 发现缓存没有命中，查询数据库中取出旧的值；<br>
线程 A 更新数据库数据，提交事务，线程 A 将数据放入缓存。</li>
</ol>
<h4 id="延时双删"><a class="header-anchor" href="#延时双删">¶</a>延时双删</h4>
<p>在《先失效缓存 -&gt; 后更新数据库数据》这种方案的基础上，增加了一个延时过期的步骤。<br>
即：过期Redis -&gt; 更新数据库 -&gt; 延迟一会再过期一次Redis<br>
这样就可以缓解上边提到的脏读问题了。<br>
但是缺点是过期两次，会占用更多的数据库资源。</p>
<h4 id="先更新数据库数据-后失效缓存"><a class="header-anchor" href="#先更新数据库数据-后失效缓存">¶</a>先更新数据库数据 -&gt; 后失效缓存</h4>
<ol>
<li>缺点<br>
如果数据更新成功,但是缓存失效失败,缓存中存放的是旧数据<br>
直接失效缓存会增加一次缓存查询的 Miss</li>
<li>优点<br>
更新数据不会强依赖缓存,就算失效缓存失败,也不会影响数据库的更新</li>
<li>场景<br>
对缓存和数据库的一致性要求不是很高的场景</li>
<li>异常情况<br>
在更新数据库数据和失效缓存之前的所有查询,查询到的都是旧数据</li>
</ol>
<h4 id="更新数据库数据-更新缓存"><a class="header-anchor" href="#更新数据库数据-更新缓存">¶</a>更新数据库数据 -&gt; 更新缓存</h4>
<ol>
<li>优点<br>
避免了一次额外的缓存查询 Miss<br>
实时性比较高</li>
<li>缺点<br>
数据库更新成功，但是更新缓存失败，缓存中存储的是旧数据<br>
选择同步还是异步来更新缓存呢？如果是同步更新，更新磁盘成功了，但是更新缓存失败了，你是不是要反复重试来保证更新成功？如果多次重试都失败，那这次更新是算成功还是失败呢？如果是异步更新缓存，怎么保证更新的时序？<br>
比如，我先把一个文件中的某个数据设置成 0，然后又设为 1，这个时候文件中的数据肯定是 1，但是缓存中的数据可不一定就是 1 了。因为把缓存中的数据更新为 0，和更新为 1 是两个并发的异步操作，不一定谁会先执行。<br>
这些问题都会导致缓存的数据和磁盘中的数据不一致，而且，在下次更新这条数据之前，这个不一致的问题它是一直存在的。当然，这些问题也不是不能解决的，比如，你可以使用分布式事务来解决，只是付出的性能、实现复杂度等代价比较大。</li>
<li>场景<br>
缓存粒度比较小,缓存的数据不需要经过计算(更新商品数据,但是缓存还需要用户数据)</li>
<li>异常情况<br>
A 线程查询缓存发现缓存中没有数据,查询数据库；<br>
B 线程更新数据库并且更新了缓存；<br>
A 再把查询的数据放入缓存,缓存中将会是旧数据</li>
</ol>
<h4 id="更新缓存-更新数据库数据"><a class="header-anchor" href="#更新缓存-更新数据库数据">¶</a>更新缓存 -&gt; 更新数据库数据</h4>
<ol>
<li>优点<br>
避免了一次额外的缓存查询 Miss</li>
<li>缺点<br>
缓存更新成功,但是数据库更新失败,导致缓存数据是旧数据;<br>
并且更新缓存失败,根据策略可能导致更新数据库失败。</li>
<li>场景<br>
缓存粒度比较小,缓存的数据不需要经过计算(更新商品数据,但是缓存还需要用户数据)</li>
<li>异常情况<br>
在更新缓存成功和更新数据库数据之前拿到的缓存是和数据库不一致的(不过这种情况造成的负面影响很小)</li>
</ol>
<h4 id="更新数据库数据-定时同步到缓存"><a class="header-anchor" href="#更新数据库数据-定时同步到缓存">¶</a>更新数据库数据 -&gt; 定时同步到缓存</h4>
<ol>
<li>优点<br>
实现简单、鲁棒性高<br>
就算某次同步过程中发生了错误，等到下一个同步周期也会自动把数据纠正过来。</li>
<li>缺点<br>
缓存更新不实时。<br>
如果缓存的数据太大，更新速度慢到无法接受，可以选择增量更新，每次只更新从上次缓存同步至今这段时间内变化的数据，代价是实现起来会稍微有些复杂。</li>
</ol>
<h3 id="设计总结"><a class="header-anchor" href="#设计总结">¶</a>设计总结</h3>
<p>针对业务系统，永远都是具体情况具体分析，没有最好，只有最合适。<br>
最后，对于缓存系统常见的缓存满了和数据丢失问题，需要根据具体业务分析，通常我们采用 LRU 策略处理溢出，Redis 的 RDB 和 AOF 持久化策略来保证一定情况下的数据安全。</p>
<ol>
<li>缓存失效策略<br>
添加 key 的时候要设置一个过期时间,采用惰性删除和定时删除相结合的策略删除过期键</li>
<li>多级缓存<br>
线程级-&gt;内存级-&gt;进程级-&gt;文件(静态资源)-&gt;分布式(redis)-&gt;Db 结果.</li>
<li>二级缓存<br>
二级缓存更多的解决是,缓存穿透与程序的健壮性,当集中式缓存出现问题的时候,我们的应用能够继续运行;一些热点数据做成内存缓存,这些数据是在上线之前是已知的(比如说秒杀,大促商品),通过配置定时任务定时刷新内存缓存,完成和分布式缓存的数据置换;更加自动化的方案,可以根据上游自动发现热点数据,广播消息替换现在集群中内存缓存的数据(但在整个集群中广播,成本比较高,并且二级缓存的管理的成本也很大);</li>
</ol>
<h2 id="实现一个简单的多级缓存"><a class="header-anchor" href="#实现一个简单的多级缓存">¶</a>实现一个简单的多级缓存</h2>
<p><img src="http://47.88.24.11/imgs/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/%E5%A4%9A%E7%BA%A7%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90.png" alt="多级数据来源" title="多级数据来源示意图"></p>
<ul>
<li>本地缓存<br>
在并发量不大的系统内，本地缓存的意义不大，反而增加维护的困难。但在高并发系统中，本地缓存可以大大节约带宽。但是要注意本地缓存不是银弹，它会引起多个副本间数据的不一致，还会占据大量的内存，所以不适合保存特别大的数据，而且需要严格考虑刷新机制。</li>
<li>缓存 / 搜索服务器<br>
TODO:</li>
<li>数据库服务器<br>
TODO：</li>
<li>同机房的其他业务服务器<br>
TODO：</li>
<li>不同机房的其他业务服务器<br>
TODO：</li>
</ul>
<p><img src="http://47.88.24.11/imgs/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/cache-drawer-core.png" alt="多级缓存组件的主要执行流程" title="cache-drawer-core 的主要执行流程"><br>
详细描述 TODO：</p>
<h3 id="缓存时机"><a class="header-anchor" href="#缓存时机">¶</a>缓存时机</h3>
<ul>
<li>5 分钟法则<br>
5 分钟法则即：如果一个数据的访问周期在 5 分钟以内则存放在内存中，否则应该存放在硬盘中。<br>
引申到缓存中，可以表述为：如果一个数据访问吞吐率大于 1 次 / 5 分钟，就可以考虑放到缓存中。</li>
<li>局部性原理<br>
局部性原理原指 CPU 访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。<br>
反过来说，如果访问存在热点，就完全可以把这些热点数据放到缓存里。</li>
</ul>
<h3 id="算法-fifo"><a class="header-anchor" href="#算法-fifo">¶</a>算法 - FIFO</h3>
<h3 id="算法-lru"><a class="header-anchor" href="#算法-lru">¶</a>算法 - LRU</h3>
<h3 id="算法-lfu"><a class="header-anchor" href="#算法-lfu">¶</a>算法 - LFU</h3>
<h3 id="回收策略"><a class="header-anchor" href="#回收策略">¶</a>回收策略</h3>
<ul>
<li>空间</li>
<li>容量<br>
条⽬数</li>
<li>时间<br>
存活期活太久淘汰<br>
空闲期太久没访问淘汰</li>
</ul>
<h3 id="缓存监控"><a class="header-anchor" href="#缓存监控">¶</a>缓存监控</h3>
<p>命中率 = 缓存读取次数 / (缓存读取次数 + 慢速设备读取次数)</p>
<h3 id="过期时间"><a class="header-anchor" href="#过期时间">¶</a>过期时间</h3>
<p>本地缓存过期时间比分布式缓存小至少一半，以防止本地缓存太久造成多实例数据不一致。</p>
<ul>
<li>不过期缓存<br>
场景：长尾访问的数据、访问频率⾼、缓存空间⾜够<br>
使⽤Cache-Aside 模式<br>
不要放事务⾥，因为⽹络抖动可能导致写缓存响应时间慢，阻塞数据库事务。但是同样存在事务成功但缓存失败⽆法回滚的情况。解决办法是使用 canal 实现缓存同步。<br>
若对⼀致性要求不高且数据量不⼤可改成定期全量同步</li>
<li>过期缓存<br>
场景：热点数据、来⾃自其他系统的数据、空间有限、访问频率低</li>
</ul>
<h3 id="sor-source-of-resource"><a class="header-anchor" href="#sor-source-of-resource">¶</a>SoR（Source-of-Resource）</h3>
<p>数据的来源，一般称为记录系统或<strong>数据源</strong>。<br>
<strong>回源</strong>即回到源头获取数据，Cache 没有命中时，需要从 SoR 获取数据，即回源。</p>
<h3 id="大-value"><a class="header-anchor" href="#大-value">¶</a>大 Value</h3>
<p>如果有⼤Value 最好切换到多线程实现的缓存如 MC，或者拆成多个小 Value 由客户端聚合。</p>
<h3 id="热点缓存"><a class="header-anchor" href="#热点缓存">¶</a>热点缓存</h3>
<p>频繁访问的热点数据，如果每次都要从缓存服务器获取，可能导致缓存服务器负载过高、或者带宽过⾼。<br>
解决办法是加缓存服务器，或者加本地缓存。</p>
<h3 id="缓存更新"><a class="header-anchor" href="#缓存更新">¶</a>缓存更新</h3>
<p>原⼦更新：</p>
<ul>
<li>版本号</li>
<li>如果是 redis，因为单线程机制本身就是⽀持原⼦更新的</li>
<li>使用 canal 订阅数据库 binlog 将更新请求按规则路由到多个队列，每个队列进⾏单线程的更新</li>
<li>加分布式锁</li>
</ul>
<h3 id="异步写"><a class="header-anchor" href="#异步写">¶</a>异步写</h3>
<p>写本地缓存后异步更新分布式缓存，尽快返回用户请求，最好不要同步写分布式缓存。</p>
<h3 id="维度化与增量缓存"><a class="header-anchor" href="#维度化与增量缓存">¶</a>维度化与增量缓存</h3>
<p>场景：一个商品包含多个属性，其中部分属性如上下架这种可能频繁更新的，最好做维度化并增量更新。</p>
<h3 id="缓存策略-分区读"><a class="header-anchor" href="#缓存策略-分区读">¶</a>缓存策略 - 分区读</h3>
<p>读缓存时划分分区异步批量读：</p>
<ul>
<li>分区可以防⽌出现慢查询；</li>
<li>异步可以把各批 key 并⾏化。</li>
</ul>
<h3 id="缓存策略-nullobj-防缓存击穿"><a class="header-anchor" href="#缓存策略-nullobj-防缓存击穿">¶</a>缓存策略 - nullobj 防缓存击穿</h3>
<p>当 db 中本身就没有该数据时，会产生每次请求都击穿的现象，解决办法是引入一个 <strong>nullobj</strong>。<br>
db 不不存在时写一个 <strong>nullobj</strong> 到缓存，下次读到 null 对象 就不去 db 读了。</p>
<h3 id="缓存策略-cache-aside-模式"><a class="header-anchor" href="#缓存策略-cache-aside-模式">¶</a>缓存策略 - Cache-aside 模式</h3>
<p>Cache-Aside 即业务代码围绕着 Cache 写，是由业务代码直接维护缓存。</p>
<h4 id="什么时候使用"><a class="header-anchor" href="#什么时候使用">¶</a>什么时候使用</h4>
<ul>
<li>当 Cache不提供原⽣的 Read-Through 和 Write-Through 操作的时候</li>
<li>资源的需求是不可预测的时候。Cache-Aside 模式令应用可以根据需求来加载数据，对于应⽤需求什么数据，不需要提前做出假设。</li>
</ul>
<h3 id="read-模式"><a class="header-anchor" href="#read-模式">¶</a>Read 模式</h3>
<p>先从缓存获取数据，如果没有命中，则回源到 SoR 并将源数据放入缓存供下次读取使用。</p>
<h3 id="write-模式"><a class="header-anchor" href="#write-模式">¶</a>Write 模式</h3>
<p>类似 Write-Through 策略。</p>
<ol>
<li>先将数据写入 SoR，写入成功后立即将数据同步写入缓存；</li>
<li>或先将数据写入 SoR，写入成功后将缓存数据过期，下次读取时再加载缓存。</li>
</ol>
<h4 id="读优化-一致性哈希"><a class="header-anchor" href="#读优化-一致性哈希">¶</a>读优化 - 一致性哈希</h4>
<p>读可以⽤⼀致性哈希减少并发。</p>
<h4 id="写优化-使用-canal-订阅更新"><a class="header-anchor" href="#写优化-使用-canal-订阅更新">¶</a>写优化 - 使用 Canal 订阅更新</h4>
<p>更新可以⽤Canal 订阅 binlog。</p>
<h4 id="缓存数据的-存时间"><a class="header-anchor" href="#缓存数据的-存时间">¶</a>缓存数据的⽣存时间</h4>
<p>很多 Cache 实现了过期的策略的，这些过期的策略可以实现数据的更新，将旧数据失效化，同时也令⼀定时间没有访问的数据失效。<br>
为了让 Cache-Aside 模式能够⽣效，开发者必须确保过期策略能够正确匹配应用所访问的数据。同时，注意不能让过期时间太短，因为太短的过期时间会令应⽤频繁地从数据仓库中获取数据来添加到 Cache 之中。当然，也不要配置超时的时间太⻓，过⻓的超时时间会让缓存的数据冗余。Cache 的性能是跟其相关的数据的读取周期等信息⾼度相关的。</p>
<h4 id="去除数据"><a class="header-anchor" href="#去除数据">¶</a>去除数据</h4>
<p>绝⼤多数的缓存跟数据仓库⽐起来，容量是很有限的，所以，如果可以的话，Cache 会移除数据。<br>
多数的 Cache 会采用 LRU 的策略来移除缓存中的数据，当然，移除的策略也是可以⾃定义的。配置全局的过期属性和缓存的其他属性，可以确保 Cache 消耗的内存资源是高效的。当然，通常不会只配置⼀个全局的过期策略。比如，某些特别昂贵、访问特别频繁而又不常更新的数据，完全可以延长其过期时间。</p>
<h4 id="一致性"><a class="header-anchor" href="#一致性">¶</a>一致性</h4>
<p>实现 Cache-Aside 模式并不能保证 Cache 和数据仓库之间的数据⼀致性。因为数据仓库中的数据可能在任何时候被其他程序所修改，⽽这个修改不会及时的反映到 Cache 上，直到下一次 Cache 被刷新为止。如果数据仓库中数据频繁由⾮Cahce 程序更新的话，这种一致性问题会变得更加明显。</p>
<h4 id="本地-内存-缓存"><a class="header-anchor" href="#本地-内存-缓存">¶</a>本地（内存）缓存</h4>
<p>Cache 也是可以做到应⽤本身里⾯的。Cache-Aside 模式在⼀些应⽤频繁访问相同的数据的时候尤其有效。然⽽，本地 Cache 都是应⽤私有 的，是属于每个应用中独有的额外的拷⻉。所以这个数据可能很快在不同的应⽤中就不一致了，所以刷新的频率最好更快些以保证⼀致性。在 有些情况下可以使⽤共享的缓存，有的时候也可以使⽤本地 Cache，具体使⽤哪⼀种就需要根据实际的场景来判断了。</p>
<h3 id="缓存策略-cache-as-sor-模式"><a class="header-anchor" href="#缓存策略-cache-as-sor-模式">¶</a>缓存策略 - Cache-as-SoR 模式</h3>
<p>由 Cache 委托给 SoR 进⾏真实的读写</p>
<h3 id="缓存策略-read-through"><a class="header-anchor" href="#缓存策略-read-through">¶</a>缓存策略 - Read-Through</h3>
<p>读 miss 则由 cache 回源到 SoR(需要防⽌dog-pile effect 即 miss 时只允许⼀个请求回源而不是所有请求都回源)。</p>
<h3 id="缓存策略-write-through"><a class="header-anchor" href="#缓存策略-write-through">¶</a>缓存策略 - Write-Through</h3>
<p>由 cache 组件负责写缓存和 SoR(一般是先 SoR 再缓存)</p>
<h3 id="缓存策略-write-behind"><a class="header-anchor" href="#缓存策略-write-behind">¶</a>缓存策略 - Write-Behind</h3>
<p>异步(队列+线程池)写 SoR</p>
<h3 id="缓存策略-copy-pattern"><a class="header-anchor" href="#缓存策略-copy-pattern">¶</a>缓存策略 - Copy-Pattern</h3>
<p>Copy-On-Read<br>
Copy-On-Write<br>
本地缓存的是引⽤，被擅⾃修改可能引起不可预测的问题</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p>所有参考文献的归档，集中管理，方便随时查阅。</p>
<h3 id="多级缓存架构"><a class="header-anchor" href="#多级缓存架构">¶</a>多级缓存架构</h3>
<ol>
<li><a href="https://juejin.im/post/5d86cf7f6fb9a06b211724e7" target="_blank" rel="noopener">一篇文章让你明白你多级缓存的分层架构</a></li>
<li><a href="https://blog.csdn.net/zlc3323/article/details/89984961" target="_blank" rel="noopener">一个牛逼的多级缓存实现方案</a></li>
<li><a href="https://www.sohu.com/a/250055167_673711" target="_blank" rel="noopener">日访问量百亿级的微博如何做缓存架构设计</a></li>
<li><a href="https://www.jianshu.com/p/eeaa62dfaf72" target="_blank" rel="noopener">分布式内存缓存系统设计</a></li>
<li><a href="https://www.cnblogs.com/mushroom/p/4199701.html#wechat_redirect" target="_blank" rel="noopener">那些年我们一起追过的缓存写法(一)</a></li>
</ol>
<h3 id="内存池"><a class="header-anchor" href="#内存池">¶</a>内存池</h3>
<ol>
<li><a href="https://blog.csdn.net/weixin_45583158/article/details/102618077" target="_blank" rel="noopener">设计模式之争：新分配内存还是内存池？（含评测）</a></li>
</ol>
<h3 id="本地缓存-v2"><a class="header-anchor" href="#本地缓存-v2">¶</a>本地缓存</h3>
<p>不得不承认本地缓存不比分布式缓存更简单，当我们讨论分布式缓存时，更多的是在讨论如何节省带宽、如何平滑扩容，但在本地缓存的范畴内，我们更多的需要关注所使用语言的内存管理机制、甚至需要向下探索到硬件层面（其实分布式缓存的基础一般也是本地缓存）。</p>
<ol>
<li><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache</a><br>
<a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU Cache</a><br>
LeetCode 上有几道缓存相关的问题，可以拿来作热身。</li>
<li>Java 内存模型<br>
Java 中的垃圾回收技术已经比较完善了，开发人员能做的除了给出合理的配置外，就是要做到对自己使用的垃圾回收技术知根知底、能写出 GC 友好的代码。<br>
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">The Java Memory Model - William Pugh</a><br>
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">JSR 133 (Java Memory Model) FAQ</a><br>
<a href="http://ifeve.com/jmm-faq/" target="_blank" rel="noopener">Java 内存模型 FAQ</a><br>
上面这篇的中文翻译，适合我这种英语渣对照阅读。<br>
<a href="https://blog.csdn.net/youyou1543724847/article/details/52728301" target="_blank" rel="noopener">GC(GC 友好编程)</a><br>
<a href="http://gee.cs.oswego.edu/" target="_blank" rel="noopener">Doug Lea’s Home Page</a><br>
<a href="http://ifeve.com/doug-lea/" target="_blank" rel="noopener">Doug Lea 并发编程文章全部译文</a></li>
<li>NonBlocking HashTable<br>
HashTable 是实现缓存的常用数据结构，而在操作时进行普通的加锁又非常影响性能，所以一般会做一些 NonBlocking 的优化。除了 JUC 的 ConcurrentHashMap，还有其他的一些相似实现。<br>
<a href="https://github.com/stephenc/high-scale-lib" target="_blank" rel="noopener">stephenc/high-scale-lib</a><br>
<a href="https://github.com/JCTools/JCTools" target="_blank" rel="noopener">JCTools/JCTools</a></li>
<li>guava - cache<br>
<a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="noopener">github - google/guava - Caches</a></li>
<li>ehcache<br>
<a href="https://github.com/ehcache" target="_blank" rel="noopener">github - ehcache3</a><br>
<a href="https://www.jianshu.com/p/5a0669d6305e" target="_blank" rel="noopener">玩转 EhCache 之最简单的缓存框架</a></li>
<li>J2Cache<br>
J2Cache 是一个国产的本地缓存框架，同时也提供了二级缓存、多机同步等特性。<br>
<a href="https://gitee.com/ld/J2Cache" target="_blank" rel="noopener">红薯 / J2Cache</a></li>
<li>Netty 中的对象池<br>
<a href="https://github.com/netty/netty/wiki/Reference-counted-objects" target="_blank" rel="noopener">netty/netty - Reference counted objects</a><br>
<a href="https://blog.csdn.net/levena/article/details/78144924" target="_blank" rel="noopener">Netty 源码 Recycler 对象池全面解析</a><br>
<a href="https://www.jianshu.com/p/854b855bd198" target="_blank" rel="noopener">netty 源码分析 4 - Recycler 对象池的设计</a><br>
Netty 为了提高性能，IO 时直接使用非堆内存来缓存收发的内容（Buf 对象），在非堆内存中 GC 效率会比 JVM 的堆内存效率低（只能通过 FullGC 回收或 CMS GC），所以 Netty 内部维护了一个对象池（Recycler），使用引用计数法来回收不用的对象到对象池中，而不是直接回收，减少了 GC 的频率。</li>
<li>C / C++ 内存模型<br>
C / C++ 只保证最基本的内存管理（malloc / free），因为其贴近操作系统的特性，很多框架都会封装一套自己的内存管理库（包括 memcached、MySQL、Cocos2d-x 等），甚至是 GC。<br>
《C 语言接口与实现》 - 第 2、4、5、6 章<br>
<a href="ftp://g.oswego.edu/pub/misc/malloc.c" target="_blank" rel="noopener">dlmalloc - Doug Lea</a><br>
<a href="https://blog.csdn.net/xushiweizh/article/category/265099" target="_blank" rel="noopener">内存管理（Memory） - 许式伟</a><br>
<a href="http://xushiwei.com/gc-allocator" target="_blank" rel="noopener">C++ Memory Management Innovation: GC Allocator</a><br>
《STL 源码剖析》 - 第 2 章<br>
《深入探索 C++对象模型》</li>
<li><a href="https://github.com/bangerlee/mempool" target="_blank" rel="noopener">bangerlee/mempool</a></li>
<li>应用层内存管理<br>
<a href="https://www.memorymanagement.org/index.html" target="_blank" rel="noopener">Memory Management Reference</a><br>
一个神奇的网站，内存管理相关的概念、综述、深入参考文献基本都能在这里找到，而且偏应用层，讲解方式友好、适合扫盲。</li>
<li>操作系统层内存管理<br>
<a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/" target="_blank" rel="noopener">The Unix and Internet Fundamentals HOWTO</a><br>
非常精炼地解释了 Unix 系统和网络的基本原理。</li>
<li>硬件层内存管理</li>
</ol>
<h3 id="分布式缓存-v2"><a class="header-anchor" href="#分布式缓存-v2">¶</a>分布式缓存</h3>
<ol>
<li>分布式缓存设计及解决方案（后端）<br>
<a href="http://www.cnblogs.com/itfly8/category/756114.html" target="_blank" rel="noopener">大型分布式网站架构</a><br>
<a href="https://segmentfault.com/a/1190000006007338" target="_blank" rel="noopener">浅谈缓存(一)</a><br>
<a href="http://www.cnblogs.com/mushroom/p/4199701.html" target="_blank" rel="noopener">那些年我们一起追过的缓存写法(一)</a><br>
<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247486493&amp;idx=1&amp;sn=2d159e329b3e579d6b844754df0dd265&amp;source=41#wechat_redirect" target="_blank" rel="noopener">缓存穿透、并发和失效，来自一线架构师的解决方案</a></li>
<li>《分布式缓存——原理、架构及 Go 语言实现》</li>
<li><a href="https://blog.csdn.net/F8qG7f9YD02Pe/article/details/78937081" target="_blank" rel="noopener">荐书：《深入分布式缓存》</a></li>
<li>Redis 教程及手册<br>
《Redis 设计与实现》<br>
《Redis 深度历险：核心原理与应用实践》<br>
<a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">Redis 命令参考</a><br>
<a href="https://redis.io/commands" target="_blank" rel="noopener">Redis Command Reference</a><br>
<a href="https://redis.io/documentation" target="_blank" rel="noopener">Redis Documentation</a></li>
<li>Redis 及客户端源码<br>
<a href="https://github.com/antirez/redis" target="_blank" rel="noopener">github - antirez/redis</a><br>
<a href="https://github.com/redisson/redisson/wiki/Redisson%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">github - redisson/redisson</a><br>
<a href="https://github.com/xetorthio/jedis/wiki" target="_blank" rel="noopener">github - xetorthio/jedis</a><br>
<a href="https://github.com/lettuce-io/lettuce-core/wiki/Redis-Command-Interfaces" target="_blank" rel="noopener">github - lettuce-io/lettuce-core</a></li>
<li>Redis - 数据结构<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247488450&amp;idx=1&amp;sn=88239e7fa2b80a9922db5fbc9629c770&amp;chksm=e91b76dede6cffc8b8820e7730349fe83cef1cdf0ac73b7a5e13569e596c77264b92edacf4f2&amp;token=649184257&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Redis 为何这么快</a><br>
<a href="https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency" target="_blank" rel="noopener">Redis strings vs Redis hashes to represent JSON: efficiency?</a><br>
如果业务里需要使用到对象的单个域则使用 hash 类型保存 JSON，否则使用 string。</li>
<li>Redis - Sentinel<br>
Sentinel 是 Redis 提供的一种高可用集群方案，它能实现自动的故障转移。<br>
<a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">Redis Sentinel Documentation</a><br>
<a href="https://redis.io/topics/sentinel-clients" target="_blank" rel="noopener">Sentinel Clients</a><br>
<a href="https://aphyr.com/posts/283-call-me-maybe-redis" target="_blank" rel="noopener">Jepsen: Redis</a><br>
<a href="http://antirez.com/news/55" target="_blank" rel="noopener"><antirez> Reply to Aphyr attack to Sentinel</antirez></a><br>
<a href="https://aphyr.com/posts/287-asynchronous-replication-with-failover" target="_blank" rel="noopener">Asynchronous replication with failover</a></li>
<li>Redis - Cluster<br>
Redis Cluster 不是使用<strong>一致性 hash</strong>、而是利用<strong>哈希槽</strong>的模式来分配数据，相对来说更简单，但是数据迁移的时候成本也会更大。<br>
<a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a><br>
<a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster Specification</a></li>
<li>在 Spring 架构后台中使用 Redis<br>
<a href="https://docs.spring.io/spring/docs/5.0.3.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">spring-framework-reference - 8. Cache Abstraction</a><br>
<a href="https://docs.spring.io/spring-data/redis/docs/2.0.3.RELEASE/reference/html/" target="_blank" rel="noopener">Spring Data Redis</a><br>
<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/" target="_blank" rel="noopener">Spring Boot Reference Guide</a></li>
<li>Redis 最佳实践<br>
<a href="https://yq.aliyun.com/articles/531067" target="_blank" rel="noopener">阿里云 Redis 开发规范</a><br>
<a href="https://juejin.im/post/5cee39a26fb9a07ed36e8c4c" target="_blank" rel="noopener">你所不知道的 Redis 热点问题以及如何发现热点</a><br>
<a href="https://blog.csdn.net/javaMerea/article/details/89317071" target="_blank" rel="noopener">史上最全 50 道 Redis 面试题（含答案），以后面试再也不怕问 Redis 了</a></li>
<li>Redis 应用<br>
<a href="https://mp.weixin.qq.com/s/y2HPj2ji2KLS_eTR5nBnDA" target="_blank" rel="noopener">一文看透 Redis 分布式锁进化史（解读 + 缺陷分析）</a><br>
<a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking</a><br>
刷新 Redis 缓存时需要加分布式锁，保证只有一个线程能够写入缓存。<br>
<a href="https://redis.io/commands/incr#pattern-rate-limiter" target="_blank" rel="noopener">INCR key (分布式限流器的例子)</a><br>
<a href="https://mp.weixin.qq.com/s/q-y10hMPjApWgnQacu-nsA" target="_blank" rel="noopener">布隆过滤器实战【防止缓存击穿】</a><br>
<a href="https://coolshell.cn/articles/7270.html" target="_blank" rel="noopener">NOSQL 数据建模技术</a></li>
<li><a href="https://github.com/memcached/memcached" target="_blank" rel="noopener">github - memcached</a><br>
memcached 是经常和 Redis 一并提起的一个分布式缓存中间件，了解其原理能对分布式缓存的实现模式有更好的认识。</li>
</ol>
<h3 id="web-缓存"><a class="header-anchor" href="#web-缓存">¶</a>Web 缓存</h3>
<p>Web 缓存指的是在服务器和客户端之间的缓存，不同于我们上边提到的都是服务器（本地缓存）及服务器之后的缓存（分布式缓存）。<br>
Web 缓存其实不仅仅指浏览器内的缓存，在剖析从客户端发送请求到服务器接收为止的一系列链路之后，可以发现 Web 缓存主要包括浏览器缓存、代理服务器缓存、网关缓存。</p>
<ol>
<li><a href="https://www.cnblogs.com/rubylouvre/p/3139620.html" target="_blank" rel="noopener">Web 开发人员需知的 Web 缓存知识</a></li>
</ol>
<h3 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h3>
<p>测试是发现问题的手段，最好的解决问题方式是避免问题。</p>
<ol>
<li>《Java 并发编程实战》 - 第三部分（并发安全及性能）</li>
<li><a href="http://www.redis.cn/topics/benchmarks.html" target="_blank" rel="noopener">Redis 有多快?</a></li>
<li>《构建高性能 Web 站点》 - 第 3 章</li>
<li>《Java 程序性能优化》</li>
<li>《Web 性能权威指南》</li>
<li>《OptimizingLinux®PerformanceAHands-OnGuidetoLinux®PerformanceTools》</li>
<li>《性能之巅》</li>
</ol>
<h3 id="运维"><a class="header-anchor" href="#运维">¶</a>运维</h3>
<ol>
<li>《The Art of Capacity Planning》</li>
<li><a href="http://stor.51cto.com/art/201808/580165.htm" target="_blank" rel="noopener">探寻 Redis 内存诡异增长的元凶</a></li>
</ol>
<h3 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h3>
<ol>
<li><a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">How To Ask Questions The Smart Way</a></li>
<li><a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html" target="_blank" rel="noopener">Software Release Practice HOWTO</a></li>
<li><a href="https://github.com/hyperoslo/Cache" target="_blank" rel="noopener">github - hyperoslo/Cache</a><br>
这个项目同样在缓存上做文章，不过是用 swift 写的。</li>
<li><a href="https://learnxinyminutes.com/docs/lua/" target="_blank" rel="noopener">Learn X in Y minutes - Where X=Lua</a></li>
<li>《设计模式》 - Factory, Builder, Proxy, Chain of Responsibility, Command, Iterator, template method</li>
<li>《Spring 源码深度解析》 - 第 5、6、7 章</li>
<li><a href="https://app.brandmark.io/v2/" target="_blank" rel="noopener">使用 AI 生成图标</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/6e8a6bb7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/6e8a6bb7.html" itemprop="url">服务治理——限流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T22:47:18+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>限流器可以用于限制打入系统的流量或限制系统的对外请求频率，这种想法有点类似 TCP 中的拥塞控制。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/6e8a6bb7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d6d73555.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/d6d73555.html" itemprop="url">Linux 无线网卡驱动器丢失问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T00:33:12+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  456 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在一次编译 jvm 的过程中，尝试将没用版本的 gcc、g++卸载，但是没想到 apt 非常智能地把无线网卡等一系列东西都给删掉了，启动后连网都上不了了，重装系统又觉得麻烦，结果开始了苦逼的填坑之旅。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/d6d73555.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
