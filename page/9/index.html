<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/9/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/9/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/afefe620.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/afefe620.html" itemprop="url">ZooKeeper 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-29T16:50:12+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="watcher"><a class="header-anchor" href="#watcher">¶</a>Watcher</h2>
<h2 id="leader-选举"><a class="header-anchor" href="#leader-选举">¶</a>Leader 选举</h2>
<h3 id="选举相关概念"><a class="header-anchor" href="#选举相关概念">¶</a>选举相关概念</h3>
<ul>
<li>服务器 ID<br>
编号越大在选择算法中的权重越大。比如有三台服务器，编号分别是 1、2、3，其中 3 的那台权重最大。</li>
<li>数据 ID<br>
服务器中存放的最大数据 ID。值越大说明数据越新，在选举算法中数据越新权重越大。</li>
<li>逻辑时钟<br>
或者叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。</li>
<li>选举状态<br>
LOOKING，竞选状态。<br>
FOLLOWING，随从状态，同步 leader 状态，参与投票。<br>
OBSERVING，观察状态,同步 leader 状态，不参与投票。<br>
LEADING，领导者状态。</li>
</ul>
<h3 id="zk-集群选举概述"><a class="header-anchor" href="#zk-集群选举概述">¶</a>zk 集群选举概述</h3>
<p>配置多个实例共同构成一个集群对外提供服务以达到水平扩展的目的，每个服务器上的数据是相同的，每一个服务器均可以对外提供读和写的服务，这点和 redis 是相同的，即对客户端来讲每个服务器都是平等的。<br>
<img src="http://47.88.24.11/imgs/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/zk%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE%E6%A6%82%E8%BF%B0.jpg" alt="zk集群选举概述" title="zk集群选举概述"><br>
zookeeper 提供了三种集群选举方式：</p>
<ul>
<li>LeaderElection</li>
<li>AuthFastLeaderElection</li>
<li>FastLeaderElection</li>
</ul>
<p>默认的算法是 FastLeaderElection，所以这里主要分析它的选举机制。</p>
<h3 id="quorumpeer"><a class="header-anchor" href="#quorumpeer">¶</a>QuorumPeer</h3>
<p>主要看这个类，只有 LOOKING 状态才会去执行选举算法。每个服务器在启动时都会选择自己做为领导，然后将投票信息发送出去，循环一直到选举出领导为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        //.......</span><br><span class="line">        try &#123;</span><br><span class="line">            while (running) &#123;</span><br><span class="line">                switch (getPeerState()) &#123;</span><br><span class="line">                case LOOKING:</span><br><span class="line">                    if (Boolean.getBoolean(&quot;readonlymode.enabled&quot;)) &#123;</span><br><span class="line">                        //...</span><br><span class="line">                        try &#123;</span><br><span class="line">                           //投票给自己...</span><br><span class="line">                            setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            //...</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            //...</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                           //...</span><br><span class="line">                            setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            //...</span><br><span class="line">                        &#125;                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case OBSERVING:</span><br><span class="line">                    //...</span><br><span class="line">                    break;</span><br><span class="line">                case FOLLOWING:</span><br><span class="line">                    //...</span><br><span class="line">                    break;</span><br><span class="line">                case LEADING:</span><br><span class="line">                    //...</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="fastleaderelection"><a class="header-anchor" href="#fastleaderelection">¶</a>FastLeaderElection</h3>
<p>它是 zookeeper 默认提供的选举算法，核心方法如下。可以与本文上面的流程图对照。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public Vote lookForLeader() throws InterruptedException &#123;</span><br><span class="line">        //...</span><br><span class="line">        try &#123;</span><br><span class="line">            HashMap&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line">            HashMap&lt;Long, Vote&gt; outofelection = new HashMap&lt;Long, Vote&gt;();</span><br><span class="line">            int notTimeout = finalizeWait;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                //给自己投票</span><br><span class="line">                logicalclock.incrementAndGet();</span><br><span class="line">                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">            &#125;</span><br><span class="line">            //将投票信息发送给集群中的每个服务器</span><br><span class="line">            sendNotifications();</span><br><span class="line">            //循环，如果是竞选状态一直到选举出结果</span><br><span class="line">            while ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</span><br><span class="line">                    (!stop))&#123;</span><br><span class="line"></span><br><span class="line">                Notification n = recvqueue.poll(notTimeout,</span><br><span class="line">                        TimeUnit.MILLISECONDS);</span><br><span class="line">                //没有收到投票信息</span><br><span class="line">                if(n == null)&#123;</span><br><span class="line">                    if(manager.haveDelivered())&#123;</span><br><span class="line">                        sendNotifications();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        manager.connectAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //...</span><br><span class="line">                &#125; </span><br><span class="line">                //收到投票信息</span><br><span class="line">                else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) &#123;</span><br><span class="line"></span><br><span class="line">                    switch (n.state) &#123;</span><br><span class="line">                    case LOOKING:</span><br><span class="line"></span><br><span class="line">                        // 判断投票是否过时，如果过时就清除之前已经接收到的信息                      </span><br><span class="line">                        if (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                            logicalclock.set(n.electionEpoch);</span><br><span class="line">                            recvset.clear();</span><br><span class="line">                            //更新投票信息</span><br><span class="line">                            if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                    getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                updateProposal(getInitId(),</span><br><span class="line">                                        getInitLastLoggedZxid(),</span><br><span class="line">                                        getPeerEpoch());</span><br><span class="line">                            &#125;</span><br><span class="line">                            //发送投票信息</span><br><span class="line">                            sendNotifications();</span><br><span class="line">                        &#125; else if (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                            //忽略</span><br><span class="line">                            break;</span><br><span class="line">                        &#125; else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                            //更新投票信息</span><br><span class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            sendNotifications();</span><br><span class="line">                        &#125;                     </span><br><span class="line">                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                        //判断是否投票结束</span><br><span class="line">                        if (termPredicate(recvset,</span><br><span class="line">                                new Vote(proposedLeader, proposedZxid,</span><br><span class="line">                                        logicalclock.get(), proposedEpoch))) &#123;</span><br><span class="line">                            // Verify if there is any change in the proposed leader</span><br><span class="line">                            while((n = recvqueue.poll(finalizeWait,</span><br><span class="line">                                    TimeUnit.MILLISECONDS)) != null)&#123;</span><br><span class="line">                                if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</span><br><span class="line">                                        proposedLeader, proposedZxid, proposedEpoch))&#123;</span><br><span class="line">                                    recvqueue.put(n);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            if (n == null) &#123;</span><br><span class="line">                                self.setPeerState((proposedLeader == self.getId()) ?</span><br><span class="line">                                        ServerState.LEADING: learningState());</span><br><span class="line">                                Vote endVote = new Vote(proposedLeader,</span><br><span class="line">                                        proposedZxid, proposedEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                return endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case OBSERVING:</span><br><span class="line">                        //忽略</span><br><span class="line">                        break;</span><br><span class="line">                    case FOLLOWING:</span><br><span class="line">                    case LEADING:</span><br><span class="line">                        //如果是同一轮投票</span><br><span class="line">                        if(n.electionEpoch == logicalclock.get())&#123;</span><br><span class="line">                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                            //判断是否投票结束</span><br><span class="line">                            if(termPredicate(recvset, new Vote(n.leader,</span><br><span class="line">                                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))</span><br><span class="line">                                            &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                                self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                        ServerState.LEADING: learningState());</span><br><span class="line">                                Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                                leaveInstance(endVote);</span><br><span class="line">                                return endVote;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //记录投票已经完成</span><br><span class="line">                        outofelection.put(n.sid, new Vote(n.leader, </span><br><span class="line">                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</span><br><span class="line">                        if (termPredicate(outofelection, new Vote(n.leader,</span><br><span class="line">                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</span><br><span class="line">                                &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</span><br><span class="line">                            synchronized(this)&#123;</span><br><span class="line">                                logicalclock.set(n.electionEpoch);</span><br><span class="line">                                self.setPeerState((n.leader == self.getId()) ?</span><br><span class="line">                                        ServerState.LEADING: learningState());</span><br><span class="line">                            &#125;</span><br><span class="line">                            Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                            leaveInstance(endVote);</span><br><span class="line">                            return endVote;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        //忽略</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    LOG.warn(&quot;Ignoring notification from non-cluster member &quot; + n.sid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断是否已经胜出<br>
默认是采用投票数大于半数则胜出的逻辑。</li>
</ul>
<h3 id="选举消息内容"><a class="header-anchor" href="#选举消息内容">¶</a>选举消息内容</h3>
<p>在投票完成后，需要将投票信息发送给集群中的所有服务器，它包含如下内容。</p>
<ul>
<li>服务器 ID</li>
<li>数据 ID</li>
<li>逻辑时钟</li>
<li>选举状态</li>
</ul>
<h3 id="选举流程简述"><a class="header-anchor" href="#选举流程简述">¶</a>选举流程简述</h3>
<p>目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ul>
<li>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。</li>
<li>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 LOOKING。</li>
<li>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。</li>
<li>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</li>
<li>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</li>
</ul>
<h3 id="选举流程"><a class="header-anchor" href="#选举流程">¶</a>选举流程</h3>
<p>描述 Leader 选择过程中的状态变化，这是假设全部实例中均没有数据，假设服务器启动顺序分别为：A,B,C。<br>
<img src="http://47.88.24.11/imgs/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="选举流程图" title="选举流程图"><br>
<img src="http://47.88.24.11/imgs/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%80%89%E4%B8%BE%E7%8A%B6%E6%80%81%E5%9B%BE.jpg" alt="选举状态图" title="选举状态图"></p>
<h3 id="如果规模为-5-的集群只起来其中的-3-台服务器-这时会进行选举吗"><a class="header-anchor" href="#如果规模为-5-的集群只起来其中的-3-台服务器-这时会进行选举吗">¶</a>如果规模为 5 的集群只起来其中的 3 台服务器，这时会进行选举吗</h3>
<p>不会，ZooKeeper 更倾向于保持一致性，如果配置中的部分服务器不可用，那么整个集群都是不可用的。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/6072597.html" target="_blank" rel="noopener">【分布式】Zookeeper 系统模型</a></li>
</ol>
<h3 id="zookeeper-服务器的启动流程"><a class="header-anchor" href="#zookeeper-服务器的启动流程">¶</a>ZooKeeper 服务器的启动流程</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/6105276.html" target="_blank" rel="noopener">【分布式】Zookeeper 服务端启动</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6139266.html" target="_blank" rel="noopener">【分布式】Zookeeper 的服务器角色</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6514897.html" target="_blank" rel="noopener">【Zookeeper】源码分析之服务器（一）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6515105.html" target="_blank" rel="noopener">【Zookeeper】源码分析之服务器（二）之 ZooKeeperServer</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6516805.html" target="_blank" rel="noopener">【Zookeeper】源码分析之服务器（三）之 LeaderZooKeeperServer</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6517058.html" target="_blank" rel="noopener">【Zookeeper】源码分析之服务器（四）之 FollowerZooKeeperServer</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6517945.html" target="_blank" rel="noopener">【Zookeeper】源码分析之服务器（五）之 ObserverZooKeeperServer</a></li>
</ol>
<h3 id="zookeeper-客户端"><a class="header-anchor" href="#zookeeper-客户端">¶</a>ZooKeeper 客户端</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/6098255.html" target="_blank" rel="noopener">【分布式】Zookeeper 客户端</a></li>
</ol>
<h3 id="watcher-v2"><a class="header-anchor" href="#watcher-v2">¶</a>Watcher</h3>
<ol>
<li><a href="https://blog.csdn.net/hohoo1990/article/details/78617336" target="_blank" rel="noopener">zookeeper 中 Watcher 通知机制的一点理解</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6286827.html" target="_blank" rel="noopener">【Zookeeper】源码分析之 Watcher 机制（一）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6288709.html" target="_blank" rel="noopener">【Zookeeper】源码分析之 Watcher 机制（二）之 WatchManager</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6291004.html" target="_blank" rel="noopener">【Zookeeper】源码分析之 Watcher 机制（三）之 ZooKeeper</a></li>
</ol>
<h3 id="leader-选举-v2"><a class="header-anchor" href="#leader-选举-v2">¶</a>Leader 选举</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">【分布式】Zookeeper 的 Leader 选举</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6494290.html" target="_blank" rel="noopener">【Zookeeper】源码分析之 Leader 选举（一）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6508185.html" target="_blank" rel="noopener">【Zookeeper】源码分析之 Leader 选举（二）之 FastLeaderElection</a></li>
</ol>
<h3 id="持久化"><a class="header-anchor" href="#持久化">¶</a>持久化</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/6179118.html" target="_blank" rel="noopener">【分布式】Zookeeper 数据与存储</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6279956.html" target="_blank" rel="noopener">【Zookeeper】源码分析之持久化（一）之 FileTxnLog</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6285014.html" target="_blank" rel="noopener">【Zookeeper】源码分析之持久化（二）之 FileSnap</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6285703.html" target="_blank" rel="noopener">【Zookeeper】源码分析之持久化（三）之 FileTxnSnapLog</a></li>
</ol>
<h3 id="通信-通信协议-序列化-会话-请求处理"><a class="header-anchor" href="#通信-通信协议-序列化-会话-请求处理">¶</a>通信（通信协议、序列化、会话、请求处理）</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/6091208.html" target="_blank" rel="noopener">【分布式】Zookeeper 序列化及通信协议</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6278853.html" target="_blank" rel="noopener">【Zookeeper】源码分析之序列化</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6103870.html" target="_blank" rel="noopener">【分布式】Zookeeper 会话</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6140503.html" target="_blank" rel="noopener">【分布式】Zookeeper 请求处理</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6410793.html" target="_blank" rel="noopener">【Zookeeper】源码分析之请求处理链（一）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6412843.html" target="_blank" rel="noopener">【Zookeeper】源码分析之请求处理链（二）之 PrepRequestProcessor</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6438411.html" target="_blank" rel="noopener">【Zookeeper】源码分析之请求处理链（三）之 SyncRequestProcessor</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6472496.html" target="_blank" rel="noopener">【Zookeeper】源码分析之请求处理链（四）之 FinalRequestProcessor</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6477815.html" target="_blank" rel="noopener">【Zookeeper】源码分析之网络通信（一）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6484780.html" target="_blank" rel="noopener">【Zookeeper】源码分析之网络通信（二）之 NIOServerCnxn</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/6486454.html" target="_blank" rel="noopener">【Zookeeper】源码分析之网络通信（三）之 NettyServerCnxn</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/32289fde.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/32289fde.html" itemprop="url">Linux 环境下制作启动盘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T23:25:30+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最近有点迷 ARPG，但是自己的 T470P 上只有一个 Ubuntu 系统，所以买了一个 2422 的固态往上面装个 Win10，Linux 下构建启动盘还是蛮多坑的，下面记录一下操作流程，免得以后忘了。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/32289fde.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/158d8ca5.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/158d8ca5.html" itemprop="url">Linux 三剑客-sed 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T21:43:48+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="为什么要使用-sed"><a class="header-anchor" href="#为什么要使用-sed">¶</a>为什么要使用 sed</h2>
<p>sed 全名叫 stream editor，流编辑器（也叫行编辑器），其处理文本的方式为一行一行的，不同于 vi 等全屏编辑器；主要用途为通过匹配一个或多个正则表达式来对文本进行处理，实现过滤和转换文本。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/158d8ca5.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/da3bc81f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/da3bc81f.html" itemprop="url">Linux环境运维命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T22:18:28+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  626 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>sar</h1>
<p>Collect, report, or save system activity information.<br>
根据要统计的信息类型的不同，输出格式也不同。</p>
<h2 id="统计cpu利用率"><a class="header-anchor" href="#统计cpu利用率">¶</a>统计CPU利用率</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看全天</span><br><span class="line">sar -p</span><br><span class="line"># 每隔1秒统计一次，统计10次</span><br><span class="line">sar -u 1 10</span><br></pre></td></tr></table></figure>
<p>CPU统计信息输出格式：</p>
<ul>
<li>CPU<br>
all表示统计信息为所有 CPU 的平均值。</li>
<li>%user<br>
显示在用户级别(application)运行使用 CPU 总时间的百分比。</li>
<li>%nice<br>
显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比。</li>
<li>%system<br>
在核心级别(kernel)运行所使用 CPU 总时间的百分比。</li>
<li>%iowait<br>
显示用于等待I/O操作占用 CPU 总时间的百分比。</li>
<li>%steal<br>
管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比。</li>
<li>%idle<br>
显示 CPU 空闲时间占用 CPU 总时间的百分比。</li>
</ul>
<h2 id="内存利用率"><a class="header-anchor" href="#内存利用率">¶</a>内存利用率</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看全天</span><br><span class="line">sar -r</span><br><span class="line"># 每隔1秒统计一次，统计10次</span><br><span class="line">sar -r 1 10</span><br></pre></td></tr></table></figure>
<p>内存统计信息输出格式</p>
<ul>
<li>kbmemfree<br>
这个值和free命令中的free值基本一致，所以它不包括buffer和cache的空间。</li>
<li>kbmemused<br>
这个值和free命令中的used值基本一致，所以它包括buffer和cache的空间。</li>
<li>%memused<br>
这个值是kbmemused和内存总量(不包括swap)的一个百分比。</li>
<li>kbbuffers和kbcached<br>
这两个值就是free命令中的buffer和cache。</li>
<li>kbcommit<br>
保证当前系统所需要的内存，即为了确保不溢出而需要的内存(RAM+swap)。</li>
<li>%commit<br>
这个值是kbcommit与内存总量(包括swap)的一个百分比。</li>
</ul>
<h2 id="磁盘io"><a class="header-anchor" href="#磁盘io">¶</a>磁盘IO</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看全天</span><br><span class="line">sar -d</span><br><span class="line"># 每隔1秒统计一次，统计10次</span><br><span class="line">sar -d 1 10</span><br></pre></td></tr></table></figure>
<p>IO信息输出格式</p>
<ul>
<li>await<br>
表示平均每次设备I/O操作的等待时间（以毫秒为单位）。</li>
<li>svctm<br>
表示平均每次设备I/O操作的服务时间（以毫秒为单位）。</li>
<li>%util<br>
表示一秒中有百分之几的时间用于I/O操作。</li>
</ul>
<h2 id="网络流量"><a class="header-anchor" href="#网络流量">¶</a>网络流量</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看全天</span><br><span class="line">sar -n DEV</span><br><span class="line"># 每个1秒统计一次，统计10次</span><br><span class="line">sar -n DEV 1 10</span><br></pre></td></tr></table></figure>
<p>流量信息输出格式：</p>
<ul>
<li>IFACE<br>
就是网络设备的名称。</li>
<li>rxpck/s<br>
每秒钟接收到的包数目。</li>
<li>txpck/s<br>
每秒钟发送出去的包数目。</li>
<li>rxkB/s<br>
每秒钟接收到的字节数。</li>
<li>txkB/s<br>
每秒钟发送出去的字节数。</li>
<li>rxcmp/s<br>
每秒钟接收到的压缩包数目。</li>
<li>txcmp/s<br>
每秒钟发送出去的压缩包数目。</li>
<li>rxmcst/s<br>
每秒钟接收到的多播包的包数目。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b10d1916.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b10d1916.html" itemprop="url">Linux 环境常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T22:18:28+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>Linux 命令尤其多，没办法一下子全部搞明白，下面来不及看的部分我就用 TODO 标出了。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/b10d1916.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1bd01bc3.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1bd01bc3.html" itemprop="url">网络协议之 TCP 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>TCP、HTTP 几乎是 TCP/IP 协议栈中最实用的两个协议，特别是在 Web 开发中。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/1bd01bc3.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b791cedc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b791cedc.html" itemprop="url">微服务核心技术总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>微服务是一种架构风格，需要注意的是它并不能与 Docker、Spring Cloud 划等号，只是这些技术栈能更好地实现微服务，这篇文档中我希望总结一下实现微服务最常用的技术。</p>
<h2 id="微服务基本概念"><a class="header-anchor" href="#微服务基本概念">¶</a>微服务基本概念</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<h3 id="为什么要使用微服务"><a class="header-anchor" href="#为什么要使用微服务">¶</a>为什么要使用微服务</h3>
<h3 id="架构与组织"><a class="header-anchor" href="#架构与组织">¶</a>架构与组织</h3>
<h3 id="中台战略与微服务"><a class="header-anchor" href="#中台战略与微服务">¶</a>中台战略与微服务</h3>
<h3 id="微服务架构风格"><a class="header-anchor" href="#微服务架构风格">¶</a>微服务架构风格</h3>
<h3 id="微服务架构"><a class="header-anchor" href="#微服务架构">¶</a>微服务架构</h3>
<h2 id="服务发现-eureka"><a class="header-anchor" href="#服务发现-eureka">¶</a>服务发现 - Eureka</h2>
<h3 id="eureka-的目标"><a class="header-anchor" href="#eureka-的目标">¶</a>Eureka 的目标</h3>
<p>原来：负载均衡器会根据配好的 IP 和主机名来进行负载均衡，但是对 AWS cloud 这样体量的系统来说，因为服务实例宕机恢复十分频繁，所以负载均衡器还会有一个更复杂的注册 / 注销服务的机制。<br>
现在：Eureka 在中间层提供一种负载均衡的可能。</p>
<h3 id="eureka-vs-zookeeper"><a class="header-anchor" href="#eureka-vs-zookeeper">¶</a>Eureka VS ZooKeeper</h3>
<ul>
<li>Eureka 能提供 REST 接口来动态调整配置、renewals、expiration、cancel 等；</li>
<li>Eureka 倾向于高可用，而不是 ZooKeeper 的高一致性。</li>
<li>Eureka 可以集成到应用中，ZooKeeper 只能作为一个外部组件提供服务，这会增加复杂性、增加系统崩溃的几率。</li>
</ul>
<h3 id="组成部分"><a class="header-anchor" href="#组成部分">¶</a>组成部分</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Eureka组件结构" title="Eureka组件结构"></p>
<ul>
<li>负载均衡：Eureka Client 提供最简单的轮询<strong>负载均衡</strong>策略，可以封装 Eureka 并根据更多的因素（流量、资源使用、异常发生频次等）来提供一种更好的弹性伸缩特性。</li>
<li>分区：每个 Region 有一个 Eureka 集群用于处理该区域服务失败的情况，各 Region 之间是不会互相通信的。</li>
<li>服务注册到 Eureka Server 后每 30 秒发送一次<strong>心跳（heartbeats）<strong>来刷新</strong>租约（lease）</strong>，如果网络出现分区或者 Eureka 宕机了，这种心跳自然会停止，如果达到了<strong>Renews threshold</strong>（即 Server 期望在每分钟中收到的心跳次数，需要考虑是否禁用服务器的自注册、Server/Client 数量等，暂时取默认值 85%就好），Eureka Server 就会将其从服务注册表中移除。</li>
<li>服务注册信息会自动同步到整个 Eureka Server 集群，这也意味着它们是对等的 P2P 集群。</li>
<li>集成到业务服务中的 Eureka Client 可以查询服务注册信息（默认每 30 秒一次）来定位服务及进行远程调用。</li>
</ul>
<h3 id="服务状态机"><a class="header-anchor" href="#服务状态机">¶</a>服务状态机</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E5%AE%9E%E4%BE%8B%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="Eureka实例状态机" title="Eureka实例状态机"></p>
<ul>
<li>STARTING：启动中的状态，应用可以在这个阶段做一些初始化工作</li>
<li>UP：可以正常进行通信；</li>
<li>DOWN：心跳停了，一般是宕机了或者网络出现了分区</li>
<li>OUT_OF_SERVICE：因为某些特殊原因无法提供服务，比如 Elasticsearch 因为没有达到最小可用分片数，或者由于蓝绿发布的需要，新版本如果发布后有问题可以直接将实例状态置为 OUT_OF_SERVICE 来达到回滚的目的。</li>
<li>UNKNOWN：WTF？</li>
</ul>
<h3 id="client-与-server-间的交互"><a class="header-anchor" href="#client-与-server-间的交互">¶</a>Client 与 Server 间的交互</h3>
<h4 id="register"><a class="header-anchor" href="#register">¶</a>Register</h4>
<p>Eureka Client 将信息注册到 Eureka Server，注册过程发生在第一次心跳时（在 30 秒后）。</p>
<h4 id="unregister"><a class="header-anchor" href="#unregister">¶</a>Unregister</h4>
<p>正常情况下，Client 必须显式调用 Unregister 来释放自己的注册信息，除非是由于&quot;unclean termination&quot;而导致心跳丢失超过 3 次。</p>
<h4 id="renew"><a class="header-anchor" href="#renew">¶</a>Renew</h4>
<p>客户端每30秒通过发送一次心跳（heartbeats）来续约（renewal），心跳告知Eureka Server本实例仍然存活，如果Server在90秒内没有收到续约请求，它将从服务注册表中移除该实例。</p>
<h4 id="fetch-registry"><a class="header-anchor" href="#fetch-registry">¶</a>Fetch Registry</h4>
<p>Eureka clients fetches the registry information from the server and csort_bufferhes it locally. After that, the clients use that information to find other services. This information is updated periodically (every 30 seconds) by getting the delta updates between the last fetch cycle and the current one. The delta information is held longer (for about 3 mins) in the server, hence the delta fetches may return the same instances again. The Eureka client automatically handles the duplicate information.</p>
<p>After getting the deltas, Eureka client reconciles the information with the server by comparing the instance counts returned by the server and if the information does not match for some reason, the whole registry information is fetched again. Eureka server caches the compressed payload of the deltas, whole registry and also per application as well as the uncompressed information of the same. The payload also supports both JSON/XML formats. Eureka client gets the information in compressed JSON format using jersey apache client.</p>
<h4 id="cancel"><a class="header-anchor" href="#cancel">¶</a>Cancel</h4>
<p>Eureka client sends a cancel request to Eureka server on shutdown. This removes the instance from the server’s instance registry thereby effectively taking the instance out of traffic.</p>
<p>This is done when the Eureka client shuts down and the application should make sure to call the following during its shutdown.<br>
DiscoveryManager.getInstance().shutdownComponent()</p>
<h4 id="time-lag"><a class="header-anchor" href="#time-lag">¶</a>Time Lag</h4>
<p>All operations from Eureka client may take some time to reflect in the Eureka servers and subsequently in other Eureka clients. This is because of the caching of the payload on the eureka server which is refreshed periodically to reflect new information. Eureka clients also fetch deltas periodically. Hence, it may take up to 2 mins for changes to propagate to all Eureka clients.</p>
<h4 id="communication-mechanism"><a class="header-anchor" href="#communication-mechanism">¶</a>Communication mechanism</h4>
<p>Eureka Client默认使用Jersey发送基于Jackson封装的JSON数据包给Eureka Server。</p>
<h4 id="通信协议"><a class="header-anchor" href="#通信协议">¶</a>通信协议</h4>
<p>Eureka 不限制通信协议，Thrift、HTTP(S)等均可。</p>
<h3 id="高可用"><a class="header-anchor" href="#高可用">¶</a>高可用</h3>
<p>Eureka Client 的高可用设计：</p>
<ul>
<li>Client 中有<strong>服务注册表的缓存</strong>，即使所有 Server 都挂掉了，Client 还是能继续工作。</li>
<li>刚开始，Eureka Client 会尝试与同一 <strong>zone</strong>（可视为同一局域网）中的 Eureka Server 交互，如果交互出现问题或同一 zone 中没有可用的 Eureka Server，则它将转向其他 zone。</li>
</ul>
<p>Eureka Server 的高可用设计：</p>
<ul>
<li>启动 Server 时<strong>从邻居节点获取注册信息</strong>，一个不行换另一个，直到获取成功，如果从邻居节点均无法获取到注册信息，则它会等待几分钟（默认 5 分钟）让 Client 注册它们的信息<br>
Server 之间获取服务注册信息的机制和 Client 从 Server 获取的一样。<br>
获取成功后，Server 会设置<code>Renewal Threshold</code>并开始接收 Client 的心跳；</li>
<li>保护模式：如果<code>Renews(last min)</code>（上一分钟内收到的心跳次数）达到了<code>Renews threshold</code>（Server 期望在每分钟中收到的心跳次数，一般是 3），或者过去 15 分钟内的统计数据小于<code>eureka.server.renewalPercentThreshold</code>（renews / renews threshold 的比值，默认为 0.85，当在 15 分钟内微服务心跳数低于 85%，则 Server 会进入自我保护状态，在这种情况下 Server 不会删除注册信息），则进入<strong>保护模式</strong>，自我保护状态其实是为了防止突发网络不稳定或断电时微服务心跳数剧减，导致微服务注册信息被大量删除的情况。<br>
在保护模式下，Client 可能从 Server 得到已经不可用的 IP（服务器已不存在或因某些原因无法响应），因此 Client 必须保证这种情况下的弹性高可用，比如快速地超时并重试其他服务器。</li>
<li>退出保护模式：在保护模式下，Eureka Server 会停止移除服务注册信息，直到满足如下条件中的任意之一：
<ol>
<li>心跳<code>Renews</code>达到了<code>Renews threshold</code>；</li>
<li>保护模式被禁用，设置<code>eureka.server.enableSelfPreservation=false</code>。</li>
</ol>
</li>
<li>孤儿 Server：当发生网络分区，一些 Eureka Server 可能会成为<code>orphaned server</code>，一些 Client 会注册到这些 Server 上，导致一些 Client 能看到这些注册信息而其他的一些则不能。<br>
当网络恢复后，Server 的 P2P 集群能正常地交互，注册信息会被自动同步到所有 Server 上。</li>
</ul>
<h3 id="异常情况"><a class="header-anchor" href="#异常情况">¶</a>异常情况</h3>
<p>比如在测试环境中出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>在生产上可以开自注册，部署两个 server</li>
<li>在本机器上测试的时候，可以把比值调低，比如 0.49</li>
<li>或者简单粗暴把自我保护模式关闭：eureka.server.enableSelfPreservation=false</li>
</ul>
<h3 id="eureka-配置"><a class="header-anchor" href="#eureka-配置">¶</a>Eureka 配置</h3>
<p>配置：<br>
<a href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka" target="_blank" rel="noopener">Configuring Eureka</a><br>
Eureka Server 开放的 REST 接口提供动态配置功能：<br>
<a href="https://github.com/Netflix/eureka/wiki/Eureka-REST-operations" target="_blank" rel="noopener">Eureka REST operations</a></p>
<h4 id="添加自定义元数据"><a class="header-anchor" href="#添加自定义元数据">¶</a>添加自定义元数据</h4>
<p>静态设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.metadata.mykey=myvalue</span><br></pre></td></tr></table></figure>
<p>设置后，相当于将<code>mykey:myvalue</code>添加到 eureka 的<code>metadata map</code>中。<br>
动态设置：<br>
需要提供一个自定义的</p>
<p>获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myValue = instanceInfo.getMetadata().get(&quot;myKey&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<h4 id="原生客户端的执行过程"><a class="header-anchor" href="#原生客户端的执行过程">¶</a>原生客户端的执行过程</h4>
<p>EurekaClient</p>
<h4 id="通过-di-依赖注入-使用-eurekaclient"><a class="header-anchor" href="#通过-di-依赖注入-使用-eurekaclient">¶</a>通过 DI（依赖注入）使用 EurekaClient</h4>
<p>ExampleEurekaGovernatedService</p>
<h4 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h4>
<p>DefaultEurekaClientConfig extends EurekaClientConfig<br>
EurekaServerConfig extends DefaultEurekaServerConfig<br>
CloudInstanceConfig extends PropertiesInstanceConfig<br>
MyDataCenterInstanceConfig extends PropertiesInstanceConfig</p>
<p>To dynamically do this, you will need to first provide your own custom implementation of the <code>EurekaInstanceConfig</code> interface. You can then overload the public Map&lt;String, String&gt; getMetadataMap() method to return a metadata map that contains the desired metadata values. See <code>PropertiesInstanceConfig</code> for an example implementation that provides the configuration based system above.</p>
<h2 id="网关-zuul"><a class="header-anchor" href="#网关-zuul">¶</a>网关 - Zuul</h2>
<h3 id="filter"><a class="header-anchor" href="#filter">¶</a>Filter</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Zuul%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Zuul组件结构" title="Zuul组件结构"><br>
Zuul 基于 Netty 开发，使用 filters 包含了核心业务逻辑，Filter 是使用 Groovy 写的，主要是为了提供动态编译加载的能力，filters 主要包含了三类：</p>
<ul>
<li>Inbound Filters execute before routing to the origin and can be used for things like authentication, dynamic routing, rate limiting, DDoS protection, metrics and decorating the request.</li>
<li>Endpoint Filters can be used to return static responses, otherwise the built-in <code>ProxyEndpoint</code> filter will route the request to the origin.</li>
<li>Outbound Filters execute after getting the response from the origin and can be used for metrics, decorating the response to the user or adding custom headers.</li>
<li>Async<br>
Filter 可以被同步执行或异步执行。<br>
如果 Filter 没有做太重的工作，可以通过继承<code>HttpInboundSyncFilter</code>或<code>HttpOutboundSyncFilter</code>来实现一种同步 Filter，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>Routes.groovy</code>；<br>
反之，如果需要从其他服务、缓存获取数据，或做一些复杂的计算工作，则最好继承<code>HttpInboundFilter</code>或<code>HttpOutboundFilter</code>，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>SampleServiceFilter.groovy</code>。</li>
</ul>
<h4 id="filter属性"><a class="header-anchor" href="#filter属性">¶</a>Filter属性</h4>
<p>Type: most often defines the stage during the routing flow when the Filter will be applied (although it can be any custom string)<br>
Async: define if the filter is sync or async, generally meaning do you need to make an external call or just doing work on-box<br>
Execution Order: applied within the Type, defines the order of execution across multiple Filters<br>
Criteria: the conditions required in order for the Filter to be executed<br>
Action: the action to be executed if the Criteria is met</p>
<h4 id="其他的一些例子"><a class="header-anchor" href="#其他的一些例子">¶</a>其他的一些例子</h4>
<p>这些例子是<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">zuul-sample</a>中的代码。</p>
<ul>
<li>DebugRequest - look for a query param to add extra debug logging for a request</li>
<li>Healthcheck - simple static endpoint filter that returns 200, if everything is bootstrapped correctly</li>
<li>ZuulResponseFilter - add informational headers to provide extra details on routing, request execution, status and error cause</li>
<li>GZipResponseFilter - can be enabled to gzip outbound responses</li>
<li>SurgicalDebugFilter - can be enabled to route specific requests to different hosts for debugging</li>
</ul>
<h3 id="缓存请求体"><a class="header-anchor" href="#缓存请求体">¶</a>缓存请求体</h3>
<p>默认情况下 Zuul 不会缓存请求体，因为 Filter 一般用到请求头就够了，但是如果需要在 inbound 中用到请求头或在 outbound 中用到响应头，则需要明确指定 Zuul 缓存，可以重写 Filter 的<code>needsBodyBuffered()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">boolean needsBodyBuffered(HttpResponseMessage input) &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络协议"><a class="header-anchor" href="#网络协议">¶</a>网络协议</h3>
<p>Zuul 支持修改暴露服务时使用的协议，使用方法见 sample 项目中的<code>SampleServerStartup</code>。</p>
<h3 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h3>
<p><a href="https://github.com/Netflix/zuul/wiki/Core-Features" target="_blank" rel="noopener">Core Features</a></p>
<h3 id="push-messaging"><a class="header-anchor" href="#push-messaging">¶</a>Push Messaging</h3>
<p>Push Messaging 机制可以支持从 Server 端推送消息到 Client 端，支持两种协议：<code>WebSockets</code> 和 <code>Server Sent Events (SSE)</code>。<br>
<a href="https://github.com/Netflix/zuul/wiki/Push-Messaging" target="_blank" rel="noopener">Push Messaging</a><br>
TODO</p>
<h2 id="负载均衡-ribbon"><a class="header-anchor" href="#负载均衡-ribbon">¶</a>负载均衡 - Ribbon</h2>
<h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3>
<p>原生 API 如何使用见：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started" target="_blank" rel="noopener">Netflix / ribbon - Getting Started</a><br>
如果是搭配 Spring Boot，可以参考 Spring Could 文档。</p>
<h3 id="组件结构及实现"><a class="header-anchor" href="#组件结构及实现">¶</a>组件结构及实现</h3>
<h4 id="rule"><a class="header-anchor" href="#rule">¶</a>Rule</h4>
<p>a logic component to determine which server to return from a list</p>
<ul>
<li>RoundRobinRule<br>
简单的轮询策略</li>
<li>AvailabilityFilteringRule<br>
这个 Rule 会跳过那些疑似“电路跳闸”或并发连接数已经很高的服务器。<br>
比如客户端的最后 3 次连接失败，客户端会认为该服务实例已经出现了类似“电路跳闸”的问题而导致无法提供服务，于是在接下来的 30 秒内均保持这种状态，如果之后还是连接失败，这个等待时间会指数增长（1min、2min、4min…）。</li>
<li>WeightedResponseTimeRule<br>
每个 Server 会根据其平均响应时间计算出一个权重，响应时间越长、比重越小，该 Rule 选择 Server 时会根据该权重来计算概率。</li>
</ul>
<h4 id="ping"><a class="header-anchor" href="#ping">¶</a>Ping</h4>
<p>a component running in background to ensure liveness of servers</p>
<h4 id="serverlist"><a class="header-anchor" href="#serverlist">¶</a>ServerList</h4>
<p>this can be static or dynamic. If it is dynamic (as used by <code>DynamicServerListLoadBalancer</code>), a background thread will refresh and filter the list at certain interval</p>
<ul>
<li>静态的 Server 列表<br>
可以在程序里写一个静态列表，将该列表设置到<code>BaseLoadBalancer.setServerList()</code>中。</li>
<li>ConfigurationBasedServerList<br>
默认的 ServerList 实现，可以通过 <code>Archaius ConfigurationManager</code>来设置 Server 列表。</li>
<li>DiscoveryEnabledNIWSServerList<br>
可以通过 Eureka Client 获取服务器列表，服务器集群必须通过 VipAddress 来定义：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="serverlistfilter"><a class="header-anchor" href="#serverlistfilter">¶</a>ServerListFilter</h4>
<p>ServerListFilter 是<code>DynamicServerListLoadBalancer</code>的组件，用于过滤从<code>ServerList</code>返回的服务器列表，现在有两种实现：</p>
<ul>
<li>
<p>ZoneAffinityServerListFilter<br>
过滤掉不在同一个 zone 内的服务器，除非 zone 内没有可用的服务器，这个 Filter 可以通过设置如下属性来启用（假设客户端名为 myclient、客户端的属性空间为 ribbon）：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myclient.ribbon.EnableZoneAffinity=true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ServerListSubsetFilter<br>
可以保证客户端只能看到<code>ServerList</code>返回的全体服务器的一个固定子集，如果有服务器可用性较弱，则可以定期用新服务器替换老服务器。可以通过设置以下属性启用该Filter：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br><span class="line">myClient.ribbon.NIWSServerListFilterClassName=com.netflix.loadbalancer.ServerListSubsetFilter</span><br><span class="line"># only show client 5 servers. default is 20.</span><br><span class="line">myClient.ribbon.ServerListSubsetFilter.size=5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码-v2"><a class="header-anchor" href="#源码-v2">¶</a>源码</h3>
<p>com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateListOfServers<br>
com.netflix.loadbalancer.ServerList#getUpdatedListOfServers<br>
com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery<br>
TODO</p>
<h2 id="hystrix"><a class="header-anchor" href="#hystrix">¶</a>Hystrix</h2>
<p><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">wiki</a></p>
<h2 id="turbine"><a class="header-anchor" href="#turbine">¶</a>Turbine</h2>
<p><a href="https://github.com/Netflix/Turbine/wiki" target="_blank" rel="noopener">wiki</a></p>
<h2 id="微服务基础设施-配置中心"><a class="header-anchor" href="#微服务基础设施-配置中心">¶</a>微服务基础设施 - 配置中心</h2>
<p>在设计微服务架构的时候常会提到一个<strong>无状态</strong>的概念，我们要求每个服务都是无状态的，因此可以做到一次编译到处运行，这也是<strong>云原生</strong>的基本要求——云环境下服务的实例集群可以弹性伸缩，</p>
<h3 id="配置分类"><a class="header-anchor" href="#配置分类">¶</a>配置分类</h3>
<p>应用服务中的配置主要分为静态配置和动态配置两类：<strong>静态配置</strong>主要和应用所处的环境有关，另外与其他服务器连接所需的用户名、密码等也需要在应用运行伊始便准备好，</p>
<ul>
<li>
<p>静态配置-环境相关：</p>
</li>
<li>
<p>静态配置-安全配置：</p>
</li>
<li>
<p>动态配置-应用配置：</p>
</li>
<li>
<p>动态配置-</p>
</li>
</ul>
<h3 id="apollo"><a class="header-anchor" href="#apollo">¶</a>Apollo</h3>
<h2 id="微服务基础设施-rpc"><a class="header-anchor" href="#微服务基础设施-rpc">¶</a>微服务基础设施 - RPC</h2>
<h2 id="微服务基础设施-后台框架"><a class="header-anchor" href="#微服务基础设施-后台框架">¶</a>微服务基础设施 - 后台框架</h2>
<h2 id="微服务基础设施-监控"><a class="header-anchor" href="#微服务基础设施-监控">¶</a>微服务基础设施 - 监控</h2>
<h2 id="微服务基础设施-服务-sla-service-level-agreement"><a class="header-anchor" href="#微服务基础设施-服务-sla-service-level-agreement">¶</a>微服务基础设施 - 服务 SLA（Service Level Agreement）</h2>
<p>熔断、限流、降级</p>
<h2 id="微服务基础设施-持续交付-continuous-delivery-简称-cd"><a class="header-anchor" href="#微服务基础设施-持续交付-continuous-delivery-简称-cd">¶</a>微服务基础设施 - 持续交付（Continuous delivery，简称 CD）</h2>
<h2 id="虚拟化"><a class="header-anchor" href="#虚拟化">¶</a>虚拟化</h2>
<p>虚拟化技术将一台服务器虚拟出多个虚拟机来提供服务。<br>
虚拟化技术包括计算虚拟化（服务器虚拟化）、存储虚拟化、网络虚拟化等。<br>
在实际讲解虚拟化之前，我们需要先解释一下隔离技术，在隔离的基础上我们才能任意粒度、自由地分配资源。</p>
<h3 id="隔离的作用"><a class="header-anchor" href="#隔离的作用">¶</a>隔离的作用</h3>
<ul>
<li>实现更细粒度的资源管理，比如将一个物理 CPU 的计算能力分给多台云主机，再将这台云主机卖给多个人。</li>
<li>控制故障的影响范围，一个 Tomcat 中可以运行多个 Web 服务器，一台 Web 服务器崩溃并不会令其他服务器一并崩溃。</li>
</ul>
<h3 id="隔离的分类"><a class="header-anchor" href="#隔离的分类">¶</a>隔离的分类</h3>
<p>广义的隔离技术包括如下几类</p>
<ul>
<li>硬件：虚拟机，如 KVM、Xen</li>
<li>操作系统：容器，如 LXC、Docker</li>
<li>Web 服务器：如 Servlet 容器</li>
<li>依赖版本：虚拟环境</li>
<li>运行环境：语言虚拟机，如JVM</li>
<li>语言：DSL</li>
</ul>
<p>前两种隔离是<strong>虚拟化技术</strong>的基础，主要用于物理资源的池化，进而弹性地分配给用户。<br>
作为一个例子，下面是一个运行时服务器中各抽象层次所采取的隔离技术的示意图：<br>
<img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%9A%94%E7%A6%BB%E5%B1%82%E6%AC%A1.png" alt="隔离层次" title="隔离层次"></p>
<p>上述隔离技术探讨的是单机环境下的资源分配，在微服务中聚焦的是如何提供更好的服务，因此可以在以下几个方向实施<strong>数据隔离</strong>：</p>
<ul>
<li>应用数据隔离<br>
多个业务服务器使用不同的数据库服务器，虽然有隔离故障、提高数据安全等好处，但是也引入了分布式事务的问题。</li>
<li>租户隔离<br>
提供统一的云服务，但是对不同的用户分组单独使用一些服务实例来提供服务，这样这些服务实例挂掉了也只会影响对应分组的用户，这样的用户分组称为<strong>租户</strong>。<br>
对于单独的一个租户，有独立服务独立数据库、共享服务独立数据库和共享服务共享数据库三种方式，可以根据成本和安全性来考虑选择哪种方案。</li>
</ul>
<p>对于业务服务器来说，更重要的是业务层面上的隔离：</p>
<ul>
<li>业务层<br>
平台与业务，业务与业务。</li>
<li>Provider，即服务提供者<br>
如订单服务和库存服务，使用上面提到的虚拟化来实现隔离，如果；</li>
<li>Consumer，即服务消费者<br>
下游服务调用多个上游服务（upstream）的时候，如果不对上游服务做服务隔离，一个服务出现问题，就会导致下游服务不可用，这种情况下，可选的隔离方案可以是给每个上游服务都准备一个线程池，称为<strong>线程池隔离</strong>：<br>
<img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%E9%9A%94%E7%A6%BB.png" alt="服务消费者端隔离" title="服务消费者端隔离"><br>
这种情况下，就算其中一个服务不可用导致线程池被迅速占满，下游服务仍可以根据预定义的降级方案来忽略这个服务。<br>
另一种可行的隔离方式是<strong>信号量隔离</strong>，常见的框架包括 Hytrix、Sentinel、以及 Resilience4j。</li>
</ul>
<h3 id="网络虚拟化"><a class="header-anchor" href="#网络虚拟化">¶</a>网络虚拟化</h3>
<p>我们暴露服务时使用的 IP 一般不是业务服务器网卡的真实 IP，而是另外配置的一个虚拟 IP，请求先被打到该 IP，然后由 LVS 等负载均衡技术来找到一个真实 IP。</p>
<p><strong>虚拟网卡</strong>通过实现一个字符设备来支持物理层，从而使应用层和物理层就通过这个字符设备联系起来，从这个字符设备读出来的就是虚拟网卡发往物理层的字节流，写入字符设备的数据作为字节流被虚拟网卡接收。<br>
虚拟网卡可以像网卡一样进行配置，常见的虚拟网卡有<strong>TUN/TAP</strong>和<strong>VEth</strong>。<br>
**虚拟网桥（Bridge）**也是一种虚拟设备，用于将多块网卡（包括虚拟网卡）连接起来。<br>
值得注意的是， Linux 中虚拟网桥是通用网络设备抽象的一种，能够绑定 IP 地址。因此在把网卡接入到网桥上后，网卡原来绑定的 IP 会失效，如果还要像原来那样收发数据，需要把该 IP 绑定到网桥上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加网桥br0</span><br><span class="line">ip link add br0 type bridge</span><br><span class="line"># 把网卡接入网桥，在把eth0和eth1接入到br0后，两个网卡就可以进行通信了。</span><br><span class="line">ip link set eth0 master br0</span><br><span class="line">ip link set eth1 master br0</span><br><span class="line"># 为网桥绑定ip</span><br><span class="line">ip addr add xx.xx.xx.xx/xx dev br0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">        inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:17ff:fe6b:bb81 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:17:6b:bb:81 txqueuelen 0 (Ethernet)</span><br><span class="line">        RX packets 0 bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">        TX packets 151 bytes 16620 (16.6 KB)</span><br><span class="line">        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br><span class="line"></span><br><span class="line">veth780318a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">        inet6 fe80::2c08:2dff:fea1:b996 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 2e:08:2d:a1:b9:96 txqueuelen 0 (Ethernet)</span><br><span class="line">        RX packets 0 bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">        TX packets 227 bytes 24338 (24.3 KB)</span><br><span class="line">        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br></pre></td></tr></table></figure>
<p>由 Docker Daemon 创建的虚拟网卡 docker0 其实就是一个网桥，可以使用 ethtool 查看设备类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -i docker0</span><br><span class="line"># 输出</span><br><span class="line">driver: bridge</span><br><span class="line">version: 2.3</span><br><span class="line">firmware-version: N/A</span><br><span class="line">expansion-rom-version: </span><br><span class="line">bus-info: N/A</span><br><span class="line">supports-statistics: no</span><br><span class="line">supports-test: no</span><br><span class="line">supports-eeprom-access: no</span><br><span class="line">supports-register-dump: no</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure>
<p>根据官方文档，Docker 通过 docker0 网桥在内核层连通了其他的物理或虚拟网卡，从而将所有容器和宿主都放到同一个物理网络下。<br>
veth780318a 是一个 VEth 设备，在容器启动后动态创建。每次启动一个容器的时候，Docker 会新建一对 VETH 设备，其中一个插在 docker0 上，另一个插在该容器里，然后从可用的地址段中选择一个空闲的 IP 地址分配给容器的 VEth，使用 docker0 的 IP 作为默认网关，从而实现宿主机和容器的双向数据通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -S veth780318a</span><br><span class="line"># 输出</span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 8</span><br><span class="line"></span><br><span class="line">$ ip link</span><br><span class="line"># 输出</span><br><span class="line">9: veth780318a@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 2e:08:2d:a1:b9:96 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>上边的 veth780318a@if8 的 peer_ifindex 为 9，和其对应的 VEth 设备的 peer_ifindex 为 8。</p>
<p>接下来可以进入容器查看是否存在对应的 peer_ifindex 为 9 的虚拟网卡（下面的是教程中的执行效果，我并没有执行成功，因为普通的容器镜像里面一般没有安装常用的网络工具）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@4c04df175784:/# ip route show</span><br><span class="line">default via 172.17.42.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.1</span><br><span class="line"></span><br><span class="line"># 从这里可以看出veth741a889的“伙伴”确实是在容器中，被重命名为eth0作为容器的网卡，并绑定了ip172.17.0.5，网关为网桥的ip172.17.42.1。</span><br><span class="line">root@4c04df175784:/# ifconfig</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:05</span><br><span class="line">          inet addr:172.17.0.5 Bcast:0.0.0.0 Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:5/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:648 (648.0 B) TX bytes:648 (648.0 B)</span><br><span class="line"></span><br><span class="line">root@4c04df175784:/# ethtool -S eth0</span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 24</span><br><span class="line"></span><br><span class="line">root@4c04df175784:/# ethtool -i eth0</span><br><span class="line">driver: veth</span><br><span class="line">version: 1.0</span><br><span class="line">firmware-version:</span><br><span class="line">bus-info:</span><br><span class="line">supports-statistics: yes</span><br><span class="line">supports-test: no</span><br><span class="line">supports-eeprom-access: no</span><br><span class="line">supports-register-dump: no</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure>
<h4 id="tun-tap-tunnel"><a class="header-anchor" href="#tun-tap-tunnel">¶</a>TUN/TAP(Tunnel)</h4>
<p>TUN 工作在 OSI 第三层(network)，实现了 IP 包的转发，相当于路由。<br>
TAP 工作在 OSI 第二层(data link)，实现了 Ethernet 帧的转发，相当于网桥。<br>
操作系统通过 TUN/TAP 设备向绑定该设备的用户空间的程序发送数据，反之，用户空间的程序也可以像操作硬件网络设备那样通过 TUN/TAP 设备发送数据，然后 TUN/TAP 设备会向操作系统的网络栈 push（或 inject）数据包，从而模拟从外部接受数据的过程。<br>
TUN 常用于 VPN，通过使用 TUN，VPN 能够在 IP 包被发出去之前将其进行加密。<br>
TAP 常用于虚拟机，为虚拟机提供网卡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip tuntap add mode tap # 创建tap</span><br><span class="line">ip tuntap add mode tun # 创建tun</span><br></pre></td></tr></table></figure>
<h4 id="veth-virtual-ethernet"><a class="header-anchor" href="#veth-virtual-ethernet">¶</a>VEth（Virtual Ethernet）</h4>
<p>VEth 是成对出现的，它的作用是反转通讯数据的方向，当数据从网络栈发送到 VEth 的一端时，数据被传送到 VEth 的另外一端流出，然后放回网络栈，相当于把需要接受的数据转换成需要发送的数据，<br>
常用于虚拟化中穿透 network namespace，把从一个 network namespace 发出的数据包转发到另一个 namespace。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth1 type veth peer name veth2 # 创建一对VEth，名为veth1和veth2</span><br></pre></td></tr></table></figure>
<h3 id="服务器虚拟化"><a class="header-anchor" href="#服务器虚拟化">¶</a>服务器虚拟化</h3>
<h4 id="插槽-内核和内核线程"><a class="header-anchor" href="#插槽-内核和内核线程">¶</a>插槽、内核和内核线程</h4>
<p>虚拟机如何分配 CPU 数：<a href="https://www.it610.com/article/3322954.htm" target="_blank" rel="noopener">vSphere 中 CPU 资源如何分配</a></p>
<h4 id="xen-kvm-与-lxc"><a class="header-anchor" href="#xen-kvm-与-lxc">¶</a>Xen、KVM 与 LXC</h4>
<p>TODO<br>
服务器虚拟化的三种比较常见的技术。<br>
Xen：<br>
KVM：<br>
LXC：</p>
<h4 id="lxc-的使用方法"><a class="header-anchor" href="#lxc-的使用方法">¶</a>LXC 的使用方法</h4>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lxc</span><br><span class="line">lxc-checkconfig # 安装完成后, 用这个命令检查系统是否可以使用 lxc</span><br><span class="line"># 我执行后没有发现missing的情况，如果没有挂载cgroup可能会出现“Cgroup namespace: CONFIG_CGROUP_NSmissing”的错误，可以挂载一个cgroup</span><br><span class="line">mount -t cgroup cgroup /mnt/cgroup</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc-create -n test -t debian # # 创建一个 debian 系统</span><br></pre></td></tr></table></figure>
<p>这样创建的容器默认在 /var/lib/lxc/test 中, 为了将容器创建在我们指定的位置, 可以写个简单的配置文件 lxc.conf, 里面只需要一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc.rootfs = /home/lxc/test</span><br></pre></td></tr></table></figure>
<p>然后重新创建容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc-create -n test -t debian -f /path/to/lxc.conf</span><br></pre></td></tr></table></figure>
<p>这样, 就把容器创建在了 /home/lxc/test 中了, /var/lib/lxc/test 中只有一个 config 文件(这个 config 文件可以作为 lxc-create 命令 -f 参数对应配置文件的参考)</p>
<ol start="3">
<li>启动容器<br>
启动后就进行入了虚拟机的控制台了. (果然像传说一样, 几秒就启动完成了 <sup>_</sup>)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-start -n test</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>停止容器<br>
在主机中输入停止的命令.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-stop -n test</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>销毁容器<br>
销毁之前, 可以通过 lxc-ls 来查看有几个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc-ls</span><br><span class="line">  test</span><br><span class="line">lxc-destroy -n test</span><br><span class="line">lxc-ls</span><br></pre></td></tr></table></figure>
<h4 id="使用示例-配置-python-uliweb-开发环境"><a class="header-anchor" href="#使用示例-配置-python-uliweb-开发环境">¶</a>使用示例（配置 python uliweb 开发环境）</h4>
<p>尝试在容器配置一次开发环境, 然后通过复制容器, 形成多个虚拟机.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 主机中</span><br><span class="line">root@debian-113:~# uliweb # 主机中没有安装uliweb 软件包</span><br><span class="line">-bash: uliweb: command not found</span><br><span class="line">root@debian-113:~# lxc-start -n test</span><br><span class="line"># 虚拟机登录界面, 输入用户名和密码</span><br><span class="line"># 虚拟机中</span><br><span class="line">root@test:~# apt-get install python</span><br><span class="line">root@test:~# apt-get install python-pip</span><br><span class="line">root@test:~# pip install Uliweb</span><br><span class="line">root@test:~# uliweb --version</span><br><span class="line">Uliweb version is 0.3.1</span><br></pre></td></tr></table></figure>
<p>主机中设置网桥, 虚拟机用桥接方式上网, 确保每个虚拟机有独立的 IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 主机中</span><br><span class="line">root@debian-113:~# lxc-stop -n test</span><br><span class="line">root@debian-113:~# apt-cache search bridge-utils</span><br><span class="line">root@debian-113:~# brctl addbr br0</span><br><span class="line"># 配置主机的网桥</span><br><span class="line">root@debian-113:/var/lib/lxc/test# cat /etc/network/interfaces </span><br><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># and how to activate them. For more information, see interfaces(5).</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">#auto eth0</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 追加的网桥配置    </span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 192.168.1.113</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">   bridge_ports eth0</span><br><span class="line">   bridge_stp on</span><br><span class="line">   bridge_fd 0</span><br><span class="line"></span><br><span class="line">root@debian-113:/var/lib/lxc/test# /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>
<p>配置容器的网络(也是在主机中修改容器的配置文件)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@debian-113:/var/lib/lxc/test# cat /var/lib/lxc/test/config</span><br><span class="line">... ... (很多默认生成的配置)</span><br><span class="line"># network &lt;-- 这个 network 相关的是要追加的</span><br><span class="line">lxc.network.type = veth</span><br><span class="line">lxc.network.flags = up</span><br><span class="line">lxc.network.link = br0</span><br><span class="line">lxc.network.name = eth0</span><br></pre></td></tr></table></figure>
<p>启动 Linux 容器, 进入虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@debian-113:/var/lib/lxc/test# lxc-start -n test</span><br><span class="line"># 登录进入虚拟机, 确认虚拟机的IP</span><br><span class="line">root@test:~# cat /etc/network/interfaces &lt;-- 默认是自动获取IP</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">root@test:~# ifconfig &lt;-- 我的机器自动分配的 192.168.1.167</span><br><span class="line"># 创建一个简单的uliweb工程</span><br><span class="line">root@test:~# cd /home/</span><br><span class="line">root@test:/home# mkdir CM-web</span><br><span class="line">root@test:/home# cd CM-web/</span><br><span class="line">root@test:/home/CM-web# uliweb makeproject test</span><br><span class="line">root@test:/home/CM-web# cd test/</span><br><span class="line">root@test:/home/CM-web/test# uliweb makeapp first_app</span><br><span class="line">root@test:/home/CM-web/test# uliweb runserver -h 0.0.0.0</span><br></pre></td></tr></table></figure>
<p>启动 Web 服务后, 就可以在主机的浏览器中 通过 <a href="http://192.168.1.167:8000/" target="_blank" rel="noopener">http://192.168.1.167:8000/</a> 来访问虚拟机中的 web 服务了.<br>
最后, 复制一个新的容器, 也就是再重新生成一个上面的 python uliweb 开发环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在主机中</span><br><span class="line">root@debian-113:~# cd /var/lib/lxc</span><br><span class="line">root@debian-113:/var/lib/lxc# cp -r test test2</span><br><span class="line"># 修改 test2/config 如下</span><br><span class="line">lxc.utsname = test2 &lt;-- 修改名称</span><br><span class="line">xc.rootfs = /home/lxc/test2 &lt;-- 修改 rootfs位置</span><br><span class="line">... ... &lt;-- 其它部分不用修改, 和 test 一样就行</span><br><span class="line">root@debian-113:/var/lib/lxc# cd /home/lxc/</span><br><span class="line">root@debian-113:/home/lxc# cp -r test test2 &lt;-- 重新复制一份 rootfs</span><br><span class="line">root@debian-113:/home/lxc# lxc-start -n test2 &lt;-- 启动 test2 虚拟机, 其中环境和 test一样, IP会不一样, 自动获取的</span><br><span class="line"># 进入 test2 虚拟机中, 可以直接启动之前的 uliweb 测试工程, 也可以从主机中访问其web服务.</span><br></pre></td></tr></table></figure>
<h3 id="lxc"><a class="header-anchor" href="#lxc">¶</a>LXC</h3>
<h4 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h4>
<p>通过 namespace 进行资源的隔离,Gust1 下的进程与 Guset2 下的进程是独立的，可以看作运行在两台物理机上一样。Contaniner 管理工具就是对 Guest 进行管理的(创建、销毁)。<br>
下图是对 LXC 架构的介绍。</p>
<h3 id="虚拟化管理平台"><a class="header-anchor" href="#虚拟化管理平台">¶</a>虚拟化管理平台</h3>
<p>虚拟化虽然可以用于自由分配资源，但是在生产环境内如果要一台一台机器安装及配置并不现实，一般来说都会尝试使用一个管理平台来自动化、批量化虚拟机的管理，或者从零开始使用 Libvirt 这样的库来实现自己需要的功能。<br>
如 <strong>Libvirt</strong> 库提供了一套用于管理虚拟机和其他虚拟化功能的 Linux API，它支持各种虚拟机监控程序，包括 Xen 和 KVM，以及 QEMU 和用于其他操作系统的一些虚拟产品。</p>
<h3 id="容器管理平台"><a class="header-anchor" href="#容器管理平台">¶</a>容器管理平台</h3>
<p>容器管理平台与其他虚拟化平台有所不同，因为和微服务关系密切，所以更关注高可用、弹性扩展等特性，如Docker Swam、Kubernetes。</p>
<h2 id="集群-分布式系统与云服务"><a class="header-anchor" href="#集群-分布式系统与云服务">¶</a>集群、分布式系统与云服务</h2>
<h3 id="集群与分布式系统"><a class="header-anchor" href="#集群与分布式系统">¶</a>集群与分布式系统</h3>
<p>集群与分布式系统是容易混淆的概念，很多时候会被混用，具体来说：</p>
<ul>
<li>集群是一个业务部署在多个服务器上，目标是高可用；</li>
<li>分布式系统是一个业务被拆分成多个子业务部署在不同的服务器上，目标是高性能。</li>
</ul>
<h3 id="数据层-分库分表"><a class="header-anchor" href="#数据层-分库分表">¶</a>数据层 - 分库分表</h3>
<h3 id="业务层-负载均衡"><a class="header-anchor" href="#业务层-负载均衡">¶</a>业务层 - 负载均衡</h3>
<p>二层：通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；<br>
三层：通过一个 VIP 地址接收请求，然后再分配到真实的 IP 地址；<br>
四层：传输层（一般是 TCP），通过 VIP+端口接收请求，然后再分配到真实的服务器，如 F5、LVS、seesaw；<br>
七层：应用层，通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器，如 Nginx（同样支持在四层工作）、HAProxy。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="常见实现"><a class="header-anchor" href="#常见实现">¶</a>常见实现</h3>
<ol>
<li><a href="https://cloud.spring.io/spring-cloud-netflix/reference/html/" target="_blank" rel="noopener">Document - Spring Cloud Netflix</a></li>
<li><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Netflix/eureka</a></li>
<li><a href="https://github.com/Netflix/zuul/blob/master/zuul-sample/src/main/java/com/netflix/zuul/sample/SampleServerStartup.java" target="_blank" rel="noopener">Netflix/zuul</a></li>
<li><a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">Netflix/ribbon</a></li>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Netflix / Hystrix</a></li>
<li><a href="https://github.com/Netflix/Turbine" target="_blank" rel="noopener">Netflix / Turbine</a></li>
</ol>
<h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3>
<ol>
<li><a href="https://github.com/cfregly/fluxcapacitor" target="_blank" rel="noopener">Flux Capacitor</a></li>
<li><a href="https://github.com/Netflix/recipes-rss" target="_blank" rel="noopener">Netflix Recipes-RSS Reader</a></li>
</ol>
<h3 id="隔离"><a class="header-anchor" href="#隔离">¶</a>隔离</h3>
<ol>
<li><a href="https://blog.csdn.net/ceshi986745/article/details/51787424" target="_blank" rel="noopener">猿学~程序员必知的六种隔离技术</a></li>
<li><a href="https://mp.weixin.qq.com/s/M1AePRMGWh49mXcN9MyXGw" target="_blank" rel="noopener">谈谈怎么做【服务隔离】</a></li>
</ol>
<h3 id="虚拟化-v2"><a class="header-anchor" href="#虚拟化-v2">¶</a>虚拟化</h3>
<ol>
<li>网络设备虚拟化<br>
<a href="http://blog.sina.com.cn/s/blog_b5e965e80102wos3.html" target="_blank" rel="noopener">网络设备设备虚拟化</a><br>
<a href="http://mp.weixin.qq.com/s/SC_j1cCm-kgOkCPKPjL5SQ" target="_blank" rel="noopener">一文搞懂网络虚拟化</a><br>
<a href="http://mp.weixin.qq.com/s/2KaHYOxyvZw1B6PhmjN_vw" target="_blank" rel="noopener">从 Bridge 到 OVS，探索虚拟交换机</a><br>
<a href="https://feisky.gitbooks.io/sdn/linux/virtual-device.html" target="_blank" rel="noopener">虚拟网络设备</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/index.html" target="_blank" rel="noopener">Linux 上的基础网络设备详解</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77840343" target="_blank" rel="noopener">Linux-虚拟网络设备-LinuxBridge</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77854651" target="_blank" rel="noopener">Linux-虚拟网络设备-tun/tap</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77650937" target="_blank" rel="noopener">Linux-虚拟网络设备-veth pair</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/78021303" target="_blank" rel="noopener">Linux-虚拟网络设备-OpenvSwitch(持续更新)</a></li>
<li>硬件虚拟化<br>
<a href="http://www.360doc.com/content/12/0213/14/7982302_186299987.shtml" target="_blank" rel="noopener">硬件虚拟化技术浅析</a><br>
<a href="http://veck.logdown.com/posts/200566-compare-of-kvm-and-lxc" target="_blank" rel="noopener">Compare of Xen, KVM, LXC and Traditional VM</a></li>
<li>Libvirt<br>
<a href="https://libvirt.org/" target="_blank" rel="noopener">Libvirt</a></li>
<li>Xen<br>
<a href="https://www.xenproject.org/" target="_blank" rel="noopener">Xen</a></li>
<li>KVM<br>
<a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">Kernel Virtual Machine（KVM）</a><br>
<a href="http://oenhan.com/kvm-src-1" target="_blank" rel="noopener">KVM 源代码分析 1:基本工作原理</a><br>
<a href="https://mp.weixin.qq.com/s/WzpH653x1hS9_PBVrIJFuw" target="_blank" rel="noopener">在 Centos6.5 上部署 kvm 虚拟化技术</a></li>
<li>LXC<br>
<a href="https://www.cnblogs.com/xidongyu/p/5767020.html" target="_blank" rel="noopener">LXC 的介绍</a><br>
<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LinuX Container（LXC）</a><br>
<a href="http://www.cnblogs.com/wang_yb/p/3923040.html" target="_blank" rel="noopener">Linux 容器的使用</a></li>
<li>Docker<br>
<a href="http://dockone.io/article/2050" target="_blank" rel="noopener">使用 NGINX 和 NGINX Plus 进行 Docker Swarm 负载均衡</a><br>
DockerSwarm 提供的负载均衡运行于每个节点上（应该是 DockerService 中的某个 Job），提供有限的负载均衡服务（TCP 层负载均衡），因此引入 Nginx 是有道理的。<br>
据说 Nginx Plus 可以实现<strong>服务弹性伸缩</strong>的功能，但还没试过。</li>
</ol>
<h3 id="集群-分布式系统与云服务-v2"><a class="header-anchor" href="#集群-分布式系统与云服务-v2">¶</a>集群、分布式系统与云服务</h3>
<ol>
<li>负载均衡<br>
<a href="https://github.com/google/seesaw" target="_blank" rel="noopener">google/seesaw</a></li>
<li>云原生<br>
<a href="https://mp.weixin.qq.com/s/gwXNBZzvygKV5xW1dfiQTA" target="_blank" rel="noopener">关于云原生，这是最详细的技术知识</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/caf2d9ed.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/caf2d9ed.html" itemprop="url">网络协议之 HTTP 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="http"><a class="header-anchor" href="#http">¶</a>HTTP</h2>
<h3 id="http-请求消息格式"><a class="header-anchor" href="#http-请求消息格式">¶</a>HTTP 请求消息格式</h3>
<h4 id="请求行"><a class="header-anchor" href="#请求行">¶</a>请求行</h4>
<h4 id="请求头"><a class="header-anchor" href="#请求头">¶</a>请求头</h4>
<h3 id="http-响应消息格式"><a class="header-anchor" href="#http-响应消息格式">¶</a>HTTP 响应消息格式</h3>
<h4 id="响应头-response-header"><a class="header-anchor" href="#响应头-response-header">¶</a>响应头（response header）</h4>
<ul>
<li>
<p>状态码<br>
状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br>
1xx：指示信息–表示请求已接收，继续处理。<br>
2xx：成功–表示请求已被成功接收、理解、接受。<br>
3xx：重定向–要完成请求必须进行更进一步的操作。<br>
4xx：客户端错误–请求有语法错误或请求无法实现。<br>
5xx：服务器端错误–服务器未能实现合法的请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Content-length<br>
在响应体(response-body)中表示 body 的长度，根据这个值就可以知道 body 的长度，客户端在接收 body 时，就可以根据这个长度来接收数据，而如果没有 Content-length，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了；如果是 HTTP1.1，响应头中可以用 Transfer-encoding 字段指定为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始处会标识出当前块的长度，body 不需要通过长度来指定。</p>
</li>
<li>
<p>Keep-Alive（持久连接）<br>
HTTP/1.0 使用非持久连接，HTTP/1.1 默认使用持久连接，每个连接建立后可以持续用于传送多个对象。<br>
适合设置 keepalive 连接的场景：客户端的一次请求需要访问同一 Server 多次，比如一个网页包含多个图片，需要访问图片服务器多次才能将这些图片下全。<br>
持久连接的条件：<strong>HTTP1.0</strong>响应不带<strong>Content-length</strong>、<strong>HTTP1.1</strong>非 chunked 且不带<strong>Content-length</strong>，这两种情况下 body 长度是不可知的，当服务端在输出完 body 之后，可以考虑使用长连接。另外，还需要考虑客户端的请求头中的<strong>Connection</strong>字段：如果为 close，则表示客户端需要关掉长连接；如果为 Keep-Alive，那么网关（一般是 Nginx）在输出完响应体之后，会设置当前连接的 keepalive 属性，然后等待客户端的下一次请求；如果没有 Connection 这个头，则根据协议，如果是 HTTP1.0，则默认为 close，如果为 HTTP1.1，则默认为 Keep-Alive。<br>
但是持久连接也不可能会一直等下去，如果客户端一直不发送数据，岂不是一直占用这个连接？所以一般网关会设置一个最大等待时间，这个值是通过<strong>keepalive_timeout</strong>属性来配置的，如果值为 0，则表示关闭 keepalive，此时不管 HTTP 版本、Connection 如何设置，都强制为 close。<br>
如果最后决定打开 keepalive，那么在响应头里也会包含有 Connection 域，如果值为 Close，则网关在响应完数据后，会主动关掉连接。<br>
总而言之：如果有办法知道服务器传来的长度，都是客户端首先断开，否则一直接收数据，直到服务端断开。<br>
<strong>http1.0</strong><br>
带 content-length，body 长度可知，客户端在接收 body 时，就可以依据这个长度来接受数据。接受完毕后，就表示这个请求完毕了。客户端主动调用 close 进入四次挥手。<br>
不带 content-length，body 长度不可知，客户端一直接受数据，直到服务端主动断开。<br>
<strong>http1.1</strong><br>
带 content-length，body 长度可知，客户端主动断开。<br>
带 Transfer-encoding: chunked，body 会被分成多个块，每块的开始会标识出当前块的长度，body 就不需要通过 content-length 来指定了。但依然可以知道 body 的长度 客户端主动断开。<br>
不带 Transfer-encoding：chunked，且不带 content-length，客户端接收数据，直到服务端主动断开连接。</p>
</li>
</ul>
<h3 id="缓存"><a class="header-anchor" href="#缓存">¶</a>缓存</h3>
<p>为了减少网络请求次数，一般可以引入缓存机制，HTTP 服务器通过两种实体头（Entity-Header）来实现缓存的过期：Expires 和 Cache-Control 的 max-age 子项。<br>
Expires/Cache-Control 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只是 Cache-Control 比 Expires 可以控制的多一些，而且 Cache-Control 会重写 Expires 的规则。<br>
相关 Header 如下所示：</p>
<ul>
<li>Cache-Control<br>
常用的值有：<br>
（1）max-age（单位为 s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。 （2）s-maxage（单位为 s）同 max-age，只用于共享缓存（比如 CDN 缓存），也就是说 max-age 用于普通缓存，而 s-maxage 用于代理缓存。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。 （3）public 指定响应会被缓存，并且在多用户间共享。如果没有指定 public 还是 private，则默认为 public。 （4）private 响应只作为私有的缓存，不能在用户间共享。如果要求 HTTP 认证，响应会自动设置为 private。 （5）no-cache 指定不缓存响应，表明资源不进行缓存，比如，设置了 no-cache 之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。 （6）no-store 表示绝对禁止缓存。一看就知道，如果用了这个命令，当然就是不会进行缓存啦！每次请求资源都要从服务器重新获取。 （7）must-revalidate 指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。</li>
<li>Expires<br>
缓存过期时间，用来指定资源到期的时间，是服务器端的具体时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。但在上面我们提到过 cache-control 的优先级更高。Expires 是 Web 服务器响应消息头字段，在响应 HTTP 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</li>
<li>Last-modified<br>
服务器端文件的最后修改时间，需要和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回码为 304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为 200，资源为服务器最新资源。</li>
<li>Etag<br>
根据实体内容生成一段 hash 字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改。<br>
为什么要使用 Etag 呢?Etag 主要为了解决 Last-Modified 无法解决的一些问题。<br>
一些文件也许会周期性的更改，但是它的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 Get。<br>
某些文件修改非常频繁，比如在秒以下的时间内进行修改（比方说 1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。<br>
某些服务器不能精确的得到文件的最后修改时间。<br>
缓存过程如下图所示。<br>
<img src="http://47.88.24.11/imgs/%E7%BD%91%E7%BB%9C/HTTP%E7%BC%93%E5%AD%98.jpg" alt="HTTP缓存" title="HTTP缓存"></li>
</ul>
<h2 id="http-1-1"><a class="header-anchor" href="#http-1-1">¶</a>HTTP/1.1</h2>
<h3 id="新增方法"><a class="header-anchor" href="#新增方法">¶</a>新增方法</h3>
<p>新增的 HTTP 方法有 PUT、PATCH、HEAD、OPTIONS、DELETE</p>
<h3 id="主机名标识"><a class="header-anchor" href="#主机名标识">¶</a>主机名标识</h3>
<p>在 HTTP/1.0 中 Host 头信息不是必须项，但 HTTP/1.1 中要求必须要有 Host 头信息。</p>
<h3 id="持久性连接"><a class="header-anchor" href="#持久性连接">¶</a>持久性连接</h3>
<p>正如前面所说，在 HTTP/1.0 中每个连接只有一个请求，且在这个请求完成后该连接就会被关闭，从而会导致严重的性能下降及延迟问题。HTTP/1.1 引入了对持久性连接的支持，例如：默认情况下连接不会被关闭，在多个连续的请求下它会保存连接的打开状态。想要关闭这些连接，需要将 Connection: close 加入到请求的头信息中。客户端通常会在最后一次请求中发送这个头信息用来安全的关闭连接。</p>
<h3 id="管道机制"><a class="header-anchor" href="#管道机制">¶</a>管道机制</h3>
<p>HTTP/1.1 也引入了对管道机制的支持，客户端可以向服务器发送多个请求，而无需等待来自同一连接上的服务器响应，并且当收到请求时服务器必须以相同的顺序来响应。但你可能会问客户端是怎么知道第一个响应下载完成和下一个响应内容开始的？要解决这个问题，必须要有 Content-Length 头信息，客户端可以用它来确定响应结束，然后开始等待下一个响应。</p>
<h2 id="http-2"><a class="header-anchor" href="#http-2">¶</a>HTTP/2</h2>
<p>HTTP/2 是专为低延迟传输的内容而设计，它与 HTTP/1.1 之间的差异如下所示：</p>
<h3 id="二进制协议"><a class="header-anchor" href="#二进制协议">¶</a>二进制协议</h3>
<p>HTTP/2 倾向于使用二进制协议来减少 HTTP/1.x 中的延迟。二进制协议更容易解析，但可读性相对较差。HTTP/2 中的数据块是帧和流。<br>
帧和流：HTTP 消息是由一个或多个帧组成的。有一个叫做 HEADERS 的帧存放元数据，真正的数据是放在 DATA 帧中的，帧类型定义在 the HTTP/2 specs（HTTP/2 规范），如 HEADERS、DATA、RST_STREAM、SETTINGS、PRIORITY 等。每个 HTTP/2 请求和响应都被赋予一个唯一的流 ID 且放入了帧中。帧就是一块二进制数据。一系列帧的集合就称为流。每个帧都有一个流 id，用于标识它属于哪一个流，每一个帧都有相同的头。同时，除了流标识是唯一的，值得一提的是，客户端发起的任何请求都使用奇数和服务器的响应是偶数的流 id。除了 HEADERS 和 DATA， 另外一个值得说一说帧类型是 RST_STREAM，它是一个特殊的帧类型，用于中止流，如客户端发送这儿帧来告诉服务器我不再需要这个流了。在 HTTP/1.1 中只有一种方式来实现服务器停止发送响应给客户端，那就是关闭连接引起延迟增加，因为后续的请求就需要打开一个新的连接。 在 HTTP/2 中，客户端可以使用 RST_FRAME 来停止接收指定的流而不关闭连接且还可以在此连接中接收其它流。</p>
<h3 id="多路复用"><a class="header-anchor" href="#多路复用">¶</a>多路复用</h3>
<p>由于 HTTP/2 现在是一个二进制协议，且是使用帧和流来实现请求和响应，一旦 TCP 连接打开了，所有的流都通过这一连接来进行异步的发送而不需要打开额外的连接。反过来，服务器的响应也是异步的方式，如响应是无序的、客户端使用流 id 来标识属于流的包。这就解决了存在于 HTTP/1.x 中 head-of-line 阻塞问题，如客户端将不必耗时等待请求，而其他请求将被处理。如下图所示。<br>
<img src="http://47.88.24.11/imgs/%E7%BD%91%E7%BB%9C/HTTP2.0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg" alt="HTTP2.0多路复用" title="HTTP2.0多路复用"></p>
<h3 id="hpack-头部压缩"><a class="header-anchor" href="#hpack-头部压缩">¶</a>HPACK 头部压缩</h3>
<p>它是一个单独的用于明确优化发送 Header RFC 的一部分。它的本质是，当我们同一个客户端不断的访问服务器时，在 header 中发送很多冗余的数据，有时 cookie 就增大 header，且消耗带宽和增加了延迟。为了解决这个问题， HTTP/2 引入了头部压缩。与请求和响应不同，header 不是使用 gzip 或 compress 等压缩格式，它有不同的机制，它使用了霍夫曼编码和在客户端和服务器维护的头部表来消除重复的 headers（如 User Agent)，在后续的请求中就只使用头部表中引用。它与 HTTP/1.1 中的一样，不过增加了伪 header，如 :method、:scheme、:host 和:path。</p>
<h3 id="服务器推送"><a class="header-anchor" href="#服务器推送">¶</a>服务器推送</h3>
<p>在服务器端，Server Push 是 HTTTP/2 的另外一个重要功能，我们知道，客户端是通过请求来获取资源的，它可以通过推送资源给客户端而不需客户端主动请求。例如，浏览器载入了一个页面，浏览器解析页面时发现了需要从服务器端载入的内容，接着它就发送一个请求来获取这些内容。Server Push 允许服务器推送数据来减少客户端请求。它是如何实现的呢，服务器在一个新的流中发送一个特殊的帧 PUSH_PROMISE，来通知客户端：“嘿，我要把这个资源发给你!你就不要请求了。”</p>
<h3 id="请求优先级"><a class="header-anchor" href="#请求优先级">¶</a>请求优先级</h3>
<p>客户端可以在一个打开的流中在流的 HEADERS 帧中放入优先级信息。在任何时间，客户端都可以发送一个 PRIORITY 的帧来改变流的优先级。如果没有优先级信息，服务器就会异步的处理请求，比如无序处理。如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。<br>
安全。大家对 HTTP/2 是否强制使用安全连接（通过 TLS）进行了充分的讨论。最后的决定是不强制使用。然而，大多数厂商表示，他们将只支持基于 TLS 的 HTTP/2。所以，尽管 HTTP/2 规范不需要加密，但它已经成为默认的强制执行的。在这种情况下，基于 TLS 实现的 HTTP/2 需要的 TLS 版本最低要求是 1.2。 因此必须有最低限度的密钥长度、临时密钥等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/10511d14.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/10511d14.html" itemprop="url">Linux 脚本基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T10:18:28+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>记录一些平时看到或用过的 shell 脚本技巧和代码片段。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/10511d14.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/59c58f8f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/59c58f8f.html" itemprop="url">Linux 三剑客-cut、awk 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在 awk、sed、cut 三个命令中，awk 是功能最强大的，基本能实现所有字符串操作，平时常用于较复杂的日志分析，不过比起别的命令来也会相对复杂一点。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/59c58f8f.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
