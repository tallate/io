<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/2/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/2/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/485e1bd7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/485e1bd7.html" itemprop="url">Vim使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T20:09:11+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  497 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>平时在Linux环境下待的久了，免不了和Vim打交道。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/485e1bd7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/283c6d00.html" itemprop="url">Linux 基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>并发（Concurrency）</h1>
<p>线程、进程，线程安全，进程同步，可见性，一致性，锁，信号量，并发，并行</p>
<h2 id="线程和进程"><a class="header-anchor" href="#线程和进程">¶</a>线程和进程</h2>
<p>从操作系统概念上说，<strong>线程</strong>是最小的可执行单位，也就是系统调度的最小单位。<strong>进程</strong>是资源分配的最小单位。线程是依赖进程存在的，共享进程内的资源，如内存，cpu，io等。在操作系统的发展过程中，为了提高系统的稳定性、吞吐量和安全性，操作系统内核和用户态做了隔离，例如Linux有内核线程，用户线程，内核进程，用户进程，从根本上Linux是没有线程的，线程对Linux系统来说是个特殊的进程。那么用户线程和内核线程是一一对应呢？从宏观上看是一一对应的，在用户态的每一个线程，都会在内核有对应的执行线程，但是由于资源的限制，用户态的线程和内核线程是多对一的关系。用户进程和内核进程也类似。具体怎样对应的，这里就不探讨了。<br>
为了提高操作系统的实时性，操作系统是以时间片轮转来实现任务调度的。理论上时间片内是不可以被中断的，可认为是cpu最小的单位执行时间。现代操作系统为了提高用户体验，线程都是抢占式的，而中断一般在时间片用完的时候发生。线程、进程和CPU都是多对一的关系，所以存在进程线程切换的问题。<br>
线程内部还是有自己内存空间的，所以有个概念叫线程内存模型。线程内部有自己私有的本地内存，故线程和线程之间的本地内存存在可见性问题。例如全局变量A在线程1修改后，线程2并不一定能拿到A的修改值，因为线程1会把全局变量A拷贝到本地内存，修改后并不会马上同步。在编译的时候，编译器为了优化，（例如利用超线程技术）可能会重排指令的执行顺序，这就会存在一致性了。</p>
<h2 id="线程安全"><a class="header-anchor" href="#线程安全">¶</a>线程安全</h2>
<p>在线程安全里面经常要讨论的两个问题就是：可见性和一致性。锁是什么东西呢？锁就是一道内存屏障，保证可见性和一致性的一种策略，由操作系统甚至更底层的硬件提供。加锁是消耗资源的，特别是在多核CPU上，现在多核CPU一般有3级缓存，一级缓存通常是单核独占的，而线程的本地内存很可能就保存在cpu的缓存里面，然而加锁就意味着保证可见性和一致性，需要中断同步数据，保证别人拿到的是最新修改值。由于用途不同，锁被设计成各种各样的，如互斥锁，读写锁，自旋锁，同步块，数据库的事务等，如果只要保证可见性的，可以不使用锁，在java里面可以使用volatile修饰全局变量。虽然在c／c＋＋，都有同样的修饰符，但是是不是一样的意思呢，请参考其他文章。</p>
<h2 id="死锁-deadlock"><a class="header-anchor" href="#死锁-deadlock">¶</a>死锁（deadlock）</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>多个进程竞争资源造成的互相等待情况。</p>
<h3 id="资源"><a class="header-anchor" href="#资源">¶</a>资源</h3>
<p>可重用性资源：可供重复使用多次的资源<br>
不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程使用完后自动释放<br>
可消耗资源:又叫临时性资源，它是在进程运行期间，由进程动态的创建和消耗的</p>
<h3 id="死锁产生的原因"><a class="header-anchor" href="#死锁产生的原因">¶</a>死锁产生的原因</h3>
<ol>
<li>系统资源的竞争<br>
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。<br>
主要是竞争可重用不可抢占式的资源和可消耗的资源。</li>
<li>进程运行推进顺序不合适<br>
进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</li>
</ol>
<h3 id="死锁产生的条件"><a class="header-anchor" href="#死锁产生的条件">¶</a>死锁产生的条件</h3>
<p><strong>互斥条件</strong> 一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>
<strong>请求与保持条件</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>
<strong>不可剥夺条件</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>
<strong>循环等待条件</strong> 若干进程间形成首尾相接循环等待资源的关系<br>
<strong>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong><br>
形象地说，就是有两个酒鬼，一个有开瓶器，一个有酒，这两种资源都只能被一个人占有（互斥），且用完之前不能被另一个人抢去（不可剥夺），他们互相等对方手上的资源（循环等待），但又不肯放开自己手上的资源（请求与保持），因此陷入了死锁。</p>
<h3 id="死锁避免"><a class="header-anchor" href="#死锁避免">¶</a>死锁避免</h3>
<p>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。<br>
书上给出了两种死锁避免策略</p>
<ol>
<li>进程启动拒绝<br>
若对每个资源，能满足现有所有进程再加上新进程的需求，则可以启动这个进程，否则拒绝</li>
<li>资源分配拒绝（银行家算法）</li>
</ol>
<h3 id="死锁预防"><a class="header-anchor" href="#死锁预防">¶</a>死锁预防</h3>
<p>死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。</p>
<ol>
<li>互斥<br>
不可能禁止，比如文件只允许互斥的写访问</li>
<li>占有且等待<br>
可以要求进程一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足，这样就不会再请求新资源了。</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<h1>持久化（Persistent）</h1>
<h2 id="存储器管理"><a class="header-anchor" href="#存储器管理">¶</a>存储器管理</h2>
<h2 id="文件系统"><a class="header-anchor" href="#文件系统">¶</a>文件系统</h2>
<h2 id="io-pipe"><a class="header-anchor" href="#io-pipe">¶</a>IO（pipe）</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line"></span><br><span class="line">int testPipe()&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line"></span><br><span class="line">    int *read_fd = &amp;fd[0];</span><br><span class="line">    int *write_fd = &amp;fd[1];</span><br><span class="line"></span><br><span class="line">    if(pipe(fd) == -1)&#123;</span><br><span class="line">        printf(&quot;pipe create failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == -1)&#123;</span><br><span class="line">        printf(&quot;fork failed&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char string[] = &quot;hahaha&quot;;</span><br><span class="line">        close(*read_fd);</span><br><span class="line">        count = write(*write_fd, string, sizeof(string));</span><br><span class="line">        printf(&quot;写了%d个字符\n&quot;, count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char buffer[100];</span><br><span class="line">        close(*write_fd);</span><br><span class="line">        count = read(*read_fd, buffer, sizeof(buffer));</span><br><span class="line">        printf(&quot;父进程接受到%d字节的数据:%s&quot;, count, buffer);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟内存"><a class="header-anchor" href="#虚拟内存">¶</a>虚拟内存</h2>
<h3 id="swap"><a class="header-anchor" href="#swap">¶</a>swap</h3>
<h1>虚拟化（Virtualization）</h1>
<h2 id="驱动管理"><a class="header-anchor" href="#驱动管理">¶</a>驱动管理</h2>
<h1>参考</h1>
<h2 id="linux应用"><a class="header-anchor" href="#linux应用">¶</a>Linux应用</h2>
<ol>
<li>IO模型<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="noopener">使用异步 I/O 大大提高应用程序的性能</a><br>
<a href="https://blog.csdn.net/historyasamirror/article/details/4270633" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞</a><br>
<a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br>
<a href="https://blog.csdn.net/suifeng3051/article/details/52779886" target="_blank" rel="noopener">关于网络IO中的同步、异步、阻塞、非阻塞之间的区别</a><br>
select, poll, epoll之间的区别整理 <a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">https://www.cnblogs.com/Anker/p/3265058.html</a><br>
<a href="https://www.cnblogs.com/linganxiong/p/5583415.html" target="_blank" rel="noopener">select、poll、epoll、kqueue多讲了一种SIGIO</a></li>
<li>虚拟内存<br>
<a href="https://www.linux.com/news/all-about-linux-swap-space" target="_blank" rel="noopener">All about Linux swap space</a><br>
<a href="https://wiki.archlinux.org/index.php/swap" target="_blank" rel="noopener">Swap</a><br>
<a href="https://haydenjames.io/linux-performance-almost-always-add-swap-space/" target="_blank" rel="noopener">Linux Performance: Why You Should Almost Always Add Swap Space</a></li>
<li>演进<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-kernel-advances/index.html" target="_blank" rel="noopener">Linux 内核的发展 介绍 2.6.28 和 2.6.29 版本中的新特性</a><br>
<a href="https://linux.cn/article-6179-1.html" target="_blank" rel="noopener">对 Linux 内核的发展方向的展望 - Linux 4.2</a></li>
<li>运维<br>
<a href="https://juejin.im/entry/5c9780335188252d941493d3" target="_blank" rel="noopener">老司机告诉你：正规的运维工作是什么的?</a></li>
<li>并发<br>
<a href="https://blog.csdn.net/u011677209/article/details/78082722" target="_blank" rel="noopener">Linux原子操作 atomic_cmpxchg()/Atomic_read()/Atomic_set()/Atomic_add()/Atomic_sub()</a></li>
<li>隔离<br>
<a href="https://www.v2ex.com/member/jerry017cn/topics" target="_blank" rel="noopener">cgroup - jerry017cn</a></li>
</ol>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a>操作系统</h2>
<ol>
<li>分时和实时操作系统<br>
<a href="https://www.osrtos.com/" target="_blank" rel="noopener">List of open source real-time operating systems</a></li>
<li>操作系统概念<br>
<a href="https://www.cnblogs.com/leesf456/p/5375198.html" target="_blank" rel="noopener">【操作系统】操作系统综述（一）</a></li>
<li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters" target="_blank" rel="noopener">Operating Systems: Three Easy Pieces</a></li>
</ol>
<h3 id="concurrency"><a class="header-anchor" href="#concurrency">¶</a>Concurrency</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5413517.html" target="_blank" rel="noopener">【操作系统】进程管理（二）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5605193.html" target="_blank" rel="noopener">【操作系统】处理机调度与死锁（三）</a></li>
</ol>
<h3 id="persistent"><a class="header-anchor" href="#persistent">¶</a>Persistent</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5616041.html" target="_blank" rel="noopener">【操作系统】存储器管理（四）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5626339.html" target="_blank" rel="noopener">【操作系统】文件管理（六）</a></li>
</ol>
<h3 id="virtualization"><a class="header-anchor" href="#virtualization">¶</a>Virtualization</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5622859.html" target="_blank" rel="noopener">【操作系统】设备管理（五）</a></li>
</ol>
<h2 id="linux内核"><a class="header-anchor" href="#linux内核">¶</a>Linux内核</h2>
<ol>
<li>哈工大操作系统<br>
<a href="https://mooc.study.163.com/course/1000002004?_trace_c_p_k2_=6a6064778bf54c5f98396d86c4146823#/info" target="_blank" rel="noopener">操作系统之基础</a><br>
<a href="https://www.shiyanlou.com/courses/115" target="_blank" rel="noopener">操作系统原理与实践</a></li>
<li>NJU<br>
<a href="https://nju-ics.gitbooks.io/ics2016-programming-assignment/content/1.1.html" target="_blank" rel="noopener">在开始愉快的PA之旅之前</a><br>
<a href="https://github.com/NJU-ProjectN/LiteNES" target="_blank" rel="noopener">NJU-ProjectN</a></li>
<li><a href="http://www.linfo.org/index.html" target="_blank" rel="noopener">The Linux Information Project</a></li>
<li><a href="https://www.kernel.org/" target="_blank" rel="noopener">The Linux Kernel Archives</a></li>
<li><a href="https://tinylab.gitbooks.io/linux-doc/content/zh-cn/" target="_blank" rel="noopener">Linux 内核文档（中文版）</a></li>
<li><a href="http://www.superfrink.net/athenaeum/OS-FAQ/os-faq.html" target="_blank" rel="noopener">Write Your Own Operating System</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/" target="_blank" rel="noopener">6.828: Operating System Engineering</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1a8406e8.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1a8406e8.html" itemprop="url">异步任务和并发安全容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  183 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="无锁栈"><a class="header-anchor" href="#无锁栈">¶</a>无锁栈</h2>
<h3 id="treiber-stack"><a class="header-anchor" href="#treiber-stack">¶</a>Treiber Stack</h3>
<h2 id="无锁队列"><a class="header-anchor" href="#无锁队列">¶</a>无锁队列</h2>
<h3 id="arrayblockingqueue-和-linkedblockingqueue"><a class="header-anchor" href="#arrayblockingqueue-和-linkedblockingqueue">¶</a>ArrayBlockingQueue 和 LinkedBlockingQueue</h3>
<h3 id="disruptor"><a class="header-anchor" href="#disruptor">¶</a>Disruptor</h3>
<ul>
<li>
<p>无锁内存队列</p>
</li>
<li>
<p>优化CPU伪共享</p>
</li>
<li>
<p>RingBuffer<br>
环形队列，使用定长数组存储，长度是2^N，可以使用位运算提升性能。<br>
无锁：无锁设计减少了竞争。<br>
预热：预先填充好任务/事件，不需要像链表那样每次添加/删除节点时去创建/回收节点，从而可以避免一定的垃圾回收。<br>
缓存行填充解决了CPU伪共享问题。</p>
</li>
<li>
<p>WorkPool<br>
存储WorkProcessor的池子，Disruptor可以通过Executor并发启动每一个WorkProcessor</p>
</li>
<li>
<p>WorkProcessor<br>
从RindBuffer消费事件/任务，并交由WorkHandler处理。</p>
</li>
<li>
<p>WorkHandler<br>
处理任务的工作者，根据任务类型委托给不同的EventHandler。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4e8abc71.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/4e8abc71.html" itemprop="url">异步任务和线程状态机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T21:07:49+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程和状态机"><a class="header-anchor" href="#线程和状态机">¶</a>线程和状态机</h2>
<h3 id="线程和线程任务"><a class="header-anchor" href="#线程和线程任务">¶</a>线程和线程任务</h3>
<p>线程任务区别于线程，可以理解为线程需要执行的逻辑，类似Thread中要执行的Runnable。</p>
<h3 id="前台线程-用户线程-和后台线程-守护线程"><a class="header-anchor" href="#前台线程-用户线程-和后台线程-守护线程">¶</a>前台线程（用户线程）和后台线程（守护线程）</h3>
<p>jvm不区分主线程和用户线程，各个线程是独立的，不同于win32的线程模型。jvm把线程分为前台线程和后台线程，前台线程官方术语叫<strong>用户线程（User）</strong>，后台线程则叫<strong>守护线程（Daemon）</strong>，jvm结束的条件是 <strong>所有的前台线程结束</strong> 。<br>
Java 中线程分为两类，分别为 Daemon 线程（守护线程）和 User 线程（用户线程），类似于Unix中的用户进程和守护进程，实际上它们的区别不大，只是它们的含义不同，用户线程为用户服务，守护线程为其他线程服务。在 JVM 启动时候会调用 main 函数，main 函数所在的线程是一个用户线程，这个是我们可以看到的线程，其实 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程（严格说属于 JVM 线程），并且在所有用户线程都退出后守护线程也一并退出。<br>
守护线程和用户线程的<strong>区别</strong>：只有且仅有当最后一个用户线程结束后JVM会正常退出，而不管当前是否有守护线程。<br>
正常构建的线程都是前台线程，可以在线程未开始前调用Thread类的setDaemon(true)方法将线程改变为后台守护线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.setDaemon(true);</span><br></pre></td></tr></table></figure>
<p>下面的例子区分了守护线程和用户线程的特点（注意不要使用JUNIT测试，因为JUNIT在主线程退出后会直接退出JVM）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 主线程退出后JVM不会退出</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      for(;;)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  //启动子线</span><br><span class="line">  thread.start();</span><br><span class="line">  System.out.print(&quot;main thread is over&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子证明主线程退出、而仍存在子线程运行时JVM是不会退出的。下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 主线程退出后不管守护线程是否仍在运行、直接退出JVM</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      for (; ; ) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  //启动子线</span><br><span class="line">  thread.setDaemon(true);</span><br><span class="line">  thread.start();</span><br><span class="line">  System.out.print(&quot;main thread is over&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果你想在主线程结束后 JVM 进程马上结束，那么创建线程的时候可以设置线程为守护线程，否则如果希望主线程结束后子线程继续工作，等子线程结束后在让 JVM 进程结束那么就设置子线程为用户线程。</p>
<h4 id="守护线程原理"><a class="header-anchor" href="#守护线程原理">¶</a>守护线程原理</h4>
<p>Java 中在 main 线程运行结束后，JVM 会自动启动一个叫做 DestroyJavaVM 线程，该线程会等待所有用户线程结束后终止 JVM 进程。<br>
翻开 JVM 的代码，最终会调用到 JavaMain 这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int JNICALL</span><br><span class="line">JavaMain(void * _args)</span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">    //执行Java中的main函数 </span><br><span class="line">    (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br><span class="line"></span><br><span class="line">    //main函数返回值</span><br><span class="line">    ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;</span><br><span class="line"></span><br><span class="line">    //等待所有非守护线程结束，然后销毁JVM进程</span><br><span class="line">    LEAVE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LEAVE 是 C 语言里面的一个宏定义，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define LEAVE() \</span><br><span class="line">    do &#123; \</span><br><span class="line">        if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) &#123; \</span><br><span class="line">            JLI_ReportErrorMessage(JVM_ERROR2); \</span><br><span class="line">            ret = 1; \</span><br><span class="line">        &#125; \</span><br><span class="line">        if (JNI_TRUE) &#123; \</span><br><span class="line">            (*vm)-&gt;DestroyJavaVM(vm); \</span><br><span class="line">            return ret; \</span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; while (JNI_FALSE)</span><br></pre></td></tr></table></figure>
<p>上面宏的作用实际是创建了一个名字叫做 DestroyJavaVM 的线程来等待所有用户线程结束。</p>
<h3 id="线程上下文切换"><a class="header-anchor" href="#线程上下文切换">¶</a>线程上下文切换</h3>
<p>在多线程编程中，线程个数一般都大于 CPU 个数，而每个 CPU 同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行，CPU 资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片，在时间片内占用 CPU 执行任务。当前线程的时间片使用完毕后当前就会处于就绪状态并让出 CPU 让其它线程占用，这就是上下文切换，从当前线程的上下文切换到了其它线程。<br>
那么就有一个问题让出 CPU 的线程等下次轮到自己占有 CPU 时候如何知道之前运行到哪里了？所以在切换线程上下文时候需要保存当前线程的执行现场，当再次执行时候根据保存的执行现场信息恢复执行现场。</p>
<h4 id="线程上下文切换时机"><a class="header-anchor" href="#线程上下文切换时机">¶</a>线程上下文切换时机</h4>
<ul>
<li>当前线程的 CPU 时间片使用完毕处于就绪状态时候；</li>
<li>当前线程被其它线程中断时候。</li>
</ul>
<h4 id="线程上下文切换开销问题"><a class="header-anchor" href="#线程上下文切换开销问题">¶</a>线程上下文切换开销问题</h4>
<p>由于线程切换是有开销的，所以并不是开的线程越多越好，比如如果机器是4核心的，你开启了100个线程，那么同时执行的只有4个线程，这100个线程会来回切换线程上下文来共享这四个 CPU。</p>
<h3 id="java如何执行线程任务"><a class="header-anchor" href="#java如何执行线程任务">¶</a>Java如何执行线程任务</h3>
<p>这个问题其实和一个经典面试题很像——如何创建线程？<br>
其实Java中创建线程的方式只有一种，就是<code>new Thread</code>，其他的所谓创建线程都是指的如何调度线程，包括Runnable、Future、Callable，及各种线程池ExecutorService、ForkJoinPool等。</p>
<h4 id="runnable和thread"><a class="header-anchor" href="#runnable和thread">¶</a>Runnable和Thread</h4>
<p>使用Runnable比直接使用Thread更加灵活：</p>
<ul>
<li>Thread继承的方式下，run()内获取当前线程可以直接使用this，但是Java不支持多重继承，如果继承了Thread就不能再继承其他类了，且任务与代码没有分离，当多个线程执行一样的任务时需要实例化多个继承的线程类。</li>
<li>实现Runnable的方式下，任务与代码分离，run()内获取当前线程必须使用Thread.currentThread()。</li>
</ul>
<h4 id="callable和future"><a class="header-anchor" href="#callable和future">¶</a>Callable和Future</h4>
<p>Java5使用Callable来执行逻辑、返回线程执行结果，且支持声明抛出异常，Future接口是Callable的执行器，可以获取Callable中call()的返回值，它有一个实现类FutureTask：</p>
<ul>
<li>可以提供给Thread调度，因为FutureTask实现了Runnable接口；</li>
<li>控制关联的Callable，比如calcel()可以取消Callable任务、get()可以获取call()方法的返回值（阻塞直到call()返回）。</li>
</ul>
<h3 id="java如何实现多线程？"><a class="header-anchor" href="#java如何实现多线程？">¶</a>Java如何实现多线程？</h3>
<p>Java并不依靠JVM实现多线程，Thread的<code>start0()</code>方法是一个native方法，这意味着线程的执行是平台相关的。<br>
JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p>
<p>Java 中在 main 线程运行结束后，JVM 会自动启动一个叫做 <strong>DestroyJavaVM 线程</strong>，该线程会等待所有用户线程结束后终止 JVM 进程，下面是 JVM 中的相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int JNICALL</span><br><span class="line">JavaMain(void * _args)</span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">    //执行Java中的main函数 </span><br><span class="line">    (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br><span class="line"></span><br><span class="line">    //main函数返回值</span><br><span class="line">    ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;</span><br><span class="line"></span><br><span class="line">    //等待所有非守护线程结束，然后销毁JVM进程</span><br><span class="line">    LEAVE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LEAVE 是 C 语言里面的一个宏定义，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define LEAVE() \</span><br><span class="line">    do &#123; \</span><br><span class="line">        if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) &#123; \</span><br><span class="line">            JLI_ReportErrorMessage(JVM_ERROR2); \</span><br><span class="line">            ret = 1; \</span><br><span class="line">        &#125; \</span><br><span class="line">        if (JNI_TRUE) &#123; \</span><br><span class="line">            (*vm)-&gt;DestroyJavaVM(vm); \</span><br><span class="line">            return ret; \</span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; while (JNI_FALSE)</span><br></pre></td></tr></table></figure>
<p>上面宏的作用实际是创建了一个名字叫做 DestroyJavaVM 的线程来等待所有用户线程结束。</p>
<p>在 Tomcat 的 NIO 实现 NioEndpoint 中会开启一组接受线程用来接受用户的链接请求和一组处理线程负责具体处理用户请求，那么这些线程是用户线程还是守护线程呢？下面我们看下 NioEndpoint 的 startInternal 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void startInternal() throws Exception &#123;</span><br><span class="line">    if (!running) &#123;</span><br><span class="line">        running = true;</span><br><span class="line">        paused = false;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //创建处理线程</span><br><span class="line">        pollers = new Poller[getPollerThreadCount()];</span><br><span class="line">        for (int i=0; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = new Poller();</span><br><span class="line">            Thread pollerThread = new Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(true);//声明为守护线程</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        //启动接受线程</span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected final void startAcceptorThreads() &#123;</span><br><span class="line">    int count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = new Acceptor[count];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        acceptors[i] = createAcceptor();</span><br><span class="line">        String threadName = getName() + &quot;-Acceptor-&quot; + i;</span><br><span class="line">        acceptors[i].setThreadName(threadName);</span><br><span class="line">        Thread t = new Thread(acceptors[i], threadName);</span><br><span class="line">        t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">        t.setDaemon(getDaemon());//设置是否为守护线程，默认为守护线程</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean daemon = true;</span><br><span class="line">public void setDaemon(boolean b) &#123; daemon = b; &#125;</span><br><span class="line">public boolean getDaemon() &#123; return daemon; &#125;</span><br></pre></td></tr></table></figure>
<p>如上代码也就是说默认情况下接受线程和处理线程都是守护线程，这意味着当 Tomact 收到 shutdown 命令后 Tomact 进程会马上消亡，而不会等处理线程处理完当前的请求。</p>
<h3 id="有限状态机-fsm"><a class="header-anchor" href="#有限状态机-fsm">¶</a>有限状态机（FSM）</h3>
<p>有限状态机也称为FSM(Finite State Machine)，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。FSM可以把模型的多状态、多状态建的转换条件解耦。可以使维护变得容易，代码也更加具有可读性。<br>
<img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%844%E8%A6%81%E7%B4%A0.png" alt="有限状态机的4要素" title="有限状态机的4要素"></p>
<h4 id="要素"><a class="header-anchor" href="#要素">¶</a>要素</h4>
<p>状态机可归纳为4个要素：现态、条件、动作、次态。</p>
<ul>
<li>现态：指当前流程所处的状态，包括起始、中间、终结状态。</li>
<li>条件：也可称为事件；当一个条件被满足时，将会触发一个动作并执行一次状态的迁移。</li>
<li>动作：当条件满足后要执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。</li>
<li>次态：当条件满足后要迁往的状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li>
</ul>
<h4 id="状态"><a class="header-anchor" href="#状态">¶</a>状态</h4>
<p>状态表示流程中的持久状态，流程图上的每一个圈代表一个状态。</p>
<ul>
<li>初始状态： 流程开始时的某一状态；</li>
<li>中间状态： 流程中间过程的某一状态；</li>
<li>终结状态： 流程完成时的某一状态。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>状态必须是一个持久状态，而不能是一个临时状态；</li>
<li>终结状态不能是中间状态，不能继续进行流程流转；</li>
<li>状态划分合理，不要把多个状态强制合并为一个状态；</li>
<li>状态尽量精简，同一状态的不同情况可以用其它字段表示。</li>
</ul>
<h4 id="动作"><a class="header-anchor" href="#动作">¶</a>动作</h4>
<p>动作的三要素：角色、现态、次态，流程图上的每一条线代表一个动作。</p>
<ul>
<li>角色： 谁发起的这个操作，可以是用户、定时任务等；</li>
<li>现态： 触发动作时当前的状态，是执行动作的前提条件；</li>
<li>次态： 完成动作后达到的状态，是执行动作的最终目标。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>每个动作执行前，必须检查当前状态和触发动作状态的一致性；</li>
<li>状态机的状态更改，只能通过动作进行，其它操作都是不符合规范的；</li>
<li>需要添加分布式锁保证动作的原子性，添加数据库事务保证数据的一致性；</li>
<li>类似的动作（比如操作用户、请求参数、动作含义等）可以合并为一个动作，并根据动作执行结果转向不同的状态。</li>
</ul>
<h3 id="线程状态"><a class="header-anchor" href="#线程状态">¶</a>线程状态</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC.jpg" alt="线程状态流转" title="线程状态流转"></p>
<ul>
<li><strong>创建（NEW）</strong>：实例化线程对象，此时还没有调用start执行线程。</li>
<li><strong>就绪（RUNNABLE）</strong>：调用了线程的start，此时调度器还没来得及给线程分配时间片，线程还处于就绪队列中。</li>
<li><strong>运行（RUNNABLE）</strong>：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li><strong>阻塞</strong>：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep、suspend、wait等方法都可以导致线程阻塞。阻塞分三种情况：
<ol>
<li>等待阻塞（WAITING）：调用wait，让线程等待某工作的完成后调用notify通知；</li>
<li>同步阻塞（BLOCKED）：synchronized获取监视器锁失败，进入同步阻塞状态，直到其他线程放开监视器锁；</li>
<li>其他阻塞（TIMED_WAITING）：sleep、join或发出了IO请求时，线程阻塞，直到sleep超时、join等待线程终止 / 超时、或IO处理完毕，线程重新进入就绪状态。</li>
</ol>
</li>
<li><strong>死亡（TERMINATED）</strong>：一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</li>
</ul>
<blockquote>
<p>Java线程状态和操作系统线程状态并不是一一映射的，这些状态是由JVM维护的，并不是调磁盘IO系统调用线程就进入BLOCKED状态。<br>
Java中线程没有RUNNING状态，RUNNABLE映射了操作系统的READY、RUNNING和WAITING三个状态，实际上RUNNABLE表示线程正在Java虚拟机中执行，但它可能正在等待来自操作系统的其他资源，比如处理器、硬盘、网卡等。</p>
</blockquote>
<h3 id="线程状态模拟"><a class="header-anchor" href="#线程状态模拟">¶</a>线程状态模拟</h3>
<ul>
<li>RUNNABLE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInBlockedIOState() throws InterruptedException &#123;</span><br><span class="line">    Scanner in = new Scanner(System.in);</span><br><span class="line">    // 创建一个名为“输入输出”的线程t</span><br><span class="line">    Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 命令行中的阻塞读</span><br><span class="line">                String input = in.nextLine();</span><br><span class="line">                System.out.println(input);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (in != null) &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;输入输出&quot;); // 线程的名字</span><br><span class="line"></span><br><span class="line">    // 启动</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    // 确保run已经得到执行</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">    // 状态为RUNNABLE</span><br><span class="line">    assertThat(t.getState(), IsEqual.equalTo(State.RUNNABLE));</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testBlockedSocketState() throws Exception &#123;</span><br><span class="line">    Thread serverThread = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            ServerSocket serverSocket = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                serverSocket = new ServerSocket(10086);</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    // 阻塞的accept方法</span><br><span class="line">                    Socket socket = serverSocket.accept();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;socket线程&quot;); // 线程的名字</span><br><span class="line">    serverThread.start();</span><br><span class="line"></span><br><span class="line">    // 确保run已经得到执行</span><br><span class="line">    Thread.sleep(500);</span><br><span class="line"></span><br><span class="line">    // 状态为RUNNABLE</span><br><span class="line">    assertThat(serverThread.getState(), IsEqual.equalTo(Thread.State.RUNNABLE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WAITING状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testInWaiting() throws InterruptedException &#123;</span><br><span class="line">    Object lock = new Object();</span><br><span class="line">    Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(&quot;wait finished&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;等待&quot;); // 线程的名字</span><br><span class="line"></span><br><span class="line">    // 启动</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    // 确保run已经得到执行</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">    // 状态为RUNNABLE</span><br><span class="line">    assertThat(t.getState(), IsEqual.equalTo(State.WAITING));</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        lock.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程调度方法"><a class="header-anchor" href="#线程调度方法">¶</a>线程调度方法</h3>
<p>Thread类有许多方法用于调度线程：<br>
<strong>sleep（睡眠）</strong> 使线程进入阻塞状态，直到睡眠时间结束<br>
<strong>wait（等待）</strong> 使线程进入等待状态，直到别的线程调用锁定对象的notify()或notifyall()方法<br>
<strong>yield（让步）</strong> 提醒线程调度器给别的线程分配更多时间<br>
<strong>join（加入）</strong> 若调用自身的join()，则等待其他线程终止；若调用了别的对象的join()，则当前线程进入阻塞状态，直到另一个线程运行结束。<br>
<strong>notify（唤醒）</strong> 唤醒此对象监视器上等待的一个线程<br>
<strong>interrupt（中断）</strong> 中断使线程离开阻塞状态，并准备下一次运行<br>
<strong>run</strong> 和 <strong>start</strong>：run定义了线程的执行逻辑，是由用户定义的，是一个回调函数，当调用start方法后并没有立刻执行而是处于就绪状态，这个就绪状态是指该线程已经获取了除 CPU 资源外的其它资源，等获取CPU资源后才会真正处于运行状态，这个资源一般指由操作系统分配的CPU时间片，当run方法执行完毕后，该线程就处于终止状态了。</p>
<h3 id="监视器锁"><a class="header-anchor" href="#监视器锁">¶</a>监视器锁</h3>
<p>在具体探究线程状态流转前，首先需要明确一个**监视器锁（monitor）**的概念，每个对象（包括Class）都持有一个monitor锁，因为每个对象都属于共享资源，多线程读写一个对象的属性，必然面临并发问题。</p>
<h3 id="线程的终止"><a class="header-anchor" href="#线程的终止">¶</a>线程的终止</h3>
<p>有三种方式：stop、interrupt和设置条件变量。</p>
<ol>
<li>stop<br>
不推荐</li>
<li>interrupt</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置条件变量<br>
创建线程任务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class StopTest implements Runnable &#123;</span><br><span class="line">    boolean isStop;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while(! isStop) &#123;</span><br><span class="line">            System.out.println(&quot;running...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;stop...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当想要终止该线程时，设置条件变量为true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StopTest s = new StopTest();</span><br><span class="line">Thread t = new Thread(s);</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">s.setStop(true);</span><br></pre></td></tr></table></figure>
<h3 id="wait-notify-线程等待与通知"><a class="header-anchor" href="#wait-notify-线程等待与通知">¶</a>wait / notify 线程等待与通知</h3>
<ul>
<li>在调用具体共享对象的 wait 或者 notify 系列函数前要先获取共享对象的锁；</li>
<li>notify和notifyAll的区别；</li>
<li>由于线程<strong>虚假唤醒</strong>的存在，一定要使用循环检查的方式。</li>
</ul>
<p>当一个线程调用一个共享对象的 wait() 方法时候，调用线程会被阻塞<strong>挂起</strong>，直到下面几个事情之一发生才返回：</p>
<ol>
<li>其它线程调用了该共享对象的 notify() 或者 notifyAll() 方法；</li>
<li>其它线程调用了该线程的 interrupt() 方法设置了该线程的中断标志，该线程会抛出 InterruptedException 异常返回。</li>
</ol>
<p>wait / notify方法签名：</p>
<ul>
<li>void wait()</li>
<li>void wait(long timeout)<br>
该方法相比 wait() 方法多一个超时参数，不同在于如果一个线程调用了共享对象的该方法挂起后，如果没有在指定的 timeout ms 时间内被其它线程调用该共享变量的 notify() 或者 notifyAll() 方法唤醒，那么该函数还是会因为超时而返回。<br>
需要注意的是如果在调用该函数时候 timeout 传递了负数会抛出 IllegalArgumentException 异常。</li>
<li>void wait(long timeout, int nanos)<br>
内部是调用 wait(long timeout)，如下代码：只是当 nanos&gt;0 时候让参数一递增1。</li>
<li>void notify()<br>
一个线程调用共享对象的 notify() 方法后，会唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程，一个共享变量上可能会有多个线程在等待，具体唤醒哪一个等待的线程是随机的。<br>
另外被唤醒的线程不能马上从 wait 返回继续执行，它必须获取了共享对象的监视器后才可以返回,也就是唤醒它的线程释放了共享变量上面的监视器锁后，被唤醒它的线程也不一定会获取到共享对象的监视器，这是因为该线程还需要和其它线程一块竞争该锁，只有该线程竞争到了该共享变量的监视器后才可以继续执行。<br>
类似 wait 系列方法，只有当前线程已经获取到了该共享变量的监视器锁后，才可以调用该共享变量的 notify() 方法，否者会抛出 <code>IllegalMonitorStateException</code> 异常。</li>
<li>void notifyAll()<br>
不同于 nofity() 方法在共享变量上调用一次就会唤醒在该共享变量上调用 wait 系列方法被挂起的一个线程，notifyAll() 则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li>
</ul>
<p>可以通过synchronized关键字获取监视器锁，需要注意，如果调用 wait() 方法的线程没有事先获取到该对象的<strong>监视器锁</strong>，则调用 wait() 方法时候调用线程会抛出 IllegalMonitorStateException 异常。</p>
<p>例1 - 获取监视器锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用同步代码块</span><br><span class="line">synchronized（共享变量）&#123;</span><br><span class="line">    //doSomething</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用同步方法</span><br><span class="line">synchronized void add(int a,int b)&#123;</span><br><span class="line">    //doSomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是一个线程可以从挂起状态变为可以运行状态（也就是被唤醒）即使该线程没有被其它线程调用 notify()，notifyAll() 进行通知，或者被中断，或者等待超时，这就是所谓的<strong>虚假唤醒</strong>。<br>
虽然虚假唤醒在应用实践中很少发生，但是还是需要防范于未然的，做法就是不停的去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中去调用 wait() 方法进行防范，退出循环的条件是条件满足了唤醒该线程。</p>
<p>例2 - 防止虚假唤醒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (条件不满足)&#123;</span><br><span class="line">        obj.wait();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码为经典的调用共享变量 wait() 方法的实例，首先通过同步块获取 obj 上面的监视器锁，然后通过 while 循环内调用 obj 的 wait() 方法。</p>
<p>另外当一个线程调用了共享变量的 wait() 方法后该线程会被挂起，同时该线程会暂时释放对该共享变量监视器的持有，直到另外一个线程调用了共享变量的 notify() 或者 notifyAll() 方法才有可能会重新获取到该共享变量的监视器的持有权（这里说有可能，是因为考虑到多个线程第一次都调用了 wait() 方法，所以多个线程会竞争持有该共享变量的监视器）。</p>
<p>例3 - 生产者消费者：<br>
下面从生产者消费者例子来加深理解，如下面代码是一个生产者的例子，其中 queue 为共享变量，生产者线程在调用 queue 的 wait 方法前，通过使用 synchronized 关键字拿到了该共享变量 queue 的监视器，所以调用 wait() 方法才不会抛出 IllegalMonitorStateException 异常，如果当前队列没有空闲容量则会调用 queued 的 wait() 挂起当前线程，这里使用循环就是为了避免上面说的虚假唤醒问题，这里假如当前线程虚假唤醒了，但是队列还是没有空余容量的话，当前线程还是会调用 wait() 把自己挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//生产线程</span><br><span class="line">synchronized (queue) &#123; </span><br><span class="line"></span><br><span class="line">    //消费队列满，则等待队列空闲</span><br><span class="line">    while (queue.size() == MAX_SIZE) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            //挂起当前线程，并释放通过同步块获取的queue上面的锁，让消费线程可以获取该锁，然后获取队列里面元素</span><br><span class="line">            queue.wait(); </span><br><span class="line">        &#125; catch (Exception ex) &#123; </span><br><span class="line">            ex.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空闲则生成元素，并通知消费线程</span><br><span class="line">    queue.add(ele); </span><br><span class="line">    queue.notifyAll(); </span><br><span class="line">&#125;</span><br><span class="line">//消费线程</span><br><span class="line">synchronized (queue) &#123; </span><br><span class="line"></span><br><span class="line">    //消费队列为空</span><br><span class="line">    while (queue.size() == 0) &#123; </span><br><span class="line">        try</span><br><span class="line">            //挂起当前线程，并释放通过同步块获取的queue上面的锁，让生产线程可以获取该锁，生产元素放入队列</span><br><span class="line">            queue.wait(); </span><br><span class="line">        &#125; catch (Exception ex) &#123; </span><br><span class="line">            ex.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费元素，并通知唤醒生产线程</span><br><span class="line">    queue.take(); </span><br><span class="line">    queue.notifyAll(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借上述代码来说明下对调用共享变量 wait() 方法后当前线程会释放持有的共享变量的锁的理解。假如生产线程 A 首先通过 synchronized 获取到了 queue 上的锁，那么其它生产线程和所有消费线程都会被阻塞，线程 A 获取锁后发现当前队列已满会调用 queue.wait() 方法阻塞自己，然后会释放获取的 queue 上面的锁，这里考虑下为何要释放该锁？如果不释放，由于其它生产线程和所有消费线程已经被阻塞挂起，而线程 A 也被挂起，这就处于了死锁状态。这里线程 A 挂起自己后释放共享变量上面的锁就是为了打破死锁必要条件之一的<strong>持有并等待原则</strong>。关于死锁下面章节会有讲到，线程 A 释放锁后其它生产线程和所有消费线程中会有一个线程获取 queue 上的锁进而进入同步块，这就打破了死锁。</p>
<p>例4 - InterruptedException：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyInterupt &#123;</span><br><span class="line"></span><br><span class="line">    static Object obj = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建线程</span><br><span class="line">        Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;---begin---&quot;);</span><br><span class="line">                    //阻塞当前线程</span><br><span class="line">                    obj.wait();</span><br><span class="line">                    System.out.println(&quot;---end---&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---begin interrupt threadA---&quot;);</span><br><span class="line">        threadA.interrupt();</span><br><span class="line">        System.out.println(&quot;---end interrupt threadA---&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">---begin---</span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	at java.lang.Object.wait(Object.java:502)</span><br><span class="line">	at com.tallate.localcache.WaitNotifyInterupt$1.run(WaitNotifyInterupt.java:15)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">---begin interrupt threadA---</span><br><span class="line">---end interrupt threadA---</span><br></pre></td></tr></table></figure>
<p>如上代码threadA调用了共享对象obj的wait()方法后阻塞挂起了自己，然后主线程在休眠1s后中断了 threadA 线程，可知中断后 threadA 在 obj.wait() 处抛出了 java.lang.IllegalMonitorStateException 异常后返回后终止。</p>
<p>例5 - notify() 和 notifyAll()的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Object resourceA = new Object();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    // 创建线程</span><br><span class="line">    Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            // 获取resourceA共享资源的监视器锁</span><br><span class="line">            synchronized (resourceA) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;threadA get resourceA lock&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;threadA begin wait&quot;);</span><br><span class="line">                    resourceA.wait();</span><br><span class="line">                    System.out.println(&quot;threadA end wait&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建线程</span><br><span class="line">    Thread threadB = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (resourceA) &#123;</span><br><span class="line">                System.out.println(&quot;threadB get resourceA lock&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;threadB begin wait&quot;);</span><br><span class="line">                    resourceA.wait();</span><br><span class="line">                    System.out.println(&quot;threadB end wait&quot;);</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建线程</span><br><span class="line">    Thread threadC = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            synchronized (resourceA) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;threadC begin notify&quot;);</span><br><span class="line">                // 如果有多个线程在等待，则notify只能唤醒其中一个，而notifyAll能唤醒全部</span><br><span class="line">                // resourceA.notify();</span><br><span class="line">                resourceA.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 启动线程</span><br><span class="line">    threadA.start();</span><br><span class="line">    threadB.start();</span><br><span class="line"></span><br><span class="line">    // 等待一会，让线程 A 和 B 全部执行到调用 wait 方法后在调用线程 C 的 notify 方法</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    threadC.start();</span><br><span class="line"></span><br><span class="line">    // 等待线程结束</span><br><span class="line">    threadA.join();</span><br><span class="line">    threadB.join();</span><br><span class="line">    threadC.join();</span><br><span class="line">    System.out.println(&quot;main over&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">threadA get resourceA lock</span><br><span class="line">threadA begin wait</span><br><span class="line">threadB get resourceA lock</span><br><span class="line">threadB begin wait</span><br><span class="line">threadC begin notify</span><br><span class="line">threadB end wait</span><br><span class="line">threadA end wait</span><br><span class="line">main over</span><br></pre></td></tr></table></figure>
<p>从结果来看，这次线程调度器先调度了线程A占用CPU来运行，线程A首先获取了resourceA上的锁，然后调用resourceA的wait()方法挂起当前线程并释放获取到的锁，然后线程B获取到resourceA上面的锁并调用了resourceA的wait()，此时线程B也被阻塞挂起并释放resourceA上的锁。<br>
注意线程C中的notify和notifyAll，如果调用了 notify() 方法，则会激活 resourceA 的阻塞集合里面的一个线程，如果是notifyAll则会激活所有，只是线程B先获取到了resourceA上面的锁然后从wait()方法返回，待B执行完毕后，线程A又获取到resourceA上面的锁，然后从wait()方法返回，等A也执行完毕后，由主线程打印结果。</p>
<h3 id="线程优先级"><a class="header-anchor" href="#线程优先级">¶</a>线程优先级</h3>
<p><strong>setPriority()/getPriority()</strong><br>
设置/获取线程优先级，Runnable的多个线程中优先级高的会被线程调度器优先分配时间片</p>
<h3 id="join-等待线程执行终止"><a class="header-anchor" href="#join-等待线程执行终止">¶</a>join 等待线程执行终止</h3>
<p>在项目实践时候经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行，比如多个线程去加载资源，当多个线程全部加载完毕后在汇总处理，Thread 类中有个静态的 join 方法就可以做这个事情。<br>
前面介绍的等待通知方法是属于 Object 类的，而 join 方法则是直接在 Thread 类里面提供的，下面简单介绍其使用方法：</p>
<p>例1 - join的简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread threadOne = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;child threadOne over!&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread threadTwo = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;child threadTwo over!&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //启动子线程</span><br><span class="line">    threadOne.start();</span><br><span class="line">    threadTwo.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;wait all child thread over!&quot;);</span><br><span class="line"></span><br><span class="line">    //等待子线程执行完毕，返回</span><br><span class="line">    threadOne.join();</span><br><span class="line">    threadTwo.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;all child thread over!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2 - 线程join()时被interrupt会抛出InterruptedException：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    //线程one</span><br><span class="line">    Thread threadOne = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;threadOne begin run!&quot;);</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //获取主线程</span><br><span class="line">    final Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    //线程two</span><br><span class="line">    Thread threadTwo = new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //休眠1s</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //中断主线程</span><br><span class="line">            mainThread.interrupt();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 启动子线程</span><br><span class="line">    threadOne.start();</span><br><span class="line"></span><br><span class="line">    // 延迟1s启动线程</span><br><span class="line">    threadTwo.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123; //等待线程one执行结束</span><br><span class="line">        threadOne.join();</span><br><span class="line"></span><br><span class="line">    &#125; catch(InterruptedException e)&#123;</span><br><span class="line">        System.out.println(&quot;main thread:&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sleep-线程睡眠"><a class="header-anchor" href="#sleep-线程睡眠">¶</a>sleep 线程睡眠</h3>
<ul>
<li>sleep 会让调用线程暂时让出指定时间的 CPU 执行权；</li>
<li>但是该线程所拥有的监视器资源，比如锁还是持有不让出的。</li>
</ul>
<p>当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。当指定的睡眠时间到了该函数会正常返回，线程就处于就绪状态，然后参与 CPU 的调度，当获取到了 CPU 资源就可以继续运行了。<br>
如果在睡眠期间其它线程调用了该线程的 interrupt() 方法中断了该线程,该线程会在调用 sleep 的地方抛出 InterruptedException 异常返回。</p>
<p>例1 - 线程sleep时不会释放监视器锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;-&gt; t1&quot;);</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                    System.out.println(&quot;&lt;- t1&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;-&gt; t2&quot;);</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                    System.out.println(&quot;&lt;- t2&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">-&gt; t1</span><br><span class="line">&lt;- t1</span><br><span class="line">-&gt; t2</span><br><span class="line">&lt;- t2</span><br></pre></td></tr></table></figure>
<p>要么是线程1先获取到锁，要么是线程2，获取锁后调用sleep挂起，此时不会释放锁，体现到输出里就是二者不会出现交叉打印的情况。</p>
<h3 id="interrupt-线程中断"><a class="header-anchor" href="#interrupt-线程中断">¶</a>interrupt 线程中断</h3>
<ul>
<li>中断一个线程仅仅是设置了该线程的中断标志，也就是设置了线程里面的一个变量的值，本身是不能终止当前线程运行的。</li>
<li>一般程序里面是检查这个标志的状态来判断是否需要终止当前线程。</li>
</ul>
<p>Java 中线程中断是一种线程间协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是需要被中断的线程根据中断状态自行处理。</p>
<ul>
<li>void interrupt()<br>
中断线程，例如当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。<strong>interrupt 仅仅是设置标志，线程 A 并没有实际被中断，会继续往下执行</strong>。如果线程 A 因为调用了 <strong>wait</strong> 系列函数或者 <strong>join</strong> 方法或者 <strong>sleep</strong> 函数而被阻塞挂起，这时候线程 B 调用了线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。</li>
<li>boolean isInterrupted()<br>
检测当前线程是否被中断，如果是返回 true，否者返回 false。</li>
<li>boolean interrupted()<br>
检测当前线程是否被中断，如果是返回 true，否者返回 false，与 isInterrupted 不同的是该方法如果发现当前线程被中断后会清除中断标志。<br>
并且，该函数是 static 方法，可以通过 Thread 类直接调用。</li>
</ul>
<p>例1 - 使用 Interrupted 优雅退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void run()&#123;    </span><br><span class="line">    try&#123;    </span><br><span class="line">         ....    </span><br><span class="line">         //线程退出条件，需要额外判断线程是否被中断</span><br><span class="line">         while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do) &#123;    </span><br><span class="line">             // do more work;    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;    </span><br><span class="line">        // thread was interrupted during sleep or wait    </span><br><span class="line">    &#125; finally &#123;    </span><br><span class="line">        // cleanup, if required    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ul>
<li>什么是线程？线程和进程的关系。</li>
<li>线程几种状态之间的转换</li>
<li>线程之间如何协调</li>
<li>线程创建与运行，创建一个线程有哪几种方式？有何区别？</li>
<li>线程安全问题</li>
<li>线程通知与等待，多线程同步的基础设施。</li>
<li>线程的虚假唤醒，以及如何避免。</li>
<li>等待线程执行终止的 join 方法。想让主线程在子线程执行完毕后在做一点事情？</li>
<li>让线程睡眠的 sleep 方法，sleep 的线程会释放持有的监视器锁？</li>
<li>线程中断。中断一个线程，被中断的线程会自己终止？</li>
<li>理解线程上下文切换。线程多了一定好？</li>
<li>线程死锁，以及如何避免。</li>
<li>守护线程与用户线程。当 main 函数执行完毕，但是还有用户线程存在的时候，JVM 进程会退出？</li>
</ul>
<ol>
<li>今有线程执行synchronized(this)，另一线程后到，他们分别属于什么状态？</li>
<li>今有线程调用interrupt()，它属于什么状态？</li>
<li>当线程wait()时，也可以通过interrupt()中断，此时它不会马上抛出异常，而是会先获取锁，在得到锁后再抛出异常</li>
<li>什么情况下会发生虚假唤醒？</li>
<li>stop为什么被Deprecated了？</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fa5fc05a.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fa5fc05a.html" itemprop="url">抽样算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T23:29:41+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  355 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题定义"><a class="header-anchor" href="#问题定义">¶</a>问题定义</h2>
<p>抽样是一种比较常见的问题，在现实中也有比较多的应用，一般问题可以描述成功</p>
<ul>
<li>有限集合随机找出k个数，或者将整个集合打乱；</li>
<li>无限集合（或者非常大的集合）中随机找出k个数。</li>
</ul>
<h3 id="公平"><a class="header-anchor" href="#公平">¶</a>公平</h3>
<p>如果将所有可能出现的结果归作一个集合R，如何保证所有可能的结果出现的概率是相同的？如果不能满足这个条件那么算法只能算作伪随机算法。<br>
根据问题问法的不同，这个问题的描述可以更精确，比如如果我们需要随机打乱一个数组，问题可以变成：每个元素出现在每个位置上的概率是否相等？</p>
<h2 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h2>
<h3 id="knuth-洗牌算法"><a class="header-anchor" href="#knuth-洗牌算法">¶</a>Knuth 洗牌算法</h3>
<h4 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i : n - 1 -&gt; 0</span><br><span class="line">  swap(a[i], a[rand(0, i)]) // rand(0, i)返回[0, i]之间的一个整数</span><br></pre></td></tr></table></figure>
<p>或者反过来，结果是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i : 0 -&gt; n - 1</span><br><span class="line">  swap(a[i], a[rand(i, n - 1)])</span><br></pre></td></tr></table></figure>
<h4 id="证明"><a class="header-anchor" href="#证明">¶</a>证明</h4>
<p>比如输入数组为<code>[1, 2, 3]</code>，</p>
<ol>
<li>假设2落到了<code>a[2]</code>上，2在<code>a[2]</code>位置上的概率是1/3，不在的概率是2/3</li>
<li>假设3落到<code>a[1]</code>，3在<code>a[1]</code>上的概率是2/3 × 1/2，不在的概率是2/3 × 1/2</li>
<li>最后1落到<code>a[0]</code>，1落到a的概率是2/3 × 1/2 × 1</li>
</ol>
<h3 id="蓄水池抽样"><a class="header-anchor" href="#蓄水池抽样">¶</a>蓄水池抽样</h3>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/346e1068.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/346e1068.html" itemprop="url">异步任务与设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T22:12:49+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="stm-软件事务内存"><a class="header-anchor" href="#stm-软件事务内存">¶</a>STM（软件事务内存）</h2>
<h2 id="actor-基于角色的并发模型"><a class="header-anchor" href="#actor-基于角色的并发模型">¶</a>Actor（基于角色的并发模型）</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/353ec849.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/353ec849.html" itemprop="url">Dubbo原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>工作中总是和Dubbo打交道，但是Dubbo的功能太强大，至今还未摸透其中的方方面面。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/353ec849.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fd8cde90.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fd8cde90.html" itemprop="url">平滑迁移-高速飞机换引擎</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T23:12:49+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  748 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>平滑迁移指的是互联网公司发版时为能正常发布新功能而又不影响用户体验所做的一些措施。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/fd8cde90.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/5582e809.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/5582e809.html" itemprop="url">分布式 Session</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T21:20:12+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>不论一家企业做什么领域业务，登录基本都是绕不过去的功能——任何操作都必须在已经登录的前提下才能执行，我这里主要聚焦登录中分布式 Session 的设计，然后连带提一下其他方方面面。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/5582e809.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/36e70598.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/36e70598.html" itemprop="url">异步任务和消息队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存队列原理"><a class="header-anchor" href="#内存队列原理">¶</a>内存队列原理</h2>
<p>TODO</p>
<h2 id="消息队列-mq-原理"><a class="header-anchor" href="#消息队列-mq-原理">¶</a>消息队列（MQ）原理</h2>
<p>MQ 有很多优势，当我们选择 MQ 时，主要是为了：</p>
<ul>
<li>解耦……<br>
比如 A 系统要将用户提交的数据推送到 B、C 两个系统的时候，最初的想法很有可能是直接用 http 或 rpc 调用实现。像这样的下游系统后来又会多出 D、E、F…，对 A 系统的压力就会越来越大，更复杂的场景中，数据通过接口传给其他系统有时候还要考虑重试、超时等一些异常情况。<br>
这时，对 A 来说更好的方案是将消息发送给 mq，不管有哪个下游系统需要这个数据都可以直接订阅这个 subject。</li>
<li>异步<br>
当请求比较复杂，而其中有部分数据没必要实时更新时，可以用 mq 实现异步化。比如取消订单后需要做订单状态的更新、对账、退款等操作，而其中只有状态的变更是有必要实时反馈给用户的，那么后续的所有操作就完全可以做成异步的。</li>
<li>削峰填谷<br>
消息队列作为缓冲队列应对突发流量时，并不能使处理速度变快，而是使处理速度变平滑，从而不会因瞬时压力过大而压垮应用。<br>
举个例子，比如我们的订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒 1000 左右的并发写入，并发量再高就容易宕机。<br>
低峰期的时候并发也就 100 多个，但是在高峰期时候，并发量会突然激增到 5000 以上，这个时候数据库肯定死了。<br>
但是使用了 MQ 之后，情况就变了，消息被 MQ 保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒 1000 个数据，这样慢慢写入数据库，这样就不会打死数据库了。<br>
如果没有用 MQ 的情况下，并发量高峰期的时候是有一个“顶峰”的，然后高峰期过后又是一个低并发的“谷”。<br>
但是使用了 MQ 之后，限制消费消息的速度为 1000，但是这样一来，高峰期产生的数据势必会被积压在 MQ 中，高峰就被“削”掉了。<br>
但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在 1000QPS，直到消费完积压的消息,这就叫做“填谷”。</li>
</ul>
<h3 id="高可用"><a class="header-anchor" href="#高可用">¶</a>高可用</h3>
<p>使用了 MQ 之后，我们肯定是希望 MQ 有高可用特性，因为不可能接受机器宕机了，就无法收发消息的情况。<br>
这一块我们也是基于 RabbitMQ 这种经典的 MQ 来说明一下：<br>
RabbitMQ 是比较有代表性的，因为是基于主从做高可用性的，我们就以他为例子讲解第一种 MQ 的高可用性怎么实现。<br>
rabbitmq 有三种模式：单机模式，普通集群模式，镜像集群模式<br>
单机模式<br>
单机模式就是 demo 级别的，就是说只有一台机器部署了一个 RabbitMQ 程序。<br>
这个会存在单点问题，宕机就玩完了，没什么高可用性可言。一般就是你本地启动了玩玩儿的，没人生产用单机模式。<br>
普通集群模式<br>
这个模式的意思就是在多台机器上启动多个 rabbitmq 实例。类似的 master-slave 模式一样。<br>
但是创建的 queue，只会放在一个 master rabbtimq 实例上，其他实例都同步那个接收消息的 RabbitMQ 元数据。<br>
在消费消息的时候，如果你连接到的 RabbitMQ 实例不是存放 Queue 数据的实例，这个时候 RabbitMQ 就会从存放 Queue 数据的实例上拉去数据，然后返回给客户端。<br>
总的来说，这种方式有点麻烦，没有做到真正的分布式，每次消费者连接一个实例后拉取数据，如果连接到不是存放 queue 数据的实例，这个时候会造成额外的性能开销。如果从放 Queue 的实例拉取，会导致单实例性能瓶颈。<br>
如果放 queue 的实例宕机了，会导致其他实例无法拉取数据，这个集群都无法消费消息了，没有做到真正的高可用。<br>
所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性可言了，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。<br>
镜像集群模式<br>
镜像集群模式才是真正的 rabbitmq 的高可用模式，跟普通集群模式不一样的是：创建的 queue 无论元数据还是 queue 里的消息都会存在于多个实例上，<br>
每次写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。<br>
这样的话任何一个机器宕机了别的实例都可以用提供服务，这样就做到了真正的高可用了。<br>
但是也存在着不好之处：</p>
<ul>
<li>性能开销过高，消息需要同步所有机器，会导致网络带宽压力和消耗很重</li>
<li>扩展性低：无法解决某个 queue 数据量特别大的情况，导致 queue 无法线性拓展。<br>
就算加了机器，那个机器也会包含 queue 的所有数据，queue 的数据没有做到分布式存储。<br>
对于 RabbitMQ 的高可用一般的做法都是开启镜像集群模式，这样起码来说做到了高可用，一个节点宕机了，其他节点可以继续提供服务。</li>
</ul>
<h3 id="高性能"><a class="header-anchor" href="#高性能">¶</a>高性能</h3>
<ul>
<li>对于内存操作的线程分离，大部分中间件做法是将数据文件缓存与内存中，通过异步线程flush至硬盘</li>
<li>合理的存储引擎对应不同的服务场景 B+树，hash，LSM</li>
<li>对于消息队列，选取顺序读写磁盘的方式，可以高效的提升磁盘IO速度</li>
<li>顺序写磁盘可以带来足够的写入速度，其读取方式为二分查找</li>
<li>对于LSM存储引擎，同样采用顺序写磁盘方式，牺牲一部分读性能从而获得更优越的写性能</li>
</ul>
<h3 id="消息队列如何选型"><a class="header-anchor" href="#消息队列如何选型">¶</a>消息队列如何选型</h3>
<h2 id="mq-应用"><a class="header-anchor" href="#mq-应用">¶</a>MQ 应用</h2>
<h3 id="异步处理"><a class="header-anchor" href="#异步处理">¶</a>异步处理</h3>
<h3 id="延时消费"><a class="header-anchor" href="#延时消费">¶</a>延时消费</h3>
<h3 id="应用隔离-系统解耦"><a class="header-anchor" href="#应用隔离-系统解耦">¶</a>应用隔离（系统解耦）</h3>
<p>比如有两个主题的消息，其中 A 主题的消息特别多，别的消息就会来不及处理。<br>
这种情况有点类似于服务治理中的隔离策略：一个服务出错不能影响别的服务不可用。一般会采用线程池、信号量来实现。<br>
MQ 消息中的主题隔离</p>
<h3 id="数据同步"><a class="header-anchor" href="#数据同步">¶</a>数据同步</h3>
<blockquote>
<p>Canel订阅数据库binlog可以实现数据库数据变更捕获，然后业务端订阅Canel进行业务处理，这种方式可以保证一致性，且不会有乱序问题。</p>
</blockquote>
<h3 id="数据异构"><a class="header-anchor" href="#数据异构">¶</a>数据异构</h3>
<h3 id="反模式-为了撇清关系所以使用-mq-消息"><a class="header-anchor" href="#反模式-为了撇清关系所以使用-mq-消息">¶</a>反模式-为了撇清关系所以使用 MQ 消息</h3>
<h3 id="反模式-为了解耦过度使用-mq-消息"><a class="header-anchor" href="#反模式-为了解耦过度使用-mq-消息">¶</a>反模式-为了解耦过度使用 MQ 消息</h3>
<h3 id="反模式-利用数据差异化来触发事件"><a class="header-anchor" href="#反模式-利用数据差异化来触发事件">¶</a>反模式-利用数据差异化来触发事件</h3>
<p>公司里有几位老员工基于 MQ 监听器组件开发了一套 MQ 客户端，这套 MQ 客户端的核心就是能通过修改数据来触发监听对应字段修改事件的监听器，这样可以避免定义一大堆主题，看起来似乎变简单了对吗？但是经过一段时间的维护发现情况并非如此，大量监听器不再根据主题来相互关联，而是数据中的一大堆字段，最开始的一批开发爽了，因为需要定义的主题少了，少了很多手动发消息的代码，但是后续维护的人就糟了，试想，每次希望修改某个字段的时候都需要把监听该字段修改事件的监听器都找一遍。<br>
两条业务同时修改</p>
<h2 id="mq-存在的问题及解决方案"><a class="header-anchor" href="#mq-存在的问题及解决方案">¶</a>MQ 存在的问题及解决方案</h2>
<h3 id="mq-存在的缺陷"><a class="header-anchor" href="#mq-存在的缺陷">¶</a>MQ 存在的缺陷</h3>
<p>上边已经说过了优点，那么 mq 又有哪些缺点呢？</p>
<ul>
<li>系统可用性降低<br>
上面的说解耦的场景，本来 A 系统的哥们要把系统关键数据发送给 B、C 系统的，现在突然加入一个 MQ，现在 BC 系统接收数据要通过 MQ 来接收。<br>
万一 MQ 挂了怎么办？这就引出一个问题，加入了 MQ 之后，系统的可用性是不是就降低了？<br>
因为多了一个风险因素：MQ 可能会挂掉。只要 MQ 挂了，数据没了，系统运行就不对了。</li>
<li>系统复杂度提高<br>
本来我的系统通过接口调用一下就能完事的，但是加入一个 MQ 之后，需要考虑消息重复消费、消息丢失、甚至消息顺序性的问题<br>
为了解决这些问题，又需要引入很多复杂的机制，这样一来是不是系统的复杂度提高了。</li>
<li>数据一致性问题<br>
本来好好的，A 系统调用 BC 系统接口，如果 BC 系统出错了，会抛出异常，返回给 A 系统让 A 系统知道，这样的话就可以做回滚操作了<br>
但是使用了 MQ 之后，A 系统发送完消息就完事了，认为成功了。而刚好 C 系统写数据库的时候失败了，但是 A 认为 C 已经成功了？这样一来数据就不一致了。</li>
</ul>
<h3 id="并发修改"><a class="header-anchor" href="#并发修改">¶</a>并发修改</h3>
<p>消息从发出到被消费会有一小段时间，这一段时间内数据可能会经过其他线程的多次修改，所以在消息消费方的编程中尤其需要注意并发修改的问题。<br>
如果是同步操作——比如用户购买商品扣款的场景——需要在比较高并发的情况下才会出现并发问题，但是如果功能是基于消息实现的，由于消息消费具有不确定性，这种风险会被放大。<br>
<img src="http://47.88.24.11/imgs/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E5%B9%B6%E5%8F%91%E6%89%A3%E6%AC%BE.png" alt="并发扣款" title="并发扣款"></p>
<ul>
<li>这些并发查询是在不同的站点实例 / 服务实例上完成的，进程内互斥锁无法解决问题。</li>
<li>不确定性来自于很多方面，比如同一主题的消息可能被多个业务线的触发、被重试、被手动重发。</li>
</ul>
<p>解决这种不一致问题的解决办法一般是加锁，因为异步处理并没有直接被用户感知，因此对效率并没有特别高的要求，悲观锁或乐观锁都是可行的。</p>
<blockquote>
<p>悲观锁会牺牲一定的吞吐量，乐观锁实现起来比较有技巧性、且可能会和业务数据耦合。</p>
</blockquote>
<p>以乐观锁为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 查询订单，Order中包含了版本信息</span><br><span class="line">Order order = queryOrder();</span><br><span class="line">// 这里使用状态机校验订单状态</span><br><span class="line">if (isStatusInvalid(order)) &#123;</span><br><span class="line">    记一下日志</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">// 扭转状态的同时也做了版本的校验，相当于一个原子操作，如果校验失败则抛出异常、交给外层MQ组件重试</span><br><span class="line">changeOrderStatus(order, targetStatus);</span><br></pre></td></tr></table></figure>
<h3 id="at-least-once-消息丢失"><a class="header-anchor" href="#at-least-once-消息丢失">¶</a>At-Least-Once（消息丢失）</h3>
<p>有很多情况可能发生 MQ 消息的丢失：</p>
<ul>
<li>生产者向 MQ 发送消息时，网络传输出现问题；</li>
<li>消息在 MQ 中存储时，发生磁盘故障等不可控问题；</li>
<li>消费者从 MQ 接收消息时，网络传输出现问题；</li>
</ul>
<p>一般 MQ 中间件都会保证<strong>At-Least-Once</strong>的消费，就需要避免消息丢失的情况，有两种方式可以解决这种情况：</p>
<p>事务方式：<br>
在生产者发送消息之前，通过<code>channel.txSelect</code>开启一个事务，接着发送消息<br>
如果消息没有成功被 RabbitMQ 接收到，生产者会收到异常，此时就可以进行事务回滚<code>channel.txRollback</code>然后重新发送。假如 RabbitMQ 收到了这个消息，就可以提交事务<code>channel.txCommit</code>。<br>
但是这样一来，生产者的吞吐量和性能都会降低很多，现在一般不这么干。</p>
<p>另外一种方式就是通过 confirm 机制：<br>
这个 confirm 模式是在生产者哪里设置的，就是每次写消息的时候会分配一个唯一的 id，然后 RabbitMQ 收到之后会回传一个 ack，告诉生产者这个消息 ok 了。<br>
如果 rabbitmq 没有处理到这个消息，那么就回调一个 nack 的接口，这个时候生产者就可以重发。<br>
事务机制和 cnofirm 机制最大的不同在于事务机制是同步的，提交一个事务之后会阻塞在那儿<br>
但是 confirm 机制是异步的，发送一个消息之后就可以发送下一个消息，然后那个消息 rabbitmq 接收了之后会异步回调你一个接口通知你这个消息接收到了。<br>
所以一般在生产者这块避免数据丢失，都是用 confirm 机制的。</p>
<p>Rabbitmq 弄丢了数据<br>
RabbitMQ 集群也会弄丢消息，这个问题在官方文档的教程中也提到过，就是说在消息发送到 RabbitMQ 之后，默认是没有落地磁盘的，万一 RabbitMQ 宕机了，这个时候消息就丢失了。<br>
所以为了解决这个问题，RabbitMQ 提供了一个持久化的机制，消息写入之后会持久化到磁盘<br>
这样哪怕是宕机了，恢复之后也会自动恢复之前存储的数据，这样的机制可以确保消息不会丢失。<br>
设置持久化有两个步骤：</p>
<ul>
<li>第一个是创建 queue 的时候将其设置为持久化的，这样就可以保证 rabbitmq 持久化 queue 的元数据，但是不会持久化 queue 里的数据</li>
<li>第二个是发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时 rabbitmq 就会将消息持久化到磁盘上去。<br>
但是这样一来可能会有人说：万一消息发送到 RabbitMQ 之后，还没来得及持久化到磁盘就挂掉了，数据也丢失了，怎么办？<br>
对于这个问题，其实是配合上面的 confirm 机制一起来保证的，就是在消息持久化到磁盘之后才会给生产者发送 ack 消息。<br>
万一真的遇到了那种极端的情况，生产者是可以感知到的，此时生产者可以通过重试发送消息给别的 RabbitMQ 节点<br>
消费端弄丢了数据<br>
RabbitMQ 消费端弄丢了数据的情况是这样的：在消费消息的时候，刚拿到消息，结果进程挂了，这个时候 RabbitMQ 就会认为你已经消费成功了，这条数据就丢了。<br>
对于这个问题，要先说明一下 RabbitMQ 消费消息的机制：在消费者收到消息的时候，会发送一个 ack 给 RabbitMQ，告诉 RabbitMQ 这条消息被消费到了，这样 RabbitMQ 就会把消息删除。<br>
但是默认情况下这个发送 ack 的操作是自动提交的，也就是说消费者一收到这个消息就会自动返回 ack 给 RabbitMQ，所以会出现丢消息的问题。<br>
所以针对这个问题的解决方案就是：关闭 RabbitMQ 消费者的自动提交 ack,在消费者处理完这条消息之后再手动提交 ack。<br>
这样即使遇到了上面的情况，RabbitMQ 也不会把这条消息删除，会在你程序重启之后，重新下发这条消息过来。</li>
</ul>
<h3 id="消息重复"><a class="header-anchor" href="#消息重复">¶</a>消息重复</h3>
<p>一般情况下 MQ 除了不保证消息的有序性外、还不保证消息不重复。<br>
因为在「网络不可达」的情况下，MQ 不能确认消息接收方收到了消息必然会重试。重试除了本文讲的幂等处理外，还可以采用每个消息有唯一的 ID+去重表实现。</p>
<h3 id="消息的有序性"><a class="header-anchor" href="#消息的有序性">¶</a>消息的有序性</h3>
<p>因为 MQ 消息在服务器上是分区存储的，每个分区自己是有序的。分区被接收端消费的时候。一般也是多个接收端一起消费。中间的每个环节都是只能保证局部有序。如果想全局有序。就需要分区只有一个，并且接收端服务器是单点，而且一次只处理一个请求。<br>
TODO: TCP是怎么做的。</p>
<h3 id="消息积压"><a class="header-anchor" href="#消息积压">¶</a>消息积压</h3>
<h2 id="数据交换"><a class="header-anchor" href="#数据交换">¶</a>数据交换</h2>
<p>Exchanger</p>
<h2 id="消息总线"><a class="header-anchor" href="#消息总线">¶</a>消息总线</h2>
<p>EventBus</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
