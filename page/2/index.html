<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/2/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/2/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e500a1f4.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/e500a1f4.html" itemprop="url">基于微服务的资金云系统发债管理子系统总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T00:40:05+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.Tony. 企业融资渠道有哪些？[EB/OL], <a href="https://www.zhihu.com/question/23939018" target="_blank" rel="noopener">https://www.zhihu.com/question/23939018</a><br>/answer/29132581, 2015.5.<br>2.周梅. ERP 实施中存在的问题及解决方案[J]. 中国集体经济,2013,28: 35-36.<br>3.于洪涛. SAP 坚定云转型之路[EB/OL], <a href="http://www.cnbp.net/news/detail/13618" target="_blank" rel="noopener">http://www.cnbp.net/news/detail/13618</a>, 2016.9.<br>4.James Lewis , Martin Fowler . Microservices a definition of this new architectural term<br>[EB/OL], <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a>, 2014.3.<br>5.IT168 企业级. 年终盘点篇：2017 年度微服务调查报告出炉[EB/OL],<br><a href="http://www.sohu.com/a/216277536_374240" target="_blank" rel="noopener">http://www.sohu.com/a/216277536_374240</a>, 2018.1.<br>6.Henry Robinson. What Is CAP Theorem?[EB/OL], <a href="https://www.quora.com/What-" target="_blank" rel="noopener">https://www.quora.com/What-</a><br>Is-CAP-Theorem-1, 2010.9.</p>
<ol start="7">
<li>Dan Pritchett. BASE: An Acid Alternative[J]. ACM Queue, 2008, 6(3):48-55.</li>
<li><a href="https://www.cnblogs.com/soundcode/p/5590710.html" target="_blank" rel="noopener">保证分布式系统数据一致性的 6 种方案</a></li>
<li>阮一峰. 理解 RESTful 架构[EB/OL], <a href="http://www.ruanyifeng.com/blog/2011/09" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09</a><br>/restful.html, 2011.9.</li>
<li>程立. 大规模 SOA 系统中的分布事务处理[EB/OL], <a href="http://tsingxu.github.io" target="_blank" rel="noopener">http://tsingxu.github.io</a><br>/blog/20140513/distributed-transaction-in-soa-by-chengli.pdf, 2008.12.</li>
</ol>
<p>15.Hunt P, Konar M, Junqueira F P. ZooKeeper: Wait-free Coordination for Internet-scale<br>Systems[C]. Usenix Annual Technical Conference. 2010:653–710.<br>16.Zachary Tong, Clinton Gormley. Elasticsearch 权威指南[M]. O’Reilly Media, Inc,<br> 2015, 27-35.<br>17.Baron.Scbwartz. 高性能 MySQL[M]. 北京:电子工业出版社, 2013.5, 1-33.<br>18.Redis Documentation[EB/OL], <a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a>, 2018.3.</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="项目意义"><a href="#项目意义" class="headerlink" title="项目意义"></a>项目意义</h3><p><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/面向企业的资金管理.png" alt="X" title="面向企业的资金管理"><br>这个项目的业务部分的原型是司库云，但是重点不在业务，因此这里仅仅简单介绍一下。平时我们接触的最多的应该是共享单车、在线聊天、支付宝这种 To C 业务，To B 业务主要是由企业提出的，和个人不同，一个企业总是会有部门、上下级等关系，因此 To B 业务与 To C 业务的主要区别有以下几条：</p>
<ol>
<li>层次化的权限管理<br>一般的企业中员工之间都会有上下级的关系，企业又会有集团、组织这些组成部分；</li>
<li>无处不在的审批<br>企业中大部门场景都需要审批，以前是拿着单子到处跑，现在会将单子录到一些 APP 中，方便很多；</li>
<li>更大的体量<br>一般企业会进行更大额的交易，我们平时将几万存入支付宝中对大型企业来说都是一点零头，对这么大额的操作，安全是优先于效率的（企业内部其实也只有百来号人会去用这样的系统）。</li>
</ol>
<p>近年，似乎所有传统企业都在试图往互联网靠拢，上次听一位朋友讲到某机关部门布了一个集群供“大数据处理”（上千条级别），再如某企业开发云服务软件，测试时专门有一项“大数据用例”（上万条级别）。<br>将业务上云后，正如之前很多人困惑的那样：不就是把代码放到云主机上跑吗？但问题的关键不是技术新老，而是为什么要迁移到云端，主要是当下业务变更迅速、弹性大，使用传统的机房部署服务，应用实例能使用的硬件资源是固定的，如果数据量超过了机器可处理的范围，要么换一台更高档的机器，要么将整个实例复制到另一台机器上，再在网关处做负载均衡，当然这两种方式都有些缺陷。因此，技术的变革都是被逼出来的，当下云原生应用能够提供弹性扩展、资源预警等功能，且有更人性化的操作界面，取代传统的运维方式也是必然的。微服务是当下实现应用上云的首选架构风格，有丰富的资源（当然最重要的是比较火），这个小项目也是我对微服务的初步探究。</p>
<hr>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="架构、架构风格、系统架构"><a href="#架构、架构风格、系统架构" class="headerlink" title="架构、架构风格、系统架构"></a>架构、架构风格、系统架构</h3><p><strong>架构风格</strong>关注的是如何使用一些连接件来组合软件组件，在 Web 应用中，我们会使用覆盖网络来描述软件的架构，连接件可以是 HTTP 协议、数据库连接器等，在桌面应用中，连接器可以是读取用户输入的管道，等等。<br><strong>系统架构</strong>关注的是软件组件是如何实例化的，比如要几台服务器、哪些组件要复制等。<br>平时说的架构一般指的是架构风格，但对实现细节的深究是成为架构师的必经之路。</p>
<h3 id="单体式、SOA-和微服务"><a href="#单体式、SOA-和微服务" class="headerlink" title="单体式、SOA 和微服务"></a>单体式、SOA 和微服务</h3><p><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/单体式应用和微服务应用部署图.png" alt="X" title="单体式应用和微服务应用部署图"><br>图中，小圆形、方形、三角这些小图形是服务实例，包围小图形的双层方形是 Docker 容器实例，立方体是物理服务器（一般是云提供商提供的虚拟机实例）<br>传统的<strong>单体式应用（monolithic）</strong>在实践中往往存在着诸多问题，比如，在达到一定的复杂度后，不仅部署效率会降低，由开发不小心引入的任何 Bug 都会弄垮整个服务，且模块之间高度耦合，添加新功能的代价变得更高，由此也对测试带来了更大的压力。<br>微服务架构模式有点像<strong>SOA</strong>，他们都由多个服务构成，因此对 SOA 缺陷的讨论可以参照下面对微服务的讨论。但是，从另一个角度看，微服务架构模式是一个不包含 Web 服务(WS-)和 ESB 服务的 SOA，微服务应用乐于采用简单轻量级协议，比如 REST，而不是 WS-，在微服务内部避免使用 ESB 以及 ESB 类似功能，微服务架构模式也拒绝使用 canonical schema 等 SOA 概念，因此可以认为微服务是轻量版的 SOA。简而言之，它们之间的主要区别是对服务的治理方式不同。<br><strong>微服务</strong>的概念由来已久，2011 年 5 月在威尼斯附近举办的软件架构师研讨会提出了“微服务”这个概念，Adrian Cockcroft 将其描述为一种“细粒度的 SOA”。<br>在国内，加快互联网+步伐成为许多传统企业的必然选择。业务场景、用户习惯和行为在迅速变化，许多传统行业线上业务出现急速增长。每个月都要进行业务系统更新的企业比例超过了半数，比如金融行业的移动支付、互联网理财等，汽车制造行业的营销、电商、售后服务等线上业务比例迅速提高。IT 团队业务开发、迭代都以每月、甚至每周来计，需要 7*24 小时响应，这些给系统开发和运维带来极大挑战。在服务的复杂化、线上访问压力大、交付速度无法满足业务需求等现状的前提下，寻求架构上的转型正是大势所趋。<br>微服务相对以传统方式部署的应用来说，具有易扩展、访问便捷、安全、性价比高等特点，将传统的单体式应用进行拆分后成为一个个微服务后，每一个微服务都可以单独进行部署，可以根据企业用户的具体需求提供服务，另外服务之间的弱耦合性也使得扩展变得更加容易。</p>
<p>总而言之，<strong>微服务应用相对单体式应用的优势</strong>体现在下面这些方面：</p>
<ol>
<li>可扩展性高<br>严格界定服务边界，服务之间是弱耦合的，每个服务本身是无状态的，可以通过水平复制和负载均衡来提高服务性能。</li>
<li>实施效率高<br>应用 Docker 实现运维自动化，且每个服务都足够小，使得部署效率不会太低。</li>
<li>健壮<br>某个服务的不可用不会引起大规模雪崩，而且服务的复制也提高了整体的可用性。</li>
<li>单个服务复杂性低<br>每个服务都足够简单，由一个独立团队来负责。</li>
</ol>
<h3 id="开发、实施和运维"><a href="#开发、实施和运维" class="headerlink" title="开发、实施和运维"></a>开发、实施和运维</h3><p>开发和运维在传统情况下是完全分割开来的，开发主要负责完成功能需求，并且知道如何去优化功能，运维要明白如何部署应用服务集群、中间件集群外，同时对所使用的工具的原理要有一定程度的了解，比如某个服务器的 CPU 打满了，原因可能是代码写得太差了，也可能是数据库某张热表没有给字段加上索引。现在 DevOps 的概念盛行，开发有时也需要承担环境的维护。<br>实施，说简单的，就是帮用户装软件的，该人员必须对软件整体具有较好的理解，因为实施会直面用户，如果被用户问倒可不只是丢自己一个人的脸，当然，一定程度的口才也是必要的。实施在 ERP 时代是很重要的一个职位，在当下云服务盛行的情况，实施往往会被派去为用户部署私有云环境（前提是有这个必要）。</p>
<h3 id="有状态和无状态服务"><a href="#有状态和无状态服务" class="headerlink" title="有状态和无状态服务"></a>有状态和无状态服务</h3><p>提到无状态我们都会想到 HTTP，HTTP 协议是一种无状态的协议，这意味着 HTTP 服务器不会保存任何用户信息，实现登录、购物车等带状态的功能时都需要额外借助 Session、分布式缓存、数据库等存储方案。以购物车为例，其中 Session 相当于将购物车的状态保存到了服务实例的内存中，而分布式缓存和数据库方案则将状态转移到了另一个服务器内（假设应用和缓存、数据库服务器是部署在不同的服务器上的）。<br>如果一个服务是有状态的，随着实例的运行，服务实例在内存中可能会多出一些与业务相关的数据，实例间产生差异后，我们后续就不能随意地对服务进行复制了，两次 HTTP 的可能会产生不同的结果，如下图所示。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/有状态服务示意图.png" alt="X" title="有状态服务示意图"><br>因此有必要在设计的时候就保证服务是无状态的。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/无状态服务示意图.png" alt="X" title="无状态服务示意图"></p>
<h3 id="CAP-amp-BASE"><a href="#CAP-amp-BASE" class="headerlink" title="CAP &amp; BASE"></a>CAP &amp; BASE</h3><p><strong>CAP</strong>是描述分布式系统特性常用的一种理论，它使用数据<strong>一致性（Consistency）</strong>、<strong>服务可用性（Availability）</strong>和<strong>分区容错性（Partition-tolerance）</strong>三个指标来定义一个分布式系统，这三个特性不能被同时完全满足，其中，P 是必须要满足的，因为一般的业务系统并不允许网络中的消息被随意丢弃，因此多数的讨论都集中于 C 和 A 之间的权衡。<br>如果需要满足强一致性，则在对数据进行读写操作时势必都需要进行加锁操作并使用事务来保证分布式一致性，但同时也会对系统的效率产生非常大的影响，起到反作用、影响用户的体验，所以在设计时往往会放宽这个要求，采取<strong>最终一致性</strong>作为实现目标。服务的高可用性要求请求必须能够完成，这可以通过复制服务实例来实现，服务实例的复制需要投入更多地成本与维护人力，需要根据具体场景进行具体分析。<br>eBay 的架构师 Dan Pritchett 源于对大规模分布式系统的实践总结，提出了 BASE 理论。<strong>BASE</strong>理论是对 CAP 理论的延伸，核心思想是即使无法做到 CAP 理论要求的强一致性，但应用可以采用适当的方式达到<strong>最终一致性（Eventual Consitency）</strong>。BASE 是指<strong>基本可用（Basically Available）</strong>、<strong>软状态（Soft State）</strong>和<strong>最终一致性（Eventual Consistency）</strong>。基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。<br>在 BASE 的提出者 Dan Pritchett 的论文《BASE: An Acid Alternative》中提出了一种实现 BASE 的经典模式，概括来讲，就是服务之间是通过消息队列连接的，消息队列会保证将消息传递给目标服务，但不保证送到的时间。</p>
<hr>
<h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>接下来，我希望对项目中使用到的一些技术进行简短总结，尽量引入一些代码和图来辅助说明。</p>
<h3 id="REST-amp-RPC"><a href="#REST-amp-RPC" class="headerlink" title="REST &amp; RPC"></a>REST &amp; RPC</h3><p>REST 是现今一套比较成熟的 API 设计理论，主要思想是将网络上的资源抽象为 URI，并通过 HTTP 协议中的字段和动词进行描述和操作，被广泛地应用于 WEB 应用 API 的设计当中。<br>RPC 是常见的实现服务之间远程调用的协议（在 Java 这种面向对象的语言上实现的理应称作 RMI 协议，但是叫习惯了就无所谓了），服务实例作为不同的进程运行于多台服务器上，在发起请求时，请求的发起方称为客户端、接收者称为服务端，它们通过指定的网络层甚至传输层协议进行通信，可以自动对消息进行序列化并包装为底层消息格式进行传输，并在服务端进行反序列化得到请求。因此 RPC 的可靠性和效率与底层协议本身的效率和对对象进行的序列化和反序列化的效率息息相关。<br>调用 RPC 接口与调用本地方法形式上是相同的，这大大减少了代码的冗余、提升了开发效率，但是 RPC 本质上与普通方法调用却有着截然不同的执行流程，因此必须与普通方法区分开来、不能滥用。在设计微服务时，也必须考虑服务划分的粒度，如果分得过细就有可能导致一次请求需要过多的网络开销。</p>
<h3 id="分布式锁、乐观锁与分布式事务"><a href="#分布式锁、乐观锁与分布式事务" class="headerlink" title="分布式锁、乐观锁与分布式事务"></a>分布式锁、乐观锁与分布式事务</h3><p>单机环境下，资源竞争者都是来自机器内部的进程或线程，那么实现锁的方案只需要借助单机资源就可以了，比如借助磁盘、内存、寄存器来实现。而在分布式环境下，资源竞争者生存环境更复杂了，原有依赖单机的方案不再发挥作用，这时候就需要一个大家都认可的协调者出来，帮助解决竞争问题，那这个协调者称之为<strong>分布式锁</strong>。<br>通过在执行修改操作前加分布式锁，可以很好地保证临界区资源的互斥访问，一定程度上维护了数据的一致性，但是在客户端进行读写的复合操作时加锁又是不充分的，因为读和写操作之间存在一定的时间差，如果在这期间数据被其他线程所修改，那么接下来的写操作就会覆盖这个修改，导致业务层面上的不一致，解决办法是引入<strong>乐观锁</strong>，本文的乐观锁是通过为实体类添加版本号来实现的，每次进行修改操作时需要比较对象与数据库中记录的版本，只有大于的情况才能执行。<br>微服务系统中的多个服务往往拥有自己独立部署的数据库，在跨服务对数据进行写操作时若发生错误就有可能产生数据不一致的情况，利用单纯的加锁机制是不能保证安全性的。<strong>分布式事务</strong>是指会涉及到操作多个数据库的事务，目的是为了保证系统中各服务能保持数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务的所有参与者的动作，事务最终必须统一提交或统一回滚。文中采取的解决办法是引入 TCC 分布式事务，将业务操作划分为 try、confirm、cancel 三个部分，try 负责对业务资源的锁定，confirm 负责提交事务、正式执行业务操作，cancel 负责回滚事务并释放锁定的资源，在业务流程中执行所有的 try 完毕后，由协调者根据事务的执行情况来统一调用所有事务参与者的 confirm 提交或 cancel 回滚。TCC 在本地事务的基础上进行多个实例间的协调，可以在很大程度上保证跨服务业务操作的一致性。</p>
<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p><strong>Spring Cloud</strong>为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如配置管理，服务发现，断路器，智能路由，微代理，控制总线等。</p>
<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><p>Sping Cloud 的实现基础是<strong>Spring Boot</strong>，在构建项目前需要先引入所需基础设施的依赖。<br>比如若需要使用 ZooKeeper 的服务发现功能，只需要在 Maven 的 pom.xml 文件中添加名为”spring-cloud-starter-zookeeper-discovery”的依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>并在属性文件中指定 ZooKeeper 服务器的地址，就可以在应用中通过注入 DiscoveryClient 来使用 ZooKeeper 的服务发现功能了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br></pre></td></tr></table></figure></p>
<p>其他的功能也可以依法炮制。从某种意义上来说，Spring Cloud 更像是通过 Spring Boot 自动配置机制实现的由众多独立子项目组成的大型综合项目。<br>Spring Boot 的主要目标是解决传统 Spring 项目中配置文件过于繁杂的问题，随着业务的复杂度增加，配置变得越来越难维护且无法定制，因此 Spring Boot 的提出者利用注解和属性文件来取代配置文件，因为注解是与代码紧紧相依的，代码中可以直接通过注解来获取到属性文件中的属性，并按用户的需求来执行 Bean 的初始化过程，从而实现配置的高度可定制化。Spring Boot 的关键特性是自动配置，实现自动配置的方式是在应用启动后从 Spring Boot 提供的包内获取配置好的 Bean，并对常用的配置设定默认值，比如其内置的 Tomcat 服务器的默认占用端口即为 8080，并且支持在属性文件中修改，这在很大程度上减少了配置项的数量，同时也降低了运维人员的压力。 </p>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p>Spring Cloud 和 Dubbo 区别?为什么不使用 Dubbo？？？</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 执行流程？为什么用它来部署环境？</p>
<p>Docker 是一个基于容器的应用开发、部署和运行平台，它为开发者和系统管理员们提供了一种新式的应用部署方式，具有灵活、轻量、可移植等特点。传统的部署云服务的方式是通过虚拟机完成的，虚拟机会在宿主机上运行一个完整的操作系统、通过 hypervisor 来间接使用宿主机的硬件资源，实际上这远远超出了应用运行所必须的资源要求。而容器正相反，它在操作系统中作为进程运行，与所有其他容器共享同一内核、占用相同容量的内存空间，相对来说会更加轻量。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL 是一种常用的开源数据库，MySQL 软件采用了双授权政策，分社区版和商业版，具有体积小、速度快、总体拥有成本低、开放源码等特点。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 有哪些数据结构？</p>
<p>Redis 是一个开源的使用 ANSI C 语言编写、支持网络、支持持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx 执行流程？反向代理解释一下？为什么使用 Nginx 作为静态页面服务器？负载均衡原理是什么？</p>
<p>Nginx 是一款高性能的 HTTP 和反向代理服务器软件，具有高性能、高并发、低 CPU 内存消耗的特点，功能包括反向代理、负载均衡、访问控制等，且可以根据需要自定义扩展组件。</p>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>ZooKeeper 执行流程？服务发现原理是什么？分布式锁原理是什么？</p>
<p>ZooKeeper 是一个分布式的开放源码的分布式应用程序协调服务，可以为分布式应用提供一致性服务，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>ZooKeeper 将资源抽象为文件系统，使用节点来表示数据在该文件系统中保存的路径。为了实现服务发现机制，每个实例在加入应用服务时会在 ZooKeeper 服务的同一命名空间下创建临时节点，并在退出时由 ZooKeeper 自动删除，这样任一个实例都可以通过查询该命名空间下来获得微服务集群内服务的注册情况。ZooKeeper 本身不提供锁服务，但是可以使用节点来表示锁，如果一个客户端需要为一个资源上锁，就可以为该资源所代表的路径下创建一个顺序节点，按照节点创建的顺序进行标号，客户端监听该路径下的节点，如果自己创建的节点标号是最小的就获取到锁，当释放锁时需要删除自己创建的节点，这样基本实现了客户端之间的互斥访问。</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 执行流程？消息队列的数据结构是怎样的？</p>
<p>RabbitMQ 是一个在 AMQP 基础上完成的、可复用的企业消息系统。AMQP 协议定义了消息队列需要具有的面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全性等特点。RabbitMQ 是一个开源的 AMQP 实现，服务器端用 Erlang 语言编写，支持包括 Java 在内的多种客户端，主要应用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch 执行流程？文档数据结构是怎样的？</p>
<p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。擅长全文搜索、结构化数据的实时统计、复杂的语言处理等。并且原生支持分布式部署，可以通过管理多节点来提高扩容性和可用性，并在硬件故障时确保数据安全。</p>
<hr>
<h2 id="架构设计与实现"><a href="#架构设计与实现" class="headerlink" title="架构设计与实现"></a>架构设计与实现</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>微服务的首要任务是对模块进行拆分，整个系统的主要模块如下图所示。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/发债管理系统模块图.png" alt="X" title="发债管理系统模块图"><br>需要实现的主要功能包括：</p>
<ol>
<li>使用权限模块来实现权限分配、功能隔离、租户隔离；</li>
<li>用户能够利用该系统进行发债放款、审批、结算等；</li>
<li>用户能获得预警信息；</li>
<li>系统内需要使用服务发现机制来实现服务的弹性伸缩。</li>
</ol>
<p>每个模块成为一个独立的服务，它们具有明确清晰的功能边界，且相互之间只暴露必要的远程接口，形成类似下图的结构。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/基于微服务的发债管理系统架构图.png" alt="X" title="单体式应用和微服务应用部署图"></p>
<p>部分功能的实现涉及到一些中间件，更详细的架构图如下图所示。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/基于微服务的发债管理系统总体实现架构图.png" alt="X" title="基于微服务的发债管理系统总体实现架构图"><br>其中：</p>
<ul>
<li>主要功能模块拥有独立的数据库，它们是独立部署的；</li>
<li>服务发现服务用于自动实现服务的上下线，使用 ZooKeeper 服务器作为服务注册中心，服务发现服务会将注册在 ZooKeeper 服务器上的服务信息更新到 Nginx 服务器上；</li>
<li>Docker 提供容器形式的运行环境，使用 Docker Swarm 管理容器集群，服务和中间件运行在容器实例内，称为服务实例，多个服务实例组成一个服务；</li>
<li>Nginx 有两个作用：<ol>
<li>作为静态文件服务器。前端使用 React 开发，通过运行 <code>npm run build</code> 编译成为静态文件，将产生的整个文件夹移动到 Nginx 的静态文件目录下；</li>
<li>负载均衡。Nginx 是一个反向代理服务器，调用任何服务的 REST 接口需要先经过 Nginx 进行转发，Nginx 在同一服务的各个实例间进行负载均衡。比如一次放款提交请求，请求会经过 Web 客户端、Nginx、发债管理、审批管理这几个服务。<br>业务服务需要保持无状态，这样才能启动多个而不影响负载均衡的有效性，而各种中间件（如 ZooKeeper、RabbitMQ）一般有自己组织集群的协议，集群一般由 master 和 slave 组成，需要在 Nginx 中配置其中 master 节点的地址。</li>
</ol>
</li>
<li>Radis 集群组成了缓存服务，因为系统中涉及到的业务大部分是读多写少的，因此缓存对提高效率是很有必要的；</li>
<li>RabbitMQ 集群组成消息队列服务，消息队列可以解耦消息管理服务和业务服务，另外，消息队列也是实现异步调用必须的，消息队列提供重试、备份等功能，有利于实现可靠消息的最终一致性效果。</li>
</ul>
<h3 id="部分功能实现"><a href="#部分功能实现" class="headerlink" title="部分功能实现"></a>部分功能实现</h3><p>我将大部分业务功能忽略了，这些功能中大部分都属于简单的 CRUD 操作，下面介绍一些技术性稍微强一些的功能的实现细节。</p>
<h4 id="服务发现功能"><a href="#服务发现功能" class="headerlink" title="服务发现功能"></a>服务发现功能</h4><p><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/服务发现功能时序图.png" alt="X" title="服务发现功能时序图"><br>服务发现功能的主要运行流程大体分成三个阶段，通过定时器来定时执行：</p>
<ol>
<li>从 zk 服务器获取服务注册信息<br>在启动服务实例后，新建的服务实例会向 ZooKeeper 服务器发送该服务的注册信息，在 ZooKeeper 中这些信息作为存在于同一命名空间下的临时节点存在。</li>
<li>构建配置文件，并上传到 Nginx 服务器<br>服务发现服务器会定时地从 ZooKeeper 服务器获取微服务集群内服务的注册情况。</li>
<li>远程执行命令，更新 Nginx 服务器<br>在获取到服务的注册信息后，服务发现模块会将数据组织成 Nginx 配置文件的格式，并上传到 Nginx 服务器内，因为 Nginx 是运行在容器之内的，所以客户端需要通过 Docker 提供的 REST API 来操作容器来达到间接操作 Nginx 服务器的目的，在上传完毕后使用 Docker 容器运行命令的接口来执行 Nginx 重新加载配置文件的命令，至此完成服务上线的过程。</li>
</ol>
<p>当实例退出集群时，代表其服务注册信息的临时节点会被自动清除，此时 Nginx 服务器经过同样的刷新过程将该实例移除出代理目标，由此完成服务的自动伸缩。</p>
<p>在实际环境中启动服务之前，需要先将项目打包成为 Docker 镜像，利用 Docker 技术只要服务器上安装有 Docker 环境即可启动应用，很大程度上减少了重复修改服务本身配置文件的麻烦，因为业务模块的框架是基于 SpringCloud 的，在启动后利用 SpringBoot 自动配置的便利，可以在初始化时调用 ZooKeeper 服务器提供的接口将服务注册到 ZooKeeper 的服务注册中心。服务发现模块的执行流程图如下图所示。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/服务发现流程图.png" alt="X" title="服务发现流程图"></p>
<p>其中，更新 Nginx 配置文件的主要代码如下所示。<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建nginx.conf配置文件</span></span><br><span class="line">String content = buildConf();</span><br><span class="line">String localPath = dockerDiscoveryClient.getLocalNginxConfPath(); <span class="comment">// 本地配置文件保存位置</span></span><br><span class="line">String fileName = dockerDiscoveryClient.getLocalNginxConfFileName(); <span class="comment">// 配置文件名</span></span><br><span class="line">String containerPath = dockerDiscoveryClient.getContainerNginxConfPath(); <span class="comment">// 容器内配置文件位置</span></span><br><span class="line">writeConf(localPath + containerPath, fileName, content);</span><br><span class="line"><span class="comment">// 遍历所有nginx服务器，重载配置文件</span></span><br><span class="line"><span class="keyword">for</span> (Container container : nginxContainerList) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = sdHelper.getMaxRetries() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将配置文件上传到服务器</span></span><br><span class="line">      upload(localPath + containerPath, container.id(), containerPath);</span><br><span class="line">      <span class="comment">// 重新加载nginx服务器</span></span><br><span class="line">      reload(container.id());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DockerDiscoveryException e) &#123;</span><br><span class="line">      <span class="comment">// 发生错误，重新上传加载</span></span><br><span class="line">      log.info(<span class="string">"Reload Nginx failed, retrying left "</span> + i + <span class="string">" times"</span>, e);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div><br>在将服务实例信息转换为 Nginx 配置文件后，需要循环遍历所有现存的 Nginx 服务器，对服务器地址的请求若出错需要一定次数的重试，尽可能地更新。<br>   客户端或其他模块通过 REST 协议来访问服务的接口，访问请求由网关服务器进行拦截，再通过负载均衡技术来发布到某个服务的实例上。</p>
<h4 id="放款更新功能"><a href="#放款更新功能" class="headerlink" title="放款更新功能"></a>放款更新功能</h4><p><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/放款更新时序图.png" alt="X" title="放款更新时序图"><br>考虑多用户登录系统并同时对同一实体执行更新操作时，就有可能发生竞态条件。如果使用普通的加锁方式只能保证同一进程内的线程同步、不能保证多个服务实例进程间的互斥访问，解决办法是引入 ZooKeeper 的分布式锁和时间戳机制，在每次修改实体后更新实体的版本，并在每次对实体 ID 加锁后再与数据库中保留的最后一次修改时的版本进行校验，加锁将使得临界区代码在集群内只能被一个服务实例的线程调用，在修改完毕退出后更新实体版本，另一个线程进入后再根据版本进行校验，从而保证了服务间的并发写的一致性。<br>时间戳的实现比较简单，而分布式锁的实现则涉及到很多细节，已知的包括：</p>
<ul>
<li>加锁操作的原子性、只有自己可以解锁自己、死锁、线程宕掉、耗时、失效时间、阻塞、可重入。</li>
</ul>
<h4 id="放款提交功能"><a href="#放款提交功能" class="headerlink" title="放款提交功能"></a>放款提交功能</h4><p>发债模块在对单据进行提交操作时实际上需要调用审批服务提供的 RPC 接口，在提交后用户即可在审批模块中查找到这些单据，并可以对其进行审批或取消审批、驳回等操作。首先需要解释的是服务为何如此划分，需要结合企业的具体业务来考虑，因为审批是十分宽泛的场景，不只是发债单据需要审批，为了提高模块的可扩展性，将其划分出来作为单独的服务是合理的。放款提交操作的时序图如下图所示。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/放款提交时序图.png" alt="X" title="放款提交时序图"><br>和其他增删改查操作相同的是，在具体的业务处理之前需要对放款进行加锁和版本校验，成功后发债服务会将该放款信息通过调用服务接口的方式提交到审批服务，审批服务会先根据放款的单据类型从数据库查找其审批流的注册信息及审批流，并成功便新增一条审批流实例到数据库，返回成功信息给发债服务，发债服务再根据返回值来修改放款的审批状态；如果查询或新增失败，审批会返回错误信息，使得发债服务也不会进行任何处理，或者处理后回滚到最初的状态。<br>发债模块并不了解审批模块内部的实现方式，二者使用相互独立的两个数据库，因此在执行审批操作时是可能发生不一致的情况的，为此需要引入 TCC 补偿机制，对提交操作需要提供一个 confirm 接口和一个 cancel 接口，代表统一的提交和回滚。<br>放款提交的具体执行过程如下图所示。<br><img src="http://47.88.24.11/基于微服务的资金云系统发债管理子系统/放款提交流程图.png" alt="X" title="放款提交流程图"><br>在登记放款页面点击提交按钮后会将放款单的 ID、版本号等信息发送到后台，程序的初步执行流程仍然是上分布式锁、校验版本号及设置新版本号和更新时间，接下来由于涉及到跨服务的写库操作所以会显得更加复杂。<br>首先服务调用方的发债服务需要生成本次调用的调用 ID，其作用之后再作论述，因为发债服务的本次调用是事务内的第一次调用，所以还需要生成一个链路 ID，用于标识一次事务，这些 ID 都需要全局唯一，所以和实体 ID 一样需要使用分布式唯一 ID 算法来生成。发债服务在调用审批服务的接口时，除了传递本来需要传递的单据信息之外，还需要将调用 ID 和链路 ID 打包一同传递，以便之后审批服务将 TCC 事务的参与信息上传到缓存中间件。事务的参与者分为根参与者和枝叶参与者，根参与者为事务的发起者，在这里即为发债服务，枝叶参与者包括事务通过传播到达的所有其余服务器，参与者包含的属性包括服务器本身的地址及 TCC 补偿事务所需的 confirm 接口和 cancel，只要某个服务接口需要添加事务属性，它就需要将自己的参与者信息上传到缓存中间件中，因此这里审批服务还有一个上传参与者信息的过程。实现 TCC 补偿事务中根参与者执行流程的关键代码如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">interceptRoot</span><span class="params">(Participator participator, MethodWrapper methodWrapper)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> TccException </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行try</span></span><br><span class="line">    log.info(<span class="string">"-&gt; ROOT.try执行"</span>);</span><br><span class="line">    result = methodWrapper.invoke();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">    <span class="comment">// 执行cancel</span></span><br><span class="line">    log.info(<span class="string">"&lt;- ROOT.try出错.即将执行cancel"</span>, cause);</span><br><span class="line">    tccCoordinateHelper.submitCancel(traceIdHelper.getTraceId());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TccException(<span class="string">"Method invocating failed. cause:"</span> + cause.getMessage(), cause);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行confirm，结束后会发送确认信息</span></span><br><span class="line">  log.info(<span class="string">"&lt;- ROOT.try完毕.即将执行confirm"</span>);</span><br><span class="line">  tccCoordinateHelper.submitConfirm(traceIdHelper.getTraceId());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在前面的准备工作完成后，审批服务正式进入业务处理流程，首先需要根据登记放款的单据类型去数据库中查找审批流注册信息，因为审批存在多级审批的场景，因此每条审批流关联了自己下一阶段的审批流，这里为了创建审批流实例需要找到源头第一条审批流，并将发债传递来的单据信息填入即可得到审批流实例。<br>保存审批流实例时不能直接保存到实体本身代表的数据库表中，而是要暂时保存到一个 dr 表中暂存，表名为“实体名_dr”，因为此时事务并没有完成，如果直接保存到实体表中，直接去审批流页面查询是能查出的，也就是说会发生“脏读”的现象，暂时保存到这个暂存表中，还可以作为日志，供系统发生故障时手动恢复之用。审批服务执行完毕之后，发债服务需要使用其返还值来更新发债数据库中的放款状态。但是事务还未完成，因为审批服务还没有将审批实例实际保存到实体表中，发债服务需要先使用链路 ID 从缓存中间件中获取所有事物参与者信息，然后根据提交操作是否成功来决定是调用 confirm 还是 cancel，这里 confirm 的逻辑是将 dr 表中的审批流实例转移到实体表中，而 cancel 是将该审批流实例从 dr 表中移除、发债服务回滚。<br>为了应对偶尔的网络不稳定等情况，根参与者需要在异常发生时再重试一定的次数，另外，试想如果请求的超时也被当成故障处理了，那么多次的写操作很有可能会为系统引入脏数据了，因此 confirm 和 cancel 接口需要额外地保证接口的幂等性，为了校验接口是否被多次调用，需要客户端在发出请求时带上此次请求的调用 ID，服务端需要缓存调用 ID 并对请求的重复性进行校验。<br>最后发债服务释放放款 ID 上的锁，完成一次提交操作。其他审批接口、结算管理的相应接口实现思路是类似的，在此不另加论述。</p>
<p><strong>总而言之</strong>，提交操作是需要跨服务写库的，除了在修改操作的加锁和版本校验之外，还需要注意<strong>TCC 的执行流程</strong>：</p>
<ol>
<li>TCC 事务需要每个参与者提供 try、confirm 和 cancel 三个接口，try 执行资源的预留，比如对涉及的实体加锁，也起着服务验活的功能，confirm 执行事务的提交，也就是真正地执行业务操作、将数据持久化到数据库，cancel 需要释放预留的资源；</li>
<li>每个事务参与者将自己的信息提交到 Redis 缓存内，之后根参与者需要取得所有参与者信息，主要是它们的 confirm 和 cancel 接口的地址；</li>
<li>根据 confirm 执行情况，有：<ol>
<li>如果业务操作都成功了，由第个参与者来调用所有其他参与者的 confirm 接口来提交事务；</li>
<li>如果业务操作失败了，同样由第一个参与者来调用所有其他参与者的 cancel 接口来回滚事务。</li>
</ol>
</li>
</ol>
<p><strong>调用 ID 和链路 ID 的作用</strong>，前者可以用于保证接口调用的<strong>幂等性</strong>，后者主要用来定位事务内的参与者。</p>
<p>用一个常见的用户购买商品场景为例，需要先确保用户能够支付，然后锁住用户和商户的账户，这是 try 阶段；如果 try 成功，即预留资源成功了，接下来再对用户账户扣款、商户账户入账，如果因为超时等原因失败了，需要事务补偿，即重试，这是 confirm 阶段；如果 try 失败，则释放所有的锁，这是 cancel 阶段。</p>
<hr>
<hr>
<h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><p>当前的系统仍存在很多可改进的地方。</p>
<h3 id="服务发现功能-1"><a href="#服务发现功能-1" class="headerlink" title="服务发现功能"></a>服务发现功能</h3><h4 id="使用-Eureka-等高可用服务发现产品替代-ZooKeeper"><a href="#使用-Eureka-等高可用服务发现产品替代-ZooKeeper" class="headerlink" title="使用 Eureka 等高可用服务发现产品替代 ZooKeeper"></a>使用 Eureka 等高可用服务发现产品替代 ZooKeeper</h4><p>ZooKeeper 集群通过 Zab 协议保证高一致性，重新选举 Leader 比较耗时，且当节点数量不足以构成容错集群时，ZooKeeper 倾向于返回空；故提出改用 Eureka 等其他倾向于提供高可用性的具有服务发现功能的产品。</p>
<h4 id="使用复制和-DNS-等手段工具提升-Nginx-服务器的可用性"><a href="#使用复制和-DNS-等手段工具提升-Nginx-服务器的可用性" class="headerlink" title="使用复制和 DNS 等手段工具提升 Nginx 服务器的可用性"></a>使用复制和 DNS 等手段工具提升 Nginx 服务器的可用性</h4><p>Nginx 服务器作为网关，存在单点故障风险，但是这里的服务发现只能保证被 Nginx 代理的那些服务能弹性伸缩，对 Nginx 本身却没有什么办法，就算复制了 Nginx 服务器，客户端也只能发到一个 IP 上。这里提出使用基于操作系统的方案对 Nginx 集群实现验活及负载均衡，主要是 Keepalived 等软件或独立的 DNS 服务器，但是论文题目限于 Saas 层展开，本人水平有限没法解释。</p>
<h3 id="服务间通信功能（RPC）"><a href="#服务间通信功能（RPC）" class="headerlink" title="服务间通信功能（RPC）"></a>服务间通信功能（RPC）</h3><h4 id="使用-TCP-等更底层、灵活的协议"><a href="#使用-TCP-等更底层、灵活的协议" class="headerlink" title="使用 TCP 等更底层、灵活的协议"></a>使用 TCP 等更底层、灵活的协议</h4><p>HTTP 是应用层的，Spring Boot 封装了一个 RestTemplate 可以很方便地发 HTTP 请求。而 TCP 是传输层的，如何包装消息需要另外再讨论，常见的框架如 Netty，提供了长连接、心跳检测等功能，可以提高开发效率。</p>
<h4 id="使用-Kryo-等更完善的序列化工具"><a href="#使用-Kryo-等更完善的序列化工具" class="headerlink" title="使用 Kryo 等更完善的序列化工具"></a>使用 Kryo 等更完善的序列化工具</h4><p>Kryo 是一个优秀的 Java 序列化方案，大概用了很多优化方案，这就是很零碎的编程问题了。<br>TCC 的 confir 和 cance 都有可能出错，一般都需要手动恢复，异常日志指的是 redo 和 undo 日志，redo 是未执行前的数据值，undo 是执行修改后的数据值。</p>
<h3 id="服务间一致性（TCC-事务）"><a href="#服务间一致性（TCC-事务）" class="headerlink" title="服务间一致性（TCC 事务）"></a>服务间一致性（TCC 事务）</h3><p>考虑 TCC 事务发生异常的情况，做好 redo/undo 日志，供出错时手动执行恢复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/179723ca.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/179723ca.html" itemprop="url">NCC 后台简析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T00:54:39+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/28039232/what-is-the-difference-between-dependency-injection-and-dependency-look-up" target="_blank" rel="noopener">What is the difference between dependency injection and dependency look up?</a></li>
</ol>
<h2 id="背景情况"><a href="#背景情况" class="headerlink" title="背景情况"></a>背景情况</h2><p>部门开始推一个大项目 NCC，后台几乎沿用原 NC（有近十年历史），将原来 JavaSwing 画的重量前端换成了一种“轻量前端”，其实这种轻量前端一点都不轻量；SQL 完全是自己用字符串拼接起来的；开发模式是前后端分离联调的方式，但是因为后台代码都是部署在一个服务里头的，没有司库云（微服务架构）复杂。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/179723ca.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/9b8ed85e.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/9b8ed85e.html" itemprop="url">公司大佬关于编码规范的一次分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T16:13:15+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/编码规范/" itemprop="url" rel="index">
                    <span itemprop="name">编码规范</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/SevenGirl2017/article/details/77678233" target="_blank" rel="noopener">数据库范式简单讲解(1NF、2NF、3NF、4NF、BCNF)</a></li>
<li><a href="https://www.cnblogs.com/duanxz/p/3783369.html" target="_blank" rel="noopener">缓存与数据库一致性之二：高并发下的 key 重建（先淘汰 cache 再写 db）的问题</a></li>
</ol>
<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>公司比较看重这批新员工（基本来自 985 院校），做了比较多的培训，从公司文化到衣着讲究都专门开了课，很切合应届毕业生的需求（强制参加的…）。<br>规范类似设计模式，是对最佳实践的总结，有点收获，这里把还记得的部分总结一下。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/9b8ed85e.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b868cbc8.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b868cbc8.html" itemprop="url">记 2018 年 8 月 9 日的转正答辩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T23:33:05+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/问题收集/" itemprop="url" rel="index">
                    <span itemprop="name">问题收集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://segmentfault.com/q/1010000010446129" target="_blank" rel="noopener">想了解 Aio 与 Nio 的利弊，为什么 Netty 没有采用 Aio 实现？</a></li>
</ol>
<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>因为毕设的关系，在用友实习了整整半年，在这期间参与了司库云这个项目的开发，因此在试用期最后的转正答辩中我就这段经历进行了一些分享和延伸。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/b868cbc8.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/6ca318ec.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/6ca318ec.html" itemprop="url">记一次硬盘数据的迁移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T23:16:23+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/折腾/" itemprop="url" rel="index">
                    <span itemprop="name">折腾</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/fishseeker/article/details/74611115" target="_blank" rel="noopener">迁移 linux 系统到新硬盘</a></li>
<li><a href="https://jingyan.baidu.com/article/cbf0e500a9731e2eab289371.html" target="_blank" rel="noopener">如何使用 fdisk 进行分区</a></li>
<li><a href="https://blog.csdn.net/erazy0/article/details/6087554" target="_blank" rel="noopener">dd 与 cp 的区别</a></li>
</ol>
<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>之前一直在用的老 SSD 只有 128GB，上边装了 Ubuntu 作为宿主 OS，另外常备一个 Windows7 的虚拟机，时常面临空间不够的问题，一般是用 Vmware 中 Hard Disk 的<strong>Compact Disk</strong>功能来挤出一些空间来，但是这样频繁的硬盘读写对硬盘寿命多少有些影响。<br>后来换新机时自带的 SSD 是 256GB 的，当时出于方便不想重装环境就用老的 SSD 替换了下来，现在抽出一块时间把数据都转移到新硬盘上，尽量不影响平时的工作。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/6ca318ec.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d8d2dc24.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/d8d2dc24.html" itemprop="url">淘淘网络商城</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T19:13:29+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该项目是 2017 年参加学院组织的实训项目期间同小组成员开发的，是一个简化版的电商项目。</p>
<h3 id="涉及到的技术"><a href="#涉及到的技术" class="headerlink" title="涉及到的技术"></a>涉及到的技术</h3><ol>
<li>掌握高并发站点的系统架构方法。</li>
<li>熟悉 linux 开发环境,掌握 tomcat、mysql 服务器集群的安装与配置。</li>
<li>理解 web 服务器的负载均衡原理,掌握配置方法。</li>
<li>掌握数据库主从复制,读写分离技术。</li>
<li>理解缓存原理,掌握缓存在程序开发的原理。</li>
<li>掌握 web 站点的动静分离技术。</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/d8d2dc24.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/f3fb008f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/f3fb008f.html" itemprop="url">博客搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-04T21:57:55+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="一、参考"><a href="#一、参考" class="headerlink" title="一、参考"></a>一、参考</h2><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><ol>
<li><a href="https://www.jianshu.com/p/1c98aed8d92e" target="_blank" rel="noopener">使用 Github 空间搭建 Hexo 技术博客–安装篇（基于 IntelliJ IDEA）</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a><h3 id="hexo-使用"><a href="#hexo-使用" class="headerlink" title="hexo 使用"></a>hexo 使用</h3></li>
<li><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">hexo-指令</a></li>
<li><a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95" target="_blank" rel="noopener">NexT 常见问题</a></li>
<li><a href="https://blog.csdn.net/weixin_38796712/article/details/79234849" target="_blank" rel="noopener">hexo 搭建个人博客–基础篇</a></li>
<li><a href="https://blog.csdn.net/weixin_38796712/article/details/79372789" target="_blank" rel="noopener">hexo 搭建个人博客–NexT 主题优化</a></li>
<li><a href="https://blog.csdn.net/weixin_38796712/article/details/79444780" target="_blank" rel="noopener">hexo 搭建个人博客–SEO 和站点加速</a><h3 id="在-GitHub-上写博客"><a href="#在-GitHub-上写博客" class="headerlink" title="在 GitHub 上写博客"></a>在 GitHub 上写博客</h3></li>
<li><a href="https://help.github.com/en/categories/writing-on-github" target="_blank" rel="noopener">Writing on GitHub</a></li>
<li><a href="http://muyunyun.cn/posts/f55182c5/#more" target="_blank" rel="noopener">hexo 摸爬滚打之进阶教程</a></li>
<li><a href="https://segmentfault.com/q/1010000002561642" target="_blank" rel="noopener">hexo 分类与 tags 配置</a></li>
<li><a href="https://github.com/guodongxiaren/README/blob/master/emoji.md" target="_blank" rel="noopener">Emoji 表情</a></li>
<li><a href="https://blog.csdn.net/u012195214/article/details/79204607" target="_blank" rel="noopener">使用七牛云作为图床获取外链方式总结</a><h3 id="添加持久链接功能"><a href="#添加持久链接功能" class="headerlink" title="添加持久链接功能"></a>添加持久链接功能</h3></li>
<li><a href="https://blog.csdn.net/yanzi1225627/article/details/77761488?locationNum=7&amp;fps=1" target="_blank" rel="noopener">hexo 链接持久化终极解决之道</a><h3 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h3></li>
<li><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">Hexo NexT 主题中集成 gitalk 评论系统</a><h3 id="添加网站统计功能"><a href="#添加网站统计功能" class="headerlink" title="添加网站统计功能"></a>添加网站统计功能</h3></li>
<li><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a></li>
<li><a href="https://www.jianshu.com/p/ae3daec00970" target="_blank" rel="noopener">Hexo+Next 主题 文章添加阅读次数，访问量等（需要额外添加不蒜子脚本<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>）</a></li>
<li><a href="https://blog.csdn.net/wangxw725/article/details/71602256?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">Hexo 添加字数统计、阅读时长、友情链接</a><h3 id="添加看板动画"><a href="#添加看板动画" class="headerlink" title="添加看板动画"></a>添加看板动画</h3></li>
<li><a href="https://juejin.im/post/5b447600f265da0fa332d8ac" target="_blank" rel="noopener">hexo 添加 live2d 看板动画</a><h3 id="添加复选框样式"><a href="#添加复选框样式" class="headerlink" title="添加复选框样式"></a>添加复选框样式</h3></li>
<li><a href="https://www.v2ex.com/t/295617" target="_blank" rel="noopener">用 VPS+hexo 搭了个博客，如何让 hexo 支持复选框</a></li>
<li><a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexojs/hexo-renderer-marked</a></li>
</ol>
<h2 id="二、博客搭建"><a href="#二、博客搭建" class="headerlink" title="二、博客搭建"></a>二、博客搭建</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>创建 GitHub Pages 仓库</li>
<li>安装 hexo 博客框架</li>
<li>初始化 hexo 项目</li>
<li>提交 hexo</li>
<li>配置 hexo</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/f3fb008f.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/ea6e9398.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ea6e9398.html" itemprop="url">内存池介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T23:58:06+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/功能设计/" itemprop="url" rel="index">
                    <span itemprop="name">功能设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><h3 id="buffer-cache-pool"><a href="#buffer-cache-pool" class="headerlink" title="buffer/cache/pool"></a>buffer/cache/pool</h3><p>cache（高速缓存）是一种介于寄存器和内存之间的存储器，访问速度也在他们二者之间，当用户程序请求存储空间时，会先尝试从 cache 获取，当找不到时再到内存中找，并且找到的页及其临近的几页都会被拿到 cache 中去以备下次访问。<br>而 buffer 出现的地方比较多，比如 java4 引入的 NIO 中就有一个 Buffer，它的主要作用是缓冲从 Channel 中取到的数据，服务器接收到网络请求时从准备到开始接收数据是有一定的时延的，当出现大量的小请求时，很容易造成资源的浪费，所以引入了缓冲区。<br>pool 常出现在一些框架中，常见的有数据库连接池、内存池，它和 buffer 有些区别，pool 中的对象往往可以重复利用。</p>
<h3 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc/free"></a>malloc/free</h3><p>通过调用 malloc 和 free 函数可以实现在堆上的对象分配，这是 C 语言标准库提供的最基本的手动管理内存分配的方法，但是 malloc/free 实现的其实是最基本的 <strong>指针碰撞（Bump the Pointer）</strong> 内存分配方式，每次分配时都会从空闲块链表表头开始搜索，找到足够大的一块就返回，释放时同样是在空闲块链表中遍历，找到它的分配位置，再和前后两块合并。  </p>
<p>显然，这种方式存在一些缺陷：  </p>
<ul>
<li>大量分配后空闲块链表变得很长（时间开销）</li>
<li>产生大量内存碎片（空间开销）</li>
<li>使用麻烦，容易造成内存泄露（申请后忘了释放）</li>
</ul>
<p>下面是一种 malloc/free 的实现：<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">typedef long Align; //最受限类型</span><br><span class="line"></span><br><span class="line">union header&#123; //块头部</span><br><span class="line">    struct&#123;</span><br><span class="line">        union header *ptr; //空闲块链表的下一块</span><br><span class="line">        unsigned size; //本块的大小</span><br><span class="line">    &#125;s;</span><br><span class="line">    Align x; //强制块对齐，即强制header最小不小于Align</span><br><span class="line">&#125;;</span><br><span class="line">typedef union header Header;</span><br><span class="line">/******************************************/</span><br><span class="line">#define MAXBYTES (unsigned)10240</span><br><span class="line"></span><br><span class="line">static Header base;//链表</span><br><span class="line">static Header *freep = NULL;//空闲链表的初始指针</span><br><span class="line"></span><br><span class="line">/* malloc函数：存储分配 */</span><br><span class="line">void *malloc(unsigned nbytes)&#123;</span><br><span class="line">    Header *p, *prevp;</span><br><span class="line">    Header *morecore(unsigned);</span><br><span class="line">    unsigned nunits;</span><br><span class="line">    </span><br><span class="line">    //超出可分配字节数上限</span><br><span class="line">    if(nbytes &gt; MAXBYTES)&#123;</span><br><span class="line">        fprintf(stderr, &quot;alloc: can&apos;t allocate more than %u bytes\n&quot;, MAXBYTES);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //需要分配的块数</span><br><span class="line">    nunits = (nbytes + sizeof(Header) - 1) / sizeof(Header) + 1;</span><br><span class="line">    //空闲链表不存在</span><br><span class="line">    if((prevp = freep) == NULL)&#123;</span><br><span class="line">        base.s.ptr = freep = prevp = &amp;base;</span><br><span class="line">        base.s.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) &#123;</span><br><span class="line">        //足够分配</span><br><span class="line">        if(p-&gt;s.size &gt;= nunits)&#123;</span><br><span class="line">            if(p-&gt;s.size == nunits)&#123;</span><br><span class="line">                prevp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                //如果找到的块太大，则分配其末尾部分</span><br><span class="line">                p-&gt;s.size -= nunits;</span><br><span class="line">                p += p-&gt;s.size;</span><br><span class="line">                p-&gt;s.size = nunits;</span><br><span class="line">            &#125;</span><br><span class="line">            freep = prevp;</span><br><span class="line">            return (void*)(p + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //闭环的空闲链表</span><br><span class="line">        if(p == freep)&#123;</span><br><span class="line">            if((p = morecore(nunits)) == NULL)&#123;</span><br><span class="line">                return NULL;//系统无剩余存储空间</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define NALLOC 1024 //最小申请单元数</span><br><span class="line">static unsigned maxalloc; //当前已分配的最大内存块的长度</span><br><span class="line">/* morecore函数：向系统申请更多的存储空间 */</span><br><span class="line">Header *morecore(unsigned nu)&#123;</span><br><span class="line">    char *cp, *sbrk(int);</span><br><span class="line">    Header *up;</span><br><span class="line">    </span><br><span class="line">    if(nu &lt; NALLOC)&#123;</span><br><span class="line">        nu = NALLOC;</span><br><span class="line">    &#125;</span><br><span class="line">    cp = sbrk(nu * sizeof(Header));</span><br><span class="line">    if(cp == (char*) - 1)&#123; //没有空间</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    up = (Header*)cp;</span><br><span class="line">    up-&gt;s.size = nu;</span><br><span class="line">    maxalloc = (up-&gt;s.size &gt; maxalloc) ? up-&gt;s.size : maxalloc;</span><br><span class="line">    //把多余的存储空间插入到空闲区域</span><br><span class="line">    free((void*)(up + 1));</span><br><span class="line">    return freep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* free函数：将块ap放入空闲块链表中 */</span><br><span class="line">void free(void *ap)&#123;</span><br><span class="line">    Header *bp, *p;</span><br><span class="line">    </span><br><span class="line">    bp = (Header*)ap - 1; //块头</span><br><span class="line">    //欲free的内存块长度不能等于0或者大于当前已分配的最大内存块长度</span><br><span class="line">    if(bp-&gt;s.size == 0 || bp-&gt;s.size &gt; maxalloc)&#123;</span><br><span class="line">        fprintf(stderr, &quot;free: can&apos;t free %u units\n&quot;, bp-&gt;s.size);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    //扫描空闲块链表，找到bp所处位置，它可能在两个空闲块之间，也可能在链表末尾</span><br><span class="line">    for(p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)&#123;</span><br><span class="line">        //被释放的块在链表的开头或末尾</span><br><span class="line">        if(p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //与上一相邻（空闲）块合并</span><br><span class="line">    if(bp + bp-&gt;s.size == p-&gt;s.ptr)&#123;</span><br><span class="line">        bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;</span><br><span class="line">        bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;//说明中间有已经分配的块</span><br><span class="line">        bp-&gt;s.ptr = p-&gt;s.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    //与下一相邻（空闲）块合并</span><br><span class="line">    if(p + p-&gt;s.size == bp)&#123;</span><br><span class="line">        p-&gt;s.size += bp-&gt;s.size;</span><br><span class="line">        p-&gt;s.ptr = bp-&gt;s.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;//说明中间有已经分配的块</span><br><span class="line">        p-&gt;s.ptr = bp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div><br>简单的测试：<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MyList &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct MyList *next;</span><br><span class="line">&#125; MyList;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    int n = 1000000;</span><br><span class="line">    while(n--) &#123;</span><br><span class="line">        MyList *list = malloc(sizeof(MyList));</span><br><span class="line">        free(list);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="设计简单内存池"><a href="#设计简单内存池" class="headerlink" title="设计简单内存池"></a>设计简单内存池</h3><p>内存池和线程池或数据库连接池（各种池）的实现机制类似，都是事先申请一大块资源，当实际使用时，不必再去申请内存，而是直接从内存池中“拿”，如果内存池设计得好，完全可以避免直接使用 malloc/free 进行内存管理的问题。  </p>
<p>下面的代码很大程度上参考了 <a href="https://github.com/bangerlee/mempool" target="_blank" rel="noopener">这里</a> 的实现<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">mem_pool.h</span><br><span class="line">#ifndef _MEM_POOL_H</span><br><span class="line">#define _MEM_POOL_H</span><br><span class="line"></span><br><span class="line">#define BLOCKHEAD_SIZE 24 // 两个地址值合为16位，再加上8位验证码</span><br><span class="line">#define MAGIC_CODE 0x123456 // 验证码（用于free内存块的时候判断是否是合法的内存块）</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 内存块</span><br><span class="line"> * 1.data包含head和body两部分</span><br><span class="line"> * head包括指向对应block的指针、对应list的指针及验证码（MAGIC_CODE）</span><br><span class="line"> * 2.双向链表</span><br><span class="line"> * 为了free时方便从used中拿出插入到free中</span><br><span class="line"> */</span><br><span class="line">typedef struct MemBlock &#123;</span><br><span class="line">    void *data;</span><br><span class="line">    struct MemBlock *prev, *next;</span><br><span class="line">&#125; MemBlock;</span><br><span class="line">static MemBlock *newMemBlock(int size) &#123;</span><br><span class="line">    MemBlock *block = malloc(sizeof(MemBlock));</span><br><span class="line">    if(! block) &#123;</span><br><span class="line">        perror(&quot;malloc MemBlock failed&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    block-&gt;data = malloc(BLOCKHEAD_SIZE + size);</span><br><span class="line">    return block;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 内存表</span><br><span class="line"> * 1.每个list保存一种size的内存块</span><br><span class="line"> */</span><br><span class="line">typedef struct MemList &#123;</span><br><span class="line">    MemBlock *free, *used;</span><br><span class="line">    int size;</span><br><span class="line">    struct MemList *next;</span><br><span class="line">&#125; MemList;</span><br><span class="line">static MemList *newMemList(int size) &#123;</span><br><span class="line">    MemList *list = malloc(sizeof(MemList));</span><br><span class="line">    if(! list) &#123;</span><br><span class="line">        perror(&quot;malloc MemList failed&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;size = size;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 内存池</span><br><span class="line"> * 1.单例（因为是C语言，所以还未实现）</span><br><span class="line"> * 1.蝇量</span><br><span class="line"> */</span><br><span class="line">typedef struct MemPool &#123;</span><br><span class="line">    MemList *head;</span><br><span class="line">    MemList *last;</span><br><span class="line">&#125; MemPool;</span><br><span class="line">static MemPool *newMemPool() &#123;</span><br><span class="line">    MemPool *pool = malloc(sizeof(MemPool));</span><br><span class="line">    if(! pool) &#123;</span><br><span class="line">        perror(&quot;malloc MemPool failed&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* getBuf(MemPool *pool, size_t bufSize);</span><br><span class="line">int freeBuf(void *buf);</span><br><span class="line"></span><br><span class="line">#endif // _MEM_POOL_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mem_pool.h&quot;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 把内存块想象成一个int64的数组，头三个元素（head）为元数据，</span><br><span class="line"> * 之后的部分为分配给用户实际可用的内存</span><br><span class="line"> */</span><br><span class="line">void setMemoryHead(void *buf, MemList *list, MemBlock *block) &#123;</span><br><span class="line">    if(buf == NULL) &#123;return ;&#125;</span><br><span class="line">    int64_t *data = (int64_t *)buf;</span><br><span class="line">    // 设置头部，注意指针有64位</span><br><span class="line">    data[0] = (int64_t)list;</span><br><span class="line">    data[1] = (int64_t)block;</span><br><span class="line">    data[2] = (int64_t)MAGIC_CODE;</span><br><span class="line">&#125;</span><br><span class="line">void* getMemoryBody(void *buf) &#123;</span><br><span class="line">    if(buf == NULL) &#123;return NULL;&#125;</span><br><span class="line">    int64_t *data = (int64_t *)buf;</span><br><span class="line">    return &amp;data[3];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 从释放的内存块中可以找到它所属的list和block节点位置</span><br><span class="line"> * @return 0表示失败，其他表示成功</span><br><span class="line"> */</span><br><span class="line">int getFromBuf(void *buf, MemList** list, MemBlock** block) &#123;</span><br><span class="line">    // 先转换为字节数组再计算到头部的偏移量，因为</span><br><span class="line">    char* cbuf = buf;</span><br><span class="line">    int64_t *data = (int64_t *)(buf - BLOCKHEAD_SIZE);</span><br><span class="line">    if(data[2] != MAGIC_CODE) &#123;</span><br><span class="line">        perror(&quot;error: not a valid block&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 还原</span><br><span class="line">    *list = data[0];</span><br><span class="line">    *block = data[1];</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从内存池中获取一块内存</span><br><span class="line"> * 内存块的大小是固定的，链表的每个节点代表一种大小的内存块</span><br><span class="line"> */</span><br><span class="line">void* getBuf(MemPool *pool, size_t bufSize) &#123;</span><br><span class="line">    if(! pool) &#123;return NULL;&#125;</span><br><span class="line">    // list为空，表示还未分配过，尝试分配并初始化</span><br><span class="line">    if(! pool-&gt;head) &#123;</span><br><span class="line">        pool-&gt;head = newMemList(bufSize);</span><br><span class="line">    &#125;</span><br><span class="line">    MemList *list = pool-&gt;head;</span><br><span class="line"></span><br><span class="line">    // 查找匹配大小的list</span><br><span class="line">    while(list &amp;&amp; list-&gt;size != bufSize) &#123;</span><br><span class="line">        list = list-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 没有匹配的list，分配一个，插入到表头处</span><br><span class="line">    if(! list) &#123;</span><br><span class="line">        MemList *tmp = newMemList(bufSize);</span><br><span class="line">        tmp-&gt;next = pool-&gt;head;</span><br><span class="line">        pool-&gt;head = tmp;</span><br><span class="line">        list = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查找已有list中是否存在空余内存块，若没有则新建</span><br><span class="line">    if(! list-&gt;free) &#123;</span><br><span class="line">        list-&gt;free = newMemBlock(list-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取一块</span><br><span class="line">    MemBlock *block = list-&gt;free;</span><br><span class="line">    list-&gt;free = block-&gt;next;</span><br><span class="line">    if(list-&gt;free) &#123;</span><br><span class="line">        list-&gt;free-&gt;prev = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // 压回已使用块表</span><br><span class="line">    if(list-&gt;used) &#123;</span><br><span class="line">        list-&gt;used-&gt;prev = block;</span><br><span class="line">    &#125;</span><br><span class="line">    block-&gt;next = list-&gt;used;</span><br><span class="line">    list-&gt;used = block;</span><br><span class="line"></span><br><span class="line">    // 设置块头部</span><br><span class="line">    setMemoryHead(block-&gt;data, list, block);</span><br><span class="line">    return getMemoryBody(block-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 释放一块内存</span><br><span class="line"> * @return 0表示释放失败，其他数字表示成功</span><br><span class="line"> */</span><br><span class="line">int freeBuf(void *buf) &#123;</span><br><span class="line">    MemList *list = NULL;</span><br><span class="line">    MemBlock *block = NULL;</span><br><span class="line">    if(! getFromBuf(buf, &amp;list, &amp;block)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从used块中取出</span><br><span class="line">    if(block-&gt;prev) &#123;</span><br><span class="line">        block-&gt;prev-&gt;next = block-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(block-&gt;next) &#123;</span><br><span class="line">        block-&gt;next-&gt;prev = block-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    // 放到free块中</span><br><span class="line">    if(list-&gt;free) &#123;</span><br><span class="line">        list-&gt;free-&gt;prev = block;</span><br><span class="line">    &#125;</span><br><span class="line">    block-&gt;next = list-&gt;free;</span><br><span class="line">    block-&gt;prev = NULL;</span><br><span class="line">    list-&gt;free = block;</span><br><span class="line"></span><br><span class="line">    // 操作成功</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>简单的测试：<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef struct List &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct List *next;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MemPool *pool = newMemPool();</span><br><span class="line">    time_t begin, end;</span><br><span class="line">    time(&amp;begin);</span><br><span class="line">    srand(time(0));</span><br><span class="line">    List *list = NULL;</span><br><span class="line">    int n = 100000000;</span><br><span class="line">    while(n--) &#123;</span><br><span class="line">        if(random() % 10 &lt; 7) &#123;</span><br><span class="line">            List *node = getBuf(pool, sizeof(List));</span><br><span class="line">            node-&gt;next = list;</span><br><span class="line">            list = node;</span><br><span class="line">        &#125; else if(list) &#123;</span><br><span class="line">            List *node = list;</span><br><span class="line">            list = list-&gt;next;</span><br><span class="line">            freeBuf(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time(&amp;end);</span><br><span class="line">    printf(&quot;OK\n&quot;);</span><br><span class="line">    printf(&quot;costs %lf\n&quot;, difftime(end, begin));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>可改进的地方：  </p>
<ul>
<li>线程安全，这里有个问题，是把整个池锁住还是把其中的某个表锁住？因为内存池是使用很频繁的，我更倾向于后者（锁住某个表的实现可以参考 Java 的分段锁机制）</li>
<li>一种 size 一个 list，各 list 之间用链表串联起来，如果申请的内存块大小不固定也可能出现这个链表特别长的情况，那样就退化成了 malloc/free，我觉得解决办法是将分配的内存块大小固定成 1024B、2048B 这些量级，但这样又会多出很多内存碎片，又退化成了 malloc/free</li>
<li>引入引用计数或可达性分析算法来管理内存，但是那样的话需要给所有类做一个公共基类，然后重载基类的’=’操作符用于修改引用数，非常麻烦，但是不这么做就退化成了 malloc/free</li>
<li>老实说这个内存池并没有实用价值</li>
</ul>
<h3 id="一些框架中的内存管理"><a href="#一些框架中的内存管理" class="headerlink" title="一些框架中的内存管理"></a>一些框架中的内存管理</h3><ol>
<li><p>Doug Lee 的 malloc/free<br>？？？</p>
</li>
<li><p>Apache 内存池<br>Apache 内存池的实现相对上面的来说有很多改进  </p>
</li>
</ol>
<ul>
<li><p>使用一个<code>free</code>数组来表示上面的<code>MemList</code>，下标每增加 1，内存节点大小增加 4K，这样可以很快定位到要分配的那个内存块链表，如果要分配的内存大小超出数组范围就直接分配到下标 0 处，所以不会有溢出的问题<br>节点大小和下标间的转换用到了一个宏<code>APR_ALIGN</code>，使用该宏要求<code>size</code>为整数，<code>boundary</code>为 2 的幂，具体执行过程还是自己代入一组值算一算  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define APR_ALIGN(size, boundary) \</span><br><span class="line">        (((size)+ ((boundary) - 1)) &amp;~((boundary) - 1))</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有 used 表，分配时就从 free 中取出来返回给用户，找不到就 malloc 一个，释放时插回到 free 表中</p>
</li>
<li>用 current_free_index 和 max_free_index 配合限制内存分配器总共能够分配的内存大小</li>
</ul>
<ol>
<li>cocos2d-x 内存管理<br>对 cocos2d-x 的使用经历比较短，不能很好体会它的设计理念，只列出我记得的一些点：  </li>
</ol>
<ul>
<li>C++11 下本地存储（栈）比堆存储好，最好不要 new 对象</li>
<li>cocos2d-x 使用引用计数算法管理内存，大部分内置对象都继承自 cocos2d::Object 类</li>
</ul>
<ol>
<li>MySQL 内存池<br>MySQL 使用二级缓存机制管理分配的对象，第一级为缓冲池和通用内存池，他们都通过调用 malloc/free 来从操作系统分配/释放内存块，他们的区别下面再讲；第二级为内存堆，它为其他模块提供内存块分配功能  </li>
</ol>
<ul>
<li>缓冲池（innobase/buf/buf0buf.c、innobase/include/buf0buf.h）<br>缓冲池的定义如下  </li>
</ul>
<ul>
<li>通用内存池（innobase/mem/mem0pool.c、innobase/include/mem0pool.h）<br>内存池的定义如下  <div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct mem_pool_struct&#123;</span><br><span class="line">	byte*		buf;		/* memory pool */</span><br><span class="line">	ulint		size;		/* memory common pool size */</span><br><span class="line">	ulint		reserved;	/* amount of currently allocated</span><br><span class="line">					memory */</span><br><span class="line">	mutex_t		mutex;		/* mutex protecting this struct */</span><br><span class="line">	UT_LIST_BASE_NODE_T(mem_area_t)</span><br><span class="line">			free_list[64];	/* lists of free memory areas: an</span><br><span class="line">					area is put to the list whose number</span><br><span class="line">					is the 2-logarithm of the area size */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ul>
<p>内存池的创建函数如下所示<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">mem_pool_t*</span><br><span class="line">mem_pool_create(</span><br><span class="line">/*============*/</span><br><span class="line">			/* out: memory pool */</span><br><span class="line">	ulint	size)	/* in: pool size in bytes */</span><br><span class="line">&#123;</span><br><span class="line">	mem_pool_t*	pool;</span><br><span class="line">	mem_area_t*	area;</span><br><span class="line">	ulint		i;</span><br><span class="line">	ulint		used;</span><br><span class="line"></span><br><span class="line">	ut_a(size &gt; 10000);</span><br><span class="line">	</span><br><span class="line">	pool = ut_malloc(sizeof(mem_pool_t));</span><br><span class="line"></span><br><span class="line">	/* We do not set the memory to zero (FALSE) in the pool,</span><br><span class="line">	but only when allocated at a higher level in mem0mem.c.</span><br><span class="line">	This is to avoid masking useful Purify warnings. */</span><br><span class="line"></span><br><span class="line">	pool-&gt;buf = ut_malloc_low(size, FALSE);</span><br><span class="line">	pool-&gt;size = size;</span><br><span class="line"></span><br><span class="line">	mutex_create(&amp;(pool-&gt;mutex));</span><br><span class="line">	mutex_set_level(&amp;(pool-&gt;mutex), SYNC_MEM_POOL);</span><br><span class="line"></span><br><span class="line">	/* Initialize the free lists */</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; 64; i++) &#123;</span><br><span class="line"></span><br><span class="line">		UT_LIST_INIT(pool-&gt;free_list[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	used = 0;</span><br><span class="line"></span><br><span class="line">	while (size - used &gt;= MEM_AREA_MIN_SIZE) &#123;</span><br><span class="line"></span><br><span class="line">		i = ut_2_log(size - used);</span><br><span class="line"></span><br><span class="line">		if (ut_2_exp(i) &gt; size - used) &#123;</span><br><span class="line"></span><br><span class="line">			/* ut_2_log rounds upward */</span><br><span class="line">		</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		area = (mem_area_t*)(pool-&gt;buf + used);</span><br><span class="line"></span><br><span class="line">		mem_area_set_size(area, ut_2_exp(i));</span><br><span class="line">		mem_area_set_free(area, TRUE);</span><br><span class="line"></span><br><span class="line">		UT_LIST_ADD_FIRST(free_list, pool-&gt;free_list[i], area);</span><br><span class="line"></span><br><span class="line">		used = used + ut_2_exp(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ut_ad(size &gt;= used);</span><br><span class="line"></span><br><span class="line">	pool-&gt;reserved = 0;</span><br><span class="line">	</span><br><span class="line">	return(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>由此可以得出通用内存池和缓冲池之间的差别</p>
<ol>
<li></li>
<li></li>
</ol>
<ul>
<li><p>内存堆（innobase/mem/mem0mem.c、innobase/include/mem0mem.h、innobase/include/mem0mem.ic）<br>内存堆的定义如下  </p>
<div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* A memory heap is a nonempty linear list of memory blocks */</span><br><span class="line">typedef mem_block_t	mem_heap_t;</span><br></pre></td></tr></table></figure>

</div></div>
<p>可见内存堆就是内存块的链表。  </p>
</li>
<li><p>内存块（memory block）的定义如下  </p>
<div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct mem_block_info_struct &#123;</span><br><span class="line">	ulint   magic_n;/* 魔数用于debug（标志该块内存是从我这分出去的） *//* magic number for debugging */</span><br><span class="line">	char	file_name[8];/* 创建内存堆的代码文件名 *//* file name where the mem heap was created */</span><br><span class="line">	ulint	line;	/* 创建内存堆的代码行 *//* line number where the mem heap was created */</span><br><span class="line">	UT_LIST_BASE_NODE_T(mem_block_t) base; /* 在第一块（表头）中定义，保存内存块链表的一些元信息，</span><br><span class="line">                        包括长度、表头指针、表尾指针 */</span><br><span class="line">                        /* In the first block in the</span><br><span class="line">			the list this is the base node of the list of blocks;</span><br><span class="line">			in subsequent blocks this is undefined */</span><br><span class="line">	UT_LIST_NODE_T(mem_block_t) list; /* 内存块的链表（双向链表） *//* This contains pointers to next</span><br><span class="line">			and prev in the list. The first block allocated</span><br><span class="line">			to the heap is also the first block in this list,</span><br><span class="line">			though it also contains the base node of the list. */</span><br><span class="line">	ulint   len;    /* 当前内存块大小，以字节为单位 *//* physical length of this block in bytes */</span><br><span class="line">	ulint 	type; 	/* 该内存堆的类型，内存堆的主要分类依据是：从通用内存池还是缓冲池分配 */</span><br><span class="line">                        /* type of heap: MEM_HEAP_DYNAMIC, or</span><br><span class="line">			MEM_HEAP_BUF possibly ORed to MEM_HEAP_BTR_SEARCH */</span><br><span class="line">	ibool	init_block; /* TRUE if this is the first block used in fast</span><br><span class="line">			creation of a heap: the memory will be freed</span><br><span class="line">			by the creator, not by mem_heap_free */</span><br><span class="line">	ulint   free;   /* 当前空闲空间位置 */</span><br><span class="line">                        /* offset in bytes of the first free position for</span><br><span class="line">			user data in the block */</span><br><span class="line">	ulint   start;  /* the value of the struct field &apos;free&apos; at the </span><br><span class="line">			creation of the block */</span><br><span class="line">	byte* 	free_block;</span><br><span class="line">			/* if the MEM_HEAP_BTR_SEARCH bit is set in type,</span><br><span class="line">			and this is the heap root, this can contain an</span><br><span class="line">			allocated buffer frame, which can be appended as a</span><br><span class="line">			free block to the heap, if we need more space;</span><br><span class="line">			otherwise, this is NULL */</span><br><span class="line">#ifdef MEM_PERIODIC_CHECK	</span><br><span class="line">	UT_LIST_NODE_T(mem_block_t) mem_block_list;</span><br><span class="line">			/* List of all mem blocks allocated; protected</span><br><span class="line">			by the mem_comm_pool mutex */</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ul>
<p>内存块的创建函数如下所示<br><div><div class="fold_hider"><div class="close hider_title">折叠/展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">UNIV_INLINE</span><br><span class="line">mem_heap_t*</span><br><span class="line">mem_heap_create_func(</span><br><span class="line">/*=================*/</span><br><span class="line">				/* out, own: memory heap */</span><br><span class="line">	ulint	n,		/* in: desired start block size,</span><br><span class="line">				this means that a single user buffer</span><br><span class="line">				of size n will fit in the block, </span><br><span class="line">				0 creates a default size block;</span><br><span class="line">				if init_block is not NULL, n tells</span><br><span class="line">				its size in bytes */</span><br><span class="line">	void*	init_block,	/* in: if very fast creation is</span><br><span class="line">				wanted, the caller can reserve some</span><br><span class="line">				memory from its stack, for example,</span><br><span class="line">				and pass it as the the initial block</span><br><span class="line">				to the heap: then no OS call of malloc</span><br><span class="line">				is needed at the creation. CAUTION:</span><br><span class="line">				the caller must make sure the initial</span><br><span class="line">				block is not unintentionally erased</span><br><span class="line">				(if allocated in the stack), before</span><br><span class="line">				the memory heap is explicitly freed. */</span><br><span class="line">	ulint	type,		/* in: MEM_HEAP_DYNAMIC, or MEM_HEAP_BUFFER</span><br><span class="line">				possibly ORed to MEM_HEAP_BTR_SEARCH */</span><br><span class="line">	char*  	file_name,	/* in: file name where created */</span><br><span class="line">	ulint	line		/* in: line where created */</span><br><span class="line">	)</span><br><span class="line">&#123;</span><br><span class="line">	mem_block_t*   block; </span><br><span class="line"></span><br><span class="line">	if (n &gt; 0) &#123;</span><br><span class="line">                // 创建指定大小的内存块</span><br><span class="line">		block = mem_heap_create_block(NULL, n, init_block, type,</span><br><span class="line">							file_name, line);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 以默认的大小创建，MEM_BLOCK_START_SIZE的值为64B</span><br><span class="line">		block = mem_heap_create_block(NULL, MEM_BLOCK_START_SIZE, </span><br><span class="line">					init_block, type, file_name, line);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ut_ad(block);</span><br><span class="line"></span><br><span class="line">	UT_LIST_INIT(block-&gt;base);</span><br><span class="line"></span><br><span class="line">	/* Add the created block itself as the first block in the list */</span><br><span class="line">	UT_LIST_ADD_FIRST(list, block-&gt;base, block);</span><br><span class="line"></span><br><span class="line">	#ifdef UNIV_MEM_DEBUG</span><br><span class="line"></span><br><span class="line">	if (block == NULL) &#123;</span><br><span class="line"></span><br><span class="line">		return(block);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mem_hash_insert(block, file_name, line);</span><br><span class="line"></span><br><span class="line">	#endif</span><br><span class="line">	</span><br><span class="line">	return(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>当想要扩增内存堆时调用，它会将扩增的内存块插入内存堆的末尾（mem_block_info_struct 结构中的 base 成员变量包含了表尾指针），而且每次扩增的内存块大小为前一次的两倍大  </p>
<ol>
<li>内存池和 GC 的关系<br>在阅读《垃圾回收的算法与实现》时，除了某人用 GC 交到了女朋友外，使我最印象深刻的应该是前言中一位教授对 GC 和虚拟内存关系的看法：<blockquote>
<p>既然话说到这里了,我就再介绍一下我的个人看法吧。实际上,GC 相当于虚拟内存。一般的虚拟内存技术是在较小的物理内存的基础上,利用辅助存储创造一片看上去很大的“虚拟”地址空间。也就是说,GC 是扩大内存空间的技术,因此我称其为空间性虚拟存储。这样一来,GC 就成了永久提供一次性存储空间的时间轴方向的时间性虚拟存储。神奇的是,比起称为“垃圾回收”,把 GC 称为“虚拟内存”令人感觉其重要了许多。当初人们根据计算机体系结构开发了许多关于空间性虚拟存储的支持,所以大部分的计算机都标配了空间性虚拟存储。只要硬件支持,GC 性能就能稳步提升,然而现实情况是几乎没有支持 GC 的硬件,这不能不令人感到遗憾。</p>
</blockquote>
</li>
</ol>
<h3 id="什么时候使用内存池及一些要点"><a href="#什么时候使用内存池及一些要点" class="headerlink" title="什么时候使用内存池及一些要点"></a>什么时候使用内存池及一些要点</h3><ol>
<li>小心内存泄露<br>如果应用从内存池中获取对象后没有释放回去就很有可能会发生内存泄露的情况，和 C 语言中 malloc 后忘了 free 的情况类似。一般内存池都是单例的，这意味着内存池和整个应用的生命周期是相同的，这块没被释放的内存将一直占用内存空间，而且因为内存池中总是有对这个对象的引用，所以就算有 GC 也没有办法进行回收。<br>水平有限我仅谈谈在 Web 应用中的几个解决办法：<ul>
<li>缩短内存池的生命周期，比如在一次会话期间占用一个内存池，这个内存池将会被保存在一个 SessionContext 对象中，当会话结束时就释放它</li>
<li>在一些对象价值不是特别高的情形下（比如），可以使用 <strong>弱引用对象池</strong> 来管理对象？？？</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《C 程序设计语言》  </li>
<li>内存池的实现 <a href="http://www.cnblogs.com/bangerlee/archive/2011/08/31/2161421.html" target="_blank" rel="noopener">http://www.cnblogs.com/bangerlee/archive/2011/08/31/2161421.html</a>  </li>
<li>A memory pool written with C++ <a href="https://github.com/bangerlee/mempool" target="_blank" rel="noopener">https://github.com/bangerlee/mempool</a>  </li>
<li>MySQL 内核 InnoDB 存储引擎  </li>
<li><a href="https://www.zhihu.com/question/26190832/answer/32387918" target="_blank" rel="noopener">https://www.zhihu.com/question/26190832/answer/32387918</a></li>
<li>《垃圾回收的算法与实现》</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fa5fc05a.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fa5fc05a.html" itemprop="url">姓名排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T23:29:41+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/功能设计/" itemprop="url" rel="index">
                    <span itemprop="name">功能设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="姓名排序"><a href="#姓名排序" class="headerlink" title="姓名排序"></a>姓名排序</h2><p>题目描述：给定 30,000 个中国人的名字，选用一种线性排序方法有效排序，要求使用内存不超过 1G。  </p>
<p>想法 1：计数排序，汉字组合显然是无穷多的，无法确定元素的范围，而且可能有重名的情况，所以不能使用；  </p>
<p>想法 2：使用桶排序，不好确定每个桶的元素范围，一般情况下都是假定元素限制在(0,1]；  </p>
<p>想法 3：使用基数排序可以一次按名字的第 i 位的排序，如果每个桶的标志为一个汉字，那桶就太多了，如果每个桶的标志为汉字的首字母，桶够少了，但是每个桶都需要大量时间，既然是汉字，我们完全可以用汉字拼音；  </p>
<h3 id="获得测试组"><a href="#获得测试组" class="headerlink" title="获得测试组"></a>获得测试组</h3><p>一组有 3w 行，每一行随机 2-10 个 utf-8 中文字符  </p>
<p>从这里[1]了解到 unicode 字符的基本汉字编码范围为 4E00-9FA5，我的想法是随机生成一个 19968-40869 的 unsigned int 型数，然后编码成 utf-8 字符；  </p>
<p>utf-8 字符可以由 unicode 字符转换而来，转换算法[2]为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">×××××××× ×××××××× -&gt; 1110×××× 10×××××× 10××××××</span><br><span class="line">1110拼上前4位</span><br><span class="line">10拼上中间6位</span><br><span class="line">10拼上后6位</span><br></pre></td></tr></table></figure></p>
<p>输入到文件中</p>
<p>源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">﻿#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">//中文字为3字节，第一步</span><br><span class="line">void randomname(unsigned char *name)&#123;</span><br><span class="line">    int length = random() % 8 + 2;</span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; length; pos++)&#123;</span><br><span class="line">        unsigned int a = (random() % 20902) + 19968;</span><br><span class="line">	       name[3 * pos] = (a &gt;&gt; 12) + 224;</span><br><span class="line">	       name[3 * pos + 1] = ((a &gt;&gt; 6) % 64) + 128;</span><br><span class="line">	       name[3 * pos + 2] = (a % 64) + 128;</span><br><span class="line">    &#125;</span><br><span class="line">    name[3 * pos] = &apos;\0&apos;;</span><br><span class="line">    printf(&quot;%s&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">void makefile(FILE *f)&#123;</span><br><span class="line">    if(f == NULL)&#123;</span><br><span class="line">        fprintf(stderr, &quot;error1&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char name[35];</span><br><span class="line">    int count = 30000;</span><br><span class="line">    srand(time(0));</span><br><span class="line">    while(count--)&#123;</span><br><span class="line">        randomname(name);</span><br><span class="line">        if(fprintf(f, &quot;%s%c&quot;, name, &apos;\r&apos;) == 0)&#123;</span><br><span class="line">            fprintf(stderr, &quot;error&quot;);</span><br><span class="line">	           break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    FILE *f = fopen(&quot;a.txt&quot;, &quot;w&quot;);</span><br><span class="line">    makefile(f);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><p>我们希望按照拼音顺序排序，所以得先将 UTF-8 字符转换为 GB2312 编码  </p>
<p>这里遇到了难题，我打算使用 linux 下的 iconv 进行转码，但是转出来的都是乱码，可能是对转码的工作原理还不明白。  </p>
<p>刚开始我打算编写 C 语言代码转换 utf-8 -&gt; gb2312，但是失败了，一是因为有些字符在 gb2312 中不存在，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C语言中出现 iconv(pattern, pin, &amp;inlen, pout, &amp;outlen) 返回-1</span><br><span class="line">命令行下出现 iconv: 未知 0 处的非法输入序列</span><br></pre></td></tr></table></figure></p>
<p>二是我直接输出到了终端，结果出现了乱码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好 -&gt; ����</span><br></pre></td></tr></table></figure></p>
<p>是因为终端默认使用 utf-8，这样就无法显示了。  </p>
<p>后来使用 GBK，因为 GBK 包括 gb2312，将编码后的字符直接输出到了文件中，这样就能看到编码后的结果了  </p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iconv.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int code_convert(char *from_charset, char *to_charset, char *inbuf, size_t inlen, char *outbuf, size_t outlen)&#123;</span><br><span class="line">    iconv_t pattern;</span><br><span class="line">    char **pin = &amp;inbuf;</span><br><span class="line">    char **pout = &amp;outbuf;</span><br><span class="line">    pattern = iconv_open(to_charset, from_charset);</span><br><span class="line">    if(pattern == 0)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(outbuf, 0, outlen);</span><br><span class="line">    if(iconv(pattern, pin, &amp;inlen, pout, &amp;outlen) == -1)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    iconv_close(pattern);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#define MAXNUM 30000</span><br><span class="line">#define MAXNAME 31</span><br><span class="line">char names_utf8[MAXNUM][MAXNAME];</span><br><span class="line">char names_gb2312[MAXNUM][MAXNAME];</span><br><span class="line">void readFile(char *fileName)&#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    if((f = fopen(fileName, &quot;r&quot;)) == NULL)&#123;</span><br><span class="line">        fprintf(stderr, &quot;cant open file %s\n&quot;, fileName);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; MAXNUM; pos++)&#123;</span><br><span class="line">        //fgets(names_utf8[pos], MAXNAME, f);fgets会保留行末尾的\r\n</span><br><span class="line">        fscanf(f, &quot;%s&quot;, names_utf8[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void convert()&#123;</span><br><span class="line">    FILE *f = fopen(&quot;b.txt&quot;, &quot;w&quot;);</span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; MAXNUM; pos++)&#123;</span><br><span class="line">        if(code_convert(&quot;utf-8&quot;, &quot;GBK&quot;, names_utf8[pos], strlen(names_utf8[pos]), names_gb2312[pos], MAXNAME) == -1)&#123;</span><br><span class="line">	           fprintf(stderr, &quot;iconv error&quot;);</span><br><span class="line">	           exit(2);</span><br><span class="line">        &#125;</span><br><span class="line">       fprintf(f, &quot;%s\r\n&quot;, names_gb2312[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分代码等价于以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iconv -f utf-8 -t GBK a.txt -o b.txt</span><br></pre></td></tr></table></figure></p>
<p>起初认为像 GBK 这样的汉字编码标准会很地道地按拼音顺序来编码，但是还是太天真了，因为有多音字存在等原因，要按拼音编码是不大可能的；  </p>
<p>最终上网找了一个汉字转拼音的程序[4]，找拼音的大致思路是预先准备好拼音及该拼音的汉字，要找一个汉字的拼音就遍历一遍找，方法比较简单只覆盖了一部分汉字，而且是线性遍历效率不高，还有个缺点就是多音字只能找到第一个；  </p>
<h3 id="对姓名进行排序"><a href="#对姓名进行排序" class="headerlink" title="对姓名进行排序"></a>对姓名进行排序</h3><p>最后就是使用基数排序了，因为使用 utf-8 编码，所以数组中 27-29 为第 10 个汉字，24-26 为第 9 个汉字，以此类推，姓名有长有短，比如“张三”的后 8 位都不存在，默认放入 0 号桶，其他情况如果能找到该位汉字的拼音，将姓名放到对应的桶中，如果找不到，默认该汉字未编码，放入 0 号桶，这里桶其实代表 a/an/ang…，最后为了保证排序的稳定性，桶使用了队列实现；  </p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;pinyin.h&quot; //汉字-拼音</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define P2HSIZE (sizeof(p2h) / sizeof(p2h[0]))</span><br><span class="line">int getP2Hpos(char word[])&#123;</span><br><span class="line">    if(word == NULL || word[0] == &apos;\0&apos;)&#123; return -1; &#125;</span><br><span class="line">    int pos;</span><br><span class="line">    char *curHzString;</span><br><span class="line">    for(pos = 0; pos &lt; P2HSIZE; pos++)&#123;</span><br><span class="line">        curHzString = p2h[pos].hz;</span><br><span class="line">        if(strstr(curHzString, word))&#123;</span><br><span class="line">            return pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">#define MAXNUM 30000 //文件中姓名的数量</span><br><span class="line">#define MAXNAME 31 //姓名最多为10个汉字</span><br><span class="line">char *names_utf8[MAXNUM];</span><br><span class="line">/*******************************************/</span><br><span class="line">void readFile(char *fileName)&#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    if((f = fopen(fileName, &quot;r&quot;)) == NULL)&#123;</span><br><span class="line">        fprintf(stderr, &quot;cant open file %s\n&quot;, fileName);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; MAXNUM; pos++)&#123;</span><br><span class="line">        names_utf8[pos] = (char*)malloc(MAXNAME * sizeof(char));</span><br><span class="line">        fscanf(f, &quot;%s&quot;, names_utf8[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void clearNames()&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; MAXNUM; pos++)&#123;</span><br><span class="line">        free(names_utf8[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/****************************************/</span><br><span class="line">typedef struct cell&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    struct cell *next;</span><br><span class="line">&#125;cell;</span><br><span class="line">typedef struct bucket&#123;</span><br><span class="line">    cell *front;</span><br><span class="line">    cell *rear;</span><br><span class="line">&#125;bucket;</span><br><span class="line">int isEmpty(bucket *b)&#123;</span><br><span class="line">    return b-&gt;rear == NULL;</span><br><span class="line">&#125;</span><br><span class="line">cell *makeCell(int pos)&#123;</span><br><span class="line">    cell *c = (cell*)malloc(sizeof(cell));</span><br><span class="line">    if(c == NULL)&#123; fprintf(stderr, &quot;error&quot;); &#125;</span><br><span class="line">    c-&gt;pos = pos, c-&gt;next = NULL;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">bucket *makeBucket()&#123;</span><br><span class="line">    bucket *b = (bucket*)malloc(sizeof(bucket));</span><br><span class="line">    b-&gt;front = b-&gt;rear = NULL;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">int push(bucket *b, int pos)&#123;</span><br><span class="line">    if(b == NULL)&#123;printf(&quot;error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    cell *c = makeCell(pos);</span><br><span class="line">    if(isEmpty(b))&#123;</span><br><span class="line">        b-&gt;rear = b-&gt;front = c;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        b-&gt;front-&gt;next = c;</span><br><span class="line">        b-&gt;front = c;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int pop(bucket *b)&#123;</span><br><span class="line">    if(isEmpty(b))&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cell *rear = b-&gt;rear;</span><br><span class="line">        int pos = rear-&gt;pos;</span><br><span class="line">        b-&gt;rear = rear-&gt;next;</span><br><span class="line">        free(rear);</span><br><span class="line">        return pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//桶的数量就是拼音的数量，0号桶用于装找不到拼音的汉字</span><br><span class="line">#define BUCKETSNUM (P2HSIZE + 1)</span><br><span class="line">bucket *buckets[BUCKETSNUM];</span><br><span class="line">char tmp[4];</span><br><span class="line">void pushBuckets(int radix)&#123;//1 &lt;= radix &lt;= 10，表示第几个字</span><br><span class="line">    int pos, bucketId;</span><br><span class="line">    for(pos = 0; pos &lt; MAXNUM; pos++)&#123;//如果改成while(pos++ &lt; MAXNUM)会出现段错误，为什么？？</span><br><span class="line">        strncpy(tmp, names_utf8[pos] + 3 * (radix - 1), 3);</span><br><span class="line">        bucketId = getP2Hpos(tmp) + 1;</span><br><span class="line">        push(buckets[bucketId], pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//桶中保存的是对应姓名数组的下标</span><br><span class="line">void popBuckets()&#123;</span><br><span class="line">    char *names_tmp[MAXNUM];</span><br><span class="line">    int npos;</span><br><span class="line">    for(npos = 0; npos &lt; MAXNUM; npos++)&#123;</span><br><span class="line">        names_tmp[npos] = names_utf8[npos];</span><br><span class="line">    &#125;</span><br><span class="line">    npos = 0;</span><br><span class="line">    int bpos;</span><br><span class="line">    for(bpos = 0; bpos &lt; BUCKETSNUM; bpos++)&#123;</span><br><span class="line">        while(!isEmpty(buckets[bpos]))&#123;</span><br><span class="line">            int pos = pop(buckets[bpos]);</span><br><span class="line">            names_utf8[npos++] = names_tmp[pos];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void initBuckets()&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; BUCKETSNUM; pos++)&#123;</span><br><span class="line">        buckets[pos] = makeBucket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void clearBuckets()&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; BUCKETSNUM; pos++)&#123;</span><br><span class="line">        while(pop(buckets[pos]) != -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void radixSort()&#123;</span><br><span class="line">    int radix;</span><br><span class="line">    for(radix = 10; radix &gt;= 1; radix--)&#123;</span><br><span class="line">        pushBuckets(radix);</span><br><span class="line">        popBuckets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void writeResult()&#123;</span><br><span class="line">    FILE *f = fopen(&quot;result.dat&quot;, &quot;w&quot;);</span><br><span class="line">    if(f == NULL)&#123; fprintf(stderr, &quot;open file failed&quot;); exit(1);&#125;</span><br><span class="line">    </span><br><span class="line">    int pos;</span><br><span class="line">    for(pos = 0; pos &lt; MAXNUM; pos++)&#123;</span><br><span class="line">        fprintf(f, &quot;%s\r\n&quot;, names_utf8[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br><span class="line">void func()&#123;</span><br><span class="line">    readFile(&quot;a.txt&quot;);</span><br><span class="line">    initBuckets();</span><br><span class="line">    radixSort();</span><br><span class="line">    writeResult();</span><br><span class="line">    clearNames();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    func();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>当需要排序的数据量很大，例如 100G 个人按照年龄排序，如何基于外存对这些数据排序？使用 mapreduce 等工具？  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.qqxiuzi.cn/zh/hanzi-unicode-bianma.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/zh/hanzi-unicode-bianma.php</a> 汉字 Unicode 编码范围  </li>
<li><a href="http://www.zhihu.com/question/23374078" target="_blank" rel="noopener">www.zhihu.com/question/23374078</a> Unicode 和 UTF-8 有何区别？  </li>
<li><a href="http://blog.csdn.net/jnbbwyth/article/details/6991371" target="_blank" rel="noopener">http://blog.csdn.net/jnbbwyth/article/details/6991371</a> linux 下 iconv()函数的用法  </li>
<li><a href="http://download.csdn.net/detail/lovesoftchina/5654309" target="_blank" rel="noopener">http://download.csdn.net/detail/lovesoftchina/5654309</a> Linux C 实现 简单的 汉字转拼音  </li>
<li><a href="http://www.crifan.com/files/doc/docbook/char_encoding/release/html/char_encoding.html" target="_blank" rel="noopener">http://www.crifan.com/files/doc/docbook/char_encoding/release/html/char_encoding.html</a> 字符编码详解  </li>
<li><a href="http://blog.csdn.net/jk110333/article/details/19685127" target="_blank" rel="noopener">http://blog.csdn.net/jk110333/article/details/19685127</a> C/C++段错误问题排查和解决方法  </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e45d6eed.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/e45d6eed.html" itemprop="url">2017 沈阳马拉松</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T15:40:32+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  164 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="马拉松计划"><a href="#马拉松计划" class="headerlink" title="马拉松计划"></a>马拉松计划</h2><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><table>
<thead>
<tr>
<th>周</th>
<th>一</th>
<th>二</th>
<th>三</th>
<th>四</th>
<th>五</th>
<th>六</th>
<th>日</th>
</tr>
</thead>
<tbody>
<tr>
<td>4-10</td>
<td>10</td>
<td>11</td>
<td>20</td>
<td>13</td>
<td>休息</td>
<td>30</td>
<td>休息</td>
</tr>
<tr>
<td>11-17</td>
<td>8</td>
<td>13</td>
<td>20</td>
<td>13</td>
<td>休息</td>
<td>20</td>
<td>休息</td>
</tr>
<tr>
<td>18-24</td>
<td>5</td>
<td>10</td>
<td>13</td>
<td>8</td>
<td>休息</td>
<td>休息</td>
<td>马拉松</td>
</tr>
</tbody>
</table>
<p>PS1：后程如果跑不动，可以尝试跑 5 分钟走 1 分钟调整，喝水时也可以走一会。<br>PS2：目标是 400，平常用 11 的速度跑，马拉松用 10 的速度。  </p>
<h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>平时多喝牛奶。<br>马拉松时带点巧克力，不知道场地里的粮食多不。  </p>
<h3 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h3><p>跑前似乎有发衣服，所以就不买专门的速干衣了，但是跑鞋和毛巾袜是必须的。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  

  

  


</body>
</html>
