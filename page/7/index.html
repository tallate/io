<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/7/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/7/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/353ec849.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/353ec849.html" itemprop="url">Dubbo 原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  15.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  60 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="为什么使用-dubbo"><a class="header-anchor" href="#为什么使用-dubbo">¶</a>为什么使用 Dubbo</h2>
<p>选型时一般需要考虑：</p>
<ol>
<li>业务特点及可预见的后续的发展。</li>
<li>可用性要求。</li>
<li>团队的成熟度。一个成熟的团队可以很好地 Hold 住复杂的开源框架，甚至做定制化开发。</li>
</ol>
<p>在选择使用 Dubbo 之后，又需要考虑很多细节，比如：</p>
<ol>
<li>Dubbo 底层走什么协议？如何对对象进行序列化，用了哪些序列化方式？如何处理异步转同步？</li>
<li>高并发高可用性。Dubbo 依赖了 ZooKeeper，但是万一 ZooKeeper 宕机了怎么办？<br>
如果 ZooKeeper 假死，客户端对服务端的调用是否会全部下线？如果是该如何避免？<br>
如何监控 Dubbo 的调用，并做到优雅的客户端无感发布？</li>
</ol>
<h3 id="最佳实践"><a class="header-anchor" href="#最佳实践">¶</a>最佳实践</h3>
<ol>
<li>模块化<br>
推荐将服务接口、实体、异常等都放到 API 包内，它们都是 API 的一部分。</li>
<li>粗粒度<br>
暴露的 Dubbo 接口的粒度应尽可能得粗，代表一个完整的功能，而不是其中的某一步，否则就不得不面对分布式事务问题了，而 Dubbo 当前并没有提供分布式事务支持。</li>
<li>版本<br>
某露服务接口的配置最好增加版本，当有不兼容的升级（比如接口定义要加个参数）时，版本可以方便地实现平滑发布，而又不用引入多余的代码。<br>
版本只需要两位即可，比如<code>&quot;1.0&quot;</code>，因为升级并不是频繁的操作，因为不兼容的升级不会那么频繁。<br>
升级时，先将一半的 provider 升级到新版本，然后将所有 consumer 升级，最后将其余的 provider 升级。</li>
<li>兼容性<br>
向后兼容：接口加方法、对象加字段；<br>
不兼容：删除方法、删除字段、枚举类型加字段。<br>
不兼容的情况下，可以通过升级版本来实现平滑发布。</li>
<li>枚举类型<br>
枚举是类型安全的，但是作为 Dubbo 接口的参数 / 返回值却不合适，因为 provider 会将枚举转换为字符串传输，接收方会尝试寻找该字符串所属的枚举 field，找不到就会直接报错。</li>
<li>序列化<br>
传值没必要使用接口抽象，因为序列化需要接口实现类的元信息（包括 getter、setter），无法隐藏实现。<br>
参数和返回值必须 byValue 而不是 byReference，因为 Dubbo 不支持远程对象，provider 引用的对象 consumer 就找不到了。</li>
<li>异常<br>
最好直接抛异常而不是返回异常码，因为异常可以携带更多信息、语法上也更加友好。<br>
provider 不要将 DAO 层的异常抛给 consumer 端，consumer 端不应该关注 provider 对服务是如何实现的。</li>
</ol>
<h2 id="开始使用-dubbo"><a class="header-anchor" href="#开始使用-dubbo">¶</a>开始使用 Dubbo</h2>
<h3 id="zookeeper"><a class="header-anchor" href="#zookeeper">¶</a>ZooKeeper</h3>
<p>ZooKeeper 在 Dubbo 中可以作为注册中心使用。<br>
下载 ZooKeeper，修改配置，配置文件位于{ZOOKEEPER_HOME}/conf/zoo.cfg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir = /tmp/zk/data</span><br><span class="line">clientPort = 2181</span><br><span class="line">tickTime = 2000</span><br><span class="line">initLimit = 5</span><br><span class="line">syncLimit = 2</span><br></pre></td></tr></table></figure>
<ul>
<li>dataDir：数据保存的目录</li>
<li>clientPort：监听的端口</li>
<li>tickTime：心跳检查间隔</li>
<li>initLimit：Follower 启动从 Leader 同步数据时能忍受多少个心跳的时间间隔</li>
<li>syncLimit：Leader 同步到 Follower 后，如果超过 syncLimit 个 tickTime 的时间过去，还没有收到 Follower 的响应，那么就认为该 Follower 已下线。</li>
</ul>
<p>后台启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh start-foreground</span><br></pre></td></tr></table></figure>
<h3 id="sdk"><a class="header-anchor" href="#sdk">¶</a>SDK</h3>
<p>SDK 是一个被 provider 和 consumer 同时依赖的 jar 包，它的作用包括：</p>
<ul>
<li>
<p>提供实体类的定义；</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提供接口的定义；</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserServiceBo &#123;</span><br><span class="line">    String sayHello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在设计 SDK 时包含一些注意要点，比如：</p>
<ul>
<li>不要使用枚举，用字符串常量来替代，因为 Dubbo 反序列化时如果碰到不存在的枚举就会抛出异常，这个问题编译期无法发现，可能造成线上故障；</li>
<li>升级时不要随意修改接口定义，provider 和 consumer 接口定义不同会导致运行时故障，最佳实践是提升<code>dubbo:reference</code>和<code>dubbo:service</code>的版本号，或者直接增加一个接口。</li>
</ul>
<h3 id="provider"><a class="header-anchor" href="#provider">¶</a>Provider</h3>
<ol>
<li>
<p>声明依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.35.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Dubbo 配置文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;dubboProvider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line">    &lt;!-- 启用monitor模块 --&gt;</span><br><span class="line">    &lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.tallate.provider.UserServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.tallate.UserServiceBo&quot; ref=&quot;userService&quot;</span><br><span class="line">      group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口的实现</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserServiceBo &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        //让当前当前线程休眠2s</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动<br>
原生 Spring 的启动方式：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws InterruptedException &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:provider.xml&quot;);</span><br><span class="line">    //挂起当前线程，如果没有改行代码，服务提供者进程会消亡，服务消费者就发现不了提供者了</span><br><span class="line">    Thread.currentThread().join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>如果需要以 SpringBoot 或 Docker 方式启动可以参考官方的示例</p>
</blockquote>
<h3 id="consumer"><a class="header-anchor" href="#consumer">¶</a>Consumer</h3>
<ol>
<li>
<p>声明依赖<br>
同 Provider</p>
</li>
<li>
<p>Dubbo 配置文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;dubboConsumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry  protocol=&quot;zookeeper&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">    &lt;!-- 启动monitor--&gt;</span><br><span class="line">    &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">    &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.tallate.UserServiceBo&quot; group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里出现了一些以 dubbo 作为前缀的标签，它们是由 Dubbo 的扩展 DubboNamespaceHandler 来处理的，DubboBeanDefinitionParser 在解析完后会得到对应 BeanDefinition，然后生成对象放到 BeanFactory 中。</p>
</blockquote>
</li>
<li>
<p>启动</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">            new String[]&#123;&quot;classpath:consumer.xml&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    final UserServiceBo demoService = (UserServiceBo) context.getBean(&quot;userService&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(demoService.sayHello(&quot;Hello World&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="调用-dubbo-原生-api-启动"><a class="header-anchor" href="#调用-dubbo-原生-api-启动">¶</a>调用 Dubbo 原生 API 启动</h3>
<ol>
<li>
<p>Provider</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 等价于&lt;bean id=&quot;userService&quot; class=&quot;com.test.UserServiceImpl&quot; /&gt;</span><br><span class="line">UserServiceBo userService = new UserServiceImpl();</span><br><span class="line">// 等价于&lt;dubbo:application name=&quot;dubboProvider&quot; /&gt;</span><br><span class="line">ApplicationConfig application = new ApplicationConfig();</span><br><span class="line">application.setName(&quot;dubboProvider&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">RegistryConfig registry = new RegistryConfig();</span><br><span class="line">registry.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line">ProtocolConfig protocol = new ProtocolConfig();</span><br><span class="line">protocol.setName(&quot;dubbo&quot;);</span><br><span class="line">protocol.setPort(20880);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:service interface=&quot;com.test.UserServiceBo&quot; ref=&quot;userService&quot;</span><br><span class="line">//      group=&quot;dubbo&quot;  version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line">// 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏</span><br><span class="line">ServiceConfig&lt;UserServiceBo&gt; service = new ServiceConfig&lt;&gt;();</span><br><span class="line">service.setApplication(application);</span><br><span class="line">service.setMonitor(monitorConfig);</span><br><span class="line">// 多个注册中心可以用setRegistries()</span><br><span class="line">service.setRegistry(registry);</span><br><span class="line">// 多个协议可以用setProtocols()</span><br><span class="line">service.setProtocol(protocol);</span><br><span class="line">service.setInterface(UserServiceBo.class);</span><br><span class="line">service.setRef(userService);</span><br><span class="line">service.setVersion(&quot;1.0.0&quot;);</span><br><span class="line">service.setGroup(&quot;dubbo&quot;);</span><br><span class="line">service.setTimeout(3000);</span><br><span class="line">service.export();</span><br><span class="line"></span><br><span class="line">// 挂起当前线程</span><br><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Consumer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 等价于&lt;dubbo:application name=&quot;dubboConsumer&quot; /&gt;</span><br><span class="line">ApplicationConfig application = new ApplicationConfig();</span><br><span class="line">application.setName(&quot;dubboConsumer&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:registry  protocol=&quot;zookeeper&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">RegistryConfig registry = new RegistryConfig();</span><br><span class="line">registry.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于 &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br><span class="line"></span><br><span class="line">//等价于&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.test.UserServiceBo&quot;</span><br><span class="line">//group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot; /&gt;</span><br><span class="line">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，最好放缓存，否则可能造成内存和连接泄漏</span><br><span class="line">ReferenceConfig&lt;UserServiceBo&gt; reference = new ReferenceConfig&lt;&gt;();</span><br><span class="line">reference.setApplication(application);</span><br><span class="line">// 多个注册中心可以用setRegistries()</span><br><span class="line">reference.setRegistry(registry);</span><br><span class="line">reference.setInterface(UserServiceBo.class);</span><br><span class="line">reference.setVersion(&quot;1.0.0&quot;);</span><br><span class="line">reference.setGroup(&quot;dubbo&quot;);</span><br><span class="line">reference.setTimeout(3000);</span><br><span class="line">reference.setInjvm(false);</span><br><span class="line">reference.setMonitor(monitorConfig);</span><br><span class="line"></span><br><span class="line">UserServiceBo userService = reference.get();</span><br><span class="line">System.out.println(userService.sayHello(&quot;哈哈哈&quot;));</span><br><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="泛化调用"><a class="header-anchor" href="#泛化调用">¶</a>泛化调用</h3>
<p>正常情况下我们使用 Dubbo 时会将实体类和接口定义放到一个 SDK 包内，其实也可以不加入这个包、直接将要传的参数放到一个 Map 对象内，称为泛化调用，但是这种方式没有什么实践价值，在此就不赘述了。</p>
<h2 id="dubbo-架构"><a class="header-anchor" href="#dubbo-架构">¶</a>Dubbo 架构</h2>
<blockquote>
<p>Dubbo 是一个分布式服务框架，是阿里巴巴 SOA 服务化治理方案的核心框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。简而言之，Dubbo 是个远程服务调用的分布式框架（告别 Web Service 模式中的 WSdl，以服务提供者与消费者的方式在 dubbo 上注册）。</p>
</blockquote>
<p>Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<br>
Dubbo 的架构基本上可以概括为 RPC+服务发现，或者可以称之为弹性 RPC 框架。</p>
<h3 id="cp-三大中心"><a class="header-anchor" href="#cp-三大中心">¶</a>CP+三大中心</h3>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E6%9E%B6%E6%9E%84.png" alt="Dubbo架构" title="Dubbo架构"></p>
<blockquote>
<p>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider、Consumer、Registry、Monitor 划分逻辑拓普节点，保持统一概念。</p>
</blockquote>
<p>Provider: 暴露服务的服务提供方，启动时会注册自己提供的服务到注册中心。<br>
Consumer: 调用远程服务的服务消费方，启动时会去注册中心订阅自己需要的服务，服务注册中心异步提供 Provider 的地址列表，Consumer 根据路由规则和预设的负载均衡算法选择一个 Provider 的 IP 进行调用，调用是直连的，失败后会调用另外一个。<br>
Registry: 服务注册与发现的注册中心。<br>
Monitor: 统计服务的调用次调和调用时间的监控中心，Provider 和 Consumer 在内存中累计调用次数和耗时，并定时每分钟发送一次统计数据到监控中心。<br>
Container: 服务运行容器。</p>
<p>大数据量传输时适合用短连接，小数据量高并发适合用长连接。从上图中可以得知，Provider 和 Consumer 均通过长连接与注册中心通信，当消费方调用服务时，会创建一个连接，然后同时会创建一个心跳发送的定时线程池，每一分钟发送一次心跳包到注册中心，通过 ping-pong 来检查连接的存活性，同时还会启动断线重连定时线程池，每两秒钟检查一次连接状态，如果断开就重连，而当注册中心断开连接后，会回调通知 Consumer 销毁连接，同理，Provider 也是通过长连接与注册中心通信。</p>
<h4 id="元数据中心"><a class="header-anchor" href="#元数据中心">¶</a>元数据中心</h4>
<p>2.7 之后提供的一个新组件，容易和注册中心混淆，元数据和注册中心中的注册信息之间的区别如下：</p>
<ul>
<li>**元数据（Metadata）**指的是服务分组、服务版本、服务名、方法列表、方法参数列表、超时时间等</li>
<li><strong>注册信息</strong>指服务分组、服务版本、服务名、地址列表等。</li>
</ul>
<p>元数据中心和注册中心包含了一些公共数据，另外，元数据中心还会存储方法列表即参数列表，注册中心存储了服务地址，其他的一些区别如下所示：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>元数据</th>
<th>注册信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>职责</td>
<td>描述服务，定义服务的基本属性</td>
<td>存储地址列表</td>
</tr>
<tr>
<td>变化频繁度</td>
<td>基本不变</td>
<td>随着服务上下线而不断变更</td>
</tr>
<tr>
<td>数据量</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>数据交互/存储模型</td>
<td>消费者/提供者上报，控制台查询</td>
<td>PubSub 模型，提供者上报，消费者订阅</td>
</tr>
<tr>
<td>主要使用场景</td>
<td>服务测试、服务</td>
<td>MOCK 服务调用</td>
</tr>
<tr>
<td>可用性要求</td>
<td>元数据中心可用性要求不高，不影响主流程</td>
<td>注册中心可用性要求高，影响到服务调用的主流程</td>
</tr>
</tbody>
</table>
<h3 id="dubbo-层次化结构"><a class="header-anchor" href="#dubbo-层次化结构">¶</a>Dubbo 层次化结构</h3>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E6%A1%86%E6%9E%B6.png" alt="Dubbo框架" title="Dubbo框架"><br>
Dubbo 的架构是分层的，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务。</p>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E6%89%A9%E5%B1%95.jpg" alt="Dubbo扩展" title="Dubbo扩展"></p>
<ul>
<li>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li>
</ul>
<p>RPC 是 Dubbo 的核心：</p>
<ul>
<li>配置层（Config）：对外配置接口，以 <strong>ServiceConfig</strong> 和 <strong>ReferenceConfig</strong> 为中心，可以直接 new 配置类，也可以通过 Spring 解析配置生成配置类。</li>
<li>服务代理层（Proxy）：服务接口透明代理。Proxy 层封装了所有接口的透明化代理，而在其它层都以 <strong>Invoker</strong> 为中心，只有到了暴露给用户使用时，才用 <strong>Proxy</strong> 将 <strong>Invoker</strong> 转成接口，或将接口实现转成 <strong>Invoker</strong>，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。<br>
Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>服务注册层（Registry）：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <strong>RegistryFactory</strong>、<strong>Registry</strong> 和 <strong>RegistryService</strong>。可能没有服务注册中心，此时服务提供方直接暴露服务。</li>
<li>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 <strong>Cluster</strong>、<strong>Directory</strong>、<strong>Router</strong> 和 <strong>LoadBalance</strong>。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</li>
<li>监控层（Monitor）：RPC 调用次数和调用时间监控，以 <strong>Statistics</strong> 为中心，扩展接口为 <strong>MonitorFactory</strong>、<strong>Monitor</strong>和 <strong>MonitorService</strong>。</li>
<li>远程调用层（Protocol）：封装 RPC 调用，扩展接口为 <strong>Protocol</strong>、<strong>Invoker</strong> 和 <strong>Exporter</strong>。Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>
</ul>
<blockquote>
<p>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。<br>
Cluster 是外围概念，Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p>
</blockquote>
<p>Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina、Netty、Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p>
<ul>
<li>交换层（Exchange）：封装请求响应模式，同步转异步，以 Request 和 Response 为中心，扩展接口为<strong>Exchanger</strong>、<strong>ExchangeChannel</strong>、<strong>ExchangeClient</strong>和<strong>ExchangeServer</strong>。</li>
<li>网络传输层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为<strong>Channel</strong>、<strong>Transporter</strong>、<strong>Client</strong>、<strong>Server</strong>和<strong>Codec</strong>。</li>
<li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为<strong>Serialization</strong>、 <strong>ObjectInput</strong>、<strong>ObjectOutput</strong>和<strong>ThreadPool</strong>。</li>
</ul>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="Dubbo包结构" title="Dubbo包结构"></p>
<ul>
<li>dubbo-common 公共逻辑模块，包括 Util 类和通用模型。</li>
<li>dubbo-remoting 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议则不需要使用此包。</li>
<li>dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>
<li>dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>
<li>dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>
<li>dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>
<li>dubbo-config 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏 Dubbo 所有细节。</li>
<li>dubbo-container 容器模块，是一个 Standalone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li>
</ul>
<h2 id="接口扩展策略注解-spi"><a class="header-anchor" href="#接口扩展策略注解-spi">¶</a>接口扩展策略注解 @SPI</h2>
<p>上面提到的扩展接口，如 Protocol、Transporter、Filter 等，都是通过 JDK 的 SPI 机制实现的，也就是说这些功能都可被用户自定义的扩展所替换，接口扩展点由注解<code>@SPI</code>定义。<br>
JDK 中 SPI（Service Provider Interface）的设计与策略模式如出一辙，开发者可以替换掉 Dubbo 原扩展接口的默认实现，完成自定义需求，即可以自定义实现策略。<br>
Dubbo 在 JDK 现有 SPI 实现的基础上做了如下改进：</p>
<ol>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName();获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
</ol>
<p>那么 Dubbo 的 SPI 机制是怎么实现的呢？以协议扩展为例，Dubbo 中协议被抽象为 Protocol 接口。</p>
<h3 id="读取扩展点"><a class="header-anchor" href="#读取扩展点">¶</a>读取扩展点</h3>
<p>ServiceConfig#protocol</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span><br></pre></td></tr></table></figure>
<p>Dubbo 使用 ExtensionLoader 实现扩展点加载。</p>
<ul>
<li>ExtensionLoader#getExtensionLoader()<br>
获取 ExtensionLoader 实现，保证每种扩展点一个单例。</li>
<li>ExtensionLoader#getAdaptiveExtension()<br>
根据不同的 SPI 扩展点，即不同的 interface，生成不同的 Adaptive 实例的代码。<br>
-&gt; getAdaptiveExtensionClass()<br>
-&gt; getExtensionClasses()<br>
-&gt; loadExtensionClasses()<br>
加载所有的扩展点实现，直到扩展点方法执行时才决定调用是一个扩展点实现，即从众多的实现策略中决定具体使用哪一个策略。<br>
ExtensionLoader 会依次从<code>META-INF/dubbo/internal</code>（Dubbo 内部实现）、<code>META-INF/dubbo/</code>（开发者自定义策略）、<code>META-INF/services/</code>这几个目录下读取扩展点实现，目录下的同名文件配置了对应扩展点的实现策略，调用 loadFile 来加载对应的扩展策略。<br>
-&gt; loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</li>
</ul>
<h3 id="生成-adaptive-实例"><a class="header-anchor" href="#生成-adaptive-实例">¶</a>生成 Adaptive 实例</h3>
<ul>
<li>ExtensionLoader#loadFile<br>
-&gt; String fileName = dir + type.getName()<br>
拼接文件路径<br>
-&gt; ClassLoader classLoader = findClassLoader()<br>
拿到 ExtensionLoader 的类加载器。<br>
-&gt; Class&lt;?&gt; clazz = Class.forName(line, true, classLoader);<br>
文件每行是一个实现类的全路径名，通过反射加载并拿到具体类型。<br>
-&gt; extensionClasses.put(n, clazz)<br>
添加到 map 里返回。</li>
<li>ExtensionLoader#cachedClasses<br>
-&gt; cachedClasses.set(classes)<br>
添加到缓存。</li>
<li>ExtensionLoader#createAdaptiveExtensionClass<br>
-&gt; ExtensionLoader#createAdaptiveExtensionClassCode<br>
生成 Adaptive 类。<br>
-&gt; compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension()<br>
拿到编译接口扩展点的一个具体实现，dubbo 内部支持 jdk 和 javassist，默认是 javassist。<br>
-&gt; compiler.compile(code, classLoader)<br>
编译代码，生成 Adaptive 实例类。</li>
</ul>
<p>上面提到 Compiler 也是一个扩展点，同样也依赖这个流程来实例化，在运行时生成 Adaptive 实例的时候，需要生成 Compiler 接口的 Adaptive 实例，即运行生成 Adaptive 实例的时候需要先有一个 Compiler 接口的 Adaptive 实例，那这样岂不是陷入了死循环，这里就要提到显示指定 Adaptive 实例的情况。<code>@Adaptive</code>注解支持类级别和方法级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、类级别：只能拥有一个，注解打在接口实现类上，显示的注册一个Adaptive实例，在编译期就存在，如`AdaptiveCompiler`，解决了上面的死循环问题，由`AdaptiveCompiler`依据dubbo配置决定使用哪个编译类；</span><br><span class="line">2、方法级别：在运行期动态的生成Adaptive实例。</span><br></pre></td></tr></table></figure>
<h3 id="通过-url-动态选择协议"><a class="header-anchor" href="#通过-url-动态选择协议">¶</a>通过 URL 动态选择协议</h3>
<p>ExtensionLoader#createAdaptiveExtensionClassCode<br>
生成的 Protocol 的 Adaptive 实例类，依据 URL 中 protocol key-value 的值，选择对应的 Protocol 策略来暴露和引用服务。<br>
扩展点方法调用会有 URL 参数（或是参数有 URL 成员），这样依赖的扩展点可以从 URL 拿到配置信息，所有的扩展点自己定好配置的 Key 后，配置信息从 URL 上从最外层传入，URL 在配置传递上即是一条总线。<br>
以 dubbo+zookeeper 为例，暴露和引用远程服务都是注册在 zookeeper 上的，服务注册在 zookeeper 上本质其实是一个 URL，远程服务调用的过程中依据 URL 的 key-value 来动态决定执行 Protocol、Filter 等接口扩展点的执行策略。<br>
下面是 Provider 端暴露 HelloService 服务时在 zookeeper 上注册的 URL，在 zookeeper 上的路径为/dubbo/com.dubbo.test.service.HelloService/providers，URL 表示了采用 dubbo 协议，接口为 com.dubbo.test.service.HelloService，方法为 say，要执行的 Filter 为 whiteFilter 等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk： localhost：2181(CONNECTED) 1] Is /dubbo/com.dubbo.test.service.HelloService/providers</span><br><span class="line">[dubbo://127.0.0.1:2O881/com.dubbo.test.service.HelloService?anyhost=true&amp;application=dubbo-test-service&amp;dubbo=2.4.10&amp;group=test-prod&amp;interface=com.dubbo.test.service.HelloService&amp;methods=say&amp;pid=21242&amp;revision=l.0&amp;service.filter=whiteFilter&amp;side=providerxtamp=1495436105078&amp;version=l.0]</span><br></pre></td></tr></table></figure>
<h3 id="缓存"><a class="header-anchor" href="#缓存">¶</a>缓存</h3>
<ul>
<li>volatile Class&lt;~&gt; cachedAdaptiveClass<br>
这个是缓存 AdaptiveClass，如果一个扩展类的类上面带有 @Adaptive 注解，那么这个类就会被缓存在这个地方，每一种类型的扩展类只有一个 AdaptiveClass，如果发现有多个，则会报错。另外，当通过 getAdaptiveExtensionClass 来获取自适应扩展类时，如果当前还没有 AdaptiveClass，则会自动创建一个（动态生成 Java 代码，再编译，典型的比如 Protocol$Adaptive 就是这么生成的）</li>
<li>Set&lt;~&gt; cachedWrapperClasses<br>
这个是缓存包装类的，Dubbo 判断一个扩展类是否是包装类比较简单，通过构造函数来判断，如果这个扩展类有一个构造函数，其中参数是当前扩展类的类型，那么就是包装类，举个例子，ProtocolFilterWrapper 就是 protocol 扩展类的包装类，因为有这个构造函数：<code>public ProtocolFilterWrapper(Protocol protocol)</code></li>
<li>Map&lt;~&gt; cachedActivates<br>
这个是缓存激活的扩展类，当然，@Activate 注解还可以规定激活的条件和时机</li>
<li>Holder&lt;~&gt; cachedClasses<br>
这个是缓存 Adaptive 和 Wrapper 扩展类之外的普通扩展类</li>
</ul>
<p>扩展类被加载后会根据一定的规则放入以上 4 个缓存中，比如带有 @Adaptive 注解的会被放入 cachedAdaptiveClass。</p>
<h2 id="服务注册-自动发现"><a class="header-anchor" href="#服务注册-自动发现">¶</a>服务注册 &amp; 自动发现</h2>
<p>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，使服务提供方可以平滑增加或减少机器。</p>
<h3 id="角色分类"><a class="header-anchor" href="#角色分类">¶</a>角色分类</h3>
<p>以功能角度来说服务可以分成以下几种：</p>
<ul>
<li>服务提供者；</li>
<li>服务消费者；</li>
<li>服务提供者兼消费者。</li>
</ul>
<h3 id="注册中心分类"><a class="header-anchor" href="#注册中心分类">¶</a>注册中心分类</h3>
<p>可以分成以下几种注册中心：</p>
<ul>
<li>Simple 注册中心 点对点直连</li>
<li>Multicast 注册中心 多播</li>
<li>Zookeeper 注册中心</li>
<li>Redis 注册中心</li>
</ul>
<h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3>
<p>服务提供者（provider）配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用名称，可显示依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;dubbo-order-server&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册中心是ZooKeeper，也可以选择Redis做注册中心 --&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;</span><br><span class="line">    client=&quot;zkclient&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过dubbo协议在注册中心（127.0.0.1表示本机）的20880端口暴露服务 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; host=&quot;127.0.0.1&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提供服务用地的是service标签，将该接口暴露到dubbo中 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.dubbo.service.OrderService&quot;</span><br><span class="line">    ref=&quot;orderService&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring容器加载具体的实现类--&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;dubbo.service.impl.OrderServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>服务消费者（consumer）配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用名称，可显示依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;dubbo-user-consumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- zookeeper作为注册中心 ，也可以选择Redis做注册中心 --&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;</span><br><span class="line">    client=&quot;zkclient&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol host=&quot;127.0.0.1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用服务使用reference标签，从注册中心中查找服务 --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;orderService&quot; interface=&quot;com.dubbo.service.OrderService&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="服务自动发现流程"><a class="header-anchor" href="#服务自动发现流程">¶</a>服务自动发现流程</h3>
<p>服务自动发现功能完成下面这个流程，我们接下来分点概述：</p>
<ol>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法（基于软件的负载均衡，与 F5 相对），选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
</ol>
<h3 id="注册和注销服务-provider-执行流程"><a class="header-anchor" href="#注册和注销服务-provider-执行流程">¶</a>注册和注销服务（Provider 执行流程）</h3>
<p>服务的注册与注销，是对服务提供方角色而言，大致流程如下所示：<br>
<img src="http://47.88.24.11/imgs/Dubbo/%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1.png" alt="注册和注销服务" title="注册和注销服务"></p>
<ol>
<li>在接口提供者初始化时，每个接口都会创建一个 Invoker 和 Exporter，Exporter 持有 Invoker 实例，通过 Invocation 中的信息就可找到对应的 Exporter 和 Invoker</li>
<li>同 Consumer 的过程类似，调用 Invoker 前会调用 Invoker-Filter。</li>
<li>调用 Invoker.invoke() 时，通过反射调用最终的服务实现执行相关逻辑。</li>
</ol>
<p>ServiceBean 负责了服务的暴露：</p>
<ul>
<li>继承自 ServiceConfig，export 方法实现了服务暴露的逻辑；</li>
<li>实现了 Spring 中的 InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener<contextrefreshedevent>, BeanNameAware</contextrefreshedevent></li>
</ul>
<p>启动时，ServiceBean 主要负责以下任务：</p>
<ul>
<li>生成 DubboExporter 对象并缓存起来</li>
<li>添加过滤器和监听器支持</li>
<li>在 zk 上注册相关信息，暴露服务，方便被感知到</li>
<li>监听端口，等待通信的到来</li>
</ul>
<h3 id="provider-启动源码-服务导出"><a class="header-anchor" href="#provider-启动源码-服务导出">¶</a>Provider 启动源码（服务导出）</h3>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA.png" alt="Dubbo服务导出" title="Dubbo服务导出"></p>
<ol>
<li>前置工作，主要用于检查参数和组装 URL；<br>
ServiceBean#onApplicationEvent: 接收 Spring 上下文刷新事件后执行服务导出操作<br>
-&gt; ServiceBean#export: 导出服务<br>
-&gt; ProviderConfig.getExport、getDelay 获取配置，如果 export 为 false 则无法提供给其他服务调用、一般只提供给本地调试时使用，如果需要 delay 则将任务交给一个 ScheduledExecutorService 延迟执行，否则调用 doExport 暴露服务<br>
-&gt; ServiceConfig.doExport 一堆配置检查</li>
<li>导出服务，包含导出服务到本地（JVM）和导出服务到远程两个过程；<br>
<code>ServiceConfig.doExportUrls</code><br>
导出服务，Dubbo 中所有服务都通过 URL 导出，支持多协议多注册中心导出服务（遍历 ProtocolConfig 集合导出每个服务）<br>
<code>AbstractInterfaceConfig#loadRegistries</code><br>
加载注册中心链接<br>
<code>ServiceConfig#doExportUrlsFor1Protocol</code><br>
组装 URL，将服务注册到注册中心<br>
<code>JavassistProxyFactory#getInvoker</code><br>
获取 Invoker 实例，用于接收请求<br>
<code>ServiceConfig#exportLocal、DubboProtocol#export</code><br>
根据配置信息导出服务到本地或远程，远程默认取Dubbo协议<br>
<code>DubboProtocol#openServer</code><br>
开始监听请求</li>
<li>向注册中心注册服务，用于服务发现<br>
Dubbo 服务注册本质是在 zk 指定目录下创建临时节点，路径是<code>{group}/{Interface}/providers/{url}</code>。<br>
RegistryProtocol#register<br>
-&gt; RegistryFactory#getRegistry<br>
-&gt; AbstractRegistry#register</li>
</ol>
<h3 id="服务订阅和取消-consumer-执行流程"><a class="header-anchor" href="#服务订阅和取消-consumer-执行流程">¶</a>服务订阅和取消（Consumer 执行流程）</h3>
<p>为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。<br>
<img src="http://47.88.24.11/imgs/Dubbo/%E6%9C%8D%E5%8A%A1%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88.png" alt="服务订阅和取消" title="服务订阅和取消"></p>
<ol>
<li>在 Consumer 初始化的时候，会生成一个代理注册到容器中，该代理回调中持有一个 Invoker 实例，消费调用服务接口时它的 invoke() 方法会被调用。</li>
<li>在这个 invoke() 方法中，首先会继续是否需要 mock 等过滤判断，关于 Filter 这里先不详细展开，这里只看下核心流程。</li>
<li>为了服务高可用同一个服务一般会有多个应用服务器提供，要先挑选一个提供者提供服务。在服务接口消费者初始化时，接口方法和提供者 Invoker 对应关系保存在 Directory。 中，通过调用的方法名称（或方法名称+第一个参数）获取该方法对应的提供者 Invoker 列表，如注册中心设置了路由规则，对这些 Invoker 根据路由规则进行过滤。</li>
<li>读取到所有符合条件的服务提供者 Invoker 之后，由 LoadBalance 组件执行负载均衡，从中挑选一个 Invoker 进行调用，框架内置支持的负载均衡算法包括 random（随机）、roundrobin（R-R 循环）、leastactive（最不活跃）、consistenthash（一致性 hash），默认 random。</li>
<li>Cluster 持有 DubboInvoker 实例的代理对象，会先激活 Filter 链然后最终调到 DubboInvoker.invoke(RpcInvocation)。</li>
</ol>
<h3 id="consumer-启动源码-服务引入"><a class="header-anchor" href="#consumer-启动源码-服务引入">¶</a>Consumer 启动源码（服务引入）</h3>
<p>有两种服务引入方式：</p>
<ol>
<li>饿汉式：Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，可通过配置 <code>&lt;dubbo:reference&gt;</code> 的 init 属性开启。</li>
<li>懒汉式：ReferenceBean 对应的服务被注入到其他类中时引用</li>
</ol>
<p>服务提供的方式有三种：</p>
<ol>
<li>引用本地 (JVM) 服务；</li>
<li>通过直连方式引用远程服务；</li>
<li>通过注册中心引用远程服务。</li>
</ol>
<p>不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。</p>
<ol>
<li>创建RPC代理<br>
spring.ReferenceBean#getObject<br>
ReferenceConfig#createProxy<br>
创建代理实例，根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用，不是本地引用的情况下默认采用Dubbo协议。</li>
<li>获取客户端实例 Invoker<br>
-&gt; DubboProtocol#getClients 获取客户端实例，实例类型为 ExchangeClient，ExchangeClient 不具备通信能力，它需要依赖更底层的客户端实例<br>
-&gt; DubboProtocol#getSharedClient 默认获取共享客户端<br>
-&gt; DubboProtocol#initClient 创建客户端实例，默认为 Netty<br>
-&gt; Exchangers#connect(URL url, ExchangeHandler handler)</li>
<li>使用 Cluster 合并 Invoker<br>
org.apache.dubbo.rpc.cluster.Cluster#join<br>
如果配置了多个 URL，则使用 Cluster 合并多个 Invoker</li>
<li>创建动态代理<br>
-&gt; ProxyFactory#getProxy(Invoker<t> invoker)<br>
常用的动态代理技术有 javassist、cglib、jdk，其中 dubbo 使用的是 javassist。</t></li>
</ol>
<blockquote>
<p>根据早期 Dubbo 作者梁飞（<a href="http://javatar.iteye.com/blog/814426%EF%BC%89%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">http://javatar.iteye.com/blog/814426）的说法，使用</a> javassist 是为了性能。</p>
</blockquote>
<h3 id="服务自动踢出"><a class="header-anchor" href="#服务自动踢出">¶</a>服务自动踢出</h3>
<p>因为Dubbo一般使用ZooKeeper作为注册中心，所以完全可以利用ZooKeeper的临时节点自动删除机制来实现服务器下线自动踢出的机制。</p>
<h3 id="查看服务注册-暴露结果"><a class="header-anchor" href="#查看服务注册-暴露结果">¶</a>查看服务注册/暴露结果</h3>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.png" alt="Dubbo服务注册信息" title="Dubbo服务注册信息"><br>
Dubbo 在 ZooKeeper 中以树形结构维护服务注册信息：</p>
<ul>
<li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址；</li>
<li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址；</li>
<li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。</li>
</ul>
<p>ZooKeeper 启动的时候会把配置信息加载进内存并持久化到数据库，然后启动定时器脏数据检查定时器 DirtyCheckTask，分别检查消费者和提供者的地址列表缓存、消费者和提供者地址列表的数据库数据，清理不存活的消费者和提供者数据，对于缓存中的存在的消费者和提供者而数据库不存在，提供者重新注册和消费者重新订阅。</p>
<p>Dubbo 提供了一些异常情况下的兜底方案：</p>
<ul>
<li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li>
<li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li>
<li>当会话过期时，能自动恢复注册数据，以及订阅请求</li>
<li>当设置 &lt;dubbo:registry check=“false” /&gt; 时，记录失败注册和订阅请求，后台定时重试</li>
</ul>
<p>在了解 ZooKeeper 基础上，还可以增加一些配置来修改注册细节：<br>
可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 ZooKeeper 登录信息<br>
可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 ZooKeeper 的根节点，不设置将使用无根树<br>
支持 * 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code> ，可订阅服务的所有分组和所有版本的提供者</p>
<p>在 Provider 启动完毕后，可以登录到 ZooKeeper 上查看注册的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] ls /</span><br><span class="line">[dubbo, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] ls /dubbo</span><br><span class="line">[com.alibaba.dubbo.monitor.MonitorService, com.tallate.UserServiceBo]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] ls /dubbo/com.tallate.UserServiceBo</span><br><span class="line">[configurators, consumers, providers, routers]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 14] ls /dubbo/com.tallate.UserServiceBo/providers</span><br><span class="line">[dubbo%3A%2F%2F192.168.96.194%3A20880%2Fcom.tallate.UserServiceBo%3Fanyhost%3Dtrue%26application%3DdubboProvider%26dubbo%3D2.0.2%26generic%3Dfalse%26group%3Ddubbo%26interface%3Dcom.tallate.UserServiceBo%26methods%3DsayHello%2CtestPojo%2CsayHello2%26pid%3D28129%26revision%3D1.0.0%26side%3Dprovider%26timeout%3D3000%26timestamp%3D1575202776615%26version%3D1.0.0]</span><br></pre></td></tr></table></figure>
<h3 id="服务调用过程"><a class="header-anchor" href="#服务调用过程">¶</a>服务调用过程</h3>
<p>Consumer 端发送</p>
<ol>
<li>调用代理类的方法<br>
请求实际调用的是<code>InvokerInvocationHandler.invoke</code>。</li>
<li>Cluster 层<br>
封装了服务降级和容错机制，比如，如果调用失败则执行其他（<code>FailoverClusterInvoker</code>）、仍然调用失败则降级执行 mock（<code>MockClusterInvoker</code>）。</li>
<li>LoadBalance<br>
Cluster 层包含多个 Invoker，LoadBalance 负责从中选出一个来调用，有多种 LoadBalance 策略，比如随机选一个（<code>RandomLoadBalance</code>）、轮询（<code>RoundRobinLoadBalance</code>）。</li>
<li>DubboInvoker<br>
封装了同步和异步调用，Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。</li>
<li>Exchange 层<br>
封装了，包括对 Request 的序列化（HeaderExchangeChannel）、无引用时自动关闭客户端（ReferenceCountExchangeClient）、心跳检测（HeaderExchangeClient）</li>
<li>数据编码<br>
DubboCodec</li>
<li>发送<br>
NettyChannel#send</li>
</ol>
<p>Provider 端接收</p>
<ol>
<li>接收请求<br>
NettyClient<br>
请求被接收后，通过 Netty 调用链向下传递执行<br>
NettyHandler#messageReceived<br>
NettyChannel</li>
<li>解码<br>
<code>ExchangeCodec</code></li>
<li>线程派发<br>
<code>Dispatcher</code><br>
IO 线程接收请求后分发给事件处理线程执行，具体的派发逻辑在<code>ChannelHandler</code>中实现，比如<code>AllChannelHandler</code>。</li>
<li>请求分发<br>
<code>ChannelEventRunnable</code><br>
根据请求类型将请求分发给不同的<code>ChannelHandler</code>处理。</li>
</ol>
<p>Provider 端响应</p>
<p>Consumer 端接收响应</p>
<ol>
<li>发送完请求后阻塞<br>
<code>HeaderExchangeHandler</code><br>
用户线程在发送完请求后，会调用 <code>DefaultFuture</code> 的 <code>get</code> 方法等待响应对象的到来，这时每个<code>DefaultFuture</code>都会关联一个<strong>调用编号</strong>，用于在接收到响应时能对应上请求的<code>DefaultFuture</code>。<br>
当响应对象到来后，IO 线程根据<strong>调用编号</strong>可以找到<code>DefaultFuture</code>，之后会将响应对象保存到<code>DefaultFuture</code>，并唤醒用户线程。</li>
</ol>
<h2 id="协议-protocol"><a class="header-anchor" href="#协议-protocol">¶</a>协议 - Protocol</h2>
<p>Dubbo 支持多种协议，如下图所示：<br>
<img src="http://47.88.24.11/imgs/Dubbo/Protocol%E6%89%A9%E5%B1%95.png" alt="Protocol扩展" title="Protocol扩展"><br>
在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情，需要根据应用的特征来选择。例如，使用 RMI 协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用 RMI 协议，而是基于 HTTP 协议或者 Hessian 协议。</p>
<h3 id="hessian-协议"><a class="header-anchor" href="#hessian-协议">¶</a>Hessian 协议</h3>
<ul>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：Hessian 二进制序列化</li>
<li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</li>
<li>适用场景：页面传输，文件传输，Hessian 是 Caucho 开源的一个 RPC 框架，其通讯效率高于 WebService 和 Java 自带的序列化，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义 hessian 协议 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;hessian&quot; port=&quot;8080&quot; server=&quot;jetty&quot; /&gt;</span><br><span class="line">&lt;!--设置默认协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;hessian&quot; /&gt;</span><br><span class="line">&lt;!--设置 service 协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;hessian&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.caucho&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hessian&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.33&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="http-协议"><a class="header-anchor" href="#http-协议">¶</a>Http 协议</h3>
<ul>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：表单序列化</li>
<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或 URL 传入参数，暂不支持传文件。</li>
<li>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置协议 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;http&quot; port=&quot;8080&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="thrift-协议"><a class="header-anchor" href="#thrift-协议">¶</a>Thrift 协议</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol name=&quot;thrift&quot; port=&quot;3030&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>Dubbo 使用的 Thrift 和原生的 Thrift 协议不兼容，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p>
<h3 id="rest-协议"><a class="header-anchor" href="#rest-协议">¶</a>Rest 协议</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8080&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.service.OrderService&quot; ref=&quot;orderService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;com.service.OrderServiceImpl&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在代码中需要通过注解指定访问路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService &#123;    </span><br><span class="line">   void createOrder(Order order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Path(&quot;orders&quot;) // 访问Url的相对路径</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @POST</span><br><span class="line">    @Path(&quot;create&quot;) // 访问Url的相对路径</span><br><span class="line">    // 将传递过来的JSON数据反序列化为Order对象</span><br><span class="line">    @Consumes(&#123;MediaType.APPLICATION_JSON&#125;) </span><br><span class="line">    public void createOrder(Order order) &#123;</span><br><span class="line">        // create the order...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="长连接-or-短连接"><a class="header-anchor" href="#长连接-or-短连接">¶</a>长连接 OR 短连接</h3>
<p>Dubbo 协议缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 表示该服务使用 JVM 共享长连接 --&gt;</span><br><span class="line">&lt;dubbo:service connections=&quot;0&quot;&gt; </span><br><span class="line">&lt;dubbo:reference connections=&quot;0&quot;&gt;</span><br><span class="line">&lt;!-- 表示该服务使用独立长连接 --&gt;</span><br><span class="line">&lt;dubbo:service connections=&quot;1&quot;&gt; </span><br><span class="line">&lt;dubbo:reference connections=&quot;1&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="为什么要消费者比提供者个数多"><a class="header-anchor" href="#为什么要消费者比提供者个数多">¶</a>为什么要消费者比提供者个数多</h3>
<p>因为 dubbo 协议采用单一长连接，假设网络为千兆网卡 3，根据测试经验数据每条连接最多只能压满 7MByte（不同的环境可能不一样），理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。</p>
<h3 id="为什么不能传大包"><a class="header-anchor" href="#为什么不能传大包">¶</a>为什么不能传大包</h3>
<p>因 dubbo 协议采用单一长连接，如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡 3，每条连接最大 7MByte(不同的环境可能不一样，供参考)，单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。</p>
<h3 id="为什么采用异步单一长连接"><a class="header-anchor" href="#为什么采用异步单一长连接">¶</a>为什么采用异步单一长连接</h3>
<p>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题（服务器无法服务 1w 左右的并发连接）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置协议端口和服务提供方最大连接数，防止服务被压垮 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; accepts=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;!--配置dubbo默认协议 --&gt;</span><br><span class="line">&lt;dubbo:provider protocol=&quot;dubbo&quot; /&gt;</span><br><span class="line">&lt;!--配置dubbo设置服务协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;dubbo&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="集群-cluster"><a class="header-anchor" href="#集群-cluster">¶</a>集群 - Cluster</h2>
<p>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p>
<h3 id="服务目录-directory"><a class="header-anchor" href="#服务目录-directory">¶</a>服务目录（Directory）</h3>
<p><strong>服务目录</strong>中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。<br>
服务目录与注册中心之间的区别：</p>
<ul>
<li>注册中心存储服务提供者信息，在 Dubbo 中通过 ZooKeeper 实现；</li>
<li>服务目录是 Invoker 的集合，且这个集合中的元素会随注册中心的变化而进行动态调整。</li>
</ul>
<p>服务目录会在客户端启动时初始化完成，并订阅注册中心的更新：<br>
<code>com.alibaba.dubbo.registry.support.FailbackRegistry#FailbackRegistry</code><br>
<code>com.alibaba.dubbo.registry.support.FailbackRegistry#subscribe</code></p>
<h4 id="directory-继承结构"><a class="header-anchor" href="#directory-继承结构">¶</a>Directory 继承结构</h4>
<p>Directory 接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。Directory 有多个实现。</p>
<ul>
<li>StaticDirectory<br>
获取一次 Invoker 列表后就不变了。</li>
<li>RegistryDirectory<br>
实现了 NotifyListener 接口，当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化，然后根据配置变更信息刷新 Invoker 列表。<br>
刷新 Invoker 列表代码：com.alibaba.dubbo.registry.integration.RegistryDirectory#refreshInvoker</li>
</ul>
<h3 id="路由-router"><a class="header-anchor" href="#路由-router">¶</a>路由（Router）</h3>
<p>服务目录中包含多个 Invoker，需要通过路由规则来选择调用哪个，Dubbo 提供了 3 种路由实现：<strong>条件路由 ConditionRouter</strong>、<strong>脚本路由 ScriptRouter</strong> 和<strong>标签路由 TagRouter</strong>。</p>
<h4 id="条件路由-conditionrouter"><a class="header-anchor" href="#条件路由-conditionrouter">¶</a>条件路由（ConditionRouter）</h4>
<h3 id="容错方案"><a class="header-anchor" href="#容错方案">¶</a>容错方案</h3>
<p><img src="http://47.88.24.11/imgs/Dubbo/%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.png" alt="集群容错" title="集群容错"><br>
Dubbo 提供多种集群的容错方案，默认情况下为 Failover。<br>
<code>com.alibaba.dubbo.rpc.cluster.Cluster</code></p>
<h4 id="failover"><a class="header-anchor" href="#failover">¶</a>Failover</h4>
<p>失败自动切换，当出现失败，重试其它服务器 （该配置为默认配置）。通常用于读操作，但重试会带来更长时间的延迟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置集群容错模式为失败自动切换 --&gt;</span><br><span class="line">&lt;dubbo:reference cluster=&quot;failover&quot; /&gt;</span><br><span class="line">&lt;!-- 调用queryOrder方法如果失败共调3次，重试2次，如果成功则只调1次 --&gt;</span><br><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrder&quot; retries=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>
<p>通常用于幂等操作，多次调用副作用相同，譬如只读请求，Failover 使用得较多，推荐使用，但重试会带来更长延迟，应用于消费者和提供者的服务调用。</p>
<h4 id="failfast"><a class="header-anchor" href="#failfast">¶</a>Failfast</h4>
<p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录和修改数据，Failfast 使用得较多，但如果有机器正在重启，可能会出现调用失败，应用于消费者和提供者的服务调用。</p>
<h4 id="failsafe"><a class="header-anchor" href="#failsafe">¶</a>Failsafe</h4>
<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作，Failsafe 使用得不多，但调用信息会丢失，应用于发送统计信息到监控中心。</p>
<h4 id="failback"><a class="header-anchor" href="#failback">¶</a>Failback</h4>
<p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作，使用得很少，不可靠，重启会丢失，应用于注册服务到注册中心。</p>
<h4 id="forking"><a class="header-anchor" href="#forking">¶</a>Forking</h4>
<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，使用得很少，但需要浪费更多服务资源。</p>
<h4 id="broadcast"><a class="header-anchor" href="#broadcast">¶</a>Broadcast</h4>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息，速度慢，任意一台报错则报错，使用得很少。</p>
<h3 id="负载均衡"><a class="header-anchor" href="#负载均衡">¶</a>负载均衡</h3>
<h4 id="random-loadbalance"><a class="header-anchor" href="#random-loadbalance">¶</a>Random LoadBalance</h4>
<p>随机调用（默认配置），按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重，使用较多，推荐使用，但重试时，可能出现瞬间压力不均。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 服务端方法基本负载均衡设置 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.service.dubbo.queryOrder&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrder&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure>
<h4 id="roundrobin-loadbalance"><a class="header-anchor" href="#roundrobin-loadbalance">¶</a>RoundRobin LoadBalance</h4>
<p>轮循调用，按公约后的权重设置轮循比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上，极端情况可能产生雪崩。</p>
<h4 id="leastactive-loadbalance"><a class="header-anchor" href="#leastactive-loadbalance">¶</a>LeastActive LoadBalance</h4>
<p>最少活跃数调用，相同活跃数的随机，活跃数指调用前后计数差，使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差（与时间有关）会越大，但不支持权重。</p>
<h4 id="consistenthash-loadbalance"><a class="header-anchor" href="#consistenthash-loadbalance">¶</a>ConsistentHash LoadBalance</h4>
<p>一致性 Hash，相同参数的请求总是发到同一提供者，当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数 Hash，如果要修改，请配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>缺省用 160 份虚拟节点，如果要修改，请配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>由于是通过哈希算法分摊调用，有可能出现调用不均匀的情况</p>
<h2 id="远程通信-transport"><a class="header-anchor" href="#远程通信-transport">¶</a>远程通信 - Transport</h2>
<p>提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。<br>
Dubbo 支持如下网络通信框架：</p>
<ul>
<li>Mina</li>
<li>Netty</li>
<li>Grizzly</li>
</ul>
<h2 id="序列化-serialize"><a class="header-anchor" href="#序列化-serialize">¶</a>序列化 - Serialize</h2>
<h3 id="反射"><a class="header-anchor" href="#反射">¶</a>反射</h3>
<p>通过缓存加载的 Class、setAccessible(false)去掉安全校验等来提高反射效率，或者使用反射包<strong>ReflectASM</strong>。</p>
<h3 id="序列化"><a class="header-anchor" href="#序列化">¶</a>序列化</h3>
<p>对性能敏感，对开发体验要求不高的内部系统 thrift 或 protobuf<br>
对开发体验敏感，性能有要求的内外部系统 hessian2<br>
对序列化后的数据要求有良好的可读性 jackson/gson/xml<br>
对兼容性和性能要求较高的系统 protobuf 或 kryo ，它们的性能相差不多，但是 protobuf 有个缺点就是要传输的每一个类的结构都要生成对应的 proto 文件。</p>
<h2 id="filter"><a class="header-anchor" href="#filter">¶</a>Filter</h2>
<p>ProtocolFilterWrapper#export：如果当前 protocol 不是 registry，则调用 buildInvokerChain<br>
-&gt; ProtocolFilterWrapper#buildInvokerChain<br>
-&gt; ExtensionLoader#getActivateExtension(URL url, String key, String group)：获取系统自动激活的 Filter 和用户自定义的 Filter，最后合并返回</p>
<h2 id="更多功能"><a class="header-anchor" href="#更多功能">¶</a>更多功能</h2>
<h3 id="限流"><a class="header-anchor" href="#限流">¶</a>限流</h3>
<p>限流最好配置在 Provider 端，因为 Consumer 可能有很多个服务器实例，如果他们同时发起对同一 Provider 实例的请求可能会超出机器的处理能力上限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 限制接口OrderService里的每个方法，服务提供者端的执行线程不超过10个 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; executes=&quot;10&quot; /&gt;</span><br><span class="line">&lt;!-- 限制接口OrderService里的queryOrderList方法，服务提供者端的执行线程不超过10个 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrderList&quot; executes=&quot;10&quot; /&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line">&lt;!--限制使用dubbo协议时在服务提供者端启用的连接数不超过1000个--&gt;</span><br><span class="line">&lt;dubbo:provider protocol=&quot;dubbo&quot; accepts=&quot;1000&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>上述配置限制的是线程数，即并发连接数，Consumer 和 Provider 默认通过一条共享的 TCP 长连接通信，连接成功的情况下请求线程交由 IO 线程池异步读写数据，数据被反序列化后交由业务线程池处理具体业务，也就是对应的 Impl 实现类的具体方法。</p>
<h3 id="服务隔离"><a class="header-anchor" href="#服务隔离">¶</a>服务隔离</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--当同一个接口有多个实现时，可以通过group来隔离  --&gt;</span><br><span class="line">&lt;!--服务提供者  --&gt;</span><br><span class="line">&lt;dubbo:service group=&quot;ImplA&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;dubbo:service group=&quot;ImplB&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;MethodA&quot; group=&quot;ImplA&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;MethodB&quot; group=&quot;ImplB&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--当一个接口出现升级，新旧实现同时存在时，可以通过版本号来隔离，通常版本号隔离也用于联调阶段，不同版本号的服务无法调用，版本号相同的服务才能调用  --&gt;</span><br><span class="line">&lt;!--服务提供者  --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;new2.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;old1.0.0&quot;/&gt;</span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;NewMethodA&quot; interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;new2.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;OldMethodB&quot; interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;old1.0.0&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>通过版本号，也可以实现消费者和提供者服务端直接连接</strong>，因为发起调用默认使用随机调用端负载均衡模式，当有多台提供者的时候，会随机选取，通常联调阶段都会调用指定服务进行联调，直连一般用在调试，开发阶段，只需要消费者和提供者 version 相同即可。</p>
<h3 id="灰度发布"><a class="header-anchor" href="#灰度发布">¶</a>灰度发布</h3>
<p>有三台服务器 A、B、C 要上线，现在三台服务器都是旧版本代码，那首先从 Ngnix 负载均衡列表里移除 A 服务器的配置，切断对 A 的访问，然后在 A 服务器不受新的代码，重新把 A 配置进 Ngnix 负载均衡列表。如果在线使用没有问题，则继续升级 B、C 服务器，否则回滚，恢复旧版本代码，这是针对三端（PC 端，微信端，移动端）跟网关系统的。<br>
如果是针对子系统，譬如用户系统、订单系统等，可以通过分组 group 来实现子系统的灰度发布。服务提供者有两组，One、Two，将新版本代码 group 改为 Two，旧版本 group 还是 One，将新版本的消费者 group 改为 Two，这时请求定位到新的消费者再调用新的提供者，而且旧的消费者还是请求旧的提供者，如果线上没有问题，那就把提供者 group 为 One 的组改为 Two，并部署新代码，旧的消费者也改成 Two 并部署新代码如果有问题，那消费端和提供端都回滚到旧版本。</p>
<h3 id="异步调用"><a class="header-anchor" href="#异步调用">¶</a>异步调用</h3>
<p>Dubbo 默认情况下是同步调用的，就是调用后立刻返回，但如果消费端调用服务端创建文件并转化成 PDF 格式的文件这种在 IO 密集操作时，消费端同步调用需要等待对方转换结束才返回，很消耗性能，这时选择异步调用和回调调用更合适。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">async=&quot;true&quot; 异步调用，调用后不用等待，继续往下执行</span><br><span class="line">onreturn =&quot;CallBack.onreturn&quot; 返回后调用自定义的类CallBack类的onreturn方法</span><br><span class="line">onthrow=&quot;CallBack.onthrow&quot; 调用后，提供者抛出异常后，返回调用自定义的类CallBack类的onthrow方法</span><br><span class="line">--&gt;    </span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;tranfromPDF&quot; interface=&quot;com.bubbo.service.OrderService&quot; &gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;tranPDF&quot; async=&quot;true&quot; </span><br><span class="line">    onreturn =&quot;CallBack.onreturn&quot; </span><br><span class="line">    onthrow=&quot;CallBack.onthrow&quot;/&gt;</span><br><span class="line"> &lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>
<p>可以在 onthrow 事件里实现服务降级的方法，譬如遇到网络抖动，调用超时返回时可在 onthrow 里 return null。</p>
<ul>
<li>
<p>调用方</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryOrder() &#123;</span><br><span class="line">    // 此时调用会立即拿到null值</span><br><span class="line">    List&lt;Order&gt; list = this.orderService.queryOrderList();</span><br><span class="line">    // 拿到Future的引用，在提供方返回结果后，结果值会被设置进Future</span><br><span class="line">    Future&lt;String&gt; orderFuture = RpcContext.getContext().getFuture();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 该方法是阻塞方法，在拿到值之前一直等待，直到拿到值才会被唤醒，该方法会抛出异常，可以捕获</span><br><span class="line">        String returnValue = orderFuture.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>回调方</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 回调接口</span><br><span class="line">interface ICallBack &#123;</span><br><span class="line">    // 第一个参数是返回值，第二个参数是原参数</span><br><span class="line">    public void onreturn(String returnValue, String initParameter);</span><br><span class="line"></span><br><span class="line">    // 第一个参数是异常，第二个参数是原参数</span><br><span class="line">    public void onthrow(Throwable ex, String initParameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">class CallBackImpl implements ICallBack &#123;</span><br><span class="line">    public void onreturn(String returnValue, String initParameter) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void onthrow(Throwable ex, String initParameter) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://47.88.24.11/imgs/Dubbo/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="异步调用" title="异步调用"><br>
调用方有一个用户线程池用于处理调用请求（比如 Tomcat 里那个线程池），请求被转发到 IO 线程池，由 IO 线程来发起对提供方的调用，此时 IO 线程会新建一个 Future 对象进 RpcContext，用户线程可以继续继续自己的业务逻辑，然后在需要的时候调用 Future 的 get 方法阻塞等待，而服务端只需要将结果返回给 IO 线程，由 IO 线程调用 notify 方法唤醒阻塞等待中的用户线程。</p>
<h3 id="服务降级"><a class="header-anchor" href="#服务降级">¶</a>服务降级</h3>
<p>服务降级用于在服务高峰期将次要服务降级，仅保留关键服务，从而降低系统负载、提升可用性。比如，订单列表正常情况下展示所有订单，但是如果是在网站开展秒杀之类的大促活动时，就可以降级展示当月的订单而不是所有，再其次，如果服务器宕机了，也最好展示兜底页而不是 504。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; mock=&quot;com.dubbo.service.MonthOderMock&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="热点缓存"><a class="header-anchor" href="#热点缓存">¶</a>热点缓存</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务调用者 --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;queryCatalog&quot; interface=&quot;com.bubbo.service.CatalogService&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryCatalog&quot; cache=&quot;lru&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line">&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果查询的对象改变很少但又数据量很大的时候，如首页目录，可以避免每次都频繁调用服务端，可以设置本地缓存，加快热点数据的访问，Dubbo 的缓存类型 LRU 缓存，最近最少使用的数据会被清除，使用频繁的数据被保留，Thredlocal 缓存，当前线程的缓存，假如当前线程有多次请求，每次请求都需要相同的用户信息，那就适用，避免每次都去查询用户基本信息。</p>
<h2 id="源码分析"><a class="header-anchor" href="#源码分析">¶</a>源码分析</h2>
<p>环境配置比较简单，就是 zk-&gt;provider-&gt;consumer，在此不再赘述。</p>
<h3 id="失败重试"><a class="header-anchor" href="#失败重试">¶</a>失败重试</h3>
<p>Dubbo 中的失败重试机制比较丰富，基本考虑到常用的场景<br>
<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html</a><br>
FailoverClusterInvoker、FailfastClusterInvoker 等，以 FailoverClusterInvoker 为例：<br>
FailoverClusterInvoker.doInvoke 重试几次，把失败的添加到 invoked 列表里<br>
-&gt; AbstractClusterInvoker.select 选一个可用的调用，如果是已经被选过或因为其他条件不可用则 reselect</p>
<h3 id="负载均衡-v2"><a class="header-anchor" href="#负载均衡-v2">¶</a>负载均衡</h3>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<h3 id="幂等"><a class="header-anchor" href="#幂等">¶</a>幂等</h3>
<p>Dubbo 没有提供幂等性检查功能，需要自定义。</p>
<h3 id="限流-v2"><a class="header-anchor" href="#限流-v2">¶</a>限流</h3>
<p>Dubbo 中的限流比较简单，采用的是<strong>计数器算法</strong>，单位时间内超出阈值的流量会被直接丢弃，而且只支持 PORVIDER 端的限流，而且为了让它生效还要搞复杂的 SPI 配置。<br>
<a href="https://www.jianshu.com/p/7112a8d3d869" target="_blank" rel="noopener">https://www.jianshu.com/p/7112a8d3d869</a><br>
入口：TpsLimitFilter.invoke<br>
-&gt; TPSLimiter.isAllowable 为每个 Service 创建一个计数器 StatItem（粒度是整个 Service 有没有太大了）</p>
<h3 id="降级"><a class="header-anchor" href="#降级">¶</a>降级</h3>
<p>Dubbo 里的降级比较水，即调用出错就改成调用 Mock 接口，没有 Hystrix 中那么复杂的逻辑：<br>
<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html</a><br>
<a href="https://www.cnblogs.com/java-zhao/p/8320519.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-zhao/p/8320519.html</a><br>
入口：ReferenceConfig.createProxy 创建代理<br>
-&gt; ProxyFactory.getProxy<br>
-&gt; InvokerInvocationHandler.invoke<br>
-&gt; MockClusterInvoker.invoke 如果配置中有 fail 开头，则在远程调用失败后调用 doMockInvoke，大概逻辑是实例化一个 XxxServiceMock 服务然后调用</p>
<h3 id="优雅停机"><a class="header-anchor" href="#优雅停机">¶</a>优雅停机</h3>
<p><a href="https://www.jianshu.com/p/6e4d1ecb0815" target="_blank" rel="noopener">https://www.jianshu.com/p/6e4d1ecb0815</a></p>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<h3 id="说一下你们怎么用-dubbo-的-考对-dubbo-的应用能力"><a class="header-anchor" href="#说一下你们怎么用-dubbo-的-考对-dubbo-的应用能力">¶</a>说一下你们怎么用 Dubbo 的（考对 Dubbo 的应用能力）</h3>
<h3 id="说一下-dubbo-的工作原理"><a class="header-anchor" href="#说一下-dubbo-的工作原理">¶</a>说一下 Dubbo 的工作原理</h3>
<p><img src="http://47.88.24.11/imgs/Dubbo/Dubbo%E6%9E%B6%E6%9E%84.png" alt="Dubbo架构" title="Dubbo架构"><br>
描述 Registry、Consumer、Provider 之间的关系。</p>
<h3 id="dubbo-负载均衡策略和集群容错策略都有哪些"><a class="header-anchor" href="#dubbo-负载均衡策略和集群容错策略都有哪些">¶</a>Dubbo 负载均衡策略和集群容错策略都有哪些</h3>
<p>负载均衡策略和集群容错策略见上面的《集群》小节。</p>
<h3 id="dubbo-的动态代理策略"><a class="header-anchor" href="#dubbo-的动态代理策略">¶</a>Dubbo 的动态代理策略</h3>
<p>javassist，类似 CGLIB，通过继承目标类以生成代理类。</p>
<h3 id="说一下服务注册-导出-过程"><a class="header-anchor" href="#说一下服务注册-导出-过程">¶</a>说一下服务注册（导出）过程</h3>
<p>分本地暴露和远程暴露两种</p>
<h3 id="说一下服务消费-引入-过程"><a class="header-anchor" href="#说一下服务消费-引入-过程">¶</a>说一下服务消费（引入）过程</h3>
<h3 id="服务的运行过程中-如果-zookeeper-挂掉了-这时还能正常请求吗？"><a class="header-anchor" href="#服务的运行过程中-如果-zookeeper-挂掉了-这时还能正常请求吗？">¶</a>服务的运行过程中，如果 ZooKeeper 挂掉了，这时还能正常请求吗？</h3>
<h3 id="说一下-dubbo-协议"><a class="header-anchor" href="#说一下-dubbo-协议">¶</a>说一下 Dubbo 协议</h3>
<h3 id="dubbo-有几种容错机制"><a class="header-anchor" href="#dubbo-有几种容错机制">¶</a>Dubbo 有几种容错机制</h3>
<h3 id="dubbo-有几种服务降级机制"><a class="header-anchor" href="#dubbo-有几种服务降级机制">¶</a>dubbo 有几种服务降级机制</h3>
<h3 id="dubbo-有几种服务降级机制-v2"><a class="header-anchor" href="#dubbo-有几种服务降级机制-v2">¶</a>dubbo 有几种服务降级机制</h3>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">apache/incubator-dubbo</a></li>
<li><a href="http://dubbo.apache.org/en-us/docs/user/preface/background.html" target="_blank" rel="noopener">Dubbo 文档</a></li>
<li><a href="http://dubbo.apache.org/en-us/docs/user/demos/preflight-check.html" target="_blank" rel="noopener">Dubbo 实例 Demos</a><br>
<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html" target="_blank" rel="noopener">中文版</a></li>
<li><a href="https://blog.csdn.net/j3t9z7h/article/details/81437570" target="_blank" rel="noopener">设计 RPC 接口时，你有考虑过这些吗？</a></li>
<li><a href="https://blog.csdn.net/wolfcode_cn/article/details/81907241" target="_blank" rel="noopener">解密 Dubbo:自己动手编写 RPC 框架</a></li>
</ol>
<h3 id="启动过程"><a class="header-anchor" href="#启动过程">¶</a>启动过程</h3>
<ol>
<li><a href="https://blog.csdn.net/j3T9Z7H/article/details/82836811" target="_blank" rel="noopener">研究优雅停机时的一点思考</a><br>
<code>kill -9</code>与<code>kill -15</code>的区别，SpringBoot 的停机机制。</li>
<li><a href="http://www.solves.com.cn/it/cxkf/bk/2019-10-14/6046.html" target="_blank" rel="noopener">一文聊透 Dubbo 优雅停机</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1543749" target="_blank" rel="noopener">一文聊透 Dubbo 优雅上线</a></li>
<li><a href="https://segmentfault.com/a/1190000015276158" target="_blank" rel="noopener">Spring-boot+Dubbo 应用启停源码分析</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html" target="_blank" rel="noopener">服务导出</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html" target="_blank" rel="noopener">服务引入</a></li>
</ol>
<h3 id="spi"><a class="header-anchor" href="#spi">¶</a>SPI</h3>
<ol>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">Dubbo SPI</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html" target="_blank" rel="noopener">自适应拓展机制</a></li>
</ol>
<h3 id="协议"><a class="header-anchor" href="#协议">¶</a>协议</h3>
<ol>
<li><a href="https://blog.csdn.net/X5fnncxzq4/article/details/80729942" target="_blank" rel="noopener">【RPC 专栏】深入理解 RPC 之协议篇</a></li>
<li><a href="https://blog.csdn.net/weixin_43970890/article/details/103348778" target="_blank" rel="noopener">Dubbo 在跨语言和协议穿透性方向的探索：支持 HTTP/2 gRPC</a></li>
<li><a href="https://blog.csdn.net/u013815546/article/details/96364814" target="_blank" rel="noopener">一文详细解读 Dubbo 中的 http 协议</a></li>
<li><a href="http://blog.itpub.net/31556476/viewspace-2375225/" target="_blank" rel="noopener">聊聊 TCP 长连接和心跳那些事</a></li>
<li><a href="http://blog.itpub.net/31556476/viewspace-2305549/" target="_blank" rel="noopener">Dubbo 中的 URL 统一模型</a></li>
<li><a href="https://www.cnkirito.moe/network-interfaces/" target="_blank" rel="noopener">研究网卡地址注册时的一点思考</a></li>
<li><a href="https://tools.ietf.org/html/rfc5234" target="_blank" rel="noopener">RFC 5234 - Augmented BNF for Syntax Specifications: ABNF</a></li>
<li><a href="https://juejin.im/post/5cac08a26fb9a068996d5fb2" target="_blank" rel="noopener">服务端经典的 C10k 问题(译)</a></li>
</ol>
<h3 id="心跳机制"><a class="header-anchor" href="#心跳机制">¶</a>心跳机制</h3>
<ol>
<li><a href="https://blog.csdn.net/weixin_34175509/article/details/87997148" target="_blank" rel="noopener">一种心跳，两种设计</a></li>
<li><a href="http://blog.itpub.net/31556476/viewspace-2375225/" target="_blank" rel="noopener">聊聊 TCP 长连接和心跳那些事</a></li>
</ol>
<h3 id="序列化-v2"><a class="header-anchor" href="#序列化-v2">¶</a>序列化</h3>
<ol>
<li><a href="https://blog.csdn.net/X5fnncxzq4/article/details/80333364" target="_blank" rel="noopener">【RPC 专栏】深入理解 RPC 之序列化篇–总结篇</a></li>
<li><a href="https://blog.csdn.net/X5fnncxzq4/article/details/80276182" target="_blank" rel="noopener">【RPC 专栏】深入理解 RPC 之序列化篇 —— Kryo</a></li>
<li><a href="https://blog.csdn.net/loveqishan/article/details/89531587" target="_blank" rel="noopener">如何提高使用 Java 反射的效率？</a></li>
<li><a href="https://blog.csdn.net/qq_26525215/article/details/82943040" target="_blank" rel="noopener">Java 序列化框架性能比较</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/89826705.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/89826705.html" itemprop="url">Docker 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="docker-是什么"><a class="header-anchor" href="#docker-是什么">¶</a>Docker 是什么</h2>
<ul>
<li>Docker 是开源应用容器引擎，轻量级容器技术。</li>
<li>基于 Go 语言，并遵循 Apache2.0 协议开源。</li>
<li>Docker 可以让开发者打包他们的应用、依赖包及配置文件打包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 系统上，也可以实现虚拟化。</li>
<li>容器完全使用沙箱技术，相互之间不会有任何接口。</li>
<li>类似于虚拟机技术（vmware、vitural），但 docker 直接运行在操作系统（Linux）上，而不是运行在虚拟机中，速度快，性能开销极低。<br>
Docker 支持将软件编译成一个<strong>镜像</strong>，然后在镜像中对各种软件做好配置，将镜像发布出去（Docker Hub），其他使用者可以直接使用这个镜像。 运行中的这个镜像称为容器，容器启动是非常快速的。类似 windows 里面的 ghost 操 作系统，安装好后什么都有了。<br>
docker<strong>容器</strong>可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</li>
</ul>
<h3 id="常见应用场景"><a class="header-anchor" href="#常见应用场景">¶</a>常见应用场景</h3>
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h3 id="docker-特点"><a class="header-anchor" href="#docker-特点">¶</a>Docker 特点</h3>
<p>Docker 是一个基于容器的应用开发、部署和运行平台，它为开发者和系统管理员们提供了一种新式的应用部署方式，具有灵活（最复杂的应用都能容器化）、轻量（容器共享一个服务器内核）、可替换的（可以在容器运行过程中更新服务器）、可移植的（本地、云上皆可）、可伸缩的（可以轻松地进行复制）、可栈化（指的是可以将多个服务部署在一起，比如用 docker-compose）的特性。<br>
Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.<br>
Containerization is increasingly popular because containers are:</p>
<ul>
<li>Flexible: Even the most complex applications can be containerized.</li>
<li>Lightweight: Containers leverage and share the host kernel.</li>
<li>Interchangeable: You can deploy updates and upgrades on-the-fly.</li>
<li>Portable: You can build locally, deploy to the cloud, and run anywhere.</li>
<li>Scalable: You can increase and automatically distribute container replicas.</li>
<li>Stackable: You can stack services vertically and on-the-fly.</li>
</ul>
<h3 id="docker-优势"><a class="header-anchor" href="#docker-优势">¶</a>Docker 优势</h3>
<p>容器技术相比虚拟机，主要优势在于性能上，其性能优势可以说达到了一个量级的差距。根据 Boden Russell 在 OpenStack 上做的一次基准测试报告，一个 KVM 实例的平均内存消耗有 292MB，而一个 docker 实例的平均内存消耗在 49MB 左右。在 CPU overhead 和启动时间方面，docker 基本都比 KVM 有一个量级的优势。<br>
目前，一个 AWS 上的 micro 实例，每小时的按需使用成本大约在一美分多一些。如果用 docker 来提供实例，那么每小时的按需使用成本很可能会做到 0.1 美分。这一点对于云经济至关重要。正如经济学家 William Stanley Jevons 的理论所呈现的，随着商品的价格越便宜，人们使用它们的场景和频率会越来越多。</p>
<ol>
<li>container 是一种部署单元，用户可以自由决定部署的范围（dev、test、production），即组织容器的方式，换句话说，容器可以简化工作流和软件的开发、部署生命周期；</li>
<li>可以从传统的虚拟机环境平滑过渡到裸机生产环境内；<br>
保证了线上线下环境的一致性。我们在线下的开发环境使用 Docker 构建好 weaapp 的镜像后，可以直接在线上使用一个镜像，保证了线上线下环境的一致性，再也不会有在线下开发环境中运行正常，而部署到线上各种错误了。</li>
<li>实现了模块化，提高了复用性。<br>
我们可以将数据库和 Tomcat 运行在不同的容器中，从某种角度来说，这也降低了模块之间的耦合性，便于拓展。比如我们要把 MySQL 替换为 oracle，只需要再构建一个 oracle 镜像并启动与 Tomcat 连接即可，非常方便。对于我们构建的镜像，在其他 app 中直接拿来用就可以了，不必重复劳动。</li>
<li>提高整体效率；<br>
极大的简化了 webapp 的部署流程。在不使用 Docker 时，我们部署 app 时，要先搭建好 app 运行所需环境，这个过程做过的人都知道多么枯燥繁琐，一不小心还出错。而有了 Docker，我们只需要直接构建一个我们 webapp 的镜像然后将其运行即可，无论在多少台服务器中部署，都是如此。再比如，使用 Docker 之前要搭建一个 WordPress 对于新手来说是有些困难的，而有了 Docker，只需要从 DockerHub 上 pull 一个 WordPress 镜像并启动就可以了，非常非常方便。</li>
<li>实现了虚拟化，提高硬件利用率，有了 Docker，我们可以在一台服务器上运行很多 webapp，充分利用闲置资源。<br>
这时候，服务器的操作系统就类似于货轮，而一个个 Docker 容器就相当于货轮上的一个个集装箱。现在大热的云服务市场，不少就用了 Docker。举个例子来说，现在我们有一台操作系统为 Ubuntu14.04 的服务器，我们构建不同版本的 ubuntu 镜像并启动，并且为不同的用户分配不同的容器。这样，用一台服务器可以虚拟出 n 个运行着不同操作系统的虚拟服务器，而对于用户来说，这些是透明的––用户则认为自己拥有一台完整的服务器。据我推测，阿里云的服务器就是这么干的。这充分利用了闲置的硬件资源。</li>
<li>Fast
<ul>
<li>传统方式慢，传统情况下，应用服务器扩容缩容步骤繁多流程冗长,从服务器申请、初始化、应用部署、测试、加入退出集群、服务器下线。比如，业务遇到突发的流量高峰时,无法进行快速的扩容,当准备好的时候可能流量高峰已经过去了。</li>
<li>传统不稳定，代码上线发布历经多个环境,在某个环境中测试时修复了 bug,代码等无法及时同步各环境中,提升了服务上线的风险。</li>
<li>Runtime performance at near bare metal speeds (typically 97+ percent or bare metal – a few ticks shaven off for bean counters).</li>
<li>Management operations (boot, stop, start, reboot, etc.) in seconds or milliseconds.</li>
</ul>
</li>
<li>Agile
<ul>
<li>VM-like agility – it’s still “virtualization”.</li>
<li>Seamlessly move between virtual and bare metal environments permitting new development workflows which reduce costs (e.g. develop on VMs and move to bare metal in the “click of a button” for production).</li>
</ul>
</li>
<li>Flexible
<ul>
<li>Containerize a “system” (OS less the kernel).</li>
<li>Containerize “application(s)”.</li>
</ul>
</li>
<li>Lightweight
<ul>
<li>Just enough Operating System (JeOS); include only what you need reducing image and container bloat.</li>
<li>Minimal per container penalty which equates to greater density and hence greater returns on existing assets – imagine packing 100s or 1000s of containers on a single host node.</li>
</ul>
</li>
<li>Inexpensive
<ul>
<li>Open source – free – lower TCO.</li>
<li>Supported with out-of-the-box modern Linux kernels.</li>
</ul>
</li>
<li>Ecosystem
<ul>
<li>Growing in popularity – just checkout the google trends for docker or LXC.</li>
<li>Vibrant community and numerous 3rd party applications (1000s of prebuilt images on docker index and 100s of open source apps on github or other public sources).</li>
</ul>
</li>
<li>Cloudy
<ul>
<li>Various Cloud management frameworks provide support for creating and managing Linux Containers – including <strong>OpenStack</strong> my personal favorite.</li>
</ul>
</li>
</ol>
<h3 id="docker-劣势"><a class="header-anchor" href="#docker-劣势">¶</a>Docker 劣势</h3>
<p>既然容器技术有如此大的优势，为什么基于容器的云现在还没有成为主流？我认为主要还是安全性的问题。虚拟机可以利用来自硬件的信任机制来提升安全性，这些机制在 Intel Virtualization Technology Evolution 的演示中有详细的介绍。即使如此，虚拟机仍然被视为相对不安全，比如前一段时间 Xen（半虚拟化，在硬件层和 OS 层之间的虚拟层）爆出一个漏洞，导致 AWS 不得不大量升级自己的主机。</p>
<ol>
<li>Docker Hub（镜像管理中心）不稳定<br>
第一个就是很重要的 Docker Hub 的访问问题。我们知道国内访问一些海外的网站有时候会有稳定性的问题。Docker Hub 在我们的实践中就经常出现访问不了的问题。但这种访问的问题并不是持续的，而是时有时无。由于大量的成熟 Docker 映像（image）都需要从 Docker Hub 下载，很多脚本在执行到这一步时，结果很难预料。一种方案是修改缺省的 Docker Hub 地址，改为采用国内的一些镜像（mirror）。但是在没有官方认证的成熟稳定的镜像网站时，Docker 映像的更新不容易得到保证；另一种方案是自行搭建自己的 Docker Hub。但是一来这样就失去了强大的社区贡献的映像资源，二来要花费很多精力来保持更新和同步。容器技术带来的简单化，又因为映像管理而复杂化，得不偿失。</li>
<li>运维难度大<br>
第二个就是容器技术的资源管理和运维。因为容器技术本身更适于解决大规模应用场景，所以通常都是集群基础上的部署、运维，但是目前对这一系列任务的自动化处理尚无统一的或者标准的框架。如果要让 Docker 真正在实际环境中发挥最大的效能并且易于维护，就需要有很成熟稳定的资源编排（orchestration）、资源调度（scheduling）和部署（deployment）的支持，但是这方面暂时还没有很明显的最佳解决方案，所以大多数人都在摸索和搭建自己的解决方案。我们在微软开放技术内部也是在一些开源技术的基础之上，自行开发了容器在微软公有云 Azure 上的资源管理调度和部署运维的系统，传统上的开发运维和持续集成，持续部署的技术，比如 Chef，Puppet，Jenkins 等，都可以很容易的与容器技术一起工作。</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://github.com/docker-library/official-images" target="_blank" rel="noopener">docker-library / official-images</a></li>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li>
<li><a href="http://www.dockone.io/article/932" target="_blank" rel="noopener">十分钟带你理解 Kubernetes 核心概念</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b13b8cb6.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b13b8cb6.html" itemprop="url">Docker 与常用中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  98 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="zookeeper"><a class="header-anchor" href="#zookeeper">¶</a>ZooKeeper</h3>
<ol>
<li><a href="https://stackoverflow.com/questions/30940981/zookeeper-error-cannot-open-channel-to-x-at-election-address" target="_blank" rel="noopener">Zookeeper error: Cannot open channel to X at election address</a></li>
</ol>
<h3 id="elasticsearch"><a class="header-anchor" href="#elasticsearch">¶</a>Elasticsearch</h3>
<ol>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" target="_blank" rel="noopener">Install Elasticsearch with Docker</a></li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/52335325" target="_blank" rel="noopener">记一次 Docker 下安装 Logstash+Elasticsearch+Kibana 经历</a></li>
<li><a href="https://stackoverflow.com/questions/40341346/kibana-on-docker-cannot-connect-to-elasticsearch" target="_blank" rel="noopener">Kibana on Docker cannot connect to Elasticsearch</a></li>
<li><a href="https://www.cnblogs.com/aubin/p/8012840.html" target="_blank" rel="noopener">Elasticsearch 集群部署</a></li>
</ol>
<h3 id="docker-mysql"><a class="header-anchor" href="#docker-mysql">¶</a>Docker MySQL</h3>
<ol>
<li><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">Docker MySQL</a></li>
</ol>
<h3 id="docker-mysql-双机热备实现"><a class="header-anchor" href="#docker-mysql-双机热备实现">¶</a>Docker MySQL 双机热备实现</h3>
<ol>
<li><a href="https://github.com/Junnplus/blog/issues/1" target="_blank" rel="noopener">Mysql Master/Slave Replication With Docker</a></li>
<li><a href="http://blog.csdn.net/huaweitman/article/details/50853075" target="_blank" rel="noopener">Mysql 双机热备实现</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-docker.html" target="_blank" rel="noopener">2.5.6 Deploying MySQL on Linux with Docker</a></li>
<li><a href="https://blog.csdn.net/boling_cavalry/article/details/71055159" target="_blank" rel="noopener">让 docker 中的 mysql 启动时自动执行 sql</a></li>
<li><a href="https://www.2cto.com/database/201503/386265.html" target="_blank" rel="noopener">MySQL 主从复制资料汇总</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/5582e809.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/5582e809.html" itemprop="url">分布式 Session</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T21:20:12+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>不论一家企业做什么领域业务，登录基本都是绕不过去的功能——任何操作都必须在已经登录的前提下才能执行，我这里主要聚焦登录中分布式 Session 的设计，然后连带提一下其他方方面面。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/5582e809.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e3d5c2fc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/e3d5c2fc.html" itemprop="url">并发和线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/e3d5c2fc.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/9d02e43e.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/9d02e43e.html" itemprop="url">并发的定义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>异步编程富有魅力，但是错误的使用不仅不会带来益处，还会使得系统变得难以维护、Bug 遍地，接下来我希望总结一下遇到的异步任务场景，减少以后遇到类似问题阻塞在设计上的时间。</p>
<blockquote>
<p>曾经经历过因三方（传统行业）接口效率过低而导致服务不可用的情况，交流发现对方根本没有考虑在系统里加入缓存、消息队列等中间件，原因竟然是希望保证高一致性。<br>
实际上大部分场景中，查询操作并没有保证一致性的意义，而写操作就算不能马上被看到结果也不会对体验造成太大的影响——只要最终能成功即可，这是符合<code>BASE</code>设计原则的。这个问题后续经排查发现原因是对方因为系统设计有问题、导致频繁大规模的接口超时，重启了后问题缓解，对方就不再追究了，非常无奈。没有不能解决的技术难题，只是有时候沟通、惰性等会阻碍问题的定位。<br>
并发的话题真是非常的多，从最底层的硬件到高级语言 Java 中的 JUC，从最繁琐的业务系统（现在一般是微服务架构）到比较新的人工智能（如分布式机器学习），几乎无所不包，一直想爬出坑来，但是总觉得差点意思，在此我也仅仅能根据一些现成的资料总结出一些结论。</p>
</blockquote>
<p>[x] 异步和非阻塞<br>
[x] 并发和并行<br>
[x] 并发模式 STM 介绍<br>
[x] 并发模式 Actor 介绍</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/9d02e43e.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/54dfb258.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/54dfb258.html" itemprop="url">异地多活</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  396 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="两地三中心"><a class="header-anchor" href="#两地三中心">¶</a>两地三中心</h2>
<h3 id="为什么要建设多个-idc-数据中心"><a class="header-anchor" href="#为什么要建设多个-idc-数据中心">¶</a>为什么要建设多个 IDC（数据中心）</h3>
<p>灾备。</p>
<h3 id="为什么是两地三中心-同城-跨城"><a class="header-anchor" href="#为什么是两地三中心-同城-跨城">¶</a>为什么是两地三中心（同城+跨城）</h3>
<p>最大可能性地避免天灾人祸。<br>
但距离过远、数据传输速度慢，同时会带来<strong>数据一致性</strong>问题。</p>
<blockquote>
<p>这体现了 CAP 原理：一致性（C）与高可用（A）不可兼得。</p>
</blockquote>
<h3 id="部署方式"><a class="header-anchor" href="#部署方式">¶</a>部署方式</h3>
<p>全量灾备例子：新浪的弹性伸缩服务（back up、单元化）<br>
部分灾备例子：支付宝早期架构</p>
<h3 id="研发"><a class="header-anchor" href="#研发">¶</a>研发</h3>
<p>业务分级</p>
<ol>
<li>SLA、SLO、SLI</li>
<li>为什么要做业务分级<br>
便于做灾备。</li>
</ol>
<p>SRE（现已归入 devops 体系）</p>
<ol>
<li>监控体系<br>
IDC<br>
网络<br>
基础服务<br>
应用服务<br>
流量<br>
安全<br>
用户（agent、听云、白山云）</li>
<li>灾备</li>
<li>fire-help<br>
发现（完备的监控系统、混沌工程）、恢复（回滚）、解决、复盘</li>
</ol>
<p>数据<br>
实时性（有些业务一定要实时，有些不需要）</p>
<h2 id="怎么做"><a class="header-anchor" href="#怎么做">¶</a>怎么做</h2>
<ol>
<li>调研方案</li>
<li>可行性分析</li>
<li>形成多种方案
<ul>
<li>进行技术选型</li>
<li>成本分析（人力、金钱）</li>
<li>风险分析</li>
<li>形成一套方案</li>
</ul>
</li>
<li>决策</li>
</ol>
<h2 id="成本预算"><a class="header-anchor" href="#成本预算">¶</a>成本预算</h2>
<h2 id="确定资源"><a class="header-anchor" href="#确定资源">¶</a>确定资源</h2>
<ol>
<li>金钱待遇</li>
<li>业务</li>
<li>职级（向谁汇报）</li>
</ol>
<h2 id="立项"><a class="header-anchor" href="#立项">¶</a>立项</h2>
<ol>
<li>计算规划</li>
<li>分配资源</li>
<li>时间节点（中期汇报、日报）</li>
<li>风险点</li>
</ol>
<h2 id="启动"><a class="header-anchor" href="#启动">¶</a>启动</h2>
<ol>
<li>安排任务</li>
<li>通过按计划完成任务来提升自我的影响力</li>
</ol>
<h2 id="验收"><a class="header-anchor" href="#验收">¶</a>验收</h2>
<ol>
<li>干系方的验收<br>
包括让 QA、产品经理验收。</li>
<li>非干系方的验收<br>
比如让媒体报道，提升我们公司的影响力。</li>
<li>形成闭环<br>
review 计划，看是否达到了预期。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/226416.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/226416.html" itemprop="url">使用 jq 解析 json 数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T10:58:55+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>分析 Json 格式接口参数或返回值。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/226416.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1c3259ad.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1c3259ad.html" itemprop="url">ES 原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T09:03:54+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  57 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="为什么用-elasticsearch"><a class="header-anchor" href="#为什么用-elasticsearch">¶</a>为什么用 ElasticSearch</h2>
<p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。大致上，它有以下重要特征：</p>
<ul>
<li>面向文档</li>
<li>Lucene 索引</li>
<li>分布式</li>
</ul>
<h2 id="搭建调试环境"><a class="header-anchor" href="#搭建调试环境">¶</a>搭建调试环境</h2>
<p>Idea - File - open，打开 <code>build.gradle</code> 文件<br>
选择 gradlew，gradle wrapper<br>
需要设置 JAVA_HOME 环境变量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalBuildInfoPlugin.java</span><br><span class="line"></span><br><span class="line">// String compilerJavaHome = System.getenv(&quot;JAVA_HOME&quot;);</span><br><span class="line">String compilerJavaHome = &quot;/Users/huanggaochi/Downloads/jdk-12.0.2.jdk/Contents/Home&quot;;</span><br></pre></td></tr></table></figure>
<p>如果需要直接在命令行编译，可以运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew idea</span><br></pre></td></tr></table></figure>
<p>需要设置<code>JAVA_HOME</code>环境变量，或者直接在项目根目录下的 gradlew 文件里加上一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/Users/huanggaochi/Downloads/jdk-12.0.2.jdk/Contents/Home</span><br></pre></td></tr></table></figure>
<h2 id="索引-映射和文档概念"><a class="header-anchor" href="#索引-映射和文档概念">¶</a>索引、映射和文档概念</h2>
<p>Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns<br>
Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields</p>
<blockquote>
<p>将 Type 类比为 Table 并不恰当，因为 ES 中一个索引下的多个类型共用相同的空间。</p>
</blockquote>
<h3 id="索引-类型和映射-index-type-mapping"><a class="header-anchor" href="#索引-类型和映射-index-type-mapping">¶</a>索引、类型和映射 - Index、Type、Mapping</h3>
<p>一个<strong>索引(index)<strong>就像是传统关系数据库中的数据库，它是相关文档存储的地方，实际上是组织数据的逻辑</strong>命名空间</strong>。<br>
在一个索引中，可以定义一种或多种<strong>类型</strong>。</p>
<ul>
<li>作为名词，一个 索引 类似于传统关系数据库中的一个 数据库，是一个存储关系型文档的地方；</li>
<li>作为动词，索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到，文档已存在时会被覆盖掉。</li>
</ul>
<p>一个<strong>类型</strong>是索引的一个逻辑上的分类，代表一类相似的文档，类型由 <strong>名称</strong>（比如 user 或 blogpost）和 <strong>映射</strong> 组成。但是在 ES 6.0.0 以后，这个概念会被废弃。<br>
类型可以很好的抽象划分相似但不相同的数据，但由于 Lucene 的处理方式，类型的使用有些限制。Lucene 没有文档类型的概念，每个文档的类型名被存储在一个叫 _type 的元数据字段上。 当我们要检索某个类型的文档时, Elasticsearch 通过在 _type 字段上使用过滤器限制只返回这个类型的文档。<br>
每个 Lucene 索引中的所有字段都包含一个单一的、扁平的模式。一个特定字段可以映射成 string 类型也可以是 number 类型，但是不能两者兼具（比如两个类型都有一个 name 字段，但是他们映射到不同的数据类型）。</p>
<p><strong>映射</strong>就像数据库中的 schema ，描述了数据在每个字段内如何存储，包括文档可能具有的字段或 属性 、 每个字段的数据类型—比如 string, integer 或 date —以及 Lucene 是如何索引和存储这些字段的。<br>
Lucene 也没有映射的概念，映射是 Elasticsearch 将复杂 JSON 文档 映射 成 Lucene 需要的扁平化数据的方式。</p>
<ul>
<li>比如下面的索引名叫 data，其中定义了 people 和 transactions 类型：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;data&quot;: &#123;</span><br><span class="line">      &quot;mappings&quot;: &#123;</span><br><span class="line">         &quot;people&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">               &quot;name&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;address&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;transactions&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">               &quot;timestamp&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">                  &quot;format&quot;: &quot;strict_date_optional_time&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;message&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被转换为类似下面的映射保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;data&quot;: &#123;</span><br><span class="line">      &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;_type&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;address&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;timestamp&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;long&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;message&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以虽然创建一个文档后其类型就确定了，但是实际上这个<strong>文档所占用的空间是该索引内所有字段的总和</strong>。<br>
所以有一条建议：一个索引中的类型应当都是相似的，他们有类似的字段，比如 man 和 woman 共享 name 属性；如果两个类型的字段集互不相同，创建一个 类型的文档后将浪费很多空间，而是应该将他们分到不同的索引中。</p>
<h3 id="动态映射机制"><a class="header-anchor" href="#动态映射机制">¶</a>动态映射机制</h3>
<p>在索引一个新的文档时，es 会自动为每个字段推断类型，这个过程称为<strong>动态映射</strong>。这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p>
<h3 id="分析和搜索-analysis-search"><a class="header-anchor" href="#分析和搜索-analysis-search">¶</a>分析和搜索 - Analysis、Search</h3>
<p>分析表示全文是如何处理使之可以被搜索的。<br>
Elasticsearch 除了支持在各种字段上的结构化查询，还支持排序、全文检索并分析相关性。</p>
<h3 id="query-dsl"><a class="header-anchor" href="#query-dsl">¶</a>Query DSL</h3>
<p>特定的查询语言，查询主要分为<strong>评分查询（query）<strong>和</strong>不评分查询（filter）</strong>，前者在查询完毕后还需要为文档进行评分，主要用于全文搜索，而后者只需要决定是否采用结果，所以速度会快一些。<br>
es 提供的查询 DSL 将语句分为<strong>叶子语句（如 match）<strong>和</strong>复合语句（如 bool）</strong>，通过组合可以表达复杂的语义。</p>
<h3 id="倒排索引"><a class="header-anchor" href="#倒排索引">¶</a>倒排索引</h3>
<p>关系型数据库通过增加一个 索引，比如一个 B 树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 <strong>倒排索引</strong> 的结构来达到相同的目的。</p>
<h3 id="根对象"><a class="header-anchor" href="#根对象">¶</a>根对象</h3>
<p>映射的最高一层被称为 根对象 ，它可能包含下面几项：</p>
<ul>
<li>一个 properties 节点，列出了文档中可能包含的每个字段的映射</li>
<li>各种元数据字段，它们都以一个下划线开头，例如 _type 、 _id 和 _source</li>
<li>设置项，控制如何动态处理新的字段，例如 analyzer 、 dynamic_date_formats 和 dynamic_templates</li>
<li>其他设置，可以同时应用在根对象和其他 object 类型的字段上，例如 enabled 、 dynamic 和 include_in_all</li>
</ul>
<h3 id="文档和字段-document-field"><a class="header-anchor" href="#文档和字段-document-field">¶</a>文档和字段 - Document、Field</h3>
<p>一个文档是一个可被索引的基础信息单元，文档以 JSON 格式来表示。<br>
在一个 index/type 里面，可以存储任意多的文档，每个文档都有唯一 id。<br>
每个文档包含多个字段(fields)，即 json 数据里的字段。</p>
<h3 id="文档元数据"><a class="header-anchor" href="#文档元数据">¶</a>文档元数据</h3>
<p>一个文档不仅仅包含它的数据，也包含 元数据 —— 有关 文档的信息。 三个必须的元数据元素如下：</p>
<ul>
<li>_index<br>
一个 索引 应该是因共同的特性被分组到一起的文档集合。<br>
索引名字必须小写，不能以下划线开头，不能包含逗号。</li>
<li>_type<br>
Lucene 没有文档类型的概念，而是使用一个元数据字段_type 文档表示的对象类别，数据可能在索引中只是松散的组合在一起，但是通常明确定义一些数据中的子分区是很有用的，不同 types 的文档可能有不同的字段，但最好能够非常相似。<br>
一个 _type 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号， 并且长度限制为 256 个字符。<br>
当我们要检索某个类型的文档时, Elasticsearch 通过在 _type 字段上使用过滤器限制只返回这个类型的文档。</li>
<li>_id<br>
文档唯一标识，和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。<br>
id 也可以由 Elasticsearch 自动生成。</li>
<li>_version<br>
在 Elasticsearch 中每个文档都有一个版本号。当每次对文档进行修改时（包括删除）， _version 的值会递增。这个字段用来确保这些改变在跨多节点时以正确的顺序执行。<br>
版本号——不管是内部的还是引用外部的——都必须是在(0, 9.2E+18)范围内的一个 long 类型的正数。</li>
<li>_source<br>
即索引数据时发送给 Elasticsearch 的原始 JSON 文档。</li>
<li>其他元数据</li>
</ul>
<h3 id="文档属性"><a class="header-anchor" href="#文档属性">¶</a>文档属性</h3>
<p>文档里有几个最重要的设置：</p>
<ul>
<li>
<p>type<br>
字段的数据类型，例如 string 或 date</p>
</li>
<li>
<p>index<br>
字段是否应当被当成全文来搜索（ analyzed ），或被当成一个准确的值（ not_analyzed ），还是完全不可被搜索（ no ）</p>
</li>
<li>
<p>analyzer<br>
确定在索引和搜索时全文字段使用的 analyzer</p>
</li>
<li>
<p>_source<br>
存储代表文档体的 JSON 字符串，和所有被存储的字段一样， _source 字段在被写入磁盘之前先会被压缩。这个字段有以下作用：</p>
<ol>
<li>搜索结果包括了整个可用的文档——不需要额外的从另一个的数据仓库来取文档。</li>
<li>如果没有 _source 字段，部分 update 请求不会生效。</li>
<li>当你的映射改变时，你需要重新索引你的数据，有了_source 字段你可以直接从 Elasticsearch 这样做，而不必从另一个（通常是速度更慢的）数据仓库取回你的所有文档。</li>
<li>当你不需要看到整个文档时，单个字段可以从 _source 字段提取和通过 get 或者 search 请求返回。</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">    &quot;_source&quot;: [ &quot;title&quot;, &quot;created&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调试查询语句更加简单，因为你可以直接看到每个文档包括什么，而不是从一列 id 猜测它们的内容。<br>
也可以调用下面的映射来禁用_source 字段：</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;my_type&quot;: &#123;</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象和文档"><a class="header-anchor" href="#对象和文档">¶</a>对象和文档</h3>
<p>通常情况下，我们使用的术语 对象 和 文档 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。<br>
文档指最顶层或者根对象，这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID 及一些必须的文档元数据。</p>
<h3 id="精确值和全文"><a class="header-anchor" href="#精确值和全文">¶</a>精确值和全文</h3>
<p><strong>精确值</strong>是结构化的，如日期或者用户 ID，字符串也可以表示精确值，例如用户名或邮箱地址，对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。<br>
查询精确值很容易，结果是二进制的：要么匹配查询，要么不匹配。<br>
<strong>全文</strong>是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。<br>
查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？es 解决这个需求的办法是为文档建立倒排索引。</p>
<h2 id="分布式概念-distribution"><a class="header-anchor" href="#分布式概念-distribution">¶</a>分布式概念（Distribution）</h2>
<h3 id="集群-cluster"><a class="header-anchor" href="#集群-cluster">¶</a>集群 - Cluster</h3>
<p>一个集群就是由一个或多个节点组织在一起，它们共同持有全部的数据。<br>
一个集群有一个唯一的名字标识 <code>cluster.name</code> ，其节点只能通过指定某个集群的名字，来加入这个集群。</p>
<h3 id="节点-node"><a class="header-anchor" href="#节点-node">¶</a>节点 - Node</h3>
<p>一个节点是集群中的一个服务器，即一个 Elasticsearch 实例。<br>
作为集群的一部分，它存储数据，参与集群的索引和搜索功能。</p>
<h3 id="主节点-master"><a class="header-anchor" href="#主节点-master">¶</a>主节点 - Master</h3>
<p>当一个节点被选举成为主节点时，它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。<br>
主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量增加它也不会成为瓶颈。</p>
<h3 id="分片-shard"><a class="header-anchor" href="#分片-shard">¶</a>分片 - Shard</h3>
<p>一个 分片 是一个底层的 工作单元 ，它仅保存了 <strong>全部数据中的一部分</strong>，是一个 Lucene 的实例，所以它本身就是一个完整的搜索引擎。<br>
一个索引可以被划分成多个分片，创建索引时可指定分片数量，默认是 5。<br>
每个分片是一个 Lucene 实例，它本身也是一个功能完善并且独立的“索引”，这个“索引” 可以被放置到集群中的任何节点上。<br>
分片是 ES 中集群管理的最小单位，在此基础上，ES 允许：</p>
<ul>
<li>允许你水平分割/扩展你的内容容量</li>
<li>允许你在分片（位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量</li>
</ul>
<p>分片类似 DB 里的分库分表，是为了解决数据量很大查询效率低下的问题，同时突破单节点磁盘限制。<br>
集群的配置非常灵活，比如对于一个需要占据 100G 磁盘空间的索引，5 个分片每个分片大小 20G，假设单节点磁盘上限 100G，可以有以下几种方案：</p>
<ol>
<li>单节点一个分片：单次只能在 100G 数据里查询一条数据，磁盘占用率 100%。</li>
<li>单节点 5 个分片：每个分片存储 20G 数据，可以 5 个任务并行查询，磁盘占用率 100%，索引大小上限 100G，无法再插入新数据。</li>
<li>集群（2 个节点）5 个分片：一个节点 3 片，另一个节点 2 片，可以并行查找，同时单节点磁盘占用量 &lt;60%，索引最大存储上限为 200G。</li>
<li>集群（5 个节点）5 个分片：每个节点包含一个分片，单节点磁盘占用量 20%，索引最大存储上限为 500G。</li>
</ol>
<p>至于是否有最佳实践，我认为还是得根据实际场景来说话，比如就简单搭建一个开发环境来说，单节点（单分片或多分片）足够，当然，因为没有荣誉，硬件故障时会有数据丢失风险。</p>
<h3 id="主分片和副分片"><a class="header-anchor" href="#主分片和副分片">¶</a>主分片和副分片</h3>
<p>一个分片可以是 主分片或者 副本分片。<br>
索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量，在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。<br>
一个副本分片只是一个主分片的拷贝。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<h3 id="索引-index"><a class="header-anchor" href="#索引-index">¶</a>索引（Index）</h3>
<p>索引实际上是指向一个或者多个物理 分片 的 <strong>逻辑命名空间</strong>。<br>
所以说一个节点包含多个分片没有问题，但是一个节点包含多个索引是不对的，因为索引包含的分片可以存在于多个节点内，且可以在后期添加。</p>
<h3 id="复制-replica"><a class="header-anchor" href="#复制-replica">¶</a>复制（Replica）</h3>
<p>Elasticsearch 允许创建分片的一份或多份拷贝（默认复制 1 份），这些拷贝叫做复制分片。<br>
在分片/节点失败的情况下，复制提供了高可用性。<br>
因为搜索可以在所有的复制上并行运行，复制可以扩展你的搜索量/吞吐量<br>
复制分片不与相同的主分片置于同一节点上，否则失去备份的意义。</p>
<p>总而言之：</p>
<ol>
<li>每个索引可以被分成多个分片。</li>
<li>一个索引也可以被复制 0 次（即没有复制） 或多次。</li>
<li>一旦复制了，每个索引就有了主分片（作为复制源的分片）和复制分片（主分片的拷贝）。</li>
<li>分片和复制的数量可以在索引创建的时候指定。在索引创建之后，可以在任何时候动态地改变复制的数量，但是不能再改变分片的数量。</li>
</ol>
<p>至于 ES 集群中如何分配分片与备份，都是 ES 内部维护管理的，对用户完全透明。</p>
<h2 id="es-整体架构"><a class="header-anchor" href="#es-整体架构">¶</a>ES 整体架构</h2>
<p>TODO</p>
<h2 id="es-节点启动和关闭"><a class="header-anchor" href="#es-节点启动和关闭">¶</a>ES 节点启动和关闭</h2>
<h3 id="检测外部环境"><a class="header-anchor" href="#检测外部环境">¶</a>检测外部环境</h3>
<p>Bootstrap#setup：初始化 node 时重写 validateNodeBeforeAcceptingRequests，在其中包含了检查逻辑<br>
-&gt; BootstrapChecks.check</p>
<h3 id="启动各模块"><a class="header-anchor" href="#启动各模块">¶</a>启动各模块</h3>
<p>Bootstrap#start<br>
-&gt; Node#start：调各子模块的 start 来初始化</p>
<h3 id="keepalive"><a class="header-anchor" href="#keepalive">¶</a>keepalive</h3>
<p>唯一的用户线程，作用是保持进程运行。</p>
<p>Bootstrap#keepAliveThread</p>
<h3 id="节点关闭"><a class="header-anchor" href="#节点关闭">¶</a>节点关闭</h3>
<p>Bootstrap#stop<br>
-&gt; IOUtils#close：关闭 node，注意 Node 实现了 Closable<br>
-&gt; Node#close</p>
<h2 id="选主"><a class="header-anchor" href="#选主">¶</a>选主</h2>
<p>ES 默认服务发现实现是内置的<code>Zen Discovery</code></p>
<h3 id="选举相关概念"><a class="header-anchor" href="#选举相关概念">¶</a>选举相关概念</h3>
<ul>
<li>选举（Election）</li>
<li>主从（主：Leader、Coordinator、Master，从：Follower、Slave）</li>
<li>分布式哈希表（DHT）</li>
<li>多数派（法定人数、Quorum）</li>
<li>分区和脑裂：集群中出现双主或多主。</li>
<li>Bully 算法</li>
<li>Paxos 算法</li>
</ul>
<h3 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h3>
<ul>
<li>node.master：决定当前节点是否具备 Master 资格</li>
<li>discovery.zen.minimum_master_nodes</li>
<li>discovery.zen.ignore_non_master_pings</li>
</ul>
<h3 id="本地节点实例的创建"><a class="header-anchor" href="#本地节点实例的创建">¶</a>本地节点实例的创建</h3>
<p>管理节点配置<br>
Node#localNodeFactory</p>
<h3 id="选主流程"><a class="header-anchor" href="#选主流程">¶</a>选主流程</h3>
<p>ZenDiscovery 的选主流程如下：</p>
<ol>
<li>每个节点计算最小的已知节点 ID，该节点为临时 Master，向该节点发送领导投票；</li>
<li>如果一个节点收到足够多的票数，并且该节点也为自己投票，那么它将扮演领导者的角色，开始发布集群状态。</li>
</ol>
<h3 id="选举临时-master"><a class="header-anchor" href="#选举临时-master">¶</a>选举临时 Master</h3>
<p>Node#start<br>
-&gt; ZenDiscovery#startInitialJoin<br>
-&gt; ZenDiscovery#JoinThreadControl#startNewThreadIfNotRunning<br>
-&gt; threadPool.generic().execute：使用 generic 线程池执行选主流程<br>
-&gt; ZenDiscovery#innerJoinCluster：加入集群<br>
-&gt; ZenDiscovery#findMaster：查找当前集群的活跃 Master，或者从候选者中选择新的 Master<br>
-&gt; ZenDiscovery#pingAndWait：ping 一下所有节点（除了本节点），获取 pingResponses<br>
-&gt; 构建<strong>activeMasters</strong>列表，将每个节点所认为的当前 Master 节点加入 activeMasters 列表<br>
-&gt; 构建<strong>masterCandidates</strong>列表，从 pingResponses 列表中去掉不具备 Master 资格的节点<br>
-&gt; 如果 activeMasters 为空，则从 masterCandidates 中选举，否则从 activeMasters 中选择最合适的作为 Master</p>
<h3 id="从-mastercandidates-选主"><a class="header-anchor" href="#从-mastercandidates-选主">¶</a>从 masterCandidates 选主</h3>
<p>activeMasters 为空一般发生在集群刚启动或大规模重启的情况下。</p>
<p>ZenDiscovery#findMaster<br>
-&gt; ElectMasterService#hasEnoughCandidates：当前候选人数是否达到法定人数，若未达到则直接令选举失败<br>
-&gt; ElectMasterService#electMaster：当候选者达到法定人数后，从中选出一个作为 Master，选择前需要先用自定义比较函数进行排序<br>
-&gt; MasterCandidate.compare 自定义的排序逻辑</p>
<p>排序条件：</p>
<ol>
<li>版本号大的优先；</li>
<li>具备 Master 资格的优先；</li>
<li>节点 ID 小的优先。</li>
</ol>
<h3 id="从-activemasters-列表中选主"><a class="header-anchor" href="#从-activemasters-列表中选主">¶</a>从 activeMasters 列表中选主</h3>
<p>此时列表中存储着集群当前活跃的 Master，从这些已知的 Master 节点中选择一个作为选举结果。</p>
<p>ZenDiscovery#findMaster<br>
-&gt; ElectMasterService#tieBreakActiveMasters：使用自定义比较函数排序后取第一个<br>
-&gt; ElectMasterService#compareNodes</p>
<p>排序条件：</p>
<ol>
<li>具备 Master 资格的优先；</li>
<li>节点 ID 小的优先。</li>
</ol>
<h3 id="收集投票进行统计"><a class="header-anchor" href="#收集投票进行统计">¶</a>收集投票进行统计</h3>
<p>ZenDiscovery#handleJoinRequest<br>
-&gt; NodeJoinController#handleJoinRequest<br>
-&gt; NodeJoinController.ElectionContext#addIncomingJoin 将收到的连接存储到 NodeJoinController.ElectionContext#joinRequestAccumulator 中</p>
<p>NodeJoinController.ElectionContext#getPendingMasterJoinsCount：节点检查收到的投票是否足够时，就是检查加入它的连接数是否足够，其中会去掉没有 Master 资格节点的投票</p>
<h3 id="加入集群"><a class="header-anchor" href="#加入集群">¶</a>加入集群</h3>
<p>如果按以上逻辑选举出的临时 Master 是本节点：</p>
<ol>
<li>等待足够多的具备 Master 资格的节点加入本节点，直到投票达到法定人数，完成选举；</li>
<li>超时（默认 30 秒且可配置）后还没有满足数量的 join 请求，则选举失败，需要进行新一轮选举；</li>
<li>成功后发布新的 clusterState。</li>
</ol>
<p>ZenDiscovery#innerJoinCluster<br>
NodeJoinController#waitToBeElectedAsMaster</p>
<p>如果按以上逻辑选举出的临时 Master 并非本节点：</p>
<ol>
<li>不再接受其他节点的 join 请求；</li>
<li>向 Master 发送 join 请求，并等待回复。超时时间默认为 1 分钟（可配置），如果遇到异常，则默认重试 3 次（可配置）。</li>
<li>最终当选的 Master 会先发布集群状态，再确认客户的 join 请求，因此，joinElectedMaster 返回代表收到了 join 请求的确认，并且已经收到了集群状态。本步骤检查收到的集群状态中的 Master 节点如果为空，或者当选的 Master 不是之前选择的节点，则重新选举。</li>
</ol>
<p>ZenDiscovery#innerJoinCluster<br>
-&gt; ZenDiscovery#joinElectedMaster</p>
<h2 id="数据副本模型"><a class="header-anchor" href="#数据副本模型">¶</a>数据副本模型</h2>
<p>主从模型是分布式的经典模型之一，通过主节点的选举可以实现高可用。的那个然主从只能提高可用性，如果要性能上的可伸缩性，一般还会对数据进行 hash。<br>
主从模型实际上也是下面将要讨论的分布式文档存储、搜索的基础。</p>
<blockquote>
<p>HDFS、Cassandra 等使用的是对等模型。</p>
</blockquote>
<h3 id="pacifica-算法"><a class="header-anchor" href="#pacifica-算法">¶</a>PacificA 算法</h3>
<p>ES 的主副本模型的实现参考了微软的 PacificA 算法，下面是算法中涉及到的几个概念：</p>
<ul>
<li>Replica Group</li>
<li>Configuration</li>
<li>Configuration Version</li>
<li>Serial Number（SN）</li>
</ul>
<p>PacificA 算法运行在分布式系统之上，对系统有以下几项假设：</p>
<ul>
<li>节点可以失效，对消息延迟的上限不做假设；</li>
<li>消息可以丢失、乱序，但不能被篡改，即不存在<strong>拜占庭问题</strong>；</li>
</ul>
<blockquote>
<p>拜占庭问题</p>
</blockquote>
<ul>
<li>网络分区可以发生，系统时钟可以不同步，但<strong>漂移</strong>是有限度的。</li>
</ul>
<blockquote>
<p>漂移</p>
</blockquote>
<h3 id="存储管理-写入"><a class="header-anchor" href="#存储管理-写入">¶</a>存储管理 - 写入</h3>
<p>数据的读取和更新策略，及使用多副本方式保证数据的可靠性和可用性。<br>
数据写流程如下：<br>
<img src="http://47.88.24.11/imgs/ES/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png" alt="数据写入流程" title="数据写入流程"></p>
<ol>
<li>写请求进入主副本节点；</li>
<li>节点为该请求分配 SN，并使用该 SN 创建 UpdateRequest，然后将该 UpdateRequest 插入自己的 prepareList；</li>
<li>主副本将携带 SN 的 UpdateRequest 发往从副本节点，从节点收到后同样插入 prepareList；</li>
<li>主副本节点接收到所有从副本节点的 ACK 响应，确认该数据已经被写入到所有的从副本节点；</li>
<li>此时达到了可提交的状态，主副本将此 UpdateRequest 放入 committedList，committedList 向前移动；</li>
<li>主副本节点回复客户端更新成功。</li>
<li>主节点向从节点发送 commit 通知，告诉它们自己的 committed point 位置，从节点收到通知后根据指示来移动 committed point 到相同位置。</li>
</ol>
<p>数据存储流程中遵循不变式<code>Commit Invariant</code>：</p>
<ol>
<li>主节点 committedList 是任何一个从节点 prepareList 的前缀（子集）；</li>
<li>任一从节点上的 committedList 是主节点上 committedList 的前缀（子集）。</li>
</ol>
<h3 id="配置管理"><a class="header-anchor" href="#配置管理">¶</a>配置管理</h3>
<p>对配置信息进行管理，维护所有配置信息的一致性。<br>
配置同样遵循版本控制，由一个全局的配置管理器管理所有副本组的配置。<br>
当节点向管理器提出添加/移除副本的请求时，每次请求都需要附带当前配置版本号，只有这个版本号和管理器记录的版本号一致的情况下才能被执行，如果请求执行成功，则这个新配置会被赋予新的版本号。</p>
<h3 id="allocation-ids"><a class="header-anchor" href="#allocation-ids">¶</a>Allocation IDs</h3>
<p>TODO</p>
<h3 id="sequence-ids"><a class="header-anchor" href="#sequence-ids">¶</a>Sequence IDs</h3>
<p>TODO</p>
<h3 id="乐观并发控制"><a class="header-anchor" href="#乐观并发控制">¶</a>乐观并发控制</h3>
<p><img src="http://47.88.24.11/imgs/ES/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.png" alt="并发更新问题" title="并发更新问题"><br>
如上图所示 Web-2 不知道自己的对象拷贝已经过期，结果执行更新时会认为库存尚充足。<br>
像这样的变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。<br>
在数据库领域中，有两种策略通常被用来确保并发更新时变更不会丢失：</p>
<ul>
<li>悲观并发控制<br>
这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此<strong>阻塞访问资源以防止冲突</strong>。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</li>
<li>乐观并发控制<br>
Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，<strong>如果源数据在读写当中被修改，更新将会失败</strong>。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</li>
</ul>
<p>Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些<strong>复制请求被并行发送，并且到达目的地时也许 顺序是乱的</strong>。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p>
<ol>
<li>
<p>内部版本号<br>
当我们之前讨论 index ， GET 和 delete 请求时，我们指出每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。 Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。<br>
当我们在更新数据时，需要指定想要修改文档的_version，如果该版本不是当前版本号，我们的请求将会失败。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/1?version=1 </span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Starting to get the hang of this...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>外部版本号<br>
一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索，Elasticsearch 提供了一种机制来重用主数据库中已经存在的版本号字段。<br>
外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果是则请求成功，外部的版本号作为文档的新 _version 进行存储，这意味着每次请求必须先在主数据库中增加版本号的值，再将新版本的数据索引到 Elasticsearch 中。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first external blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Starting to get the hang of this...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="分布式文档存储"><a class="header-anchor" href="#分布式文档存储">¶</a>分布式文档存储</h2>
<h3 id="相关配置"><a class="header-anchor" href="#相关配置">¶</a>相关配置</h3>
<ul>
<li>wait_for_active_shards：开始执行写入操作前需要等待的活跃分片数量，主要用于维护写一致性。</li>
</ul>
<h3 id="文档路由"><a class="header-anchor" href="#文档路由">¶</a>文档路由</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>
<p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （<strong>主分片的数量</strong>）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。<br>
这就解释了为什么我们要在<strong>创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量</strong>：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。<br>
所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。</p>
<blockquote>
<p>主节点数固定不是一件好事，我们会在<strong>集群扩容</strong>里提到如何解决扩容问题。</p>
</blockquote>
<h3 id="分发机制"><a class="header-anchor" href="#分发机制">¶</a>分发机制</h3>
<p>可以将请求发送到 集群中的任何节点 ，包括主节点。<strong>每个节点都知道任意文档所处的位置</strong>，并且能够将我们的请求直接转发到存储我们所需文档的节点。无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。<br>
一个分片是一个 Lucene 实例，我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互的。Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时，Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。<br>
我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。但是为了更好地实现负载均衡，我们一般会轮询节点，每次接受请求的节点称为 <strong>（协调节点）</strong>，比如下面的 Node1。</p>
<h3 id="consistency"><a class="header-anchor" href="#consistency">¶</a>consistency</h3>
<p>为了保证一致性，在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 <em>规定数量(quorum)</em>（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写_操作(其中分片副本可以是主分片或者副本分片)。这是为了避免在发生网络分区故障（network partition）的时候进行_写_操作，进而导致数据不一致。</p>
<p>注意：下面的参数只对 ElasticSearch 5.0 以下的版本有效，在 ElasticSearch 5.0 之后貌似使用 wait_for_active_shards 代替了 consistency。所以之前的参数了解即可，实际可以参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-create-index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-create-index.html</a><br>
consistency 有三种取值：</p>
<ol>
<li>
<p>quorum（规定大多数，默认）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int( (primary + number_of_replicas) / 2 ) + 1</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>one（只要主分片 ok 就可以）</p>
</li>
<li>
<p>all（必须要主分片和所有副本分片的状态都没问题才允许执行写操作）</p>
</li>
</ol>
<h3 id="timeout"><a class="header-anchor" href="#timeout">¶</a>timeout</h3>
<p>如果没有足够的副本分片数，Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。可以设置 timeout 的值来修改等待时间。</p>
<h3 id="创建-索引-删除"><a class="header-anchor" href="#创建-索引-删除">¶</a>创建、索引、删除</h3>
<p>新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，所以需要：</p>
<ol>
<li>先<strong>根据 id 确定其所属的主分片位置</strong>；</li>
<li>主分片若执行成功，将请求并行转发到副本分片上；</li>
<li>Node3 上的主分片执行成功，向协调节点报告成功，协调节点再汇报给客户端；<br>
<img src="http://47.88.24.11/imgs/ES/%E6%96%B0%E5%A2%9E%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%A0%E9%99%A4.png" alt="新增、索引、删除" title="新增、索引、删除"></li>
</ol>
<h3 id="取回单个文档"><a class="header-anchor" href="#取回单个文档">¶</a>取回单个文档</h3>
<p>可以从主分片或者从其它任意副本分片检索文档：</p>
<ol>
<li>向协调节点发送请求，请求方式是轮询，比如上次从 2 获取到数据，则这次从 3 开始；</li>
<li>使用 id 确定文档所处主分片位置，如果存在多份则返回第一份即可；</li>
<li>协调节点将文档返回给客户端<br>
<img src="http://47.88.24.11/imgs/ES/%E5%8F%96%E5%9B%9E%E5%8D%95%E4%B8%AA%E6%96%87%E6%A1%A3.png" alt="取回单个文档" title="取回单个文档"></li>
</ol>
<h3 id="局部更新"><a class="header-anchor" href="#局部更新">¶</a>局部更新</h3>
<p>部分更新包括读取和写入两个过程：</p>
<ol>
<li>同样先向协调节点发送更新请求；</li>
<li>从 id 计算出文档所在的主分片位置；</li>
<li>从主分片检索文档，修改 _source 字段中的 JSON ，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 retry_on_conflict 次后放弃。</li>
<li>如果成功地更新文档，它将新版本的文档（而<strong>不是更新请求本身</strong>，因为如果以错误的顺序到达，可能导致文档损坏）并行转发到其他节点的副本分片，重新建立索引。</li>
<li>一旦所有副本分片都返回成功，向协调节点也返回成功，协调节点向客户端返回成功。<br>
<img src="http://47.88.24.11/imgs/ES/%E5%B1%80%E9%83%A8%E6%9B%B4%E6%96%B0.png" alt="局部更新" title="局部更新"></li>
</ol>
<h3 id="mget-批量读"><a class="header-anchor" href="#mget-批量读">¶</a>mget（批量读）</h3>
<p>mget 和 bulk API 的 模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。</p>
<ol>
<li>将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点；</li>
<li>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。<br>
<img src="http://47.88.24.11/imgs/ES/%E6%89%B9%E9%87%8F%E8%AF%BB.png" alt="批量读" title="批量读"></li>
</ol>
<h3 id="bulk-批量改"><a class="header-anchor" href="#bulk-批量改">¶</a>bulk（批量改）</h3>
<ol>
<li>协调节点接受请求，为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机；</li>
<li>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li>
</ol>
<blockquote>
<p>bulk API 格式中有换行符，这是因为请求文档可能属于不同的主分片，如果将这些文档放到一个 JSON 数组中，则需要解析它们并重新创建请求数组，这需要占用大量 RAM 空间来存储原数据的副本，JVM 将不得不花费时间进行垃圾回收。<br>
<img src="http://47.88.24.11/imgs/ES/%E6%89%B9%E9%87%8F%E6%94%B9.png" alt="批量改" title="批量改"></p>
</blockquote>
<h3 id="写入流程-协调节点"><a class="header-anchor" href="#写入流程-协调节点">¶</a>写入流程 - 协调节点</h3>
<p>TransportAction#execute<br>
-&gt; ActionRequest#validate：参数检查<br>
处理 pipeline 请求<br>
-&gt; TransportAction.RequestFilterChain#proceed<br>
-&gt; TransportBulkAction#doExecute<br>
-&gt; TransportBulkAction#createIndex：自动创建索引<br>
-&gt; TransportBulkAction#executeBulk：索引创建成功后，执行批量操作<br>
-&gt; TransportBulkAction.BulkOperation#doRun<br>
-&gt;</p>
<ol>
<li>对请求的预先处理</li>
<li>检测集群状态</li>
</ol>
<h3 id="写入流程-主分片节点"><a class="header-anchor" href="#写入流程-主分片节点">¶</a>写入流程 - 主分片节点</h3>
<h2 id="分布式搜索"><a class="header-anchor" href="#分布式搜索">¶</a>分布式搜索</h2>
<p>在分布式环境中执行的搜索是一个两阶段的过程，我们称之为 <strong>query then fetch</strong> 。</p>
<h3 id="查询阶段"><a class="header-anchor" href="#查询阶段">¶</a>查询阶段</h3>
<p><img src="http://47.88.24.11/imgs/ES/%E6%9F%A5%E8%AF%A2%E9%98%B6%E6%AE%B5.png" alt="查询阶段" title="查询阶段"></p>
<ul>
<li>
<p>客户端发送一个 search 请求到协调节点（也就是 Node 3），协调节点会创建一个大小为 <code>from+size</code> 的<strong>空优先队列</strong></p>
</li>
<li>
<p>协调节点将请求广播到索引中每一个分片拷贝（主分片或者副本分片）。</p>
</li>
<li>
<p>每个分片在本地执行搜索并构建一个匹配文档的 <strong>优先队列</strong>。<br>
一个 优先队列 仅仅是一个存有 top-n 匹配文档的有序列表。优先队列的大小取决于分页参数 from 和 size ，其值为 from + size，比如下面的搜索请求需要足够大的优先队列来放入 100 条文档。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;from&quot;: 90,</span><br><span class="line">    &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载，因此更多的副本（结合更多的硬件）能增加搜索吞吐率。<br>
每个分片返回各自优先队列中所有文档的 ID 和排序值（_score）给协调节点 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
</li>
</ul>
<h3 id="取回阶段"><a class="header-anchor" href="#取回阶段">¶</a>取回阶段</h3>
<p><img src="http://47.88.24.11/imgs/ES/%E5%8F%96%E5%9B%9E%E9%98%B6%E6%AE%B5.png" alt="取回阶段" title="取回阶段"></p>
<ul>
<li>协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。</li>
<li>每个分片加载并 丰富 文档（_source），如果有需要的话，接着返回文档给协调节点。</li>
<li>一旦所有的文档都被取回了，协调节点需要对 number_of_shards * (from + size) 大小的文档集合排序，协调节点返回结果给客户端。</li>
</ul>
<h3 id="深分页问题-deep-pagination"><a class="header-anchor" href="#深分页问题-deep-pagination">¶</a>深分页问题（Deep Pagination）</h3>
<p>先查后取的过程支持用 <code>from</code> 和 <code>size</code> 参数分页，但是这是 有限制的 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 <code>number_of_shards * (from + size)</code> 排序文档，来找到被包含在 size 里的文档。<br>
取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的 CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。<br>
实际上，深分页很少符合人的行为。当 2 到 3 页过去以后，人会停止翻页，并且改变搜索标准。会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者 web spider。<br>
如果你确实需要从你的集群取回大量的文档，你可以通过用 <code>scroll</code> 查询禁用排序使这个取回行为更有效率</p>
<h3 id="偏好"><a class="header-anchor" href="#偏好">¶</a>偏好</h3>
<p>偏好这个参数 <code>preference</code> 允许 用来控制由哪些分片或节点来处理搜索请求。 它接受像 <code>_primary, _primary_first, _local, _only_node:xyz, _prefer_node:xyz, 和 _shards:2,3</code> 这样的值，在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-request-preference.html" target="_blank" rel="noopener">search Preference</a>有说明。<br>
偏好字段可以用于解决<strong>Bouncing Results</strong>问题。</p>
<blockquote>
<p>Bouncing Results<br>
想象一下有两个文档有同样值的时间戳字段，搜索结果用 timestamp 字段来排序。 由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序， 而副本分片处理请求时又是另一种顺序。<br>
这就是所谓的 bouncing results 问题: 每次用户刷新页面，搜索结果表现是不同的顺序。 让同一个用户始终使用同一个分片，这样可以避免这种问题， 可以设置 preference 参数为一个特定的任意值比如用户会话 ID 来解决。</p>
</blockquote>
<h3 id="超时"><a class="header-anchor" href="#超时">¶</a>超时</h3>
<p>通常分片处理完它所有的数据后再把结果返回给协调节点，协调节点把收到的所有结果合并为最终结果。这意味着花费的时间是最慢分片的处理时间加结果合并的时间。如果有一个节点有问题，就会导致所有的响应缓慢。<br>
参数 <code>timeout</code> 告诉 分片允许处理数据的最大时间。如果没有足够的时间处理所有数据，这个分片的结果可以是部分的，甚至是空数据。<br>
搜索的返回结果会用属性 timed_out 标明分片是否返回的是部分结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;time_out&quot;: true // 表示搜索请求超时了</span><br></pre></td></tr></table></figure>
<p>很有可能查询会超过设定的超时时间，这种情况可能有两个原因：</p>
<ol>
<li>超时检查是基于每文档做的。 但是某些查询类型有大量的工作在文档评估之前需要完成。 这种 “setup” 阶段并不考虑超时设置，所以太长的建立时间会导致超过超时时间的整体延迟。</li>
<li>因为时间检查是基于每个文档的，一次长时间查询在单个文档上执行并且在下个文档被评估之前不会超时。 这也意味着差的脚本（比如带无限循环的脚本）将会永远执行下去。</li>
</ol>
<h3 id="路由"><a class="header-anchor" href="#路由">¶</a>路由</h3>
<p>路由能够在索引时提供来确保相关的文档，比如属于某个用户的文档被存储在某个分片上。 在搜索的时候，不用搜索索引的所有分片，而是通过指定几个 routing 值来限定只搜索几个相关的分片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?routing=user_1,user2</span><br></pre></td></tr></table></figure>
<h3 id="搜索类型"><a class="header-anchor" href="#搜索类型">¶</a>搜索类型</h3>
<p>缺省的搜索类型是 <code>query_then_fetch</code> 。 在某些情况下，你可能想明确设置 <code>search_type</code> 为 <code>dfs_query_then_fetch</code> 来改善相关性精确度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?search_type=dfs_query_then_fetch</span><br></pre></td></tr></table></figure>
<p>搜索类型 <code>dfs_query_then_fetch</code> 有预查询阶段，这个阶段可以从所有相关分片获取词频来计算全局词频。</p>
<h3 id="游标查询-scroll"><a class="header-anchor" href="#游标查询-scroll">¶</a>游标查询 Scroll</h3>
<p><code>scroll</code> 查询 可以用来对 Elasticsearch 有效地执行大批量的文档查询，而又不用付出深度分页那种代价。<br>
游标查询允许我们 先做查询初始化，然后再批量地拉取结果。 这有点儿像传统数据库中的 <code>cursor</code> 。<br>
游标查询会取某个时间点的快照数据。 查询初始化之后索引上的任何变化会被它忽略。 它通过保存旧的数据文件来实现这个特性，结果就像保留初始化时的索引 <code>视图</code> 一样。<br>
深度分页的代价根源是结果集全局排序，如果去掉全局排序的特性的话查询结果的成本就会很低。 游标查询用字段 <code>_doc</code> 来排序。 这个指令让 Elasticsearch 仅仅从还有结果的分片返回下一批结果。<br>
启用游标查询可以通过在查询的时候设置参数 scroll 的值为我们期望的游标查询的过期时间。 游标查询的过期时间会在每次做查询的时候刷新，所以这个时间只需要足够处理当前批的结果就可以了，而不是处理查询结果的所有文档的所需时间。 这个过期时间的参数很重要，因为保持这个游标查询窗口需要消耗资源，所以我们期望如果不再需要维护这种资源就该早点儿释放掉。 设置这个超时能够让 Elasticsearch 在稍后空闲的时候自动释放这部分资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m // 保持游标查询窗口一分钟。</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">    &quot;sort&quot; : [&quot;_doc&quot;], // 关键字 _doc 是最有效的排序顺序。</span><br><span class="line">    &quot;size&quot;:  1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个查询的返回结果包括一个字段 <code>_scroll_id</code>， 它是一个 base64 编码的长字符串。现在我们能传递字段 <code>_scroll_id</code> 到 <code>_search/scroll</code> 查询接口获取下一批结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scroll&quot;: &quot;1m&quot;, // 注意再次设置游标查询过期时间为一分钟。</span><br><span class="line">    &quot;scroll_id&quot; : &quot;cXVlcnlUaGVuRmV0Y2g7NTsxMDk5NDpkUmpiR2FjOFNhNnlCM1ZDMWpWYnRROzEwOTk1OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MTA5OTM6ZFJqYkdhYzhTYTZ5QjNWQzFqVmJ0UTsxMTE5MDpBVUtwN2lxc1FLZV8yRGVjWlI2QUVBOzEwOTk2OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MDs=&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个游标查询返回的下一批结果。 尽管我们指定字段 size 的值为 1000，我们有可能取到超过这个值数量的文档。 当查询的时候， 字段 size 作用于单个分片，所以每个批次实际返回的文档数量最大为 <code>size * number_of_primary_shards</code>。<br>
当没有更多结果返回的时候，我们就处理完所有匹配的文档了。</p>
<h2 id="索引原理"><a class="header-anchor" href="#索引原理">¶</a>索引原理</h2>
<p>基于 Lucene，ES 实现了分布式的索引管理。</p>
<h3 id="索引策略"><a class="header-anchor" href="#索引策略">¶</a>索引策略</h3>
<p>在 Elasticsearch 中， <strong>每个字段的所有数据 都是 默认被索引的</strong> 。 即每个字段都有为了快速检索设置的专用<strong>倒排索引</strong>。<br>
倒排索引由一些词项组成，每个词项包含了它所有曾出现过的文档的列表。<br>
Term  | Doc 1 | Doc 2 | Doc 3 |</p>
<hr>
<p>brown |   X   |       |  X    | …<br>
fox   |   X   |   X   |  X    | …<br>
quick |   X   |   X   |       | …<br>
the   |   X   |       |  X    | …</p>
<p>另外，这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许 Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，用于搜索时计算文档的相关性。</p>
<h3 id="不变性"><a class="header-anchor" href="#不变性">¶</a>不变性</h3>
<p>倒排索引被写入磁盘后是 不可改变 的:它永远不会修改。 不变性有重要的价值：</p>
<ul>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像 filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。</li>
</ul>
<p>当然，一个不变的索引也有不好的地方：</p>
<ul>
<li>由于不变性，你不能修改它，如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这对一个索引能包含的数据量和被更新频率造成很大限制。</li>
</ul>
<h3 id="段和提交点"><a class="header-anchor" href="#段和提交点">¶</a>段和提交点</h3>
<p><img src="http://47.88.24.11/imgs/ES/%E4%B8%80%E4%B8%AALucene%E7%B4%A2%E5%BC%95%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4%E7%82%B9%E5%92%8C%E4%B8%89%E4%B8%AA%E6%AE%B5.png" alt="一个Lucene索引包含一个提交点和三个段" title="一个Lucene索引包含一个提交点和三个段"></p>
<ul>
<li>每一个段本身都是一个倒排索引，索引在 Lucene 中表示所有段的集合。</li>
</ul>
<blockquote>
<p>一个 Lucene 索引在 Elasticsearch 中被称作分片，一个 Elasticsearch 索引是分片的集合，当 Elasticsearch 在索引中搜索的时候，会发送查询请求到每一个属于该索引的分片，然后合并每个分片的结果到一个全局的结果集中。</p>
</blockquote>
<ul>
<li>提交点是一个列出了所有已知段的文件，Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</li>
</ul>
<h3 id="动态更新索引"><a class="header-anchor" href="#动态更新索引">¶</a>动态更新索引</h3>
<ol>
<li>新文档首先被添加到内存索引缓存中；<br>
<img src="http://47.88.24.11/imgs/ES/%E6%96%B0%E6%96%87%E6%A1%A3%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%BC%93%E5%AD%98.png" alt="新文档被添加到缓存" title="新文档被添加到缓存"></li>
<li>提交是针对缓存进行的：
<ul>
<li>生成一个新的段（倒排索引）并被写入磁盘；</li>
<li>一个新的包含新段名字的<strong>提交点</strong>被写入磁盘，此时文档在缓存中、还未被刷新到磁盘，如下图所示；</li>
<li>磁盘同步（<code>fsync</code>），所有在文件系统缓存中等待的写入都被刷新到磁盘，以确保它们被写入物理文件。<br>
<img src="http://47.88.24.11/imgs/ES/%E7%BC%93%E5%86%B2%E5%8C%BA%E8%A2%AB%E5%86%99%E5%85%A5%E6%AE%B5%E4%BD%86%E6%9C%AA%E5%AE%8C%E6%88%90%E6%8F%90%E4%BA%A4.png" alt="缓冲区被写入段但未完成提交" title="缓冲区被写入段但未完成提交"></li>
</ul>
</li>
<li>新的段被开启，它包含的文档可以被搜索；</li>
<li>内存缓存被清空，等待接收新的文档。<br>
<img src="http://47.88.24.11/imgs/ES/%E6%8F%90%E4%BA%A4%E5%90%8E%E7%94%9F%E6%88%90%E6%96%B0%E6%AE%B5%E4%B8%94%E7%BC%93%E5%AD%98%E8%A2%AB%E6%B8%85%E7%A9%BA.png" alt="提交后生成新段且缓存被清空" title="提交后生成新段且缓存被清空"></li>
</ol>
<p>当一个查询被触发时，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。</p>
<h3 id="删除和更新索引"><a class="header-anchor" href="#删除和更新索引">¶</a>删除和更新索引</h3>
<p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 <code>.del</code> 文件，文件中会列出这些被删除文档的段信息。<br>
当一个文档被 <strong>删除</strong> 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。<br>
文档<strong>更新</strong>也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<h3 id="准实时搜索与刷新策略"><a class="header-anchor" href="#准实时搜索与刷新策略">¶</a>准实时搜索与刷新策略</h3>
<p>对一个文档进行更新操作后可能会发现属性还是旧的值，我们称之为<strong>准实时现象</strong>：更新的数据还存在于内存中、还未刷新到磁盘上。</p>
<ul>
<li>在索引期新文档会写入<strong>索引段</strong>，这些索引段是独立的，这意味着查询是可以与索引并行的，只是不时会有新增的索引段被添加到可被搜索的索引段集合之中。</li>
<li>Lucene 通过创建后续的（基于索引只写一次的特性）segments_N 文件来实现此功能，且该文件列举了索引中的索引段。这个过程称为<strong>提交（committing）</strong>，Lucene 以一种安全的方式来执行该操作，能确保索引更改以原子操作方式写入索引，即便有错误发生，也能保证索引数据的一致性。</li>
</ul>
<p>随着按段搜索（per-segment）的发展，一个新的文档从索引到可被搜索的延迟显著降低，新文档在几分钟内即可被检索，但是这个速度还是不够快。磁盘在这里称为了瓶颈，提交（Commiting）一个新的段到磁盘需要一个 <code>fsync</code> 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 <code>fsync</code> 操作代价很大，如果每次索引一个文档都去执行一次的话会造成很大的性能问题。<br>
在 Lucene 中提交后，内存索引缓冲区中的文档会被写入到一个新的段中，但是这里新段会被先写入到文件系统缓存——这一步代价会比较低，稍后再被刷新到磁盘——这一步代价比较高，不过只要文件已经在缓存中就可以像其他文件一样被打开和读取了。<br>
另外，Lucene 使用了一个叫作<strong>Searcher</strong>的抽象类来执行索引的读取，如果索引更新提交了，但 Searcher 实例并没有重新打开，那么它觉察不到新索引段的加入。写入和 Searcher 重新打开新段的过程叫作<strong>刷新（refresh）</strong>。出于性能考虑，Lucene 推迟了耗时的刷新，因此它不会在每次新增一个文档（或批量增加文档）的时候刷新，但 Searcher 会<strong>默认每秒刷新一次</strong>。这就是为什么我们说 Elasticsearch 是 近 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br>
因此新索引的数据找不到可能有以下两个原因：</p>
<ol>
<li>可能还未执行提交 commit 操作</li>
<li>Searcher 未重新打开执行刷新</li>
</ol>
<p>如果有必要执行强制刷新，可以使用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 刷新所有索引</span><br><span class="line">POST /_refresh</span><br><span class="line"># 只刷新一个索引</span><br><span class="line">POST /my_index/_refresh</span><br></pre></td></tr></table></figure>
<p>可以更改 ElasticSearch 配置文件中的 index.refresh_interval，，或者使用下面的命令来修改自动刷新时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot;: &#123;</span><br><span class="line">        &quot;refresh_interval&quot;: &quot;5m&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;refresh_interval&quot;: &quot;30s&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新操作是很耗资源的，因此刷新间隔时间越长，索引速度越快。如果需要长时间高速建索引、或建一个比较大的新索引，并且在建索引结束之前暂不执行查询，那么可以考虑将 index.refresh_interval 参数值设置为-1，然后在建索引结束以后再将该参数恢复为初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 关闭自动刷新</span><br><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;refresh_interval&quot;: -1</span><br><span class="line">&#125;</span><br><span class="line"># 每秒自动刷新</span><br><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;refresh_interval&quot;: &quot;1s&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 refresh_interval 的单位，设置为 1 实际上表示的是 1 毫秒，这显然会导致集群陷入瘫痪。<br>
尽管刷新是比提交轻量很多的操作，它还是会有性能开销。 当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
</blockquote>
<h3 id="事务日志-translog"><a class="header-anchor" href="#事务日志-translog">¶</a>事务日志（TransLog）</h3>
<h4 id="lucene-不能保证索引数据不丢失"><a class="header-anchor" href="#lucene-不能保证索引数据不丢失">¶</a>Lucene 不能保证索引数据不丢失</h4>
<p>Lucene 能保证索引的一致性，但是这并不能保证当往索引中写数据（fsync）失败时不会损失数据（如磁盘空间不足、设备损坏，或没有足够的文件句柄供索引文件使用）。<br>
另外，频繁提交操作会导致严重的性能问题（因为每提交一次就会触发一个索引段的创建操作，同时也可能触发索引段的合并）。<br>
即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
<h4 id="使用事务日志记录未提交事务"><a class="header-anchor" href="#使用事务日志记录未提交事务">¶</a>使用事务日志记录未提交事务</h4>
<p>Elasticsearch 增加了一个 <code>translog</code> ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。<br>
ElasticSearch 通过使用<code>translog</code>保存所有的未提交的事务，而 ElasticSearch 会不时创建一个新的日志文件用于记录每个事务的后续操作。当有错误发生时，就会检查事务日志，必要时会再次执行某些操作，以确保没有丢失任何更改信息。而且，事务日志的相关操作都是自动完成的，用户并不会意识到某个特定时刻触发的更新提交。事务日志中的信息与存储介质之间的同步（同时清空事务日志）称为事务日志刷新（<code>Flush</code>），Flush 操作会截断 translog。<br>
注意事务日志刷新与 Searcher 刷新的区别。大多数情况下，Searcher 刷新是你所期望的，即搜索到最新的文档。而事务日志刷新用来确保数据正确写入了索引并清空了事务日志。</p>
<p>通过<code>translog</code>，整个流程看起来是下面这样：</p>
<ol>
<li>一个文档被索引之后，就会被添加到内存缓冲区，并且 追加到了 translog；<br>
<img src="http://47.88.24.11/imgs/ES/%E6%96%B0%E7%9A%84%E6%96%87%E6%A1%A3%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B9%B6%E4%B8%94%E8%A2%AB%E8%BF%BD%E5%8A%A0%E5%88%B0%E4%BA%86%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97.png" alt="新的文档被添加到内存缓冲区并且被追加到了事务日志" title="新的文档被添加到内存缓冲区并且被追加到了事务日志"></li>
<li>分片每秒被刷新（refresh）一次：
<ul>
<li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 fsync 操作。</li>
<li>这个段被打开，使其可被搜索。</li>
<li>内存缓冲区被清空。<br>
<img src="http://47.88.24.11/imgs/ES/Refresh%E5%AE%8C%E6%88%90%E5%90%8E%E7%BC%93%E5%AD%98%E8%A2%AB%E6%B8%85%E7%A9%BA%E4%BD%86%E6%98%AF%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%B8%8D%E4%BC%9A.png" alt="Refresh完成后缓存被清空但是事务日志不会" title="Refresh完成后缓存被清空但是事务日志不会"></li>
</ul>
</li>
<li>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志；<br>
<img src="http://47.88.24.11/imgs/ES/%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%B8%8D%E6%96%AD%E7%A7%AF%E7%B4%AF%E6%96%87%E6%A1%A3.png" alt="事务日志不断积累文档" title="事务日志不断积累文档"></li>
<li>每隔一段时间，索引会被刷新（Flush），一个新的 translog 被创建，并且一个全量提交被执行。
<ul>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过 fsync 被刷新（flush）。</li>
<li>老的 translog 被删除。<br>
translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。<br>
translog 也被用来提供实时 CRUD 。当你试着通过 ID 查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。<br>
<img src="http://47.88.24.11/imgs/ES/Flush%E4%B9%8B%E5%90%8E%E6%AE%B5%E8%A2%AB%E5%85%A8%E9%87%8F%E6%8F%90%E4%BA%A4%E5%B9%B6%E4%B8%94%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E8%A2%AB%E6%B8%85%E7%A9%BA.png" alt="Flush之后段被全量提交并且事务日志被清空" title="Flush之后段被全量提交并且事务日志被清空"></li>
</ul>
</li>
</ol>
<h4 id="手动执行事务日志刷新"><a class="header-anchor" href="#手动执行事务日志刷新">¶</a>手动执行事务日志刷新</h4>
<p>分片每 30 分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /_flush</span><br><span class="line">POST /my_index/_flush</span><br><span class="line"># Flush所有的索引并且并且等待所有刷新在返回前完成。 </span><br><span class="line">POST /_flush?wait_for_ongoing</span><br><span class="line"># 在事务日志刷新之后，调用Searcher刷新操作，打开一个新的Searcher实例</span><br><span class="line">POST /my_index/_refresh</span><br></pre></td></tr></table></figure>
<p>一般不需要自己手动执行<code>Flush</code>操作，自动刷新就足够了。一般重启节点或关闭索引之前都需要执行一次<code>Flush</code>。<br>
当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，如果日志越短，恢复越快。</p>
<h4 id="异步-fsync"><a class="header-anchor" href="#异步-fsync">¶</a>异步 fsync</h4>
<p>默认 translog 是每 5 秒被 fsync 刷新到硬盘，或者在每次写请求（index, delete, update, bulk）完成之后执行。这个过程在主分片和复制分片都会发生，这意味着在整个请求被 fsync 到主分片和复制分片的 translog 之前，客户端不会得到一个 200 OK 响应。<br>
对于一些大容量的偶尔丢失几秒数据问题也不严重的集群，使用异步的 fsync 相对来说更好，比如，写入的数据被缓存到内存中，再每 5 秒执行一次 fsync ，可以使用如下命令配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index.translog.durability&quot;: &quot;async&quot;,</span><br><span class="line">    &quot;index.translog.sync_interval&quot;: &quot;5s&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果不确定丢失几秒数据的后果能否接受，最好还是使用默认的参数：<code>&quot;index.translog.durability&quot;: &quot;request&quot;</code>。</p>
<h4 id="配置-v2"><a class="header-anchor" href="#配置-v2">¶</a>配置</h4>
<p>以下参数既可以通过修改 elasticsearch.yml 文件来配置，也可以通过索引配置更新 API 来更改。</p>
<ul>
<li>index.translog.flush_threshold_period：该参数的默认值为 30 分钟，它控制了强制自动事务日志刷新的时间间隔，即便是没有新数据写入。强制进行事务日志刷新通常会导致大量的 I/O 操作，因此当事务日志涉及少量数据时，才更适合进行这项操作。</li>
<li>index.translog.flush_threshold_ops：该参数确定了一个最大操作数，即在上次事务日志刷新以后，当索引更改操作次数超过该参数值时，强制进行事务日志刷新操作，默认值为 5000。</li>
<li>index.translog.flush_threshold_size：该参数确定了事务日志的最大容量，当容量大于等于该参数值，就强制进行事务日志刷新操作，默认值为 200MB。</li>
<li>index.translog.disable_flush:禁用事务日志刷新。尽管默认情况下事务日志刷新是可用的，但对它临时性地禁用能带来其他方面的便利。例如，向索引中导入大量文档的时候。</li>
</ul>
<p>或者调用 API 动态修改配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot;: &#123;</span><br><span class="line">        &quot;translog.disable_flush&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前述命令在向索引导入大量数据之前执行、可以大幅提高索引的速度。但是请记住，当数据导入完毕之后，要重新设置事务日志刷新相关参数。</p>
<h3 id="段合并"><a class="header-anchor" href="#段合并">¶</a>段合并</h3>
<p>由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增，而段数目太多会带来较大的麻烦：</p>
<ul>
<li>每一个段都会消耗文件句柄、内存和 cpu 运行周期；</li>
<li>更重要的是，每个搜索请求都必须轮流检查每个段，所以段越多，搜索也就越慢。</li>
</ul>
<p>Elasticsearch 通过在后台进行段合并来解决这个问题：</p>
<ul>
<li>小的段被合并到大的段，然后这些大的段再被合并到更大的段。</li>
<li>段合并的时候会将那些旧的已删除文档 从文件系统中清除。 被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</li>
</ul>
<h4 id="段合并流程"><a class="header-anchor" href="#段合并流程">¶</a>段合并流程</h4>
<p>进行索引和搜索时会自动进行段合并：</p>
<ol>
<li>当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</li>
<li>合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。<br>
<img src="http://47.88.24.11/imgs/ES/%E4%B8%A4%E4%B8%AA%E6%8F%90%E4%BA%A4%E4%BA%86%E7%9A%84%E6%AE%B5%E5%92%8C%E4%B8%80%E4%B8%AA%E6%9C%AA%E6%8F%90%E4%BA%A4%E7%9A%84%E6%AE%B5%E8%A2%AB%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%AE%B5.png" alt="两个提交了的段和一个未提交的段被合并到一个更大的段" title="两个提交了的段和一个未提交的段被合并到一个更大的段"></li>
<li>合并完成后：
<ul>
<li>新的段被刷新（flush）到了磁盘。写入一个包含新段且排除旧的和较小的段的新提交点。</li>
<li>新的段被打开用来搜索。</li>
<li>老的段被删除。<br>
<img src="http://47.88.24.11/imgs/ES/%E5%90%88%E5%B9%B6%E7%BB%93%E6%9D%9F%E5%90%8E%E8%80%81%E7%9A%84%E6%AE%B5%E8%A2%AB%E5%88%A0%E9%99%A4.png" alt="合并结束后老的段被删除" title="合并结束后老的段被删除"></li>
</ul>
</li>
</ol>
<h4 id="optimize-api"><a class="header-anchor" href="#optimize-api">¶</a>optimize API</h4>
<p>optimize API 用于手动触发段合并。<br>
将一个分片强制合并到 max_num_segments 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。<br>
optimize API 不应该被用在一个活跃的索引上，Elasticsearch 后台会自动触发合并。<br>
在特定情况下，使用 optimize API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。 老的索引实质上是只读的，它们也并不太可能会发生变化，将历史段合并成一个单独的段就很有用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 合并索引中的每个分片为一个单独的段 </span><br><span class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 optimize API 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的 I/O 资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。 如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配把索引移到一个安全的节点，再执行。</p>
</blockquote>
<h2 id="集群扩容"><a class="header-anchor" href="#集群扩容">¶</a>集群扩容</h2>
<h3 id="配置节点"><a class="header-anchor" href="#配置节点">¶</a>配置节点</h3>
<p>集群是由一个或者多个拥有相同 <strong><a href="http://cluster.name" target="_blank" rel="noopener">cluster.name</a></strong> 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会<strong>重新平均分布所有的数据</strong>。</p>
<h3 id="水平扩容"><a class="header-anchor" href="#水平扩容">¶</a>水平扩容</h3>
<p><img src="http://47.88.24.11/imgs/ES/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B91.png" alt="水平扩容1" title="水平扩容1"><br>
主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。但是，<strong>读操作</strong>——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。<br>
动态调整副本分片数目的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line">&#123;</span><br><span class="line">   &quot;number_of_replicas&quot; : 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://47.88.24.11/imgs/ES/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B92.png" alt="水平扩容2" title="水平扩容2"><br>
为了提高性能，要么是为已有的结点分配更多的资源，要么是分配更多的结点并扩展当前集群。但是不能通过为已有的分片分配更多的资源或者为一个结点分配更多的分片来提高性能，因为一个结点内的所有分片共享这个结点（JVM）的资源，最终还是必须增加更多的硬件资源来提升吞吐量。<br>
更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点的情况下不丢失任何数据（因为每个结点上要么存在一个分片要么存在一个分片的冗余）。</p>
<p>更多关于扩容的知识需要阅读相关文献，比如：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html" target="_blank" rel="noopener">扩容设计</a>。</p>
<h2 id="故障转移"><a class="header-anchor" href="#故障转移">¶</a>故障转移</h2>
<h3 id="同机多节点"><a class="header-anchor" href="#同机多节点">¶</a>同机多节点</h3>
<p>当在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 <a href="http://cluster.name" target="_blank" rel="noopener">cluster.name</a> 配置，它就会自动发现集群并加入到其中。</p>
<h3 id="不同机器多节点"><a class="header-anchor" href="#不同机器多节点">¶</a>不同机器多节点</h3>
<p>在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表，设置其他节点的 ip:port 列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="故障转移机制"><a class="header-anchor" href="#故障转移机制">¶</a>故障转移机制</h3>
<p><img src="http://47.88.24.11/imgs/ES/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png" alt="故障转移" title="故障转移"><br>
所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档，即使主分片不可用了，服务仍然可用。如上图所示。<br>
如果集群缺失主节点，集群不能正常工作。所以发生的第一件事情就是选举一个新的主节点。但是需要注意的是<strong>集群必须存在且仅存在一个主节点</strong>，否则会出现<strong>脑裂</strong>现象，因此 Elasticsearch 提供了很多参数来避免这个情况。<br>
如果索引缺失主分片，索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片<strong>提升</strong>为主分片， 此时集群的状态将会为 yellow ，因为在创建索引时设置了每个主分片需要对应 2 份副本分片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number_of_replicas : 2</span><br></pre></td></tr></table></figure>
<p>重启节点后，集群可以将缺失的副本分片再次进行分配，如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ol>
<li>为什么搜索是近实时的？</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 实时 的？</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</li>
<li>为什么删除文档不会立刻释放空间？</li>
<li>refresh, flush, 和 optimize API 都做了什么, 你什么情况下应该使用他们？</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="文档"><a class="header-anchor" href="#文档">¶</a>文档</h3>
<ol>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">Elasticsearch: 权威指南</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch Reference</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html" target="_blank" rel="noopener">REST APIs</a></li>
</ol>
<h3 id="索引-映射和文档"><a class="header-anchor" href="#索引-映射和文档">¶</a>索引、映射和文档</h3>
<ol>
<li><a href="https://blog.csdn.net/napoay/article/details/52032931" target="_blank" rel="noopener">Elasticsearch 索引的父子关系(index parent-child)</a></li>
<li><a href="https://www.elastic.co/blog/elasticsearch-versioning-support" target="_blank" rel="noopener">Elasticsearch Versioning Support</a></li>
</ol>
<h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3>
<ol>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-in-depth.html" target="_blank" rel="noopener">深入搜索</a></li>
</ol>
<h3 id="集群"><a class="header-anchor" href="#集群">¶</a>集群</h3>
<ol>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html" target="_blank" rel="noopener">扩容设计</a></li>
</ol>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<ol>
<li><a href="https://blog.csdn.net/sinat_14913533/article/details/85833635" target="_blank" rel="noopener">elasticsearch 源码编译问题</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e43d540f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/e43d540f.html" itemprop="url">使用 Arthas 排查线上问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T21:37:14+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>一般来说，查问题有以下几个层次：</p>
<ul>
<li>看服务器指标</li>
<li>看日志</li>
<li>review 代码</li>
<li>debug</li>
</ul>
<p>debug 可以说是撒手锏了，一般不到万不得已的情况不会 debug，费时费力，而且上线后谁还能在服务器上开个 debug 端口？印象中，遇到非常棘手的问题时，只能 review 代码然后在关键位置加日志，究其根本原因，是没法看到进程运行时的内存状况。Arthas 就是为了解决这种问题而诞生的。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/e43d540f.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
