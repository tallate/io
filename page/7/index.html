<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/7/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/7/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3e0c4ce6.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/3e0c4ce6.html" itemprop="url">Spring 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  844 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>Spring 如何加载注解</h1>
<p>很多注解本身只是提供了一个标识，要实现注解所表示的功能，必然还会有一个扫描器扫描这个注解，然后将必须的Bean注入到Spring容器内，而且很多时候会<strong>为被注解的对象生成一个动态代理</strong>，以实现日志记录、接口幂等、限流等功能。<br>
要自己实现一个注解，关键是如何扫描及如何生成代理并注入到Spring容器这两个步骤，具体的实现可以参考<code>MapperScannerConfigurer</code>，大体逻辑是：</p>
<ol>
<li>在Spring容器加载完毕后，再对指定包下的类进行一次扫描；</li>
<li></li>
</ol>
<h1>Spring 三级缓存</h1>
<h2 id="spring-中产生循环依赖的三种情况"><a class="header-anchor" href="#spring-中产生循环依赖的三种情况">¶</a>Spring 中产生循环依赖的三种情况</h2>
<ol>
<li>构造器注入循环依赖 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>构造器注入构成的循环依赖，此种循环依赖方式是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖。<br>
不能解决的原因是：Spring 解决循环依赖的原理是实例化 Bean 后先把引用存到一个 Map 中，之后初始化成员变量时，可以直接从这个 Map 中取。但是构造器注入相当于<strong>实例化和初始化是同时进行的</strong>，因此无法解决。</p>
<ol>
<li>
<p>singleton 模式 field 属性注入循环依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>prototype 模式 field 属性注入循环依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="spring-创建-bean-的流程"><a class="header-anchor" href="#spring-创建-bean-的流程">¶</a>Spring 创建 Bean 的流程</h2>
<ol>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</li>
<li>populateBean：填充属性，这一步主要是对 bean 的依赖属性进行注入(@Autowired)</li>
<li>initializeBean：回到一些形如 initMethod、InitializingBean 等方法</li>
</ol>
<p>其中，循环依赖可能发生在第一步和第二步，其中第一步是因为构造方法中可能会需要传入其他 Bean。</p>
<h2 id="spring-三级缓存如何解决循环依赖"><a class="header-anchor" href="#spring-三级缓存如何解决循环依赖">¶</a>Spring 三级缓存如何解决循环依赖</h2>
<h3 id="缓存生效时间"><a class="header-anchor" href="#缓存生效时间">¶</a>缓存生效时间</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    // 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用</span><br><span class="line">	/** Cache of singleton objects: bean name --&gt; bean instance */</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</span><br><span class="line"></span><br><span class="line">    // 提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</span><br><span class="line">	/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br><span class="line">	private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);</span><br><span class="line">	</span><br><span class="line">	// 单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</span><br><span class="line">	/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br><span class="line">    private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);</span><br></pre></td></tr></table></figure>
<h3 id="获取单例-bean-的过程"><a class="header-anchor" href="#获取单例-bean-的过程">¶</a>获取单例 Bean 的过程</h3>
<p><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String)</code></p>
<ol>
<li>先从一级缓存 singletonObjects 中去获取，如果获取到就直接 return。</li>
<li>如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存 earlySingletonObjects 中获取，如果获取到就直接 return。</li>
<li>如果还是获取不到，且允许 singletonFactories（allowEarlyReference=true）通过 getObject()获取。就从三级缓存 singletonFactory.getObject()获取，如果获取到了就从 singletonFactories 中移除，并且放进 earlySingletonObjects，其实也就是从三级缓存移动到了二级缓存。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/92a28d62.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/92a28d62.html" itemprop="url">SpringCloud 配置总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。<br>
Spring Cloud 常常被拿来和 Dubbo 比较，实际上 Dubbo 只实现了服务治理，接入 Dubbo 的服务能够实现自动上下线、能通过 Dubbo 协议（其实 Dubbo 还支持其他很多协议）互联，但是 Dubbo 并不提供网关、配置中心、链路追踪等一系列微服务架构常用的技术，需要单独引入。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/92a28d62.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/485e1bd7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/485e1bd7.html" itemprop="url">Vim 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T20:09:11+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  501 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>平时在 Linux 环境下待的久了，免不了和 Vim 打交道。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/485e1bd7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/283c6d00.html" itemprop="url">Linux 基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>并发（Concurrency）</h1>
<p>线程、进程，线程安全，进程同步，可见性，一致性，锁，信号量，并发，并行</p>
<h2 id="线程和进程"><a class="header-anchor" href="#线程和进程">¶</a>线程和进程</h2>
<p>从操作系统概念上说，<strong>线程</strong>是最小的可执行单位，也就是系统调度的最小单位。<strong>进程</strong>是资源分配的最小单位。线程是依赖进程存在的，共享进程内的资源，如内存，cpu，io 等。在操作系统的发展过程中，为了提高系统的稳定性、吞吐量和安全性，操作系统内核和用户态做了隔离，例如 Linux 有内核线程，用户线程，内核进程，用户进程，从根本上 Linux 是没有线程的，线程对 Linux 系统来说是个特殊的进程。那么用户线程和内核线程是一一对应呢？从宏观上看是一一对应的，在用户态的每一个线程，都会在内核有对应的执行线程，但是由于资源的限制，用户态的线程和内核线程是多对一的关系。用户进程和内核进程也类似。具体怎样对应的，这里就不探讨了。<br>
为了提高操作系统的实时性，操作系统是以时间片轮转来实现任务调度的。理论上时间片内是不可以被中断的，可认为是 cpu 最小的单位执行时间。现代操作系统为了提高用户体验，线程都是抢占式的，而中断一般在时间片用完的时候发生。线程、进程和 CPU 都是多对一的关系，所以存在进程线程切换的问题。<br>
线程内部还是有自己内存空间的，所以有个概念叫线程内存模型。线程内部有自己私有的本地内存，故线程和线程之间的本地内存存在可见性问题。例如全局变量 A 在线程 1 修改后，线程 2 并不一定能拿到 A 的修改值，因为线程 1 会把全局变量 A 拷贝到本地内存，修改后并不会马上同步。在编译的时候，编译器为了优化，（例如利用超线程技术）可能会重排指令的执行顺序，这就会存在一致性了。</p>
<h2 id="线程安全"><a class="header-anchor" href="#线程安全">¶</a>线程安全</h2>
<p>在线程安全里面经常要讨论的两个问题就是：可见性和一致性。锁是什么东西呢？锁就是一道内存屏障，保证可见性和一致性的一种策略，由操作系统甚至更底层的硬件提供。加锁是消耗资源的，特别是在多核 CPU 上，现在多核 CPU 一般有 3 级缓存，一级缓存通常是单核独占的，而线程的本地内存很可能就保存在 cpu 的缓存里面，然而加锁就意味着保证可见性和一致性，需要中断同步数据，保证别人拿到的是最新修改值。由于用途不同，锁被设计成各种各样的，如互斥锁，读写锁，自旋锁，同步块，数据库的事务等，如果只要保证可见性的，可以不使用锁，在 java 里面可以使用 volatile 修饰全局变量。虽然在 c／c＋＋，都有同样的修饰符，但是是不是一样的意思呢，请参考其他文章。</p>
<h2 id="死锁-deadlock"><a class="header-anchor" href="#死锁-deadlock">¶</a>死锁（deadlock）</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>多个进程竞争资源造成的互相等待情况。</p>
<h3 id="资源"><a class="header-anchor" href="#资源">¶</a>资源</h3>
<p>可重用性资源：可供重复使用多次的资源<br>
不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程使用完后自动释放<br>
可消耗资源:又叫临时性资源，它是在进程运行期间，由进程动态的创建和消耗的</p>
<h3 id="死锁产生的原因"><a class="header-anchor" href="#死锁产生的原因">¶</a>死锁产生的原因</h3>
<ol>
<li>系统资源的竞争<br>
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。<br>
主要是竞争可重用不可抢占式的资源和可消耗的资源。</li>
<li>进程运行推进顺序不合适<br>
进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</li>
</ol>
<h3 id="死锁产生的条件"><a class="header-anchor" href="#死锁产生的条件">¶</a>死锁产生的条件</h3>
<p><strong>互斥条件</strong> 一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>
<strong>请求与保持条件</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>
<strong>不可剥夺条件</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>
<strong>循环等待条件</strong> 若干进程间形成首尾相接循环等待资源的关系<br>
<strong>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong><br>
形象地说，就是有两个酒鬼，一个有开瓶器，一个有酒，这两种资源都只能被一个人占有（互斥），且用完之前不能被另一个人抢去（不可剥夺），他们互相等对方手上的资源（循环等待），但又不肯放开自己手上的资源（请求与保持），因此陷入了死锁。</p>
<h3 id="死锁避免"><a class="header-anchor" href="#死锁避免">¶</a>死锁避免</h3>
<p>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。<br>
书上给出了两种死锁避免策略</p>
<ol>
<li>进程启动拒绝<br>
若对每个资源，能满足现有所有进程再加上新进程的需求，则可以启动这个进程，否则拒绝</li>
<li>资源分配拒绝（银行家算法）</li>
</ol>
<h3 id="死锁预防"><a class="header-anchor" href="#死锁预防">¶</a>死锁预防</h3>
<p>死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。</p>
<ol>
<li>互斥<br>
不可能禁止，比如文件只允许互斥的写访问</li>
<li>占有且等待<br>
可以要求进程一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足，这样就不会再请求新资源了。</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<h1>持久化（Persistent）</h1>
<h2 id="linux-io-模型"><a class="header-anchor" href="#linux-io-模型">¶</a>Linux IO 模型</h2>
<p><img src="http://47.88.24.11/imgs/Linux/Linux%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="X" title="Linux整体结构"><br>
应用程序调用内核 IO 函数的过程如下图所示：<br>
<img src="http://47.88.24.11/imgs/Linux/IO%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="X" title="IO系统调用过程"><br>
处于 OS 的安全性等的考虑，进程无法直接操作 I/O 设备，必须通过系统调用来请求内核完成 I/O 动作，而内核会为每个 I/O 设备维护一个 Buffer。</p>
<ol>
<li>用户进程发起请求；</li>
<li>内核接收到请求后，从 I/O 设备中获取数据到 Buffer 中；</li>
<li>将 Buffer 中的数据拷贝到用户进程的地址空间，该用户进程获取到数据后响应给客户端。</li>
</ol>
<p>在整个请求过程中，数据输入至 Buffer 需要时间，从 Buffer 复制数据到进程也需要时间，这个等待时间是限制 I/O 效率的罪魁祸首，根据等待方式的不同，I/O 动作可以分为以下五种模式：</p>
<ul>
<li>阻塞 I/O（Blocking I/O）</li>
<li>非阻塞 I/O（Non-Blocking I/O）</li>
<li>I/O 复用（I/O Multiplexing）</li>
<li>信号驱动的 I/O（Signal Driven I/O）</li>
<li>异步 I/O（Asynchronous I/O）</li>
</ul>
<h2 id="存储器管理"><a class="header-anchor" href="#存储器管理">¶</a>存储器管理</h2>
<h2 id="文件系统"><a class="header-anchor" href="#文件系统">¶</a>文件系统</h2>
<h2 id="io-pipe"><a class="header-anchor" href="#io-pipe">¶</a>IO（pipe）</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line"></span><br><span class="line">int testPipe()&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line"></span><br><span class="line">    int *read_fd = &amp;fd[0];</span><br><span class="line">    int *write_fd = &amp;fd[1];</span><br><span class="line"></span><br><span class="line">    if(pipe(fd) == -1)&#123;</span><br><span class="line">        printf(&quot;pipe create failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == -1)&#123;</span><br><span class="line">        printf(&quot;fork failed&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char string[] = &quot;hahaha&quot;;</span><br><span class="line">        close(*read_fd);</span><br><span class="line">        count = write(*write_fd, string, sizeof(string));</span><br><span class="line">        printf(&quot;写了%d个字符\n&quot;, count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char buffer[100];</span><br><span class="line">        close(*write_fd);</span><br><span class="line">        count = read(*read_fd, buffer, sizeof(buffer));</span><br><span class="line">        printf(&quot;父进程接受到%d字节的数据:%s&quot;, count, buffer);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟内存"><a class="header-anchor" href="#虚拟内存">¶</a>虚拟内存</h2>
<h3 id="swap"><a class="header-anchor" href="#swap">¶</a>swap</h3>
<h1>虚拟化（Virtualization）</h1>
<h2 id="驱动管理"><a class="header-anchor" href="#驱动管理">¶</a>驱动管理</h2>
<h1>参考</h1>
<h2 id="linux-应用"><a class="header-anchor" href="#linux-应用">¶</a>Linux 应用</h2>
<ol>
<li>虚拟内存<br>
<a href="https://www.linux.com/news/all-about-linux-swap-space" target="_blank" rel="noopener">All about Linux swap space</a><br>
<a href="https://wiki.archlinux.org/index.php/swap" target="_blank" rel="noopener">Swap</a><br>
<a href="https://haydenjames.io/linux-performance-almost-always-add-swap-space/" target="_blank" rel="noopener">Linux Performance: Why You Should Almost Always Add Swap Space</a></li>
<li>演进<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-kernel-advances/index.html" target="_blank" rel="noopener">Linux 内核的发展 介绍 2.6.28 和 2.6.29 版本中的新特性</a><br>
<a href="https://linux.cn/article-6179-1.html" target="_blank" rel="noopener">对 Linux 内核的发展方向的展望 - Linux 4.2</a></li>
<li>运维<br>
<a href="https://juejin.im/entry/5c9780335188252d941493d3" target="_blank" rel="noopener">老司机告诉你：正规的运维工作是什么的?</a></li>
<li>并发<br>
<a href="https://blog.csdn.net/u011677209/article/details/78082722" target="_blank" rel="noopener">Linux 原子操作 atomic_cmpxchg()/Atomic_read()/Atomic_set()/Atomic_add()/Atomic_sub()</a></li>
<li>隔离<br>
<a href="https://www.v2ex.com/member/jerry017cn/topics" target="_blank" rel="noopener">cgroup - jerry017cn</a></li>
</ol>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a>操作系统</h2>
<ol>
<li>分时和实时操作系统<br>
<a href="https://www.osrtos.com/" target="_blank" rel="noopener">List of open source real-time operating systems</a></li>
<li>操作系统概念<br>
<a href="https://www.cnblogs.com/leesf456/p/5375198.html" target="_blank" rel="noopener">【操作系统】操作系统综述（一）</a></li>
<li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters" target="_blank" rel="noopener">Operating Systems: Three Easy Pieces</a></li>
</ol>
<h3 id="concurrency"><a class="header-anchor" href="#concurrency">¶</a>Concurrency</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5413517.html" target="_blank" rel="noopener">【操作系统】进程管理（二）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5605193.html" target="_blank" rel="noopener">【操作系统】处理机调度与死锁（三）</a></li>
</ol>
<h3 id="persistent"><a class="header-anchor" href="#persistent">¶</a>Persistent</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5616041.html" target="_blank" rel="noopener">【操作系统】存储器管理（四）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5626339.html" target="_blank" rel="noopener">【操作系统】文件管理（六）</a></li>
</ol>
<h3 id="virtualization"><a class="header-anchor" href="#virtualization">¶</a>Virtualization</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5622859.html" target="_blank" rel="noopener">【操作系统】设备管理（五）</a></li>
</ol>
<h2 id="linux-内核"><a class="header-anchor" href="#linux-内核">¶</a>Linux 内核</h2>
<ol>
<li>哈工大操作系统<br>
<a href="https://mooc.study.163.com/course/1000002004?_trace_c_p_k2_=6a6064778bf54c5f98396d86c4146823#/info" target="_blank" rel="noopener">操作系统之基础</a><br>
<a href="https://www.shiyanlou.com/courses/115" target="_blank" rel="noopener">操作系统原理与实践</a></li>
<li>NJU<br>
<a href="https://nju-ics.gitbooks.io/ics2016-programming-assignment/content/1.1.html" target="_blank" rel="noopener">在开始愉快的 PA 之旅之前</a><br>
<a href="https://github.com/NJU-ProjectN/LiteNES" target="_blank" rel="noopener">NJU-ProjectN</a></li>
<li><a href="http://www.linfo.org/index.html" target="_blank" rel="noopener">The Linux Information Project</a></li>
<li><a href="https://www.kernel.org/" target="_blank" rel="noopener">The Linux Kernel Archives</a></li>
<li><a href="https://tinylab.gitbooks.io/linux-doc/content/zh-cn/" target="_blank" rel="noopener">Linux 内核文档（中文版）</a></li>
<li><a href="http://www.superfrink.net/athenaeum/OS-FAQ/os-faq.html" target="_blank" rel="noopener">Write Your Own Operating System</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/" target="_blank" rel="noopener">6.828: Operating System Engineering</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fca77f63.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fca77f63.html" itemprop="url">Linux 与 IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>5 种 IO 模型</h1>
<h2 id="blocking"><a class="header-anchor" href="#blocking">¶</a>Blocking</h2>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-BIO.png" alt="Linux-BIO" title="Linux-BIO"></p>
<ol>
<li>用户程序调用系统调用 read()，应用程序阻塞；</li>
<li>当内核把数据准备好后，将数据从内核拷贝到用户内存；</li>
<li>内核返回，用户线程解除 block 状态。</li>
</ol>
<h2 id="non-blocking"><a class="header-anchor" href="#non-blocking">¶</a>Non-Blocking</h2>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-NIO.png" alt="Linux-NIO" title="Linux-NIO"></p>
<ol>
<li>用户进程轮询调用 recvfrom，直到内核将数据准备好；</li>
<li>轮询期间用户可以去做别的事；</li>
<li>当内核中的数据准备好了，再次接收到 recvfrom 调用时会将数据拷贝到用户内存并返回。</li>
</ol>
<h2 id="io-multiplexing-多路复用"><a class="header-anchor" href="#io-multiplexing-多路复用">¶</a>IO Multiplexing（多路复用）</h2>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="Linux-IO多路复用" title="Linux-IO多路复用"><br>
又称为事件驱动 IO。</p>
<ol>
<li>内核会同时监听多个 select 负责的 socket，当其中任何一个 socket 中的数据准备好了，select 就会返回；</li>
<li>当数据准备好了，用户进程再调用 read、内核会将数据从内核拷贝到用户进程。</li>
</ol>
<p>优势：</p>
<ol>
<li>能同时监听多个 socket；</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果 socket 较少，因为有两次系统调用，性能甚至不如 BIO；</li>
</ol>
<h3 id="select"><a class="header-anchor" href="#select">¶</a>select</h3>
<p>原理：如上所述<br>
缺点：</p>
<ol>
<li>select 最大的缺陷是单个进程打开的 fd 数量有限（因为是用数组保存的）；</li>
<li>对多个 socket 的扫描是线性轮询扫描的，效率较低，当 socket 较多时，select 会浪费很多 CPU 时间，且 socket 越多，这个现象会越明显；</li>
<li>需要一个大数据结构来存放打开的 fd，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
</ol>
<h3 id="poll"><a class="header-anchor" href="#poll">¶</a>poll</h3>
<p>原理：本质上与 select 没有区别，只是存储 fd 的结构是链表。<br>
优点（相对 select）：</p>
<ol>
<li>没有最大连接数的限制</li>
</ol>
<p>缺点：</p>
<ol>
<li>大量 fd 组成的链表被整体复制于用户态和内核地址空间之间，很多时候这样的复制没有意义；</li>
</ol>
<h3 id="epoll"><a class="header-anchor" href="#epoll">¶</a>epoll</h3>
<p>原理：</p>
<ol>
<li>更灵活，使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次；</li>
<li>通过回调通知进程，而不是轮询。</li>
</ol>
<p>优点：</p>
<ol>
<li>没有描述符限制，epoll 会把所有创建的描述符放到一个事件表（文件）中由一个描述符统一管理；</li>
<li>效率更高、IO 的效率不会随着监视 fd 的数量的增长而下降，fd 变为活跃时才会调用 callback 函数通知用户进程，而不是通过轮询的方式；</li>
<li>使用 mmap()文件映射内存加速与内核空间的消息传递，减少了复制的开销。</li>
</ol>
<h4 id="进程调度原理"><a class="header-anchor" href="#进程调度原理">¶</a>进程调度原理</h4>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.png" alt="Linux-操作系统的进程调度" title="Linux-操作系统的进程调度"></p>
<ol>
<li>进程刚开始处于运行中状态，这时进程处于<strong>工作队列</strong>内，进程调度程序会分时执行各个运行状态的进程；</li>
<li>进程调用了<code>recv</code>这种需要阻塞的系统调用，这时，进程从运行状态变为等待状态，会被添加到对应<strong>socket</strong>中的<strong>等待队列</strong>内，这时进程调度程序不会分配时间片给该进程，因此也不会占用任何 CPU 资源；</li>
<li>socket 接收到数据后，操作系统将该 socket<strong>等待队列</strong>上的进程重新放回到<strong>工作队列</strong>，该进程变成运行状态，继续执行代码。也由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</li>
</ol>
<h4 id="操作系统如何知道网络数据对应于哪个-socket"><a class="header-anchor" href="#操作系统如何知道网络数据对应于哪个-socket">¶</a>操作系统如何知道网络数据对应于哪个 socket</h4>
<p>如上面进程调度原理所述，操作系统接收数据后需要唤醒 socket 上等待队列里的进程，但是操作系统接收数据后怎么知道网络数据属于哪个 socket 呢？<br>
不妨回忆下我们平时创建 socket 时给出的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Socket(serverHost, serverPort)</span><br></pre></td></tr></table></figure>
<p>实际上因为每个 socket 都对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 socket。<br>
而且为了提高处理速度，操作系统会维护端口号到 socket 的索引结构。</p>
<h4 id="多路复用的基石-select-及其存在的问题"><a class="header-anchor" href="#多路复用的基石-select-及其存在的问题">¶</a>多路复用的基石-select 及其存在的问题</h4>
<p>前面我们讨论了操作系统如何唤醒进程，如果进程和 socket 是一一对应的，那么我们就实现了 BIO。<br>
不过 epoll 等模型的特点是一个进程同时监听多个 socket，即一对多的多路复用。<br>
最普通的 select 模型中，进程将所有监听的 socket 放到一个列表内，只要有一个 socket 监听到数据到，操作系统会唤醒该进程，然后程序需要遍历一次该列表，就可以拿到所有就绪的 socket。<br>
这种方式的缺点主要是：</p>
<ul>
<li>有两次遍历过程：每次 socket 读取到数据后需要遍历该 socket 的<strong>等待队列</strong>；每次进程被唤醒后，都需要遍历一次它监听的 socket 列表。<br>
这里涉及了两次遍历，而且每次都要将整个 fds 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024 个 socket。</li>
</ul>
<p>poll 与 select 没有本质区别，只不过 poll 使用链表来保存监听的 socket，没有最大监听数量限制。</p>
<h4 id="为什么使用-epoll"><a class="header-anchor" href="#为什么使用-epoll">¶</a>为什么使用 epoll</h4>
<ol>
<li>功能分离<br>
传统 select 每次调用 select 都需要将运行队列中的进程添加到 socket 的等待队列，唤醒时再移除，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。<br>
epoll 的改进是只添加一次等待队列，之后每次都只需要阻塞进程，如下图所示：<br>
<img src="http://47.88.24.11/imgs/Linux/Linux-epoll%E6%8B%86%E5%88%86%E5%8A%9F%E8%83%BD.jpg" alt="Linux-epoll拆分功能" title="Linux-epoll拆分功能"></li>
<li>就绪列表<br>
epoll 中，操作系统唤醒进程后，进程不需要遍历所有监听的 socket，因为收到数据的 socket 会被添加到一个<strong>就绪队列</strong>内，然后唤醒等待队列中的所有进程，这时进程只需要遍历<strong>就绪队列</strong>即可拿到所有接收到数据的 socket。<br>
<img src="http://47.88.24.11/imgs/Linux/Linux-epoll%E5%8E%9F%E7%90%86.png" alt="Linux-epoll原理" title="Linux-epoll原理"></li>
</ol>
<h3 id="kqueue"><a class="header-anchor" href="#kqueue">¶</a>kqueue</h3>
<p>与 epoll 非常相似，注册一批 socket 描述符到 kqueue 以后，当其中的描述符状态发生变化时，kqueue 将一次性通知应用程序哪些描述符可读、可写或出错了。</p>
<blockquote>
<p>可能是因为不同 Linux 发行版之间存在接口兼容性问题，所以在已有 epoll 的情况下又有人开发了 kqueue，kqueue 主要应用在 freebsd 和 macosx 内核的操作系统上。</p>
</blockquote>
<h3 id="reactor"><a class="header-anchor" href="#reactor">¶</a>Reactor</h3>
<p>Reactor 是 Java 中的一种设计模式：</p>
<ol>
<li>事件驱动；</li>
<li>一次性处理一个或多个事件（输入源）；</li>
<li>通过 Service Handler 同步的将输入事件（Event）采用多路复用分发给相应的 Request Handler（多个）处理。</li>
</ol>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-Reactor%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%A8%A1%E5%9E%8B.png" alt="Linux-Reactor事件分发模型" title="Linux-Reactor事件分发模型"></p>
<p>Reactor 的实现上有 3 种模式：</p>
<ol>
<li>单 Reactor 单线程模型<br>
<img src="http://47.88.24.11/imgs/Linux/Linux-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="Linux-单Reactor单线程模型" title="Linux-单Reactor单线程模型"></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Reactor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    public Reactor(int port) throws Exception &#123;</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket = server.socket();</span><br><span class="line">        serverSocket.bind(new InetSocketAddress(port));</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        SelectionKey sk = server.register(selector,</span><br><span class="line">                SelectionKey.OP_ACCEPT);</span><br><span class="line">        // attach Acceptor 处理新连接</span><br><span class="line">        sk.attach(new Acceptor(server, selector));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set selected = selector.selectedKeys();</span><br><span class="line">                Iterator it = selected.iterator();</span><br><span class="line">                while (it.hasNext()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                    //分发事件处理</span><br><span class="line">                    dispatch((SelectionKey) (it.next()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            log.info(&quot;异常&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatch(SelectionKey k) &#123;</span><br><span class="line">        // 若是连接事件获取是acceptor</span><br><span class="line">        // 若是IO读写事件获取是handler</span><br><span class="line">        Runnable runnable = (Runnable) (k.attachment());</span><br><span class="line">        if (runnable != null) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class Acceptor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    private ExecutorService tp = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);</span><br><span class="line"></span><br><span class="line">    public Acceptor(ServerSocketChannel serverSocket,</span><br><span class="line">            Selector selector) &#123;</span><br><span class="line">        this.serverSocket = serverSocket;</span><br><span class="line">        this.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            SocketChannel c = serverSocket.accept();</span><br><span class="line">            if (c != null) &#123;</span><br><span class="line">                // 每个连接一个Handler</span><br><span class="line">                tp.submit(new SimpleHandler(c, selector));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.info(&quot;异常&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class SimpleHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public static final int READING = 0, WRITING = 1;</span><br><span class="line"></span><br><span class="line">    int state;</span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line">    private SelectionKey sk;</span><br><span class="line"></span><br><span class="line">    public SimpleHandler(SocketChannel socketChannel, Selector selector) throws IOException &#123;</span><br><span class="line">        this.state = READING;</span><br><span class="line">        this.socketChannel = socketChannel;</span><br><span class="line">        sk = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        sk.attach(this);</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (state == READING) &#123;</span><br><span class="line">            read();</span><br><span class="line">        &#125; else if (state == WRITING) &#123;</span><br><span class="line">            write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void read() &#123;</span><br><span class="line">        // TODO 处理读</span><br><span class="line">        //下一步处理写事件</span><br><span class="line">        sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        this.state = WRITING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void write() &#123;</span><br><span class="line">        // TODO 处理写</span><br><span class="line">        //下一步处理读事件</span><br><span class="line">        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        this.state = READING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码可知，Reactor 线程启动后监听客户端请求、多路分离 socket，将 connect 事件分发给 Acceptor 处理，有 IO 读写事件后交给 Handler 处理，分发过程中并没有创建新线程。<br>
这种单线程模型不能充分利用多核资源，所以实际使用不多。</p>
<ol>
<li>单 Reactor 多线程模型<br>
<img src="http://47.88.24.11/imgs/Linux/Linux-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="Linux-单Reactor多线程模型" title="Linux-单Reactor多线程模型"><br>
与上面的区别是 Handler 通过多线程来执行读写任务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThreadHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static final int READING = 0, WRITING = 1;</span><br><span class="line">    private int state;</span><br><span class="line">    private final SocketChannel socket;</span><br><span class="line">    private final SelectionKey sk;</span><br><span class="line"></span><br><span class="line">    //多线程处理业务逻辑</span><br><span class="line">    private ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    public MultiThreadHandler(SocketChannel socket, Selector selector) throws Exception &#123;</span><br><span class="line">        this.state = READING;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">        sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        sk.attach(this);</span><br><span class="line">        socket.configureBlocking(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (state == READING) &#123;</span><br><span class="line">            read();</span><br><span class="line">        &#125; else if (state == WRITING) &#123;</span><br><span class="line">            write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void read() &#123;</span><br><span class="line">        //任务异步处理</span><br><span class="line">        executorService.submit(this::process);</span><br><span class="line"></span><br><span class="line">        //下一步处理写事件</span><br><span class="line">        sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        this.state = WRITING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void write() &#123;</span><br><span class="line">        //任务异步处理</span><br><span class="line">        executorService.submit(this::process);</span><br><span class="line"></span><br><span class="line">        //下一步处理读事件</span><br><span class="line">        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        this.state = READING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * task 业务处理</span><br><span class="line">     */</span><br><span class="line">    public void process() &#123;</span><br><span class="line">        //do IO ,task,queue something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>多 Reactor 多线程模型<br>
<img src="http://47.88.24.11/imgs/Linux/Linux-%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="Linux-多Reactor多线程模型" title="Linux-多Reactor多线程模型"><br>
相对上面两种来说，第三种将 Reactor 分成了两部分：
<ul>
<li>mainReactor 负责监听 server socket，用来处理新连接的建立，将建立的 socketChannel 指定注册给 subReactor。</li>
<li>subReactor 维护自己的 selector, 基于 mainReactor 注册的 socketChannel 多路分离 IO 读写事件，读写网络数据，对业务处理的功能，将其扔给 worker 线程池来完成。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 多work 连接事件Acceptor,处理连接事件</span><br><span class="line"> */</span><br><span class="line">public class MultiWorkThreadAcceptor implements Runnable &#123; </span><br><span class="line">    </span><br><span class="line">    // cpu线程数相同多work线程</span><br><span class="line">    private int workCount =Runtime.getRuntime().availableProcessors();</span><br><span class="line">    private SubReactor[] workThreadHandlers = new SubReactor[workCount];</span><br><span class="line">    private volatile int nextHandler = 0;</span><br><span class="line">    </span><br><span class="line">    public MultiWorkThreadAcceptor() &#123;</span><br><span class="line">        this.init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void init() &#123;</span><br><span class="line">        nextHandler = 0;</span><br><span class="line">        for (int i = 0; i &lt; workThreadHandlers.length; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                workThreadHandlers[i] = new SubReactor();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            SocketChannel c = serverSocket.accept();</span><br><span class="line">            if (c != null) &#123;// 注册读写</span><br><span class="line">                synchronized (c) &#123;</span><br><span class="line">                    // 顺序获取SubReactor，然后注册channel</span><br><span class="line">                    SubReactor work = workThreadHandlers[nextHandler];</span><br><span class="line">                    work.registerChannel(c);</span><br><span class="line">                    nextHandler++;</span><br><span class="line">                    if (nextHandler &gt;= workThreadHandlers.length) &#123;</span><br><span class="line">                        nextHandler = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多work线程处理读写业务逻辑</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class SubReactor implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private final Selector mySelector;</span><br><span class="line"></span><br><span class="line">    //多线程处理业务逻辑</span><br><span class="line">    private int workCount = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    private ExecutorService executorService = Executors.newFixedThreadPool(workCount);</span><br><span class="line"></span><br><span class="line">    public SubReactor() throws Exception &#123;</span><br><span class="line">        // 每个SubReactor 一个selector </span><br><span class="line">        this.mySelector = SelectorProvider.provider().openSelector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册chanel</span><br><span class="line">     */</span><br><span class="line">    public void registerChannel(SocketChannel sc) throws Exception &#123;</span><br><span class="line">        sc.register(mySelector, SelectionKey.OP_READ | SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //每个SubReactor 自己做事件分派处理读写事件</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    if (key.isReadable()) &#123;</span><br><span class="line">                        read();</span><br><span class="line">                    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">                        write();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.warn(&quot;出错&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void read() &#123;</span><br><span class="line">        //任务异步处理</span><br><span class="line">        executorService.submit(() -&gt; process());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void write() &#123;</span><br><span class="line">        //任务异步处理</span><br><span class="line">        executorService.submit(() -&gt; process());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * task 业务处理</span><br><span class="line">     */</span><br><span class="line">    public void process() &#123;</span><br><span class="line">        //do IO ,task,queue something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="signal-driven-io-信号驱动的-io"><a class="header-anchor" href="#signal-driven-io-信号驱动的-io">¶</a>Signal Driven IO（信号驱动的 IO）</h2>
<p>用户注册一个信号处理函数，一旦数据准备好，由内核生成一个 SIGIO 信号，通知数据已经准备好的事件，之后用户进程可以调用 recvfrom 把数据从内核拷贝出来并返回结果。</p>
<h2 id="aio"><a class="header-anchor" href="#aio">¶</a>AIO</h2>
<p>与信号驱动 IO 的主要区别是：在信号驱动的 I/O 中，内核告诉我们何时可以启动 I/O 操作，但是异步 I/O 时，内核告诉我们何时 I/O 操作完成。</p>
<h3 id="proactor"><a class="header-anchor" href="#proactor">¶</a>Proactor</h3>
<h2 id="5-种-io-模型的比较"><a class="header-anchor" href="#5-种-io-模型的比较">¶</a>5 种 IO 模型的比较</h2>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="Linux-5种IO模型的比较" title="Linux-5种IO模型的比较"></p>
<h1>优化</h1>
<h2 id="pagecache"><a class="header-anchor" href="#pagecache">¶</a>pageCache</h2>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-pageCache%E4%B8%8Emmap.png" alt="Linux-pageCache与mmap" title="Linux-pageCache与mmap"></p>
<ul>
<li>Linux里所有处理文件的IO请求均需经过pageCache，对于操作系统来说，磁盘文件都是由一系列的数据块顺序组成。<br>
比如要读的磁盘位置若未加载到pageCache（pageCache中的每一个数据块都设置了文件以及偏移量地址信息），则发起一次<strong>缺页中断</strong>，由操作系统加载该页到pageCache中的一个空闲块，并注册到<strong>页表</strong>，然后再copy到用户缓冲区中。换进新页面时会通过<strong>页面置换算法</strong>将老页面换出，Linux中一般是基于LRU实现的。</li>
<li>预读取（局部性原理）<br>
page cache本身也会对数据文件进行预读取，对于每个文件的第一个读请求操作，系统在读入所请求页面的同时会读入紧随其后的少数几个页面。</li>
</ul>
<p>PageCache机制也不是完全无缺点的，当遇到OS进行脏页回写，内存回收，内存swap等情况时，就会引起较大的消息读写延迟，优化方式主要包括内存预分配，文件预热和mlock系统调用。</p>
<h2 id="零拷贝"><a class="header-anchor" href="#零拷贝">¶</a>零拷贝</h2>
<p>零拷贝技术主要有以下几种：</p>
<ol>
<li>直接 I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输：这类零拷贝技术针对的是操作系统内核并不需要对数据进行直接处理的情况，数据可以在应用程序地址空间的缓冲区和磁盘之间直接进行传输，完全不需要 Linux 操作系统内核提供的页缓存的支持。</li>
<li>在数据传输的过程中，避免数据在<strong>操作系统内核地址空间的缓冲区</strong>和<strong>用户应用程序地址空间的缓冲区</strong>之间进行拷贝。有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的<strong>pageCache</strong>拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在<strong>pageCache</strong>中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 <code>mmap()</code>，<code>sendfile()</code> 以及 <code>splice()</code>。</li>
<li>对数据在 <strong>Linux 的页缓存</strong>和<strong>用户进程的缓冲区</strong>之间的传输过程进行优化。该零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统的页缓存之间的拷贝操作。这种方法延续了传统的通信方式，但是更加灵活。在 Linux 中，该方法主要利用了<strong>写时复制</strong>技术。</li>
</ol>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-%E4%B8%80%E6%AC%A1IO%E5%8F%91%E7%94%9F%E7%9A%84%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D.png" alt="Linux-一次IO发生的内存拷贝" title="Linux-一次IO发生的内存拷贝"><br>
当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据 read 系统调用提供的 buf 地址，将内核缓冲区的内容拷贝到 buf 所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠 DMA 来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。 接下来，write 系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后 socket 再把内核缓冲区的内容发送到网卡上。<br>
这期间，一共进行了 4 次数据拷贝，且用户态和内核态也发生了多次上下文切换。</p>
<p>从代码层面上来看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。<br>
但是通过内存映射的方法访问硬盘文件效率会比 read 和 write 系统调用高：</p>
<ol>
<li>read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；</li>
<li>map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。</li>
</ol>
<h3 id="mmap"><a class="header-anchor" href="#mmap">¶</a>mmap</h3>
<p><img src="http://47.88.24.11/imgs/Linux/Linux-mmap.png" alt="Linux-mmap" title="Linux-mmap"><br>
mmap是零拷贝的实现方案，mmap 将内核缓冲区与应用程序缓冲区共享，减少了 2 次拷贝及拷贝过程中必经的上下文切换过程。</p>
<h3 id="java-中的零拷贝"><a class="header-anchor" href="#java-中的零拷贝">¶</a>Java 中的零拷贝</h3>
<p>Java 中的 NIO 相对 BIO 的优势之一就是 NIO 提供了零拷贝提高了 IO 速度，实现是<code>MappedByteBuffer</code>，核心方法是<code>map()</code>，该方法把文件映射到内存中，获得内存地址 addr，然后通过这个 addr 构造<code>MappedByteBuffer</code>类，以暴露各种文件操作 API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MappedByteBufferTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File file = new File(&quot;/Users/huanggaochi/Downloads/a.txt&quot;);</span><br><span class="line">        long len = file.length();</span><br><span class="line">        byte[] ds = new byte[(int) len];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 读文件到字节数组</span><br><span class="line">            MappedByteBuffer mappedByteBuffer = new RandomAccessFile(file, &quot;r&quot;)</span><br><span class="line">                    .getChannel()</span><br><span class="line">                    .map(FileChannel.MapMode.READ_ONLY, 0, len);</span><br><span class="line">            for (int offset = 0; offset &lt; len; offset++) &#123;</span><br><span class="line">                byte b = mappedByteBuffer.get();</span><br><span class="line">                ds[offset] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            // 从字节数组读</span><br><span class="line">            Scanner scan = new Scanner(new ByteArrayInputStream(ds)).useDelimiter(&quot; &quot;);</span><br><span class="line">            while (scan.hasNext()) &#123;</span><br><span class="line">                System.out.print(scan.next() + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MappedByteBuffer</code>本身是一个抽象类，它申请的是堆外内存，因此<strong>不受 Minor GC 控制</strong>，只能在发生 Full GC 时才能被回收。而<code>DirectByteBuffer</code>改善了这一情况，原理是在<code>MappedByteBuffer</code>的基础上，维护了一个 Cleaner 对象来完成内存的回收工作，因此它既可以通过 Full GC 来回收内存，也可以调用 clean()方法来进行回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (address == 0) &#123;</span><br><span class="line">    // Paranoia</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">unsafe.freeMemory(address);</span><br><span class="line">address = 0;</span><br><span class="line">Bits.unreserveMemory(size, capacity);</span><br></pre></td></tr></table></figure>
<p>读取内存和写入数据都是直接调用 Unsafe 的对应接口 getByte 和 putByte，通过（address + 偏移量）获取指定内存的数据。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public byte get(int i) &#123;</span><br><span class="line">    return ((unsafe.getByte(ix(checkIndex(i)))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ByteBuffer put(int i, byte x) &#123;</span><br><span class="line">    unsafe.putByte(ix(checkIndex(i)), ((x)));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一次访问 address 所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非 jvm 堆内存）。</li>
<li>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。</li>
</ol>
<blockquote>
<p>MappedByteBuffer 还有一个兄弟 HeapByteBuffer，它在堆中申请内存，本质上是一个数组，由于位于堆中，因此可受 GC 管控，易于回收。</p>
</blockquote>
<h1>C10K问题</h1>
<p>两个限制：</p>
<ol>
<li>可打开文件句柄数的限制<br>
可以通过ulimit命令调整。</li>
<li>线程数的限制<br>
注意内存容量限制，线程本身会占用堆栈空间内存。</li>
</ol>
<p>解决C10K问题采用的IO模型：epoll<br>
<img src="http://47.88.24.11/imgs/Linux/Linux-epoll%E5%8E%9F%E7%90%86.png" alt="Linux-epoll原理" title="Linux-epoll原理"><br>
epoll具体原理描述见之前的小节。</p>
<h1>参考</h1>
<ol>
<li>为什么说NIO是同步非阻塞的？和BIO有什么区别？<br>
非阻塞指的是：通过轮询selector监听socket是否来数据，而不是阻塞等待。<br>
同步指的是：一个socket来数据后需要创建一个线程读取，读取过程是同步的。<br>
异步指的是：读取数据由操作系统做好，业务线程等着数据读取完毕的通知。</li>
<li>多路复用机制如何支持海量连接？<br>
多路复用可以用很少的线程监听很多客户端的请求。<br>
因此多路复用常用于解决C10K问题。</li>
</ol>
<h1>参考文档</h1>
<ol>
<li><a href="https://wenchao.ren/2019/07/Select%E3%80%81Epoll%E3%80%81KQueue%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">Select、poll、Epoll、KQueue 区别</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清 epoll 的本质，那就过来掐死我吧！ （1）</a></li>
<li><a href="https://www.jianshu.com/p/275602182f39" target="_blank" rel="noopener">零拷贝</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/283c6d00.html" itemprop="url">Linux 与文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  223 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="文件系统操作"><a class="header-anchor" href="#文件系统操作">¶</a>文件系统操作</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -F filename # 列出目录，使用*等符号标志文件类型，*表示可执行文件，/为目录文件</span><br><span class="line">ls -i filename # 查看文件inode号</span><br><span class="line">mkdir -p dirname # 创建目录，如果有父目录就创建父目录</span><br><span class="line">stat filename # 查看文件详细信息，包括inode号、链接数</span><br><span class="line">mv # 移动/重命名</span><br><span class="line">ln oldfile newfile # 创建硬链接</span><br><span class="line">ln -s sourcefile/sourcedir targetfile/targetdir # 创建软链接</span><br></pre></td></tr></table></figure>
<h3 id="chroot"><a class="header-anchor" href="#chroot">¶</a>chroot</h3>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/" target="_blank" rel="noopener">chroot</a></p>
<h3 id="mount-和-umount"><a class="header-anchor" href="#mount-和-umount">¶</a>mount 和 umount</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t # 查看挂载分区信息</span><br></pre></td></tr></table></figure>
<p>制作目录硬链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 假设当前目录下有a和b两个目录</span><br><span class="line">mount -o bind a b # b成为a的硬链接，其实就是将a挂载到了b上</span><br><span class="line">mount # 通过mount可以看出是bind这个参数起作用</span><br><span class="line">/dev/sda2 on /home/hgc/Downloads/b type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line"># 删除时必须先卸载再删除</span><br><span class="line">umount b</span><br><span class="line">rm -rf b</span><br></pre></td></tr></table></figure>
<h3 id="ln"><a class="header-anchor" href="#ln">¶</a>ln</h3>
<h3 id="fdisk"><a class="header-anchor" href="#fdisk">¶</a>fdisk</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l # 查看硬盘分区信息</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1a8406e8.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1a8406e8.html" itemprop="url">并发和并发安全容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>无锁栈</h1>
<h2 id="treiber-stack"><a class="header-anchor" href="#treiber-stack">¶</a>Treiber Stack</h2>
<h1>无锁列表</h1>
<h2 id="copyonwritearraylist"><a class="header-anchor" href="#copyonwritearraylist">¶</a>CopyOnWriteArrayList</h2>
<p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，对其进行的修改操作和元素迭代操作都是在底层创建一个拷贝的数组（快照）上进行的，也就是写时拷贝策略。CopyOnWriteArrayList 适合读多写少的场景，但如果应用在写操作频繁的场景下反而会降低性能。<br>
<img src="http://47.88.24.11/imgs/%E5%B9%B6%E5%8F%91/CopyOnWriteArrayList%E7%B1%BB%E5%9B%BE.png" alt="CopyOnWriteArrayList类图" title="CopyOnWriteArrayList类图"></p>
<ul>
<li>lock：保证写操作时的并发安全；</li>
</ul>
<h3 id="add-e-e"><a class="header-anchor" href="#add-e-e">¶</a>add(E e)</h3>
<p>添加操作拷贝了份快照，在快照上添加元素，最后替代原数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"></span><br><span class="line">    // 加独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取array</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        // 拷贝array到新数组，添加元素到新数组</span><br><span class="line">        // 新数组长度是原数组长度+1，可见CopyOnWriteArrayList是无界的</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line"></span><br><span class="line">        // 使用新数组替换添加前的数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放独占锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-int-index"><a class="header-anchor" href="#get-int-index">¶</a>get(int index)</h3>
<p>get 操作获取下标处的元素，实际上 get 可以被分解为以下两个步骤：</p>
<ol>
<li>获取 array 的引用；</li>
<li>通过下标访问 array 指定位置的元素。</li>
</ol>
<p>整个过程并没有加锁，如果在访问期间有另一个线程删除了某个元素，实际上因为修改操作是发生在原数组的一个快照上的，get 操作仍然获取的是原数组上的元素，因此不会发生类似数组越界的问题。但同时也不可避免这个过程带来的<strong>弱一致性</strong>，因为元素事实上已经被删除了却仍然可以被访问到。</p>
<h3 id="set-int-index-e-element"><a class="header-anchor" href="#set-int-index-e-element">¶</a>set(int index, E element)</h3>
<p>修改 list 中指定元素的值。</p>
<ul>
<li>如果指定位置的元素不存在则抛出 IndexOutOfBoundsException 异常；</li>
<li>如果指定位置元素与新值不一致，则创建新数组、在新数组上修改，最后设置新数组到 array（COW）。</li>
<li>即使没有变化，也还是需要重新设置一次 array，这主要是因为 array 本身是 volatile 的，set 方法应当提供 volatile 的语义。</li>
</ul>
<h3 id="remove-int-index"><a class="header-anchor" href="#remove-int-index">¶</a>remove(int index)</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    //获取独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        //获取数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line"></span><br><span class="line">        //获取指定元素</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line"></span><br><span class="line">        //如果要删除的是最后一个元素</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            //分两次拷贝除删除后的元素到新数组</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            //使用新数组代替老的                </span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-object-o"><a class="header-anchor" href="#remove-object-o">¶</a>remove(Object o)</h3>
<h3 id="remove-object-o-object-snapshot-int-index"><a class="header-anchor" href="#remove-object-o-object-snapshot-int-index">¶</a>remove(Object o, Object[] snapshot, int index)</h3>
<h3 id="iterator"><a class="header-anchor" href="#iterator">¶</a>iterator</h3>
<p>CopyOnWriteArrayList 中的 iterator 是弱一致性的，其他线程的修改操作对 iterator 不可见的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    //array的快照版本</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    //数组下标</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否遍历结束</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        if (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在该线程使用返回的迭代器遍历元素的过程中，其它线程没有对 list 进行增删改，那么 snapshot 本身就是 list 的 array，因为它们是引用关系。</li>
<li>如果在遍历期间存在其他线程对 list 的增删改操作，那么 snapshot 会成为原 array 的快照，此时其他线程对 list 进行的增删改是不可见的，因为它们操作的是两个不同的数组。</li>
</ul>
<h1>无锁队列</h1>
<h2 id="concurrentlinkedqueue"><a class="header-anchor" href="#concurrentlinkedqueue">¶</a>ConcurrentLinkedQueue</h2>
<ul>
<li>线程安全</li>
<li>无界</li>
<li>非阻塞</li>
</ul>
<h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3>
<p><img src="http://47.88.24.11/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%B1%BB%E5%9B%BE.png" alt="ConcurrentLinkedQueue类图" title="ConcurrentLinkedQueue类图"></p>
<ul>
<li>底层队列使用单向链表实现。</li>
<li>两个volatile的Node节点（head和tail）分别存放队列的首尾节点，从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">    head = tail = new Node(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Node节点内部为一个volatile修饰的变量item用来存放节点的值，next用来存放链表的下一个节点，从而链接成一个单向无界链表，如下图所示：<br>
<img src="http://47.88.24.11/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%9A%84%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="ConcurrentLinkedQueue的队列结构" title="ConcurrentLinkedQueue的队列结构"></li>
</ul>
<h3 id="入队-offer"><a class="header-anchor" href="#入队-offer">¶</a>入队 - offer</h3>
<p>使用CAS操作实现线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    // 从尾节点进行插入</span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        </span><br><span class="line">        // 如果q==null说明p是尾节点，则执行插入</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            // 使用CAS设置p节点的next节点</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                // cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点</span><br><span class="line">                if (p != t)</span><br><span class="line">                    casTail(t, newNode); // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p == q)</span><br><span class="line">            // 多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要</span><br><span class="line">            // 重新找新的head，因为新的head后面的节点才是正常的节点。</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">            //（8） 寻找尾节点</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="出队-poll"><a class="header-anchor" href="#出队-poll">¶</a>出队 - poll</h3>
<p>poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    // goto标记</span><br><span class="line">    restartFromHead:</span><br><span class="line"></span><br><span class="line">    // 无限循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            // 保存当前节点值</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            // 当前节点有值则cas变为null</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                //（5）cas成功标志当前节点以及从链表中移除</span><br><span class="line">                if (p != h) </span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前队列为空则返回null</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 自引用了，则重新找新的队列头节点</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            else</span><br><span class="line">                // </span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">    if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arrayblockingqueue-和-linkedblockingqueue"><a class="header-anchor" href="#arrayblockingqueue-和-linkedblockingqueue">¶</a>ArrayBlockingQueue 和 LinkedBlockingQueue</h2>
<h2 id="priorityblockingqueue"><a class="header-anchor" href="#priorityblockingqueue">¶</a>PriorityBlockingQueue</h2>
<h2 id="队列比较"><a class="header-anchor" href="#队列比较">¶</a>队列比较</h2>
<h2 id="disruptor"><a class="header-anchor" href="#disruptor">¶</a>Disruptor</h2>
<ul>
<li>
<p>无锁内存队列</p>
</li>
<li>
<p>优化 CPU 伪共享</p>
</li>
<li>
<p>RingBuffer<br>
环形队列，使用定长数组存储，长度是 2^N，可以使用位运算提升性能。<br>
无锁：无锁设计减少了竞争。<br>
预热：预先填充好任务/事件，不需要像链表那样每次添加/删除节点时去创建/回收节点，从而可以避免一定的垃圾回收。<br>
缓存行填充解决了 CPU 伪共享问题。</p>
</li>
<li>
<p>WorkPool<br>
存储 WorkProcessor 的池子，Disruptor 可以通过 Executor 并发启动每一个 WorkProcessor</p>
</li>
<li>
<p>WorkProcessor<br>
从 RindBuffer 消费事件/任务，并交由 WorkHandler 处理。</p>
</li>
<li>
<p>WorkHandler<br>
处理任务的工作者，根据任务类型委托给不同的 EventHandler。</p>
</li>
</ul>
<h2 id="logback-框架中异步日志打印中-arrayblockingqueue-的使用"><a class="header-anchor" href="#logback-框架中异步日志打印中-arrayblockingqueue-的使用">¶</a>Logback 框架中异步日志打印中 ArrayBlockingQueue 的使用</h2>
<p>异步模型是业务线程把要打印的日志任务写入一个队列后直接返回，然后使用一个线程专门负责从队列中获取日志任务写入磁盘，对用户线程来说，耗时只有将数据写入队列中。</p>
<h1>并发安全 Map</h1>
<h2 id="concurrenthashmap"><a class="header-anchor" href="#concurrenthashmap">¶</a>ConcurrentHashMap</h2>
<p><img src="http://47.88.24.11/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%BB%93%E6%9E%84.png" alt="ConcurrentHashMap结构" title="ConcurrentHashMap结构"></p>
<h3 id="get"><a class="header-anchor" href="#get">¶</a>get</h3>
<p>代码：java.util.concurrent.ConcurrentHashMap.get</p>
<ol>
<li>计算 key 的散列值，可以使用该散列值定位到散列表中的某个槽。<br>
如果 key 是自定义类型对象，需要实现重写 hash 方法。</li>
<li>找到对象<br>
hash 值是不精确匹配的，hash 值的关键是计算简单而且有一定的区分度，比如取 string 的前 3 位的和作为 hash 值。<br>
要精确匹配需要使用对象的 equals 方法。<br>
ConcurrentHashMap 中哈希槽的实现方法有两种：链表和红黑树，链表和红黑树的查找过程就不必细说了。</li>
</ol>
<h3 id="put"><a class="header-anchor" href="#put">¶</a>put</h3>
<p><img src="http://47.88.24.11/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C.png" alt="ConcurrentHashMap的put操作" title="ConcurrentHashMap的put操作"><br>
代码：java.util.concurrent.ConcurrentHashMap.put</p>
<ol>
<li>hash</li>
<li>找对象<br>
找对象过程与 get 的区别主要是 put 需要并发控制：
<ul>
<li>如果槽是空的，则通过 CAS 直接赋值；</li>
<li>如果槽非空，则先用<code>synchronized</code>锁住槽，接下来根据槽的数据结构来插入节点，如果槽是链表，则遍历链表找该 Node 是否已存在，不存在的情况下插入到末尾，如果槽是红黑树，则通过二叉树的遍历找目标 Node，找不到的情况下插入到叶子并重新执行红黑平衡。</li>
</ul>
</li>
</ol>
<h3 id="rehash"><a class="header-anchor" href="#rehash">¶</a>rehash</h3>
<p><code>java.util.concurrent.ConcurrentHashMap.transfer</code><br>
扩容的触发条件与HashMap一致。<br>
扩容流程大致上是：遍历哈希槽，对每个需要迁移的哈希槽进行<code>synchronized</code>加锁。<br>
当扩容开始后，其他线程必须等扩容完成后才能工作，但其他线程也不是就一直阻塞等扩容完成，而是调用<code>helpTransfer</code>方法一起帮助进行扩容，实际上扩容的单位是哈希槽，因此多线程并发执行扩容并不会导致冲突增加。</p>
<h3 id="size"><a class="header-anchor" href="#size">¶</a>size</h3>
<p>size操作返回的是一个不精确的值，因为进行统计的过程中，很有可能会有其他线程正在进行插入和删除操作。</p>
<p>1.8之前的size：</p>
<ol>
<li>遍历segments数组，将每个segment的count加起来作为总数，将modCount加起来作为修改总数；<br>
modCount会在每次segment被修改时+1（只增不减），用于比较。</li>
<li>再做一遍遍历，将这次的modCount总数和上一次的比较，如果一致则计数准确直接返回，否则重试；</li>
<li>如果重试了2次都不行，则第三次会对segment加锁再统计。</li>
</ol>
<p>1.8之后，没有了分段锁，size不会每次都遍历segments统计，而是在更新时修改总数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到，<code>ConcurrentHashMap#size</code>的结果就是：<br>
<code>baseCount + sum(counterCells)</code><br>
其中：</p>
<ul>
<li>baseCount：计数，总数发生变化时通过CAS修改</li>
<li>counterCells：如果baseCount CAS修改失败，作为兜底，类似LongAdder的思路。</li>
</ul>
<p>put操作的末尾会调用addCount()更新baseCount的值，如果CAS修改失败了，则使用counterCells，如果CAS修改 counterCells失败了，则使用fullAddCount方法继续死循环操作，直到成功。</p>
<h1>QA</h1>
<ol>
<li>
<p>JUC 并发包中并发组件 CopyOnWriteArrayList 的实现原理，CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？</p>
</li>
<li>
<p>什么是弱一致性？</p>
</li>
<li>
<p>说一下 ConcurrentHashMap。</p>
</li>
<li>
<p>ConcurrentHashMap 怎么实现并发安全？<br>
相对 Hashtable 来说 ConcurrentHashMap 的锁粒度是更小的，Hashtable 中使用 synchronized 实现的一种方法级的悲观锁，相当于把整个散列表锁住了，不利于系统整体吞吐量的提升。<br>
JDK1.7 中它使用的是一种分段锁来保证并发安全，是一种粒度较小的锁，写操作每次只锁住一个哈希槽，<br>
JDK1.8 之后改为通过实现一种基于 CAS 的乐观锁来保证并发安全，当然，和 HashMap 一样，每个哈希槽在增长到一定程度后会自动转换为红黑树。</p>
</li>
</ol>
<h1>参考</h1>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5550043.html" target="_blank" rel="noopener">【目录】JUC 集合框架目录</a></li>
<li><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">并发框架 Disruptor 译文</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4e8abc71.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/4e8abc71.html" itemprop="url">并发和线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T21:07:49+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="线程和状态机"><a class="header-anchor" href="#线程和状态机">¶</a>线程和状态机</h2>
<h3 id="线程和线程任务"><a class="header-anchor" href="#线程和线程任务">¶</a>线程和线程任务</h3>
<p>线程任务区别于线程，可以理解为线程需要执行的逻辑，类似 Thread 中要执行的 Runnable。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/4e8abc71.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b13b8cb6.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b13b8cb6.html" itemprop="url">Docker 与常用中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  98 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="zookeeper"><a class="header-anchor" href="#zookeeper">¶</a>ZooKeeper</h3>
<ol>
<li><a href="https://stackoverflow.com/questions/30940981/zookeeper-error-cannot-open-channel-to-x-at-election-address" target="_blank" rel="noopener">Zookeeper error: Cannot open channel to X at election address</a></li>
</ol>
<h3 id="elasticsearch"><a class="header-anchor" href="#elasticsearch">¶</a>Elasticsearch</h3>
<ol>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" target="_blank" rel="noopener">Install Elasticsearch with Docker</a></li>
<li><a href="http://blog.csdn.net/sbsujjbcy/article/details/52335325" target="_blank" rel="noopener">记一次 Docker 下安装 Logstash+Elasticsearch+Kibana 经历</a></li>
<li><a href="https://stackoverflow.com/questions/40341346/kibana-on-docker-cannot-connect-to-elasticsearch" target="_blank" rel="noopener">Kibana on Docker cannot connect to Elasticsearch</a></li>
<li><a href="https://www.cnblogs.com/aubin/p/8012840.html" target="_blank" rel="noopener">Elasticsearch 集群部署</a></li>
</ol>
<h3 id="docker-mysql"><a class="header-anchor" href="#docker-mysql">¶</a>Docker MySQL</h3>
<ol>
<li><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">Docker MySQL</a></li>
</ol>
<h3 id="docker-mysql-双机热备实现"><a class="header-anchor" href="#docker-mysql-双机热备实现">¶</a>Docker MySQL 双机热备实现</h3>
<ol>
<li><a href="https://github.com/Junnplus/blog/issues/1" target="_blank" rel="noopener">Mysql Master/Slave Replication With Docker</a></li>
<li><a href="http://blog.csdn.net/huaweitman/article/details/50853075" target="_blank" rel="noopener">Mysql 双机热备实现</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-docker.html" target="_blank" rel="noopener">2.5.6 Deploying MySQL on Linux with Docker</a></li>
<li><a href="https://blog.csdn.net/boling_cavalry/article/details/71055159" target="_blank" rel="noopener">让 docker 中的 mysql 启动时自动执行 sql</a></li>
<li><a href="https://www.2cto.com/database/201503/386265.html" target="_blank" rel="noopener">MySQL 主从复制资料汇总</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/89826705.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/89826705.html" itemprop="url">Docker 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="docker-是什么"><a class="header-anchor" href="#docker-是什么">¶</a>Docker 是什么</h2>
<ul>
<li>Docker 是开源应用容器引擎，轻量级容器技术。</li>
<li>基于 Go 语言，并遵循 Apache2.0 协议开源。</li>
<li>Docker 可以让开发者打包他们的应用、依赖包及配置文件打包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 系统上，也可以实现虚拟化。</li>
<li>容器完全使用沙箱技术，相互之间不会有任何接口。</li>
<li>类似于虚拟机技术（vmware、vitural），但 docker 直接运行在操作系统（Linux）上，而不是运行在虚拟机中，速度快，性能开销极低。<br>
Docker 支持将软件编译成一个<strong>镜像</strong>，然后在镜像中对各种软件做好配置，将镜像发布出去（Docker Hub），其他使用者可以直接使用这个镜像。 运行中的这个镜像称为容器，容器启动是非常快速的。类似 windows 里面的 ghost 操 作系统，安装好后什么都有了。<br>
docker<strong>容器</strong>可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</li>
</ul>
<h3 id="常见应用场景"><a class="header-anchor" href="#常见应用场景">¶</a>常见应用场景</h3>
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h3 id="docker-特点"><a class="header-anchor" href="#docker-特点">¶</a>Docker 特点</h3>
<p>Docker 是一个基于容器的应用开发、部署和运行平台，它为开发者和系统管理员们提供了一种新式的应用部署方式，具有灵活（最复杂的应用都能容器化）、轻量（容器共享一个服务器内核）、可替换的（可以在容器运行过程中更新服务器）、可移植的（本地、云上皆可）、可伸缩的（可以轻松地进行复制）、可栈化（指的是可以将多个服务部署在一起，比如用 docker-compose）的特性。<br>
Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.<br>
Containerization is increasingly popular because containers are:</p>
<ul>
<li>Flexible: Even the most complex applications can be containerized.</li>
<li>Lightweight: Containers leverage and share the host kernel.</li>
<li>Interchangeable: You can deploy updates and upgrades on-the-fly.</li>
<li>Portable: You can build locally, deploy to the cloud, and run anywhere.</li>
<li>Scalable: You can increase and automatically distribute container replicas.</li>
<li>Stackable: You can stack services vertically and on-the-fly.</li>
</ul>
<h3 id="docker-优势"><a class="header-anchor" href="#docker-优势">¶</a>Docker 优势</h3>
<p>容器技术相比虚拟机，主要优势在于性能上，其性能优势可以说达到了一个量级的差距。根据 Boden Russell 在 OpenStack 上做的一次基准测试报告，一个 KVM 实例的平均内存消耗有 292MB，而一个 docker 实例的平均内存消耗在 49MB 左右。在 CPU overhead 和启动时间方面，docker 基本都比 KVM 有一个量级的优势。<br>
目前，一个 AWS 上的 micro 实例，每小时的按需使用成本大约在一美分多一些。如果用 docker 来提供实例，那么每小时的按需使用成本很可能会做到 0.1 美分。这一点对于云经济至关重要。正如经济学家 William Stanley Jevons 的理论所呈现的，随着商品的价格越便宜，人们使用它们的场景和频率会越来越多。</p>
<ol>
<li>container 是一种部署单元，用户可以自由决定部署的范围（dev、test、production），即组织容器的方式，换句话说，容器可以简化工作流和软件的开发、部署生命周期；</li>
<li>可以从传统的虚拟机环境平滑过渡到裸机生产环境内；<br>
保证了线上线下环境的一致性。我们在线下的开发环境使用 Docker 构建好 weaapp 的镜像后，可以直接在线上使用一个镜像，保证了线上线下环境的一致性，再也不会有在线下开发环境中运行正常，而部署到线上各种错误了。</li>
<li>实现了模块化，提高了复用性。<br>
我们可以将数据库和 Tomcat 运行在不同的容器中，从某种角度来说，这也降低了模块之间的耦合性，便于拓展。比如我们要把 MySQL 替换为 oracle，只需要再构建一个 oracle 镜像并启动与 Tomcat 连接即可，非常方便。对于我们构建的镜像，在其他 app 中直接拿来用就可以了，不必重复劳动。</li>
<li>提高整体效率；<br>
极大的简化了 webapp 的部署流程。在不使用 Docker 时，我们部署 app 时，要先搭建好 app 运行所需环境，这个过程做过的人都知道多么枯燥繁琐，一不小心还出错。而有了 Docker，我们只需要直接构建一个我们 webapp 的镜像然后将其运行即可，无论在多少台服务器中部署，都是如此。再比如，使用 Docker 之前要搭建一个 WordPress 对于新手来说是有些困难的，而有了 Docker，只需要从 DockerHub 上 pull 一个 WordPress 镜像并启动就可以了，非常非常方便。</li>
<li>实现了虚拟化，提高硬件利用率，有了 Docker，我们可以在一台服务器上运行很多 webapp，充分利用闲置资源。<br>
这时候，服务器的操作系统就类似于货轮，而一个个 Docker 容器就相当于货轮上的一个个集装箱。现在大热的云服务市场，不少就用了 Docker。举个例子来说，现在我们有一台操作系统为 Ubuntu14.04 的服务器，我们构建不同版本的 ubuntu 镜像并启动，并且为不同的用户分配不同的容器。这样，用一台服务器可以虚拟出 n 个运行着不同操作系统的虚拟服务器，而对于用户来说，这些是透明的––用户则认为自己拥有一台完整的服务器。据我推测，阿里云的服务器就是这么干的。这充分利用了闲置的硬件资源。</li>
<li>Fast
<ul>
<li>传统方式慢，传统情况下，应用服务器扩容缩容步骤繁多流程冗长,从服务器申请、初始化、应用部署、测试、加入退出集群、服务器下线。比如，业务遇到突发的流量高峰时,无法进行快速的扩容,当准备好的时候可能流量高峰已经过去了。</li>
<li>传统不稳定，代码上线发布历经多个环境,在某个环境中测试时修复了 bug,代码等无法及时同步各环境中,提升了服务上线的风险。</li>
<li>Runtime performance at near bare metal speeds (typically 97+ percent or bare metal – a few ticks shaven off for bean counters).</li>
<li>Management operations (boot, stop, start, reboot, etc.) in seconds or milliseconds.</li>
</ul>
</li>
<li>Agile
<ul>
<li>VM-like agility – it’s still “virtualization”.</li>
<li>Seamlessly move between virtual and bare metal environments permitting new development workflows which reduce costs (e.g. develop on VMs and move to bare metal in the “click of a button” for production).</li>
</ul>
</li>
<li>Flexible
<ul>
<li>Containerize a “system” (OS less the kernel).</li>
<li>Containerize “application(s)”.</li>
</ul>
</li>
<li>Lightweight
<ul>
<li>Just enough Operating System (JeOS); include only what you need reducing image and container bloat.</li>
<li>Minimal per container penalty which equates to greater density and hence greater returns on existing assets – imagine packing 100s or 1000s of containers on a single host node.</li>
</ul>
</li>
<li>Inexpensive
<ul>
<li>Open source – free – lower TCO.</li>
<li>Supported with out-of-the-box modern Linux kernels.</li>
</ul>
</li>
<li>Ecosystem
<ul>
<li>Growing in popularity – just checkout the google trends for docker or LXC.</li>
<li>Vibrant community and numerous 3rd party applications (1000s of prebuilt images on docker index and 100s of open source apps on github or other public sources).</li>
</ul>
</li>
<li>Cloudy
<ul>
<li>Various Cloud management frameworks provide support for creating and managing Linux Containers – including <strong>OpenStack</strong> my personal favorite.</li>
</ul>
</li>
</ol>
<h3 id="docker-劣势"><a class="header-anchor" href="#docker-劣势">¶</a>Docker 劣势</h3>
<p>既然容器技术有如此大的优势，为什么基于容器的云现在还没有成为主流？我认为主要还是安全性的问题。虚拟机可以利用来自硬件的信任机制来提升安全性，这些机制在 Intel Virtualization Technology Evolution 的演示中有详细的介绍。即使如此，虚拟机仍然被视为相对不安全，比如前一段时间 Xen（半虚拟化，在硬件层和 OS 层之间的虚拟层）爆出一个漏洞，导致 AWS 不得不大量升级自己的主机。</p>
<ol>
<li>Docker Hub（镜像管理中心）不稳定<br>
第一个就是很重要的 Docker Hub 的访问问题。我们知道国内访问一些海外的网站有时候会有稳定性的问题。Docker Hub 在我们的实践中就经常出现访问不了的问题。但这种访问的问题并不是持续的，而是时有时无。由于大量的成熟 Docker 映像（image）都需要从 Docker Hub 下载，很多脚本在执行到这一步时，结果很难预料。一种方案是修改缺省的 Docker Hub 地址，改为采用国内的一些镜像（mirror）。但是在没有官方认证的成熟稳定的镜像网站时，Docker 映像的更新不容易得到保证；另一种方案是自行搭建自己的 Docker Hub。但是一来这样就失去了强大的社区贡献的映像资源，二来要花费很多精力来保持更新和同步。容器技术带来的简单化，又因为映像管理而复杂化，得不偿失。</li>
<li>运维难度大<br>
第二个就是容器技术的资源管理和运维。因为容器技术本身更适于解决大规模应用场景，所以通常都是集群基础上的部署、运维，但是目前对这一系列任务的自动化处理尚无统一的或者标准的框架。如果要让 Docker 真正在实际环境中发挥最大的效能并且易于维护，就需要有很成熟稳定的资源编排（orchestration）、资源调度（scheduling）和部署（deployment）的支持，但是这方面暂时还没有很明显的最佳解决方案，所以大多数人都在摸索和搭建自己的解决方案。我们在微软开放技术内部也是在一些开源技术的基础之上，自行开发了容器在微软公有云 Azure 上的资源管理调度和部署运维的系统，传统上的开发运维和持续集成，持续部署的技术，比如 Chef，Puppet，Jenkins 等，都可以很容易的与容器技术一起工作。</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://github.com/docker-library/official-images" target="_blank" rel="noopener">docker-library / official-images</a></li>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li>
<li><a href="http://www.dockone.io/article/932" target="_blank" rel="noopener">十分钟带你理解 Kubernetes 核心概念</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">122</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
