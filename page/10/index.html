<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/10/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/10/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b791cedc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b791cedc.html" itemprop="url">微服务核心技术总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>微服务是一种架构风格，需要注意的是它并不能与 Docker、Spring Cloud 划等号，只是这些技术栈能更好地实现微服务，这篇文档中我希望总结一下实现微服务最常用的技术。</p>
<h2 id="微服务基本概念"><a class="header-anchor" href="#微服务基本概念">¶</a>微服务基本概念</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<h3 id="为什么要使用微服务"><a class="header-anchor" href="#为什么要使用微服务">¶</a>为什么要使用微服务</h3>
<h3 id="架构与组织"><a class="header-anchor" href="#架构与组织">¶</a>架构与组织</h3>
<h3 id="中台战略与微服务"><a class="header-anchor" href="#中台战略与微服务">¶</a>中台战略与微服务</h3>
<h3 id="微服务架构风格"><a class="header-anchor" href="#微服务架构风格">¶</a>微服务架构风格</h3>
<h3 id="微服务架构"><a class="header-anchor" href="#微服务架构">¶</a>微服务架构</h3>
<h2 id="服务发现-eureka"><a class="header-anchor" href="#服务发现-eureka">¶</a>服务发现 - Eureka</h2>
<h3 id="eureka-的目标"><a class="header-anchor" href="#eureka-的目标">¶</a>Eureka 的目标</h3>
<p>原来：负载均衡器会根据配好的 IP 和主机名来进行负载均衡，但是对 AWS cloud 这样体量的系统来说，因为服务实例宕机恢复十分频繁，所以负载均衡器还会有一个更复杂的注册 / 注销服务的机制。<br>
现在：Eureka 在中间层提供一种负载均衡的可能。</p>
<h3 id="eureka-vs-zookeeper"><a class="header-anchor" href="#eureka-vs-zookeeper">¶</a>Eureka VS ZooKeeper</h3>
<ul>
<li>Eureka 能提供 REST 接口来动态调整配置、renewals、expiration、cancel 等；</li>
<li>Eureka 倾向于高可用，而不是 ZooKeeper 的高一致性。</li>
<li>Eureka 可以集成到应用中，ZooKeeper 只能作为一个外部组件提供服务，这会增加复杂性、增加系统崩溃的几率。</li>
</ul>
<h3 id="组成部分"><a class="header-anchor" href="#组成部分">¶</a>组成部分</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Eureka组件结构" title="Eureka组件结构"></p>
<ul>
<li>负载均衡：Eureka Client 提供最简单的轮询<strong>负载均衡</strong>策略，可以封装 Eureka 并根据更多的因素（流量、资源使用、异常发生频次等）来提供一种更好的弹性伸缩特性。</li>
<li>分区：每个 Region 有一个 Eureka 集群用于处理该区域服务失败的情况，各 Region 之间是不会互相通信的。</li>
<li>服务注册到 Eureka Server 后每 30 秒发送一次<strong>心跳（heartbeats）<strong>来刷新</strong>租约（lease）</strong>，如果网络出现分区或者 Eureka 宕机了，这种心跳自然会停止，如果达到了<strong>Renews threshold</strong>（即 Server 期望在每分钟中收到的心跳次数，需要考虑是否禁用服务器的自注册、Server/Client 数量等，暂时取默认值 85%就好），Eureka Server 就会将其从服务注册表中移除。</li>
<li>服务注册信息会自动同步到整个 Eureka Server 集群，这也意味着它们是对等的 P2P 集群。</li>
<li>集成到业务服务中的 Eureka Client 可以查询服务注册信息（默认每 30 秒一次）来定位服务及进行远程调用。</li>
</ul>
<h3 id="服务状态机"><a class="header-anchor" href="#服务状态机">¶</a>服务状态机</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E5%AE%9E%E4%BE%8B%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="Eureka实例状态机" title="Eureka实例状态机"></p>
<ul>
<li>STARTING：启动中的状态，应用可以在这个阶段做一些初始化工作</li>
<li>UP：可以正常进行通信；</li>
<li>DOWN：心跳停了，一般是宕机了或者网络出现了分区</li>
<li>OUT_OF_SERVICE：因为某些特殊原因无法提供服务，比如 Elasticsearch 因为没有达到最小可用分片数，或者由于蓝绿发布的需要，新版本如果发布后有问题可以直接将实例状态置为 OUT_OF_SERVICE 来达到回滚的目的。</li>
<li>UNKNOWN：WTF？</li>
</ul>
<h3 id="client-与-server-间的交互"><a class="header-anchor" href="#client-与-server-间的交互">¶</a>Client 与 Server 间的交互</h3>
<h4 id="register"><a class="header-anchor" href="#register">¶</a>Register</h4>
<p>Eureka Client 将信息注册到 Eureka Server，注册过程发生在第一次心跳时（在 30 秒后）。</p>
<h4 id="unregister"><a class="header-anchor" href="#unregister">¶</a>Unregister</h4>
<p>正常情况下，Client 必须显式调用 Unregister 来释放自己的注册信息，除非是由于&quot;unclean termination&quot;而导致心跳丢失超过 3 次。</p>
<h4 id="renew"><a class="header-anchor" href="#renew">¶</a>Renew</h4>
<p>客户端每30秒通过发送一次心跳（heartbeats）来续约（renewal），心跳告知Eureka Server本实例仍然存活，如果Server在90秒内没有收到续约请求，它将从服务注册表中移除该实例。</p>
<h4 id="fetch-registry"><a class="header-anchor" href="#fetch-registry">¶</a>Fetch Registry</h4>
<p>Eureka clients fetches the registry information from the server and csort_bufferhes it locally. After that, the clients use that information to find other services. This information is updated periodically (every 30 seconds) by getting the delta updates between the last fetch cycle and the current one. The delta information is held longer (for about 3 mins) in the server, hence the delta fetches may return the same instances again. The Eureka client automatically handles the duplicate information.</p>
<p>After getting the deltas, Eureka client reconciles the information with the server by comparing the instance counts returned by the server and if the information does not match for some reason, the whole registry information is fetched again. Eureka server caches the compressed payload of the deltas, whole registry and also per application as well as the uncompressed information of the same. The payload also supports both JSON/XML formats. Eureka client gets the information in compressed JSON format using jersey apache client.</p>
<h4 id="cancel"><a class="header-anchor" href="#cancel">¶</a>Cancel</h4>
<p>Eureka client sends a cancel request to Eureka server on shutdown. This removes the instance from the server’s instance registry thereby effectively taking the instance out of traffic.</p>
<p>This is done when the Eureka client shuts down and the application should make sure to call the following during its shutdown.<br>
DiscoveryManager.getInstance().shutdownComponent()</p>
<h4 id="time-lag"><a class="header-anchor" href="#time-lag">¶</a>Time Lag</h4>
<p>All operations from Eureka client may take some time to reflect in the Eureka servers and subsequently in other Eureka clients. This is because of the caching of the payload on the eureka server which is refreshed periodically to reflect new information. Eureka clients also fetch deltas periodically. Hence, it may take up to 2 mins for changes to propagate to all Eureka clients.</p>
<h4 id="communication-mechanism"><a class="header-anchor" href="#communication-mechanism">¶</a>Communication mechanism</h4>
<p>Eureka Client默认使用Jersey发送基于Jackson封装的JSON数据包给Eureka Server。</p>
<h4 id="通信协议"><a class="header-anchor" href="#通信协议">¶</a>通信协议</h4>
<p>Eureka 不限制通信协议，Thrift、HTTP(S)等均可。</p>
<h3 id="高可用"><a class="header-anchor" href="#高可用">¶</a>高可用</h3>
<p>Eureka Client 的高可用设计：</p>
<ul>
<li>Client 中有<strong>服务注册表的缓存</strong>，即使所有 Server 都挂掉了，Client 还是能继续工作。</li>
<li>刚开始，Eureka Client 会尝试与同一 <strong>zone</strong>（可视为同一局域网）中的 Eureka Server 交互，如果交互出现问题或同一 zone 中没有可用的 Eureka Server，则它将转向其他 zone。</li>
</ul>
<p>Eureka Server 的高可用设计：</p>
<ul>
<li>启动 Server 时<strong>从邻居节点获取注册信息</strong>，一个不行换另一个，直到获取成功，如果从邻居节点均无法获取到注册信息，则它会等待几分钟（默认 5 分钟）让 Client 注册它们的信息<br>
Server 之间获取服务注册信息的机制和 Client 从 Server 获取的一样。<br>
获取成功后，Server 会设置<code>Renewal Threshold</code>并开始接收 Client 的心跳；</li>
<li>保护模式：如果<code>Renews(last min)</code>（上一分钟内收到的心跳次数）达到了<code>Renews threshold</code>（Server 期望在每分钟中收到的心跳次数，一般是 3），或者过去 15 分钟内的统计数据小于<code>eureka.server.renewalPercentThreshold</code>（renews / renews threshold 的比值，默认为 0.85，当在 15 分钟内微服务心跳数低于 85%，则 Server 会进入自我保护状态，在这种情况下 Server 不会删除注册信息），则进入<strong>保护模式</strong>，自我保护状态其实是为了防止突发网络不稳定或断电时微服务心跳数剧减，导致微服务注册信息被大量删除的情况。<br>
在保护模式下，Client 可能从 Server 得到已经不可用的 IP（服务器已不存在或因某些原因无法响应），因此 Client 必须保证这种情况下的弹性高可用，比如快速地超时并重试其他服务器。</li>
<li>退出保护模式：在保护模式下，Eureka Server 会停止移除服务注册信息，直到满足如下条件中的任意之一：
<ol>
<li>心跳<code>Renews</code>达到了<code>Renews threshold</code>；</li>
<li>保护模式被禁用，设置<code>eureka.server.enableSelfPreservation=false</code>。</li>
</ol>
</li>
<li>孤儿 Server：当发生网络分区，一些 Eureka Server 可能会成为<code>orphaned server</code>，一些 Client 会注册到这些 Server 上，导致一些 Client 能看到这些注册信息而其他的一些则不能。<br>
当网络恢复后，Server 的 P2P 集群能正常地交互，注册信息会被自动同步到所有 Server 上。</li>
</ul>
<h3 id="异常情况"><a class="header-anchor" href="#异常情况">¶</a>异常情况</h3>
<p>比如在测试环境中出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>在生产上可以开自注册，部署两个 server</li>
<li>在本机器上测试的时候，可以把比值调低，比如 0.49</li>
<li>或者简单粗暴把自我保护模式关闭：eureka.server.enableSelfPreservation=false</li>
</ul>
<h3 id="eureka-配置"><a class="header-anchor" href="#eureka-配置">¶</a>Eureka 配置</h3>
<p>配置：<br>
<a href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka" target="_blank" rel="noopener">Configuring Eureka</a><br>
Eureka Server 开放的 REST 接口提供动态配置功能：<br>
<a href="https://github.com/Netflix/eureka/wiki/Eureka-REST-operations" target="_blank" rel="noopener">Eureka REST operations</a></p>
<h4 id="添加自定义元数据"><a class="header-anchor" href="#添加自定义元数据">¶</a>添加自定义元数据</h4>
<p>静态设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.metadata.mykey=myvalue</span><br></pre></td></tr></table></figure>
<p>设置后，相当于将<code>mykey:myvalue</code>添加到 eureka 的<code>metadata map</code>中。<br>
动态设置：<br>
需要提供一个自定义的</p>
<p>获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myValue = instanceInfo.getMetadata().get(&quot;myKey&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<h4 id="原生客户端的执行过程"><a class="header-anchor" href="#原生客户端的执行过程">¶</a>原生客户端的执行过程</h4>
<p>EurekaClient</p>
<h4 id="通过-di-依赖注入-使用-eurekaclient"><a class="header-anchor" href="#通过-di-依赖注入-使用-eurekaclient">¶</a>通过 DI（依赖注入）使用 EurekaClient</h4>
<p>ExampleEurekaGovernatedService</p>
<h4 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h4>
<p>DefaultEurekaClientConfig extends EurekaClientConfig<br>
EurekaServerConfig extends DefaultEurekaServerConfig<br>
CloudInstanceConfig extends PropertiesInstanceConfig<br>
MyDataCenterInstanceConfig extends PropertiesInstanceConfig</p>
<p>To dynamically do this, you will need to first provide your own custom implementation of the <code>EurekaInstanceConfig</code> interface. You can then overload the public Map&lt;String, String&gt; getMetadataMap() method to return a metadata map that contains the desired metadata values. See <code>PropertiesInstanceConfig</code> for an example implementation that provides the configuration based system above.</p>
<h2 id="网关-zuul"><a class="header-anchor" href="#网关-zuul">¶</a>网关 - Zuul</h2>
<h3 id="filter"><a class="header-anchor" href="#filter">¶</a>Filter</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Zuul%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Zuul组件结构" title="Zuul组件结构"><br>
Zuul 基于 Netty 开发，使用 filters 包含了核心业务逻辑，Filter 是使用 Groovy 写的，主要是为了提供动态编译加载的能力，filters 主要包含了三类：</p>
<ul>
<li>Inbound Filters execute before routing to the origin and can be used for things like authentication, dynamic routing, rate limiting, DDoS protection, metrics and decorating the request.</li>
<li>Endpoint Filters can be used to return static responses, otherwise the built-in <code>ProxyEndpoint</code> filter will route the request to the origin.</li>
<li>Outbound Filters execute after getting the response from the origin and can be used for metrics, decorating the response to the user or adding custom headers.</li>
<li>Async<br>
Filter 可以被同步执行或异步执行。<br>
如果 Filter 没有做太重的工作，可以通过继承<code>HttpInboundSyncFilter</code>或<code>HttpOutboundSyncFilter</code>来实现一种同步 Filter，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>Routes.groovy</code>；<br>
反之，如果需要从其他服务、缓存获取数据，或做一些复杂的计算工作，则最好继承<code>HttpInboundFilter</code>或<code>HttpOutboundFilter</code>，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>SampleServiceFilter.groovy</code>。</li>
</ul>
<h4 id="filter属性"><a class="header-anchor" href="#filter属性">¶</a>Filter属性</h4>
<p>Type: most often defines the stage during the routing flow when the Filter will be applied (although it can be any custom string)<br>
Async: define if the filter is sync or async, generally meaning do you need to make an external call or just doing work on-box<br>
Execution Order: applied within the Type, defines the order of execution across multiple Filters<br>
Criteria: the conditions required in order for the Filter to be executed<br>
Action: the action to be executed if the Criteria is met</p>
<h4 id="其他的一些例子"><a class="header-anchor" href="#其他的一些例子">¶</a>其他的一些例子</h4>
<p>这些例子是<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">zuul-sample</a>中的代码。</p>
<ul>
<li>DebugRequest - look for a query param to add extra debug logging for a request</li>
<li>Healthcheck - simple static endpoint filter that returns 200, if everything is bootstrapped correctly</li>
<li>ZuulResponseFilter - add informational headers to provide extra details on routing, request execution, status and error cause</li>
<li>GZipResponseFilter - can be enabled to gzip outbound responses</li>
<li>SurgicalDebugFilter - can be enabled to route specific requests to different hosts for debugging</li>
</ul>
<h3 id="缓存请求体"><a class="header-anchor" href="#缓存请求体">¶</a>缓存请求体</h3>
<p>默认情况下 Zuul 不会缓存请求体，因为 Filter 一般用到请求头就够了，但是如果需要在 inbound 中用到请求头或在 outbound 中用到响应头，则需要明确指定 Zuul 缓存，可以重写 Filter 的<code>needsBodyBuffered()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">boolean needsBodyBuffered(HttpResponseMessage input) &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络协议"><a class="header-anchor" href="#网络协议">¶</a>网络协议</h3>
<p>Zuul 支持修改暴露服务时使用的协议，使用方法见 sample 项目中的<code>SampleServerStartup</code>。</p>
<h3 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h3>
<p><a href="https://github.com/Netflix/zuul/wiki/Core-Features" target="_blank" rel="noopener">Core Features</a></p>
<h3 id="push-messaging"><a class="header-anchor" href="#push-messaging">¶</a>Push Messaging</h3>
<p>Push Messaging 机制可以支持从 Server 端推送消息到 Client 端，支持两种协议：<code>WebSockets</code> 和 <code>Server Sent Events (SSE)</code>。<br>
<a href="https://github.com/Netflix/zuul/wiki/Push-Messaging" target="_blank" rel="noopener">Push Messaging</a><br>
TODO</p>
<h2 id="负载均衡-ribbon"><a class="header-anchor" href="#负载均衡-ribbon">¶</a>负载均衡 - Ribbon</h2>
<h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3>
<p>原生 API 如何使用见：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started" target="_blank" rel="noopener">Netflix / ribbon - Getting Started</a><br>
如果是搭配 Spring Boot，可以参考 Spring Could 文档。</p>
<h3 id="组件结构及实现"><a class="header-anchor" href="#组件结构及实现">¶</a>组件结构及实现</h3>
<h4 id="rule"><a class="header-anchor" href="#rule">¶</a>Rule</h4>
<p>a logic component to determine which server to return from a list</p>
<ul>
<li>RoundRobinRule<br>
简单的轮询策略</li>
<li>AvailabilityFilteringRule<br>
这个 Rule 会跳过那些疑似“电路跳闸”或并发连接数已经很高的服务器。<br>
比如客户端的最后 3 次连接失败，客户端会认为该服务实例已经出现了类似“电路跳闸”的问题而导致无法提供服务，于是在接下来的 30 秒内均保持这种状态，如果之后还是连接失败，这个等待时间会指数增长（1min、2min、4min…）。</li>
<li>WeightedResponseTimeRule<br>
每个 Server 会根据其平均响应时间计算出一个权重，响应时间越长、比重越小，该 Rule 选择 Server 时会根据该权重来计算概率。</li>
</ul>
<h4 id="ping"><a class="header-anchor" href="#ping">¶</a>Ping</h4>
<p>a component running in background to ensure liveness of servers</p>
<h4 id="serverlist"><a class="header-anchor" href="#serverlist">¶</a>ServerList</h4>
<p>this can be static or dynamic. If it is dynamic (as used by <code>DynamicServerListLoadBalancer</code>), a background thread will refresh and filter the list at certain interval</p>
<ul>
<li>静态的 Server 列表<br>
可以在程序里写一个静态列表，将该列表设置到<code>BaseLoadBalancer.setServerList()</code>中。</li>
<li>ConfigurationBasedServerList<br>
默认的 ServerList 实现，可以通过 <code>Archaius ConfigurationManager</code>来设置 Server 列表。</li>
<li>DiscoveryEnabledNIWSServerList<br>
可以通过 Eureka Client 获取服务器列表，服务器集群必须通过 VipAddress 来定义：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="serverlistfilter"><a class="header-anchor" href="#serverlistfilter">¶</a>ServerListFilter</h4>
<p>ServerListFilter 是<code>DynamicServerListLoadBalancer</code>的组件，用于过滤从<code>ServerList</code>返回的服务器列表，现在有两种实现：</p>
<ul>
<li>
<p>ZoneAffinityServerListFilter<br>
过滤掉不在同一个 zone 内的服务器，除非 zone 内没有可用的服务器，这个 Filter 可以通过设置如下属性来启用（假设客户端名为 myclient、客户端的属性空间为 ribbon）：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myclient.ribbon.EnableZoneAffinity=true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ServerListSubsetFilter<br>
可以保证客户端只能看到<code>ServerList</code>返回的全体服务器的一个固定子集，如果有服务器可用性较弱，则可以定期用新服务器替换老服务器。可以通过设置以下属性启用该Filter：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br><span class="line">myClient.ribbon.NIWSServerListFilterClassName=com.netflix.loadbalancer.ServerListSubsetFilter</span><br><span class="line"># only show client 5 servers. default is 20.</span><br><span class="line">myClient.ribbon.ServerListSubsetFilter.size=5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码-v2"><a class="header-anchor" href="#源码-v2">¶</a>源码</h3>
<p>com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateListOfServers<br>
com.netflix.loadbalancer.ServerList#getUpdatedListOfServers<br>
com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery<br>
TODO</p>
<h2 id="hystrix"><a class="header-anchor" href="#hystrix">¶</a>Hystrix</h2>
<p><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">wiki</a></p>
<h2 id="turbine"><a class="header-anchor" href="#turbine">¶</a>Turbine</h2>
<p><a href="https://github.com/Netflix/Turbine/wiki" target="_blank" rel="noopener">wiki</a></p>
<h2 id="微服务基础设施-配置中心"><a class="header-anchor" href="#微服务基础设施-配置中心">¶</a>微服务基础设施 - 配置中心</h2>
<p>在设计微服务架构的时候常会提到一个<strong>无状态</strong>的概念，我们要求每个服务都是无状态的，因此可以做到一次编译到处运行，这也是<strong>云原生</strong>的基本要求——云环境下服务的实例集群可以弹性伸缩，</p>
<h3 id="配置分类"><a class="header-anchor" href="#配置分类">¶</a>配置分类</h3>
<p>应用服务中的配置主要分为静态配置和动态配置两类：<strong>静态配置</strong>主要和应用所处的环境有关，另外与其他服务器连接所需的用户名、密码等也需要在应用运行伊始便准备好，</p>
<ul>
<li>
<p>静态配置-环境相关：</p>
</li>
<li>
<p>静态配置-安全配置：</p>
</li>
<li>
<p>动态配置-应用配置：</p>
</li>
<li>
<p>动态配置-</p>
</li>
</ul>
<h3 id="apollo"><a class="header-anchor" href="#apollo">¶</a>Apollo</h3>
<h2 id="微服务基础设施-rpc"><a class="header-anchor" href="#微服务基础设施-rpc">¶</a>微服务基础设施 - RPC</h2>
<h2 id="微服务基础设施-后台框架"><a class="header-anchor" href="#微服务基础设施-后台框架">¶</a>微服务基础设施 - 后台框架</h2>
<h2 id="微服务基础设施-监控"><a class="header-anchor" href="#微服务基础设施-监控">¶</a>微服务基础设施 - 监控</h2>
<h2 id="微服务基础设施-服务-sla-service-level-agreement"><a class="header-anchor" href="#微服务基础设施-服务-sla-service-level-agreement">¶</a>微服务基础设施 - 服务 SLA（Service Level Agreement）</h2>
<p>熔断、限流、降级</p>
<h2 id="微服务基础设施-持续交付-continuous-delivery-简称-cd"><a class="header-anchor" href="#微服务基础设施-持续交付-continuous-delivery-简称-cd">¶</a>微服务基础设施 - 持续交付（Continuous delivery，简称 CD）</h2>
<h2 id="虚拟化"><a class="header-anchor" href="#虚拟化">¶</a>虚拟化</h2>
<p>虚拟化技术将一台服务器虚拟出多个虚拟机来提供服务。<br>
虚拟化技术包括计算虚拟化（服务器虚拟化）、存储虚拟化、网络虚拟化等。<br>
在实际讲解虚拟化之前，我们需要先解释一下隔离技术，在隔离的基础上我们才能任意粒度、自由地分配资源。</p>
<h3 id="隔离的作用"><a class="header-anchor" href="#隔离的作用">¶</a>隔离的作用</h3>
<ul>
<li>实现更细粒度的资源管理，比如将一个物理 CPU 的计算能力分给多台云主机，再将这台云主机卖给多个人。</li>
<li>控制故障的影响范围，一个 Tomcat 中可以运行多个 Web 服务器，一台 Web 服务器崩溃并不会令其他服务器一并崩溃。</li>
</ul>
<h3 id="隔离的分类"><a class="header-anchor" href="#隔离的分类">¶</a>隔离的分类</h3>
<p>广义的隔离技术包括如下几类</p>
<ul>
<li>硬件：虚拟机，如 KVM、Xen</li>
<li>操作系统：容器，如 LXC、Docker</li>
<li>Web 服务器：如 Servlet 容器</li>
<li>依赖版本：虚拟环境</li>
<li>运行环境：语言虚拟机，如JVM</li>
<li>语言：DSL</li>
</ul>
<p>前两种隔离是<strong>虚拟化技术</strong>的基础，主要用于物理资源的池化，进而弹性地分配给用户。<br>
作为一个例子，下面是一个运行时服务器中各抽象层次所采取的隔离技术的示意图：<br>
<img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%9A%94%E7%A6%BB%E5%B1%82%E6%AC%A1.png" alt="隔离层次" title="隔离层次"></p>
<p>上述隔离技术探讨的是单机环境下的资源分配，在微服务中聚焦的是如何提供更好的服务，因此可以在以下几个方向实施<strong>数据隔离</strong>：</p>
<ul>
<li>应用数据隔离<br>
多个业务服务器使用不同的数据库服务器，虽然有隔离故障、提高数据安全等好处，但是也引入了分布式事务的问题。</li>
<li>租户隔离<br>
提供统一的云服务，但是对不同的用户分组单独使用一些服务实例来提供服务，这样这些服务实例挂掉了也只会影响对应分组的用户，这样的用户分组称为<strong>租户</strong>。<br>
对于单独的一个租户，有独立服务独立数据库、共享服务独立数据库和共享服务共享数据库三种方式，可以根据成本和安全性来考虑选择哪种方案。</li>
</ul>
<p>对于业务服务器来说，更重要的是业务层面上的隔离：</p>
<ul>
<li>业务层<br>
平台与业务，业务与业务。</li>
<li>Provider，即服务提供者<br>
如订单服务和库存服务，使用上面提到的虚拟化来实现隔离，如果；</li>
<li>Consumer，即服务消费者<br>
下游服务调用多个上游服务（upstream）的时候，如果不对上游服务做服务隔离，一个服务出现问题，就会导致下游服务不可用，这种情况下，可选的隔离方案可以是给每个上游服务都准备一个线程池，称为<strong>线程池隔离</strong>：<br>
<img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%E9%9A%94%E7%A6%BB.png" alt="服务消费者端隔离" title="服务消费者端隔离"><br>
这种情况下，就算其中一个服务不可用导致线程池被迅速占满，下游服务仍可以根据预定义的降级方案来忽略这个服务。<br>
另一种可行的隔离方式是<strong>信号量隔离</strong>，常见的框架包括 Hytrix、Sentinel、以及 Resilience4j。</li>
</ul>
<h3 id="网络虚拟化"><a class="header-anchor" href="#网络虚拟化">¶</a>网络虚拟化</h3>
<p>我们暴露服务时使用的 IP 一般不是业务服务器网卡的真实 IP，而是另外配置的一个虚拟 IP，请求先被打到该 IP，然后由 LVS 等负载均衡技术来找到一个真实 IP。</p>
<p><strong>虚拟网卡</strong>通过实现一个字符设备来支持物理层，从而使应用层和物理层就通过这个字符设备联系起来，从这个字符设备读出来的就是虚拟网卡发往物理层的字节流，写入字符设备的数据作为字节流被虚拟网卡接收。<br>
虚拟网卡可以像网卡一样进行配置，常见的虚拟网卡有<strong>TUN/TAP</strong>和<strong>VEth</strong>。<br>
**虚拟网桥（Bridge）**也是一种虚拟设备，用于将多块网卡（包括虚拟网卡）连接起来。<br>
值得注意的是， Linux 中虚拟网桥是通用网络设备抽象的一种，能够绑定 IP 地址。因此在把网卡接入到网桥上后，网卡原来绑定的 IP 会失效，如果还要像原来那样收发数据，需要把该 IP 绑定到网桥上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加网桥br0</span><br><span class="line">ip link add br0 type bridge</span><br><span class="line"># 把网卡接入网桥，在把eth0和eth1接入到br0后，两个网卡就可以进行通信了。</span><br><span class="line">ip link set eth0 master br0</span><br><span class="line">ip link set eth1 master br0</span><br><span class="line"># 为网桥绑定ip</span><br><span class="line">ip addr add xx.xx.xx.xx/xx dev br0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">        inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:17ff:fe6b:bb81 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:17:6b:bb:81 txqueuelen 0 (Ethernet)</span><br><span class="line">        RX packets 0 bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">        TX packets 151 bytes 16620 (16.6 KB)</span><br><span class="line">        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br><span class="line"></span><br><span class="line">veth780318a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">        inet6 fe80::2c08:2dff:fea1:b996 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 2e:08:2d:a1:b9:96 txqueuelen 0 (Ethernet)</span><br><span class="line">        RX packets 0 bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">        TX packets 227 bytes 24338 (24.3 KB)</span><br><span class="line">        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br></pre></td></tr></table></figure>
<p>由 Docker Daemon 创建的虚拟网卡 docker0 其实就是一个网桥，可以使用 ethtool 查看设备类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -i docker0</span><br><span class="line"># 输出</span><br><span class="line">driver: bridge</span><br><span class="line">version: 2.3</span><br><span class="line">firmware-version: N/A</span><br><span class="line">expansion-rom-version: </span><br><span class="line">bus-info: N/A</span><br><span class="line">supports-statistics: no</span><br><span class="line">supports-test: no</span><br><span class="line">supports-eeprom-access: no</span><br><span class="line">supports-register-dump: no</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure>
<p>根据官方文档，Docker 通过 docker0 网桥在内核层连通了其他的物理或虚拟网卡，从而将所有容器和宿主都放到同一个物理网络下。<br>
veth780318a 是一个 VEth 设备，在容器启动后动态创建。每次启动一个容器的时候，Docker 会新建一对 VETH 设备，其中一个插在 docker0 上，另一个插在该容器里，然后从可用的地址段中选择一个空闲的 IP 地址分配给容器的 VEth，使用 docker0 的 IP 作为默认网关，从而实现宿主机和容器的双向数据通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -S veth780318a</span><br><span class="line"># 输出</span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 8</span><br><span class="line"></span><br><span class="line">$ ip link</span><br><span class="line"># 输出</span><br><span class="line">9: veth780318a@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 2e:08:2d:a1:b9:96 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>上边的 veth780318a@if8 的 peer_ifindex 为 9，和其对应的 VEth 设备的 peer_ifindex 为 8。</p>
<p>接下来可以进入容器查看是否存在对应的 peer_ifindex 为 9 的虚拟网卡（下面的是教程中的执行效果，我并没有执行成功，因为普通的容器镜像里面一般没有安装常用的网络工具）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@4c04df175784:/# ip route show</span><br><span class="line">default via 172.17.42.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.1</span><br><span class="line"></span><br><span class="line"># 从这里可以看出veth741a889的“伙伴”确实是在容器中，被重命名为eth0作为容器的网卡，并绑定了ip172.17.0.5，网关为网桥的ip172.17.42.1。</span><br><span class="line">root@4c04df175784:/# ifconfig</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:05</span><br><span class="line">          inet addr:172.17.0.5 Bcast:0.0.0.0 Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:5/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:648 (648.0 B) TX bytes:648 (648.0 B)</span><br><span class="line"></span><br><span class="line">root@4c04df175784:/# ethtool -S eth0</span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 24</span><br><span class="line"></span><br><span class="line">root@4c04df175784:/# ethtool -i eth0</span><br><span class="line">driver: veth</span><br><span class="line">version: 1.0</span><br><span class="line">firmware-version:</span><br><span class="line">bus-info:</span><br><span class="line">supports-statistics: yes</span><br><span class="line">supports-test: no</span><br><span class="line">supports-eeprom-access: no</span><br><span class="line">supports-register-dump: no</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure>
<h4 id="tun-tap-tunnel"><a class="header-anchor" href="#tun-tap-tunnel">¶</a>TUN/TAP(Tunnel)</h4>
<p>TUN 工作在 OSI 第三层(network)，实现了 IP 包的转发，相当于路由。<br>
TAP 工作在 OSI 第二层(data link)，实现了 Ethernet 帧的转发，相当于网桥。<br>
操作系统通过 TUN/TAP 设备向绑定该设备的用户空间的程序发送数据，反之，用户空间的程序也可以像操作硬件网络设备那样通过 TUN/TAP 设备发送数据，然后 TUN/TAP 设备会向操作系统的网络栈 push（或 inject）数据包，从而模拟从外部接受数据的过程。<br>
TUN 常用于 VPN，通过使用 TUN，VPN 能够在 IP 包被发出去之前将其进行加密。<br>
TAP 常用于虚拟机，为虚拟机提供网卡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip tuntap add mode tap # 创建tap</span><br><span class="line">ip tuntap add mode tun # 创建tun</span><br></pre></td></tr></table></figure>
<h4 id="veth-virtual-ethernet"><a class="header-anchor" href="#veth-virtual-ethernet">¶</a>VEth（Virtual Ethernet）</h4>
<p>VEth 是成对出现的，它的作用是反转通讯数据的方向，当数据从网络栈发送到 VEth 的一端时，数据被传送到 VEth 的另外一端流出，然后放回网络栈，相当于把需要接受的数据转换成需要发送的数据，<br>
常用于虚拟化中穿透 network namespace，把从一个 network namespace 发出的数据包转发到另一个 namespace。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth1 type veth peer name veth2 # 创建一对VEth，名为veth1和veth2</span><br></pre></td></tr></table></figure>
<h3 id="服务器虚拟化"><a class="header-anchor" href="#服务器虚拟化">¶</a>服务器虚拟化</h3>
<h4 id="插槽-内核和内核线程"><a class="header-anchor" href="#插槽-内核和内核线程">¶</a>插槽、内核和内核线程</h4>
<p>虚拟机如何分配 CPU 数：<a href="https://www.it610.com/article/3322954.htm" target="_blank" rel="noopener">vSphere 中 CPU 资源如何分配</a></p>
<h4 id="xen-kvm-与-lxc"><a class="header-anchor" href="#xen-kvm-与-lxc">¶</a>Xen、KVM 与 LXC</h4>
<p>TODO<br>
服务器虚拟化的三种比较常见的技术。<br>
Xen：<br>
KVM：<br>
LXC：</p>
<h4 id="lxc-的使用方法"><a class="header-anchor" href="#lxc-的使用方法">¶</a>LXC 的使用方法</h4>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lxc</span><br><span class="line">lxc-checkconfig # 安装完成后, 用这个命令检查系统是否可以使用 lxc</span><br><span class="line"># 我执行后没有发现missing的情况，如果没有挂载cgroup可能会出现“Cgroup namespace: CONFIG_CGROUP_NSmissing”的错误，可以挂载一个cgroup</span><br><span class="line">mount -t cgroup cgroup /mnt/cgroup</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc-create -n test -t debian # # 创建一个 debian 系统</span><br></pre></td></tr></table></figure>
<p>这样创建的容器默认在 /var/lib/lxc/test 中, 为了将容器创建在我们指定的位置, 可以写个简单的配置文件 lxc.conf, 里面只需要一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc.rootfs = /home/lxc/test</span><br></pre></td></tr></table></figure>
<p>然后重新创建容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc-create -n test -t debian -f /path/to/lxc.conf</span><br></pre></td></tr></table></figure>
<p>这样, 就把容器创建在了 /home/lxc/test 中了, /var/lib/lxc/test 中只有一个 config 文件(这个 config 文件可以作为 lxc-create 命令 -f 参数对应配置文件的参考)</p>
<ol start="3">
<li>启动容器<br>
启动后就进行入了虚拟机的控制台了. (果然像传说一样, 几秒就启动完成了 <sup>_</sup>)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-start -n test</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>停止容器<br>
在主机中输入停止的命令.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-stop -n test</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>销毁容器<br>
销毁之前, 可以通过 lxc-ls 来查看有几个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc-ls</span><br><span class="line">  test</span><br><span class="line">lxc-destroy -n test</span><br><span class="line">lxc-ls</span><br></pre></td></tr></table></figure>
<h4 id="使用示例-配置-python-uliweb-开发环境"><a class="header-anchor" href="#使用示例-配置-python-uliweb-开发环境">¶</a>使用示例（配置 python uliweb 开发环境）</h4>
<p>尝试在容器配置一次开发环境, 然后通过复制容器, 形成多个虚拟机.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 主机中</span><br><span class="line">root@debian-113:~# uliweb # 主机中没有安装uliweb 软件包</span><br><span class="line">-bash: uliweb: command not found</span><br><span class="line">root@debian-113:~# lxc-start -n test</span><br><span class="line"># 虚拟机登录界面, 输入用户名和密码</span><br><span class="line"># 虚拟机中</span><br><span class="line">root@test:~# apt-get install python</span><br><span class="line">root@test:~# apt-get install python-pip</span><br><span class="line">root@test:~# pip install Uliweb</span><br><span class="line">root@test:~# uliweb --version</span><br><span class="line">Uliweb version is 0.3.1</span><br></pre></td></tr></table></figure>
<p>主机中设置网桥, 虚拟机用桥接方式上网, 确保每个虚拟机有独立的 IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 主机中</span><br><span class="line">root@debian-113:~# lxc-stop -n test</span><br><span class="line">root@debian-113:~# apt-cache search bridge-utils</span><br><span class="line">root@debian-113:~# brctl addbr br0</span><br><span class="line"># 配置主机的网桥</span><br><span class="line">root@debian-113:/var/lib/lxc/test# cat /etc/network/interfaces </span><br><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># and how to activate them. For more information, see interfaces(5).</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">#auto eth0</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 追加的网桥配置    </span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 192.168.1.113</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">   bridge_ports eth0</span><br><span class="line">   bridge_stp on</span><br><span class="line">   bridge_fd 0</span><br><span class="line"></span><br><span class="line">root@debian-113:/var/lib/lxc/test# /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>
<p>配置容器的网络(也是在主机中修改容器的配置文件)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@debian-113:/var/lib/lxc/test# cat /var/lib/lxc/test/config</span><br><span class="line">... ... (很多默认生成的配置)</span><br><span class="line"># network &lt;-- 这个 network 相关的是要追加的</span><br><span class="line">lxc.network.type = veth</span><br><span class="line">lxc.network.flags = up</span><br><span class="line">lxc.network.link = br0</span><br><span class="line">lxc.network.name = eth0</span><br></pre></td></tr></table></figure>
<p>启动 Linux 容器, 进入虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@debian-113:/var/lib/lxc/test# lxc-start -n test</span><br><span class="line"># 登录进入虚拟机, 确认虚拟机的IP</span><br><span class="line">root@test:~# cat /etc/network/interfaces &lt;-- 默认是自动获取IP</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">root@test:~# ifconfig &lt;-- 我的机器自动分配的 192.168.1.167</span><br><span class="line"># 创建一个简单的uliweb工程</span><br><span class="line">root@test:~# cd /home/</span><br><span class="line">root@test:/home# mkdir CM-web</span><br><span class="line">root@test:/home# cd CM-web/</span><br><span class="line">root@test:/home/CM-web# uliweb makeproject test</span><br><span class="line">root@test:/home/CM-web# cd test/</span><br><span class="line">root@test:/home/CM-web/test# uliweb makeapp first_app</span><br><span class="line">root@test:/home/CM-web/test# uliweb runserver -h 0.0.0.0</span><br></pre></td></tr></table></figure>
<p>启动 Web 服务后, 就可以在主机的浏览器中 通过 <a href="http://192.168.1.167:8000/" target="_blank" rel="noopener">http://192.168.1.167:8000/</a> 来访问虚拟机中的 web 服务了.<br>
最后, 复制一个新的容器, 也就是再重新生成一个上面的 python uliweb 开发环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在主机中</span><br><span class="line">root@debian-113:~# cd /var/lib/lxc</span><br><span class="line">root@debian-113:/var/lib/lxc# cp -r test test2</span><br><span class="line"># 修改 test2/config 如下</span><br><span class="line">lxc.utsname = test2 &lt;-- 修改名称</span><br><span class="line">xc.rootfs = /home/lxc/test2 &lt;-- 修改 rootfs位置</span><br><span class="line">... ... &lt;-- 其它部分不用修改, 和 test 一样就行</span><br><span class="line">root@debian-113:/var/lib/lxc# cd /home/lxc/</span><br><span class="line">root@debian-113:/home/lxc# cp -r test test2 &lt;-- 重新复制一份 rootfs</span><br><span class="line">root@debian-113:/home/lxc# lxc-start -n test2 &lt;-- 启动 test2 虚拟机, 其中环境和 test一样, IP会不一样, 自动获取的</span><br><span class="line"># 进入 test2 虚拟机中, 可以直接启动之前的 uliweb 测试工程, 也可以从主机中访问其web服务.</span><br></pre></td></tr></table></figure>
<h3 id="lxc"><a class="header-anchor" href="#lxc">¶</a>LXC</h3>
<h4 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h4>
<p>通过 namespace 进行资源的隔离,Gust1 下的进程与 Guset2 下的进程是独立的，可以看作运行在两台物理机上一样。Contaniner 管理工具就是对 Guest 进行管理的(创建、销毁)。<br>
下图是对 LXC 架构的介绍。</p>
<h3 id="虚拟化管理平台"><a class="header-anchor" href="#虚拟化管理平台">¶</a>虚拟化管理平台</h3>
<p>虚拟化虽然可以用于自由分配资源，但是在生产环境内如果要一台一台机器安装及配置并不现实，一般来说都会尝试使用一个管理平台来自动化、批量化虚拟机的管理，或者从零开始使用 Libvirt 这样的库来实现自己需要的功能。<br>
如 <strong>Libvirt</strong> 库提供了一套用于管理虚拟机和其他虚拟化功能的 Linux API，它支持各种虚拟机监控程序，包括 Xen 和 KVM，以及 QEMU 和用于其他操作系统的一些虚拟产品。</p>
<h3 id="容器管理平台"><a class="header-anchor" href="#容器管理平台">¶</a>容器管理平台</h3>
<p>容器管理平台与其他虚拟化平台有所不同，因为和微服务关系密切，所以更关注高可用、弹性扩展等特性，如Docker Swam、Kubernetes。</p>
<h2 id="集群-分布式系统与云服务"><a class="header-anchor" href="#集群-分布式系统与云服务">¶</a>集群、分布式系统与云服务</h2>
<h3 id="集群与分布式系统"><a class="header-anchor" href="#集群与分布式系统">¶</a>集群与分布式系统</h3>
<p>集群与分布式系统是容易混淆的概念，很多时候会被混用，具体来说：</p>
<ul>
<li>集群是一个业务部署在多个服务器上，目标是高可用；</li>
<li>分布式系统是一个业务被拆分成多个子业务部署在不同的服务器上，目标是高性能。</li>
</ul>
<h3 id="数据层-分库分表"><a class="header-anchor" href="#数据层-分库分表">¶</a>数据层 - 分库分表</h3>
<h3 id="业务层-负载均衡"><a class="header-anchor" href="#业务层-负载均衡">¶</a>业务层 - 负载均衡</h3>
<p>二层：通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；<br>
三层：通过一个 VIP 地址接收请求，然后再分配到真实的 IP 地址；<br>
四层：传输层（一般是 TCP），通过 VIP+端口接收请求，然后再分配到真实的服务器，如 F5、LVS、seesaw；<br>
七层：应用层，通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器，如 Nginx（同样支持在四层工作）、HAProxy。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="常见实现"><a class="header-anchor" href="#常见实现">¶</a>常见实现</h3>
<ol>
<li><a href="https://cloud.spring.io/spring-cloud-netflix/reference/html/" target="_blank" rel="noopener">Document - Spring Cloud Netflix</a></li>
<li><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Netflix/eureka</a></li>
<li><a href="https://github.com/Netflix/zuul/blob/master/zuul-sample/src/main/java/com/netflix/zuul/sample/SampleServerStartup.java" target="_blank" rel="noopener">Netflix/zuul</a></li>
<li><a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">Netflix/ribbon</a></li>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Netflix / Hystrix</a></li>
<li><a href="https://github.com/Netflix/Turbine" target="_blank" rel="noopener">Netflix / Turbine</a></li>
</ol>
<h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3>
<ol>
<li><a href="https://github.com/cfregly/fluxcapacitor" target="_blank" rel="noopener">Flux Capacitor</a></li>
<li><a href="https://github.com/Netflix/recipes-rss" target="_blank" rel="noopener">Netflix Recipes-RSS Reader</a></li>
</ol>
<h3 id="隔离"><a class="header-anchor" href="#隔离">¶</a>隔离</h3>
<ol>
<li><a href="https://blog.csdn.net/ceshi986745/article/details/51787424" target="_blank" rel="noopener">猿学~程序员必知的六种隔离技术</a></li>
<li><a href="https://mp.weixin.qq.com/s/M1AePRMGWh49mXcN9MyXGw" target="_blank" rel="noopener">谈谈怎么做【服务隔离】</a></li>
</ol>
<h3 id="虚拟化-v2"><a class="header-anchor" href="#虚拟化-v2">¶</a>虚拟化</h3>
<ol>
<li>网络设备虚拟化<br>
<a href="http://blog.sina.com.cn/s/blog_b5e965e80102wos3.html" target="_blank" rel="noopener">网络设备设备虚拟化</a><br>
<a href="http://mp.weixin.qq.com/s/SC_j1cCm-kgOkCPKPjL5SQ" target="_blank" rel="noopener">一文搞懂网络虚拟化</a><br>
<a href="http://mp.weixin.qq.com/s/2KaHYOxyvZw1B6PhmjN_vw" target="_blank" rel="noopener">从 Bridge 到 OVS，探索虚拟交换机</a><br>
<a href="https://feisky.gitbooks.io/sdn/linux/virtual-device.html" target="_blank" rel="noopener">虚拟网络设备</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/index.html" target="_blank" rel="noopener">Linux 上的基础网络设备详解</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77840343" target="_blank" rel="noopener">Linux-虚拟网络设备-LinuxBridge</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77854651" target="_blank" rel="noopener">Linux-虚拟网络设备-tun/tap</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77650937" target="_blank" rel="noopener">Linux-虚拟网络设备-veth pair</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/78021303" target="_blank" rel="noopener">Linux-虚拟网络设备-OpenvSwitch(持续更新)</a></li>
<li>硬件虚拟化<br>
<a href="http://www.360doc.com/content/12/0213/14/7982302_186299987.shtml" target="_blank" rel="noopener">硬件虚拟化技术浅析</a><br>
<a href="http://veck.logdown.com/posts/200566-compare-of-kvm-and-lxc" target="_blank" rel="noopener">Compare of Xen, KVM, LXC and Traditional VM</a></li>
<li>Libvirt<br>
<a href="https://libvirt.org/" target="_blank" rel="noopener">Libvirt</a></li>
<li>Xen<br>
<a href="https://www.xenproject.org/" target="_blank" rel="noopener">Xen</a></li>
<li>KVM<br>
<a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">Kernel Virtual Machine（KVM）</a><br>
<a href="http://oenhan.com/kvm-src-1" target="_blank" rel="noopener">KVM 源代码分析 1:基本工作原理</a><br>
<a href="https://mp.weixin.qq.com/s/WzpH653x1hS9_PBVrIJFuw" target="_blank" rel="noopener">在 Centos6.5 上部署 kvm 虚拟化技术</a></li>
<li>LXC<br>
<a href="https://www.cnblogs.com/xidongyu/p/5767020.html" target="_blank" rel="noopener">LXC 的介绍</a><br>
<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LinuX Container（LXC）</a><br>
<a href="http://www.cnblogs.com/wang_yb/p/3923040.html" target="_blank" rel="noopener">Linux 容器的使用</a></li>
<li>Docker<br>
<a href="http://dockone.io/article/2050" target="_blank" rel="noopener">使用 NGINX 和 NGINX Plus 进行 Docker Swarm 负载均衡</a><br>
DockerSwarm 提供的负载均衡运行于每个节点上（应该是 DockerService 中的某个 Job），提供有限的负载均衡服务（TCP 层负载均衡），因此引入 Nginx 是有道理的。<br>
据说 Nginx Plus 可以实现<strong>服务弹性伸缩</strong>的功能，但还没试过。</li>
</ol>
<h3 id="集群-分布式系统与云服务-v2"><a class="header-anchor" href="#集群-分布式系统与云服务-v2">¶</a>集群、分布式系统与云服务</h3>
<ol>
<li>负载均衡<br>
<a href="https://github.com/google/seesaw" target="_blank" rel="noopener">google/seesaw</a></li>
<li>云原生<br>
<a href="https://mp.weixin.qq.com/s/gwXNBZzvygKV5xW1dfiQTA" target="_blank" rel="noopener">关于云原生，这是最详细的技术知识</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/10511d14.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/10511d14.html" itemprop="url">Linux 脚本基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T10:18:28+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>记录一些平时看到或用过的 shell 脚本技巧和代码片段。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/10511d14.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/59c58f8f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/59c58f8f.html" itemprop="url">Linux 三剑客-cut、awk 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在 awk、sed、cut 三个命令中，awk 是功能最强大的，基本能实现所有字符串操作，平时常用于较复杂的日志分析，不过比起别的命令来也会相对复杂一点。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/59c58f8f.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/9acacb00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/9acacb00.html" itemprop="url">Kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="kubectl-的安装"><a class="header-anchor" href="#kubectl-的安装">¶</a>kubectl 的安装</h2>
<p><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-macos" target="_blank" rel="noopener">Install and Set Up kubectl</a></p>
<h2 id="kubernetes-含义"><a class="header-anchor" href="#kubernetes-含义">¶</a>kubernetes 含义</h2>
<h3 id="kubernetes-master"><a class="header-anchor" href="#kubernetes-master">¶</a>Kubernetes Master</h3>
<p>Kubernetes Master 主要负责管理集群，它会协调集群内的所有活动，包括：scheduling applications, maintaining applications’ desired state, scaling applications, and rolling out new updates。<br>
Master 实际上是三个进程的集合，它们运行在集群的一个 Master Node 上，这三个进程包括：</p>
<ul>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" target="_blank" rel="noopener">kube-apiserver</a>：提供<a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">REST-API</a>来操作 Kubernetes Objects，包括 pods、services、replicationcontrollers 等，并可用于控制集群状态。</li>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>：通过 apiserver 监听集群状态并做状态转移操作。</li>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" rel="noopener">kube-scheduler</a>：scheduler 可以根据集群的拓扑结构、性能、容量等动态分配资源。</li>
</ul>
<h3 id="node"><a class="header-anchor" href="#node">¶</a>Node</h3>
<p>Node 是一台虚拟机或物理电脑，在集群中作为 Worker。Master 管理 Cluster，而 Node 则管理应用。<br>
每个 Node 都有一个 Kubelet，是管理 Node 的媒介，且负责与 Kubernetes Master 进行交互。<br>
每个 Node 还需要有工具来处理容器操作，比如 Docker 或 rkt。<br>
一个生产环境的 cluster 必须由至少 3 个 Node 组成。</p>
<h4 id="kubelet"><a class="header-anchor" href="#kubelet">¶</a><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" target="_blank" rel="noopener">kubelet</a></h4>
<p>节点代理，负责和 Kubernetes Master 交互：</p>
<ul>
<li>向 apiserver 注册节点</li>
<li>其他云计算指定逻辑。</li>
</ul>
<h4 id="kube-proxy"><a class="header-anchor" href="#kube-proxy">¶</a><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="noopener">kube-proxy</a></h4>
<p>运行于每个 Node 上的一个网络代理，可以执行简单的 TCP、UDP、SCTP 流转发或提供多后端进程的负载均衡。<br>
相当于在主机和 Cluster 之间创建了一个连接，让我们能直接访问 API。</p>
<h3 id="pod"><a class="header-anchor" href="#pod">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a></h3>
<p>一个或多个应用容器集合的抽象，并且包含一些共享资源，包括：</p>
<ul>
<li>共享存储，如 Volumes；</li>
<li>网络连接，每个 Pod 具有 Cluster 中唯一的一个 IP 地址；</li>
<li>运行每个容器所必须的信息，比如容器镜像的版本、端口等。</li>
</ul>
<p>Pod 建模了一种“logical host”，可以同时运行多种不同的容器。<br>
当 Pod 所处的 Node 挂了，<code>ReplicaSet</code>会动态地创建新 Pod 来使得 Cluster 回到原来的状态。</p>
<h3 id="service"><a class="header-anchor" href="#service">¶</a><a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service</a></h3>
<p>Service 定义了 Pod 的逻辑集合及其访问规则，虽然每个 Pod 都有一个唯一的 IP 地址（Cluster 范围内），但是如果没有 Service 的话这些 IP 也是没法暴露到 Cluster 外的，可以通过指定 ServiceSpec 中的<code>type</code>来指定暴露服务的方式：</p>
<ul>
<li>ClusterIP (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster.</li>
<li>NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. Superset of ClusterIP.</li>
<li>LoadBalancer - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort.</li>
<li>ExternalName - Exposes the Service using an arbitrary name (specified by <code>externalName</code> in the spec) by returning a CNAME record with the name. No proxy is used. This type requires v1.7 or higher of <code>kube-dns</code>.</li>
</ul>
<h3 id="volumes"><a class="header-anchor" href="#volumes">¶</a><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">Volumes</a></h3>
<h3 id="namespaces"><a class="header-anchor" href="#namespaces">¶</a><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">Namespaces</a></h3>
<h3 id="deployments"><a class="header-anchor" href="#deployments">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a></h3>
<p>负责创建和更新应用实例，创建 Deployment 后，Master 会持续监听并在各 Node 中调度应用实例，一旦有实例挂掉或被删掉，Deployment controller 就会用 Cluster 中另一 Node 上的实例取代之。</p>
<ul>
<li>searched for a suitable node where an instance of the application could be run (we have only 1 available node)</li>
<li>scheduled the application to run on that Node</li>
<li>configured the cluster to reschedule the instance on a new Node when needed</li>
</ul>
<h3 id="daemonset"><a class="header-anchor" href="#daemonset">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet</a></h3>
<h3 id="statefulsets"><a class="header-anchor" href="#statefulsets">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets</a></h3>
<h3 id="replicaset"><a class="header-anchor" href="#replicaset">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet</a></h3>
<h3 id="jobs"><a class="header-anchor" href="#jobs">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="noopener">Jobs</a></h3>
<h2 id="kubernetes-使用"><a class="header-anchor" href="#kubernetes-使用">¶</a>kubernetes 使用</h2>
<p>可以采用<code>kubectl</code>命令来和 Cluster 交互，<code>kubectl</code>最常用的操作只有如下 4 种：</p>
<ul>
<li>kubectl get - list resources</li>
<li>kubectl describe - show detailed information about a resource</li>
<li>kubectl logs - print the logs from a container in a pod</li>
<li>kubectl exec - execute a command on a container in a pod</li>
</ul>
<h3 id="创建cluster"><a class="header-anchor" href="#创建cluster">¶</a>创建Cluster</h3>
<p>例子中使用<code>minikube</code>创建 Cluster，然后使用<code>kubectl</code>来和创建的 Cluster 交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">minikube version</span><br><span class="line"># 启动一个Cluster</span><br><span class="line">minikube start</span><br><span class="line"># 查看客户端（kubectl的版本）和服务端（Kubernetes的版本）的版本</span><br><span class="line">kubectl version</span><br><span class="line"># Cluster的详细信息</span><br><span class="line">kubectl cluster-info</span><br><span class="line"># 获取Cluster内的Node列表</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<ol>
<li>创建部署单元（Deployment）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Deploymnet</span><br><span class="line">kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1</span><br><span class="line"># 查看Deployment</span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"># 查看Pod</span><br><span class="line">kubectl get pods</span><br><span class="line"># 查看Pod内Container的属性，比如使用的是什么镜像</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure>
<h3 id="访问"><a class="header-anchor" href="#访问">¶</a>访问</h3>
<ol>
<li>使用 proxy 访问 Service 和 Pod</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建proxy实例</span><br><span class="line">kubectl proxy</span><br><span class="line"># 创建proxy后可以在另一个终端调用REST API来查看Cluster信息</span><br><span class="line">curl http://localhost:8001/version</span><br><span class="line"># 查看Pod的名字</span><br><span class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</span><br><span class="line">echo Name of the Pod: $POD_NAME</span><br><span class="line"># 可以通过proxy直接访问Pod</span><br><span class="line">curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</span><br></pre></td></tr></table></figure>
<ol>
<li>查看日志</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 所有应用发送给STDOUT的信息都会成为Pod容器的日志</span><br><span class="line">kubectl logs $POD_NAME</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 exec 命令访问 Pod</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看Pod内的环境变量</span><br><span class="line">kubectl exec $POD_NAME env</span><br><span class="line"># 在Pod中一个容器内启动一个bash会话，相当于登入了该容器</span><br><span class="line">kubectl exec -ti $POD_NAME bash</span><br></pre></td></tr></table></figure>
<h3 id="service-v2"><a class="header-anchor" href="#service-v2">¶</a>Service</h3>
<ol>
<li>创建 Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看Service</span><br><span class="line">kubectl get services</span><br><span class="line"># 创建一个新的Service并暴露端口（type=NodePort可以用于占用一个Node上的端口来暴露服务）</span><br><span class="line">kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br><span class="line"># 查看Service信息</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<ol>
<li>Deployment 与 Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 8080其实是集群内的一个逻辑端口，可以通过以下命令获取Node上暴露的端口</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line"># 然后我们可以通过curl访问Node上的端口来确认Service已经被暴露到了Cluster外</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line"></span><br><span class="line"># Deployment会自动为Pod创建一个label，可以通过如下命令来查看</span><br><span class="line">kubectl describe deployment</span><br><span class="line"># 通过label查看Pod列表和Service列表</span><br><span class="line">kubectl get pods -l run=kubernetes-bootcamp</span><br><span class="line">kubectl get services -l run=kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<ol>
<li>Service 中的 Pod</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先获取Pod的名字</span><br><span class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</span><br><span class="line">echo Name of the Pod: $POD_NAME</span><br><span class="line"># 通过label命令可以设置一个新的label</span><br><span class="line">kubectl label pod $POD_NAME app=v1</span><br><span class="line"># 之后可以使用describe 命令来查看这些label，也可以使用label来查询Pod</span><br><span class="line">kubectl describe pods $POD_NAME</span><br><span class="line">kubectl get pods -l app=v1</span><br></pre></td></tr></table></figure>
<ol>
<li>删除 Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 删除一个Service</span><br><span class="line">kubectl delete service -l run=kubernetes-bootcamp</span><br><span class="line"># 查看服务列表，该服务已经被删除</span><br><span class="line">kubectl get services</span><br><span class="line"># curl端口确认不再暴露服务</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br><span class="line"># 我们可以在Pod中运行curl来确定应用仍运行于Pod中</span><br><span class="line">kubectl exec -ti $POD_NAME curl localhost:8080</span><br><span class="line"># 如果需要终止应用，则需要同时删除Deployment</span><br></pre></td></tr></table></figure>
<h3 id="app-扩展"><a class="header-anchor" href="#app-扩展">¶</a>app 扩展</h3>
<p><img src="http://47.88.24.11/imgs/Kubernetes/scaling.svg" alt="scaling" title="scaling"><br>
上图来自<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/" target="_blank" rel="noopener">官网教程</a>，Scaling 即修改 Deployment 中的 Pod 数。</p>
<ol>
<li>扩展 ReplicaSet（Scale Up）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先看下部署了几个Pod</span><br><span class="line">kubectl get deployments</span><br><span class="line"># 查看Deployment创建的ReplicaSet，ReplicaSet名的格式为[DEPLOYMENT-NAME]-[RANDOM-STRING]</span><br><span class="line">kubectl get rs</span><br><span class="line"># 将Deployment扩展为4个复制</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br><span class="line"># 查看Deployment及其中的Pod</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"># 查看Deployment的时间日志</span><br><span class="line">kubectl describe deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<ol>
<li>Load Balancing</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个NODE_PORT环境变量来保存Node暴露的端口</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line"># curl访问多次，会发现请求被负载均衡到了不同的Pod上</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br></pre></td></tr></table></figure>
<ol>
<li>缩小（Scale Down）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 再运行一次scale命令来缩小ReplicaSet</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=2</span><br><span class="line"># 查看伸缩结果</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>
<h3 id="滚动更新-rolling-update"><a class="header-anchor" href="#滚动更新-rolling-update">¶</a>滚动更新（Rolling Update）</h3>
<ol>
<li>更新应用版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 先看看Cluster里有啥</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br><span class="line"># 查看应用当前使用的镜像版本</span><br><span class="line">kubectl describe pods</span><br><span class="line"># 使用set image命令设置应用的镜像版本</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br><span class="line"># 可以通过Pod查看应用的更新过程</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ol>
<li>验证更新</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 确认应用正在运行中</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br><span class="line"># 用一个NODE_PORT环境变量保存Node暴露的端口，然后用curl确认暴露的服务可以使用</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br><span class="line"># 更新同样可以使用rollout status命令来确认</span><br><span class="line">kubectl rollout status deployments/kubernetes-bootcamp</span><br><span class="line"># 查看应用当前使用的镜像的版本</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure>
<ol>
<li>回滚（Rollback）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置镜像进行更新，但是这个镜像的v10版本是不存在的，因此会引起更新失败</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</span><br><span class="line"># 查看Deployment的当前状态，会发现某些Pod运行不正常</span><br><span class="line">kubectl get deployments</span><br><span class="line"># 查看Pod状态，describe能提供更多信息</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pods</span><br><span class="line"># 发现问题，可以使用rollout undo命令来回滚，rollout命令会复原deployment到上一已知状态。实际上所有更新操作都是版本化的，并且每次更新都可以回滚到之前的任意版本</span><br><span class="line">kubectl rollout undo deployments/kubernetes-bootcamp</span><br><span class="line"># 接下来再查看Pod的状态可以发现所有的Pod都已经恢复运行了</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="noopener">Tutorials</a><br>
<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" target="_blank" rel="noopener">Learn Kubernetes Basics</a><br>
<a href="https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap/" target="_blank" rel="noopener">Configuring Redis using a ConfigMap</a><br>
使用 k8s 搭建 Redis 集群<br>
<a href="https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/" target="_blank" rel="noopener">Exposing an External IP Address to Access an Application in a Cluster</a><br>
如何使用 k8s 搭建一个无状态服务<br>
<a href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/" target="_blank" rel="noopener">StatefulSet Basics</a><br>
如何使用 k8s 搭建一个有状态服务<br>
<a href="https://kubernetes.io/docs/tutorials/clusters/apparmor/" target="_blank" rel="noopener">AppArmor</a><br>
<a href="https://kubernetes.io/docs/tutorials/services/source-ip/" target="_blank" rel="noopener">Using Source IP</a><br>
<a href="linux.com/tutorials/set-cicd-pipeline-kubernetes-part-1-overview/">CICD</a><br>
<a href="https://www.linux.com/tutorials/set-cicd-pipeline-jenkins-pod-kubernetes-part-2/" target="_blank" rel="noopener">https://www.linux.com/tutorials/set-cicd-pipeline-jenkins-pod-kubernetes-part-2/</a><br>
<a href="https://www.linux.com/tutorials/run-and-scale-distributed-crossword-puzzle-app-cicd-kubernetes-part-3/" target="_blank" rel="noopener">https://www.linux.com/tutorials/run-and-scale-distributed-crossword-puzzle-app-cicd-kubernetes-part-3/</a><br>
<a href="https://www.linux.com/tutorials/set-cicd-distributed-crossword-puzzle-app-kubernetes-part-4/" target="_blank" rel="noopener">https://www.linux.com/tutorials/set-cicd-distributed-crossword-puzzle-app-kubernetes-part-4/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e8597381.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/e8597381.html" itemprop="url">网络架构梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T14:01:28+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>不懂很多网络概念，在一些开会、对接场合出了很多洋相，趁机好好补补。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/e8597381.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/a4caf2c1.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/a4caf2c1.html" itemprop="url">Nginx 原理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T11:32:43+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="为什么要使用-nginx"><a class="header-anchor" href="#为什么要使用-nginx">¶</a>为什么要使用 Nginx</h2>
<h3 id="nginx-优点"><a class="header-anchor" href="#nginx-优点">¶</a>Nginx 优点</h3>
<ol>
<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>
<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>
<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>
<li>nginx 的设计高度模块化，编写模块相对简单</li>
<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>
<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>
<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>
<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ol>
<h3 id="nginx-优点-说出原因"><a class="header-anchor" href="#nginx-优点-说出原因">¶</a>Nginx 优点（说出原因）</h3>
<ol>
<li>Nginx 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。</li>
<li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发</li>
<li>内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术<br>
nginx 处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。<br>
节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存<br>
稳定性高：宕机的概率非常小</li>
<li>master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程<br>
接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力<br>
一边接收 web 服务器的返回数据，一边发送给浏览器客户端<br>
网络依赖性比较低，只要 ping 通就可以负载均衡<br>
可以有多台 nginx 服务器</li>
<li>事件驱动：通信机制采用 epoll 模型</li>
</ol>
<h3 id="apache-优点"><a class="header-anchor" href="#apache-优点">¶</a>Apache 优点</h3>
<ol>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 超稳定</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<h3 id="nginx-和-apache-区别总结"><a class="header-anchor" href="#nginx-和-apache-区别总结">¶</a>Nginx 和 Apache 区别总结</h3>
<p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程<br>
一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。<br>
更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>
<h2 id="使用-nginx"><a class="header-anchor" href="#使用-nginx">¶</a>使用 Nginx</h2>
<h3 id="手动安装-nginx"><a class="header-anchor" href="#手动安装-nginx">¶</a>手动安装 Nginx</h3>
<ol>
<li>配置<br>
创建目录<code>/var/temp/nginx</code><br>
这个目录保存临时文件，在安装配置中指定：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure>
<ol>
<li>配置环境变量<br>
在<code>/etc/profile</code>中编辑，这样就可以直接使用 nginx 命令启动了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure>
<ol>
<li>启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line"># 指定配置文件</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>如果不指定-c，nginx 在启动时默认加载 conf/nginx.conf 文件，此文件的地址也可以在编译安装 nginx 时指定./configure 的参数（–conf-path= 指向配置文件（nginx.conf））</p>
<ol>
<li>停止</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop # 相当于先查出nginx进程id再kill</span><br><span class="line">nginx -s quit # 建议使用，这种方法是等nginx进程的任务处理完毕后再停止</span><br></pre></td></tr></table></figure>
<ol>
<li>重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>要想在修改配置文件 nginx.conf 后生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h3 id="开机自启"><a class="header-anchor" href="#开机自启">¶</a>开机自启</h3>
<ol>
<li>创建<code>/etc/init.d/nginx</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&apos;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<ol>
<li>设置文件访问权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<ol>
<li>设置开机加载<br>
在<code>/etc/rc.local</code>中加入一行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure>
<h3 id="通过-docker-运行-nginx"><a class="header-anchor" href="#通过-docker-运行-nginx">¶</a>通过 Docker 运行 Nginx</h3>
<p>手动进行 Nginx 配置十分繁琐，可以使用 Docker 来简化部署流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<h2 id="优化-linux-最大连接数"><a class="header-anchor" href="#优化-linux-最大连接数">¶</a>优化 Linux 最大连接数</h2>
<h3 id="查看-linux-连接数"><a class="header-anchor" href="#查看-linux-连接数">¶</a>查看 Linux 连接数</h3>
<p>默认配置下，Linux 只支持有限的连接数。<br>
Linux 的线程其实是一个进程，所以 java 的也是，具体来说，叫做“light weight process(LWP)”—轻量级进程。<br>
LWP 与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个 LWP，这样它们共享大部分资源；LWP 有它自己的进程标识符，并和其他进程有着父子关系；。LWP 由内核管理并像普通进程一样被调度<br>
使用以下命令可以看到某个用户使用了多少进程资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep xjjbot(uid)  | wc -l</span><br></pre></td></tr></table></figure>
<p>使用下面命令可以查看具体每个进程开启了多少线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u xjjbot(uid)  | sort -n</span><br></pre></td></tr></table></figure>
<p>根据 linux 一切都是文件的规则，首先想到的，是修改 ulimit 的参数，然而也不是，因为它已经足够大了。交叉回想一下 elasticsearch，在安装的时候，需要配置一个叫做 nproc 的东西，问题大概就出在这，是进程资源不够用啦。<br>
相关的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>在不同的内核版本上，也有一些小差异。比如：/etc/security/limits.d/*<br>
下的文件，会在某些时候覆盖 limits.conf 的配置。所以配置不生效的情况下，记得检查一下。<br>
鉴于以上原因，可以将 limits.d 中的配置全部注释掉，统一在 limits.conf 中配置。<br>
以下是原始配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<p>将 4096 改为大点的数字，或者直接改成 unlimited 就可以了。</p>
<p>单机支持 100 万连接是可行的，但带宽问题会成为显著的瓶颈。启用压缩的二进制协议会节省部分带宽，但开发难度增加。</p>
<h3 id="操作系统优化"><a class="header-anchor" href="#操作系统优化">¶</a>操作系统优化</h3>
<p>更改进程最大文件句柄数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1048576</span><br></pre></td></tr></table></figure>
<p>复制代码修改单个进程可分配的最大文件数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2097152 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>
<p>复制代码修改/etc/security/limits.conf 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   soft nofile  1048576</span><br><span class="line">*   hard nofile 1048576</span><br><span class="line">*   soft nproc unlimited</span><br><span class="line">root soft nproc unlimited</span><br></pre></td></tr></table></figure>
<p>复制代码记得清理掉/etc/security/limits.d/*下的配置</p>
<h3 id="网络优化"><a class="header-anchor" href="#网络优化">¶</a>网络优化</h3>
<p>打开/etc/sysctl.conf，添加配置然后执行，使用 sysctl 生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#单个进程可分配的最大文件数</span><br><span class="line">fs.nr_open=2097152</span><br><span class="line"></span><br><span class="line">#系统最大文件句柄数</span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line">#backlog 设置</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">net.core.netdev_max_backlog=16384</span><br><span class="line"></span><br><span class="line">#可用知名端口范围配置</span><br><span class="line">net.ipv4.ip_local_port_range=&apos;1000 65535&apos;</span><br><span class="line"></span><br><span class="line">#TCP Socket 读写 Buffer 设置</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.optmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=&apos;1024 4096 16777216&apos;</span><br><span class="line">net.ipv4.tcp_wmem=&apos;1024 4096 16777216&apos;</span><br><span class="line"></span><br><span class="line">#TCP 连接追踪设置</span><br><span class="line">net.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait=30</span><br><span class="line"></span><br><span class="line">#TIME-WAIT Socket 最大数量、回收与重用设置</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line"></span><br><span class="line"># FIN-WAIT-2 Socket 超时设置</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure>
<h2 id="接入层演进"><a class="header-anchor" href="#接入层演进">¶</a>接入层演进</h2>
<p>通过研究接入层的发展历程，我们可以一窥 Nginx 在互联网架构中的地位。</p>
<h3 id="接入层结构"><a class="header-anchor" href="#接入层结构">¶</a>接入层结构</h3>
<p><img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%85%A5%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="接入层结构" title="接入层结构"><br>
可以看到，每一个下游都有多个上游调用，只需要做到，<strong>每一个上游都均匀访问每一个下游</strong>，就能实现整体的均匀分摊。</p>
<ol>
<li>客户端层-&gt;反向代理层<br>
DNS 轮询<br>
DNS-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 DNS-server，会轮询返回这些 ip，保证每个 ip 的解析概率是相同的。这些 ip 就是 nginx 的外网 ip，以做到每台 nginx 的请求分配也是均衡的。</li>
<li>反向代理层-&gt;站点层<br>
反向代理层到站点层的负载均衡，是通过“nginx”实现的。<br>
修改 nginx.conf，可以实现多种均衡策略：<br>
2.1 请求轮询：和 DNS 轮询类似，请求依次路由到各个 web-server；<br>
2.2 最少连接路由：哪个 web-server 的连接少，路由到哪个 web-server；<br>
2.3 ip 哈希：按照访问用户的 ip 哈希值来路由 web-server，只要用户的 ip 分布是均匀的，请求理论上也是均匀的，ip 哈希均衡方法可以做到，同一个用户的请求固定落到同一台 web-server 上，此策略适合有状态服务，例如 session；</li>
</ol>
<blockquote>
<p>session 不推荐放到站点层，后期扩展会有问题，更好的方案是放到数据层。</p>
</blockquote>
<ol start="3">
<li>站点层-&gt;服务层<br>
站点层到服务层的负载均衡，是通过“服务连接池”实现的。<br>
上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。除了负载均衡，服务连接池还能够实现故障转移、超时处理、限流限速、ID 串行化等诸多功能。</li>
<li>服务层-&gt;数据层<br>
在数据量很大的情况下，由于数据层（db/cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<br>
<strong>数据的均衡</strong>是指：水平切分后的每个服务（db/cache），数据量是均匀的。<br>
<strong>请求的均衡</strong>是指：水平切分后的每个服务（db/cache），请求量是均匀的。</li>
</ol>
<h3 id="接入层演进-v2"><a class="header-anchor" href="#接入层演进-v2">¶</a>接入层演进</h3>
<ol>
<li>单机架构<br>
客户端用 DNS 解析出来的 IP 就是 web 服务器的地址。<br>
缺点：
<ul>
<li>单点；</li>
<li>扩展性差。</li>
</ul>
</li>
<li>DNS 轮询<br>
在 DNS 服务器上多配几个 IP，由域名服务器的解析策略实现负载均衡。<br>
缺点：
<ul>
<li>非高可用，因为一个 web 服务器挂掉后 DNS 服务器仍然会将请求解析到该服务器对应的 IP 上；</li>
<li>扩容非实时，DNS 服务器有一个配置生效的延时时间；</li>
<li>暴露太多外网 IP。</li>
</ul>
</li>
<li>反向代理 Nginx<br>
DNS 解析到 Nginx 的 IP，然后由 Nginx 将请求负载均衡到 web 服务器。<br>
缺点：基本解决了上一个架构存在的问题，且可以利用 Nginx 的探活机制实现 web 服务器的高可用，但是此时 Nginx 也会成为一个单点。</li>
<li>keepalived<br>
两台 Nginx 组成集群，分别部署上 keepalived，设置成相同的虚 IP，保证 Nginx 的高可用。当一台 Nginx 挂了，keepalived 能够探测到并将流量迁移到另一台 Nginx 上，整个过程对调用方透明。<br>
缺点：
<ul>
<li>资源利用率低；</li>
<li>扩容不方便，如果吞吐量超过 Nginx 性能上线，要加机器配置起来比较麻烦。</li>
</ul>
</li>
<li>lvs/f5<br>
DNS 解析出来的 IP 是 lvs 的地址。由 lvs 反向代理 Nginx 服务器，lvs 的机器上部署 keepalived+VIP 实现高可用；<br>
f5 的性能比 lvs 更高，但是成本也会更高。</li>
<li>DNS 轮询<br>
水平扩展才是解决性能问题的根本方案，能够通过加机器扩充性能的方案才具备最好的扩展性。<br>
<img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8E%A5%E5%85%A5%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="可扩展高可用接入层架构" title="可扩展高可用接入层架构">
<ul>
<li>通过 DNS 轮询来线性扩展入口 lvs 层的性能；</li>
<li>通过 keepalived 保证高可用；</li>
<li>通过 lvs 来扩展多个 Nginx；</li>
<li>通过 Nginx 实现对业务服务器的七层负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="nginx-原理-进程"><a class="header-anchor" href="#nginx-原理-进程">¶</a>Nginx 原理 - 进程</h2>
<h3 id="nginx-代码的模块化结构"><a class="header-anchor" href="#nginx-代码的模块化结构">¶</a>Nginx 代码的模块化结构</h3>
<p>Nginx 的代码是由一个核心和一系列的模块组成的。<br>
<strong>核心</strong>主要用于提供 WebServer 的基本功能，以及 Web 和 Mail 反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。<br>
不过，大多跟协议相关的功能和应用特有的功能都是由 nginx 的模块实现的。<br>
换句话说， <strong>每一个功能或操作都由一个模块来实现</strong>。<br>
这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream 和负载均衡几个类别，这些共同组成了 nginx 的 http 功能。<br>
<strong>事件模块</strong>主要用于提供 OS 独立的(不同操作系统的事件机制有所不同)事件通知机制如 kqueue 或 epoll 等。<br>
<strong>协议模块</strong>则负责实现 nginx 通过 http、tls/ssl、smtp、pop3 以及 imap 与对应的客户端建立会话。<br>
在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的。<br>
换句话说，每一个功能或操作都由一个模块来实现。例如：压缩、通过 FastCGI 或 uwsgi 协议与 upstream 服务器通信、以及与 memcached 建立会话等。</p>
<h3 id="进程结构"><a class="header-anchor" href="#进程结构">¶</a>进程结构</h3>
<p>一个 Nginx 服务器实例由一个 master 进程和多个 worker 进程组成。<br>
<img src="http://47.88.24.11/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"><br>
<strong>master</strong>进程主要用来管理 worker 进程，还有一些对整个服务器的初始化和日志记录等工作。<br>
<strong>管理 worker 的过程</strong>：接收来自外界的信号，向各 worker 进程发送 <strong>信号</strong> ，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动（fork）新的 worker 进程。</p>
<p><strong>master 主要功能</strong>：</p>
<ul>
<li>读取并验证配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止 worker 进程及维护 worker 进程的个数；</li>
<li>无须中止服务而重新配置工作；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式 perl 脚本</li>
</ul>
<p>对请求的实际处理由 <strong>worker</strong> 负责，且每个请求只能由一个 worker 负责（一对一）。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。</p>
<p><strong>worker 主要功能</strong>：</p>
<ul>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx 任何能完成的其它任务</li>
</ul>
<h3 id="nginx-的启动"><a class="header-anchor" href="#nginx-的启动">¶</a>Nginx 的启动</h3>
<p>nginx 启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程（你可以理解为工人和管理员）。</p>
<h3 id="nginx-处理连接过程"><a class="header-anchor" href="#nginx-处理连接过程">¶</a>Nginx 处理连接过程</h3>
<p>nginx 不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的 <strong>循环</strong> 来处理数千个连接。<br>
Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。 <strong>监听套接字</strong> 在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。</p>
<p>一次请求过程大概执行过程为：</p>
<ol>
<li>nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面先初始化好这个监控的 socket，再进行 listen（listenfd）；</li>
<li>由 master 进程 fork 出多个 worker 进程；</li>
<li>此时客户端可以向 nginx 发起连接了，客户端会与 nginx 进行三次握手（TCP），与 nginx 建立好一个连接；</li>
<li>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接</li>
<li>当一个 worker 进程在 accept 这个连接之后，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体，就开始读取请求、解析请求、处理请求（ <strong>异步非阻塞</strong> ），主要是根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换</li>
<li>产生数据后，再返回给客户端，最后才断开连接，或者由客户端主动关闭连接。</li>
</ol>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h3>
<p>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的，其原理是<strong>信号机制</strong>，master 对 worker 进程采用信号进行控制。</p>
<h3 id="事件驱动"><a class="header-anchor" href="#事件驱动">¶</a>事件驱动</h3>
<p>所谓<strong>事件驱动</strong>架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会“消费”这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。<br>
传统 web 服务器（如 Apache）的所谓事件局限在 TCP 连接建立、关闭上，其他读写都不再是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 Web 服务器每个事件消费者独占一个进程资源，相对来说，Nginx 只是被事件分发者进程短期调用而已。<br>
nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限，多少个 worker 就能处理多少个并发，那么何来的高并发呢？<br>
其实，Nginx 是采用了<strong>异步非阻塞</strong>的 IO 模型来处理请求的（epoll），异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。<br>
请求的<strong>多阶段异步处理</strong>只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段。<br>
每种事件都有一个事件队列，按触发的先后顺序处理。</p>
<h3 id="惊群现象"><a class="header-anchor" href="#惊群现象">¶</a>惊群现象</h3>
<p>惊群是多个子进程在同一时刻监听同一个端口引起的；<br>
Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。这可以通过锁或互斥量实现。</p>
<h3 id="为什么不使用多线程"><a class="header-anchor" href="#为什么不使用多线程">¶</a>为什么不使用多线程</h3>
<ul>
<li>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。</li>
<li>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</li>
</ul>
<h2 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h2>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.shiyanlou.com/courses/95" target="_blank" rel="noopener">Linux Web 运维（Nginx）实战</a></li>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx 开发从入门到精通</a></li>
<li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">nginx documentation</a></li>
</ol>
<h3 id="nginx-原理"><a class="header-anchor" href="#nginx-原理">¶</a>Nginx 原理</h3>
<ol>
<li><a href="https://segmentfault.com/q/1010000003901360?_ea=416091" target="_blank" rel="noopener">Nginx 内部有使用多线程吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清 epoll 的本质，那就过来掐死我吧！ （1）</a></li>
</ol>
<h3 id="模块-v2"><a class="header-anchor" href="#模块-v2">¶</a>模块</h3>
<ol>
<li>log<br>
<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">Module ngx_http_log_module</a><br>
<a href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html#log_format" target="_blank" rel="noopener">Module ngx_stream_log_module</a><br>
<a href="http://blog.chinaunix.net/uid-29179844-id-4433640.html" target="_blank" rel="noopener">nginx 日志格式及自定义日志配置</a></li>
<li>proxy<br>
<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">Module ngx_http_proxy_module</a></li>
<li>TCP / UDP<br>
<a href="http://nginx.org/en/docs/stream/stream_processing.html" target="_blank" rel="noopener">How nginx processes a TCP/UDP session</a></li>
</ol>
<h3 id="tengine"><a class="header-anchor" href="#tengine">¶</a>Tengine</h3>
<ol>
<li><a href="http://tengine.taobao.org/documentation.html" target="_blank" rel="noopener">Documentation</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d9054d7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/d9054d7.html" itemprop="url">Redis事务和Lua</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-06T09:42:14+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这一篇是对在公司内缓存代码应用 Redis-Lua 的一个总结，经过 benchmark 测试，这种方式效率更高，且理论上有更低的可能性。<br>
顺便，一开始先描述一下Redis中的事务的原理，因为Redis-Lua本身是事务的一个替代品，这二者一般放在一起讨论。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/d9054d7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4be4a53c.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/4be4a53c.html" itemprop="url">一些有价值的开源学习资料汇总（updating）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-05T21:37:14+08:00">
                2019-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  304 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>收集从网上找到的学习资料，大部分来自 Github。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/4be4a53c.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1840c3ba.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1840c3ba.html" itemprop="url">自适应负载均衡(20%)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T22:32:50+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/项目总结/" itemprop="url" rel="index">
                    <span itemprop="name">项目总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>云环境下自适应负载均衡算法的设计。<br>
题目描述 -&gt; <a href="https://code.aliyun.com/middlewarerace2019/adaptive-loadbalance" target="_blank" rel="noopener">阿里巴巴 2019 中间件性能挑战赛-自适应负载均衡（初赛）赛题</a></p>
<p>抽不出时间，中途放弃了。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/1840c3ba.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/7d1f0594.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/7d1f0594.html" itemprop="url">Java 基础总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T17:23:14+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="java5"><a class="header-anchor" href="#java5">¶</a>Java5</h2>
<h3 id="语法-集合框架等"><a class="header-anchor" href="#语法-集合框架等">¶</a>语法、集合框架等</h3>
<ul>
<li>泛型</li>
<li>枚举</li>
<li>装箱拆箱</li>
<li>变长参数</li>
<li>注解</li>
<li>foreach 循环</li>
<li>静态导入</li>
<li>格式化</li>
<li>线程框架/数据结构</li>
<li>Arrays 工具类/StringBuilder/instrument</li>
</ul>
<h4 id="泛型"><a class="header-anchor" href="#泛型">¶</a>泛型</h4>
<p>不同于 C++中的泛型，Java 的泛型会在编译后被清除，这种机制被称为泛型擦除。</p>
<blockquote>
<p>java 的类型推断基本都在编译期完成</p>
</blockquote>
<p><strong>优点</strong>：可以免去大量的显式类型转换；<br>
<strong>缺点</strong>：由于泛型擦除的存在，在很多场合下容易引起误会：</p>
<ul>
<li>比如向 List<integer>类型的表里添加一个 String 类型对象就不会通过，因为在编译期间还需要进行类型检查。</integer></li>
<li>在继承重写方法时，若父类中被重写的方法中含有泛型，因为泛型擦除理应变成重载，但是 Java 编译器会在编译后的字节码中添加桥方法（已经被类型擦除）、桥方法再调用重写的方法来解决；</li>
<li>泛型类型参数不能使用基本类型，因为基本类型不是 Object 的子类；</li>
<li>其他一些注意事项…</li>
</ul>
<h4 id="枚举"><a class="header-anchor" href="#枚举">¶</a>枚举</h4>
<p>枚举可以使用 enum 声明，在 switch 中可以作为 case 后的标签。可以使用 EnumMap 来保存枚举到其他类型的映射或使用 EnumSet 保存枚举值的集合。<br>
<strong>优点</strong>：</p>
<ul>
<li>相对使用 int 或 String 当作枚举对象来说，Java 编译器本身提供了对 enum 的类型检查，可以更安全地使用；</li>
<li>可以用于声明单例对象。</li>
</ul>
<h4 id="装箱拆箱"><a class="header-anchor" href="#装箱拆箱">¶</a>装箱拆箱</h4>
<p>基本类型可以自动转换成对应的包装类型，比如 boolean 会被包装为 Boolean。<br>
<strong>优点</strong>：</p>
<ul>
<li>方便。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>注意拆箱时不能对 null 拆箱，不然会报空指针。</li>
</ul>
<h4 id="变长参数"><a class="header-anchor" href="#变长参数">¶</a>变长参数</h4>
<p>可以传入任意多个相同类型的参数。<br>
<strong>优点</strong>：</p>
<ul>
<li>提供了更多灵活性，比如编写输出方法时可以格式化多个参数。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要注意 null 值的传入。</li>
</ul>
<h4 id="注解"><a class="header-anchor" href="#注解">¶</a>注解</h4>
<p>注解需要和反射配合使用，JDK 提供了一些具有特定语义的注解：<br>
@Inherited：是否对类的子类继承的方法等起作用；<br>
@Target：作用目标；<br>
@Rentation：表示 annotation 是否保留在编译过的 class 文件中还是在运行时可读。</p>
<h4 id="for-in-循环"><a class="header-anchor" href="#for-in-循环">¶</a>for/in 循环</h4>
<p><strong>优点</strong>：</p>
<ul>
<li>方便</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>获取不到元素所在 index；</li>
<li>无法在遍历的时候删除元素；</li>
</ul>
<h4 id="静态-import"><a class="header-anchor" href="#静态-import">¶</a>静态 import</h4>
<p>可以直接使用一个类中的静态方法。<br>
<strong>缺点</strong>：</p>
<ul>
<li>如果有同名的容易引起混淆；</li>
</ul>
<h4 id="formatter"><a class="header-anchor" href="#formatter">¶</a>Formatter</h4>
<p>提供对日期、数字等的格式化支持</p>
<h4 id="线程框架-数据结构"><a class="header-anchor" href="#线程框架-数据结构">¶</a>线程框架/数据结构</h4>
<ol>
<li>
<p>在线程中可以设置 UncaughtExceptionHandler，当抛出异常后可以执行指定的逻辑；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadingTest extends Thread &#123;</span><br><span class="line">  private int[] numbers;</span><br><span class="line">  public ThreadingTest(int[] numbers) &#123;</span><br><span class="line">    setName(&quot;Simple Thread&quot;);</span><br><span class="line">    setUncaughtExceptionHandler(</span><br><span class="line">        new SimpleThreadExceptionHandler());</span><br><span class="line">    this.numbers = numbers;</span><br><span class="line">  &#125;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    int index = numbers.length;</span><br><span class="line">    boolean finished = false;</span><br><span class="line">    while (!finished) &#123;</span><br><span class="line">      index--;</span><br><span class="line">      finished = true;</span><br><span class="line">      for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">        // Create error condition</span><br><span class="line">        if (numbers[i + 1] &lt; 0) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;Cannot pass negative numbers into this thread!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (numbers[i] &gt; numbers[i + 1]) &#123;</span><br><span class="line">          // swap</span><br><span class="line">          int temp = numbers[i];</span><br><span class="line">          numbers[i] = numbers[i + 1];</span><br><span class="line">          numbers[i + 1] = temp;</span><br><span class="line">          finished = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] numbers = new int[]&#123;2, -1, 56, 4, 7&#125;;</span><br><span class="line">    ThreadingTest threadingTest = new ThreadingTest(numbers);</span><br><span class="line">    threadingTest.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SimpleThreadExceptionHandler implements</span><br><span class="line">    Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">  public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">    System.err.printf(&quot;%s: %s at line %d of %s%n&quot;,</span><br><span class="line">        t.getName(),</span><br><span class="line">        e.toString(),</span><br><span class="line">        e.getStackTrace()[0].getLineNumber(),</span><br><span class="line">        e.getStackTrace()[0].getFileName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引入 Queue、BlockingQueue、ConcurrentMap 数据结构；</p>
</li>
<li>
<p>引入 JUC 线程池；</p>
<ul>
<li>每次提交任务时，如果线程数还没达到 coreSize 就创建新线程并绑定该任务。 所以第 coreSize 次提交任务后线程总数必达到 coreSize，不会重用之前的空闲线程。</li>
<li>线程数达到 coreSize 后，新增的任务就放到工作队列里，而线程池里的线程则努力的使用 take()从工作队列里拉活来干。</li>
<li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li>
<li>临时线程使用 poll(keepAliveTime，timeUnit)来从工作队列拉活，如果时候到了仍然两手空空没拉到活，表明它太闲了，就会被解雇掉。</li>
<li>如果 core 线程数＋临时线程数 &gt;maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder。默认的 AbortPolicy 抛 RejectedExecutionException 异常，其他选择包括静默放弃当前任务(Discard)，放弃工作队列里最老的任务(DisacardOldest)，或由主线程来直接执行(CallerRuns)，或你自己发挥想象力写的一个。</li>
</ul>
</li>
<li>
<p>Arrays<br>
提供数组相关的一些工具类。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(myArray);</span><br><span class="line">Arrays.toString(myArray)</span><br><span class="line">Arrays.binarySearch(myArray, 98)</span><br><span class="line">Arrays.deepToString(ticTacToe)</span><br><span class="line">Arrays.deepEquals(ticTacToe, ticTacToe3)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="override-支持协变"><a class="header-anchor" href="#override-支持协变">¶</a>Override 支持协变</h4>
<p>返回类型可以是父类中相应类型或其子类。</p>
<h3 id="jvm"><a class="header-anchor" href="#jvm">¶</a>JVM</h3>
<h4 id="cds-class-data-sharing"><a class="header-anchor" href="#cds-class-data-sharing">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html" target="_blank" rel="noopener">CDS（Class Data Sharing）</a></h4>
<p>JRE installer 能将一些系统 jar 文件加载到一种私有内部表示方式，然后转储到一个文件内，称为“shared archive”，下次启动应用的时候可以直接使用这个包内的类数据，这样可以减少部分启动时间。</p>
<h4 id="自动检测服务器级机器"><a class="header-anchor" href="#自动检测服务器级机器">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html" target="_blank" rel="noopener">自动检测服务器级机器</a></h4>
<p>如果机器至少有 2 CPUs 和至少 2GB 物理内存，use the Java HotSpot Server Virtual Machine (server VM) instead of the Java HotSpot Client Virtual Machine (client VM).，The aim is to improve performance even if no one configures the VM to reflect the application it’s running. In general, the server VM starts up more slowly than the client VM, but over time runs more quickly.</p>
<h4 id="垃圾收集器自适应"><a class="header-anchor" href="#垃圾收集器自适应">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="noopener">垃圾收集器自适应</a></h4>
<p>服务器类机器默认垃圾回收器改为并行垃圾回收器。<br>
可以指定性能目标，并行收集器可以自动调整堆的大小，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeLimit=time-limit ：花费在GC上的时间上限，默认是98，当超过上限时，会抛出OutOfMemory(HeapSpace)的异常</span><br><span class="line">-XX:GCHeapFreeLimit=space-limit ：Heap空闲空间的最低比例下限，默认是2，当超过下限时，会抛出OutOfMemory(HeapSpace)的异常</span><br><span class="line">-XX:MaxGCPauseMillis=nnn ：最长的GC暂停时间，如果时间过长，会相应调整空间的大小（单位是毫秒）</span><br><span class="line">-XX:GCTimeRatio=nnn ：最大的GC占总可用时间的比例，如果时间过长，会相应调整空间的大小（花费在GC上的时间比例不超过1 / (1 + nnn)）</span><br></pre></td></tr></table></figure>
<h4 id="线程优先级"><a class="header-anchor" href="#线程优先级">¶</a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/thread-priorities.html" target="_blank" rel="noopener">线程优先级</a></h4>
<p>Thread 类中给出了三个线程优先级常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.MIN_PRIORITY = 1</span><br><span class="line">java.lang.Thread.NORM_PRIORITY = 5</span><br><span class="line">java.lang.Thread.MAX_PRIORITY = 10</span><br></pre></td></tr></table></figure>
<p>默认情况下线程优先级为 java.lang.Thread.NORM_PRIORITY，我们可以自定义设置在[1…10]内。<br>
JVM（Java HotSpot）将 Java 线程关联到唯一的一个 native thread。</p>
<h2 id="网络编程-socket"><a class="header-anchor" href="#网络编程-socket">¶</a>网络编程（Socket）</h2>
<h3 id="inetaddress"><a class="header-anchor" href="#inetaddress">¶</a>InetAddress</h3>
<p>IP 地址是在网络层封装上的，确定 Internet 上的一个唯一的地址，端口号是由传输层封装上的，标志主机上的一个服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class InetAddressTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        InetAddressTest.printAddress();</span><br><span class="line">    &#125;</span><br><span class="line">    static void printAddress()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(address);//输出：机器名/IP地址</span><br><span class="line">            address = InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            System.out.println(address);//输出：域名/IP地址</span><br><span class="line">            InetAddress[] addresses = InetAddress.getAllByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            for(InetAddress a : addresses)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(UnknownHostException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="url-和-urlconnection"><a class="header-anchor" href="#url-和-urlconnection">¶</a>URL 和 UrlConnection</h3>
<p>UrlConnection 可以从一个 URL 中打开流，可以方便地进行 Http 数据的收发。<br>
内部是使用 Socket 进行连接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取链接属性</span><br><span class="line">URL url = new URL(&quot;http://java.sun.com:80/docs/books/tutorial/index.html#DOWN&quot;);//#后面的DOWN是位置标识符，在获得网页后，浏览器将直接跳到网页的DOWN处读取</span><br><span class="line">String protocal = url.getProtocol();</span><br><span class="line">String host = url.getHost();</span><br><span class="line">String file = url.getFile();</span><br><span class="line">int port = url.getPort();</span><br><span class="line">String ref = url.getRef();//获得#后面的</span><br><span class="line">System.out.println(protocal + &quot;, &quot; + host + &quot;, &quot; + file + &quot;, &quot;</span><br><span class="line">        + port + &quot;, &quot; + ref);</span><br></pre></td></tr></table></figure>
<p>访问链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 访问链接读取数据</span><br><span class="line">URL url = new URL(&quot;http://www.cnblogs.com/mengdd/archive/2013/03/09/2951877.html&quot;);</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(url.openStream()));</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line">while((line = reader.readLine()) != null)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>
<p>下面是对 URLConnection 的测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class URLTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        URLTest c = new URLTest();</span><br><span class="line">        c.createURL();</span><br><span class="line">        c.printURLParam();</span><br><span class="line">        c.readURL();</span><br><span class="line">        c.printURL();</span><br><span class="line">    &#125;</span><br><span class="line">    void createURL()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://localhost:8080/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void printURLParam()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://java.sun.com:80/docs/books/tutorial/index.html#DOWN&quot;);//#后面的DOWN是位置标识符，在获得网页后，浏览器将直接跳到网页的DOWN处读取</span><br><span class="line">            String protocal = url.getProtocol();</span><br><span class="line">            String host = url.getHost();</span><br><span class="line">            String file = url.getFile();</span><br><span class="line">            int port = url.getPort();</span><br><span class="line">            String ref = url.getRef();//获得#后面的</span><br><span class="line">            System.out.println(protocal + &quot;, &quot; + host + &quot;, &quot; + file + &quot;, &quot;</span><br><span class="line">                    + port + &quot;, &quot; + ref);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void readURL()&#123;//将网页内容拷贝到本地</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">            URLConnection conn = url.openConnection();</span><br><span class="line">            InputStream is = conn.getInputStream();</span><br><span class="line">            //或者直接is = url.openStream();</span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;e:\\baidu.txt&quot;);</span><br><span class="line">            byte[] buffer = new byte[2048];</span><br><span class="line">            int length = 0;</span><br><span class="line">            while((length = is.read(buffer, 0, buffer.length)) != -1)&#123;</span><br><span class="line">                os.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void printURL()&#123;//读取网页内容到控制台</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">            BufferedReader reader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(url.openStream()));</span><br><span class="line">            String line;</span><br><span class="line">            while((line = reader.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tcp-和-udp"><a class="header-anchor" href="#tcp-和-udp">¶</a>TCP 和 UDP</h3>
<p>它们都是位于传输层的协议，为应用进程提供服务，根据不同的应用场景，会使用不同的协议。<br>
TCP 是基于连接的、面向流的协议，提供可靠通信，因此每次通信必须先建立连接，建立连接后可以分多次进行传输任务，并且保证数据的正确性。<br>
UDP 是基于无连接的、面向数据报的协议，提供不可靠通信，每次通信只需要发送一次数据报，可以分多次发送，但不保证能否到达、到达的顺序。</p>
<p>Socket 是 TCP 的应用编程接口，DatagramSocket 是 UDP 的应用编程接口，他们之间没有继承关系（都实现 Closeable 接口）。<br>
Socket 使用时需要先指定目标主机地址和端口号，然后打开 io 流进行操作<br>
1.服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 监听8080端口</span><br><span class="line">ServerSocket server = new ServerSocket(8080);</span><br><span class="line">// 等待请求</span><br><span class="line">Socket socket = server.accept();</span><br><span class="line">// 进行通信</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = reader.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">PrintWriter writer = new PrintWriter(socket.getOutputStream());</span><br><span class="line">writer.println(line);</span><br><span class="line">writer.flush(); // 不要忘了这个</span><br><span class="line">// 关闭资源</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure>
<p>2.客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 监听8080端口</span><br><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080);</span><br><span class="line">// 开始通信</span><br><span class="line">PrintWriter writer = new PrintWriter(socket.getOutputStream());</span><br><span class="line">writer.println(&quot;hello&quot;);</span><br><span class="line">writer.flush();</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = reader.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">// 关闭资源</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<h3 id="socketchannel-和-serversocketchannel"><a class="header-anchor" href="#socketchannel-和-serversocketchannel">¶</a>SocketChannel 和 ServerSocketChannel</h3>
<p>缓冲（Buffer）：相当于货物<br>
管道（Channel）：相当于配货车，支持同时装多件货物。<br>
选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况。相当于中转站的分拣员。</p>
<h3 id="使用-datagramsocket-进行-udp-通信"><a class="header-anchor" href="#使用-datagramsocket-进行-udp-通信">¶</a>使用 DatagramSocket 进行 UDP 通信</h3>
<h4 id="下面的代码使用-datagramsocket-实现-udp-通信"><a class="header-anchor" href="#下面的代码使用-datagramsocket-实现-udp-通信">¶</a>下面的代码使用 DatagramSocket 实现 UDP 通信</h4>
<p>服务端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建服务器socket，指定端口</span><br><span class="line">DatagramSocket socket = new DatagramSocket(7000);</span><br><span class="line">// 接收信息保存到一个缓冲区，DatagramPacket(bytes, len)</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket packet = new DatagramPacket(buffer, 1024);</span><br><span class="line">socket.receive(packet);</span><br><span class="line">System.out.println(new String(buffer, 0, packet.getLength()));</span><br><span class="line">// 响应信息，接收时需要指定地址和端口</span><br><span class="line">String str = &quot;Welcome!&quot;;</span><br><span class="line">DatagramPacket packet1 = new DatagramPacket(str.getBytes(),</span><br><span class="line">        str.length(), packet.getAddress(), packet.getPort());</span><br><span class="line">socket.send(packet1);</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket = new DatagramSocket();</span><br><span class="line">// 发送数据包</span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">DatagramPacket packet = new DatagramPacket(str.getBytes(),</span><br><span class="line">        str.length(), InetAddress.getByName(&quot;localhost&quot;), 7000);</span><br><span class="line">socket.send(packet);</span><br><span class="line">// 接收响应</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket packet1 = new DatagramPacket(buffer, 100);</span><br><span class="line">socket.receive(packet1);</span><br><span class="line">System.out.println(new String(buffer, 0, packet1.getLength()));</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<h4 id="下面的代码使用-nio-实现数据报协议"><a class="header-anchor" href="#下面的代码使用-nio-实现数据报协议">¶</a>下面的代码使用 NIO 实现数据报协议</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 发送</span><br><span class="line">public void send() throws IOException&#123;</span><br><span class="line">    // 打开数据报通道</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(false);</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">    Scanner scan = new Scanner(System.in);</span><br><span class="line">    while(scan.hasNext())&#123;</span><br><span class="line">        String str = scan.next();</span><br><span class="line">        buf.put((new Date().toString() + &quot;:\n&quot; + str).getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf, new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br><span class="line">// 接收</span><br><span class="line">public void receive() throws IOException&#123;</span><br><span class="line">    // 传送数据报通道</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(false);</span><br><span class="line">    dc.bind(new InetSocketAddress(9898));</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    dc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    while(selector.select() &gt; 0)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            if(sk.isReadable())&#123;</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(new String(buf.array(), 0, buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-nio-实现简易-httpserver"><a class="header-anchor" href="#使用-nio-实现简易-httpserver">¶</a>使用 NIO 实现简易 HttpServer</h3>
<p>主要思路很简单：<br>
(1) 服务器打开后首先为 Selector 注册一个 OP_ACCEPT 的 key，这样 select 时就能接收客户端请求了；<br>
(2) 每接收一个请求后即为该 key 创建一个线程，处理该 key 的操作，操作包括 accept 和 read，对于前者，只需为该 key 的 selector 再注册一个 OP_READ 用于准备接下来的读请求；<br>
(3) 读取时先读入一个 Buffer，首先解析请求头部分，直到遇到一个空行结束，因为这里只考虑 GET 请求，所以不必继续解析请求体了；<br>
(4) 返回时，首先构建响应头，同样使用一个空行结束，然后构建响应体，写回客户端，结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 监听8080端口</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line">        // 为server注册选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        // 创建处理器</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            // 等待请求，每次阻塞3s，若超过3s线程继续运行，</span><br><span class="line">            // select(0)或select()表示一直阻塞</span><br><span class="line">            if(selector.select(3000) == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取所有待处理的选择键</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line">            while(keyIter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIter.next();</span><br><span class="line">                // 启动新线程以处理SelectionKey</span><br><span class="line">                new Thread(new HttpHandler(key)).run();</span><br><span class="line">                // 处理完毕后，移除当前key</span><br><span class="line">                keyIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class HttpHandler implements Runnable &#123;</span><br><span class="line">        private int bufferSize = 1024;</span><br><span class="line">        private String localCharset = &quot;UTF-8&quot;;</span><br><span class="line">        private SelectionKey key;</span><br><span class="line"></span><br><span class="line">        public HttpHandler(SelectionKey key) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义操作</span><br><span class="line">        private void handleAccept() throws IOException &#123;</span><br><span class="line">            // 接受请求后，注册OP_READ选择键以等待下一次请求</span><br><span class="line">            SocketChannel clientChannel = ((ServerSocketChannel)key.channel()).accept();</span><br><span class="line">            clientChannel.configureBlocking(false);</span><br><span class="line">            // !!!请求报文被限制在1024个字节内</span><br><span class="line">            clientChannel.register(key.selector(),</span><br><span class="line">                    SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">        private void handleRead() throws IOException &#123;</span><br><span class="line">            // 获取</span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            // 获取Buffer并重置</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            // 读取，并判断内容是否为空，若是则关闭并退出</span><br><span class="line">            if(sc.read(buffer) == -1) &#123;</span><br><span class="line">               sc.close();</span><br><span class="line">               return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 接收请求数据</span><br><span class="line">            buffer.flip();</span><br><span class="line">            String receivedString = Charset.forName(localCharset).newDecoder().</span><br><span class="line">                    decode(buffer).toString();</span><br><span class="line"></span><br><span class="line">            // 打印请求报文头</span><br><span class="line">            String[] requestMessage = receivedString.split(&quot;\r\n&quot;);</span><br><span class="line">            for(String s: requestMessage) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                // 遇到空行说明报文头已经打印完</span><br><span class="line">                if(s.isEmpty()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 控制台打印首行信息</span><br><span class="line">            String[] firstLine = requestMessage[0].split(&quot; &quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;Method:\t&quot; + firstLine[0]);</span><br><span class="line">            System.out.println(&quot;url:\t&quot; + firstLine[1]);</span><br><span class="line">            System.out.println(&quot;HTTP Version:\t&quot; + firstLine[2]);</span><br><span class="line">            System.out.println();</span><br><span class="line">            // 返回客户端（!!!考虑对不同的Url和不同的请求方法进行不同的处理和响应）</span><br><span class="line">            StringBuilder sendString = new StringBuilder();</span><br><span class="line">            sendString.append(&quot;HTTP/1.1 200 OK\r\n&quot;); // 响应报文首行</span><br><span class="line">            sendString.append(&quot;Content-Type:text/html;charset=&quot; + // !!!如果要传输流数据必须修改Content-Type</span><br><span class="line">                    localCharset + &quot;\r\n&quot;);</span><br><span class="line">            sendString.append(&quot;\r\n&quot;); // 报文结束后加一空行</span><br><span class="line">            // 响应体</span><br><span class="line">            sendString.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;显示报文&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</span><br><span class="line">            sendString.append(&quot;接收到请求报文是: &lt;br/&gt;&quot;);</span><br><span class="line">            for(String s: requestMessage) &#123;</span><br><span class="line">                sendString.append(s + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sendString.append(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">            // 使用缓冲区写入channel</span><br><span class="line">            buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));</span><br><span class="line">            sc.write(buffer);</span><br><span class="line">            // 关闭资源</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 根据请求类型进行转发</span><br><span class="line">                if(key.isAcceptable()) &#123;</span><br><span class="line">                    handleAccept();</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable()) &#123;</span><br><span class="line">                    handleRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-nio-selector-实现简易聊天室"><a class="header-anchor" href="#使用-nio-selector-实现简易聊天室">¶</a>使用 NIO-Selector 实现简易聊天室</h3>
<h4 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h4>
<p>声明数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 管道、选择器、字符集</span><br><span class="line">private SocketChannel sc = null;</span><br><span class="line">private Selector selector = null;</span><br><span class="line">private Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<p>创建线程类用于从服务端获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class ClientThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 遍历所有选择键</span><br><span class="line">            while(selector.select() &gt; 0) &#123;</span><br><span class="line">                for(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">                    // 删除正在处理的</span><br><span class="line">                    selector.selectedKeys().remove(sk);</span><br><span class="line">                    // 如果该键对应的通道中有可读的数据</span><br><span class="line">                    if(sk.isReadable()) &#123;</span><br><span class="line">                        // 使用缓冲区读取管道内的数据</span><br><span class="line">                        SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">                        ByteBuffer buff = ByteBuffer.allocate(1024);</span><br><span class="line">                        String content = &quot;&quot;;</span><br><span class="line">                        while(sc.read(buff) &gt; 0) &#123;</span><br><span class="line">                            buff.flip();</span><br><span class="line">                            content += charset.decode(buff);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 打印</span><br><span class="line">                        System.out.println(&quot;聊天信息&quot; + content);</span><br><span class="line">                        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化SocketChannel</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">sc = SocketChannel.open(isa);</span><br><span class="line">sc.configureBlocking(false);</span><br><span class="line">// 注册选择器</span><br><span class="line">selector = Selector.open();</span><br><span class="line">sc.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>创建线程从服务端拉取数据，及不断从键盘读入发送到服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 启动线程不断从服务端拉取</span><br><span class="line">new ClientThread().start();</span><br><span class="line">// 读取键盘输入到通道</span><br><span class="line">Scanner reader = new Scanner(System.in);</span><br><span class="line">while(reader.hasNextLine()) &#123;</span><br><span class="line">    String line = reader.nextLine();</span><br><span class="line">    sc.write(charset.encode(line));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务端"><a class="header-anchor" href="#服务端">¶</a>服务端</h4>
<p>声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 选择器、字符集</span><br><span class="line">private Selector selector = null;</span><br><span class="line">private Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 打开管道</span><br><span class="line">ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">server.socket().bind(isa);</span><br><span class="line">server.configureBlocking(false);</span><br><span class="line">// 打开选择器</span><br><span class="line">selector = Selector.open();</span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>接受连接，读取及发送数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 依次处理选择器上的选择键</span><br><span class="line">while(selector.select() &gt; 0) &#123;</span><br><span class="line">    for(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">        selector.selectedKeys().remove(sk);</span><br><span class="line">        // 连接请求</span><br><span class="line">        if(sk.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel sc = server.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            sk.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;</span><br><span class="line">        // 存在可读取数据</span><br><span class="line">        if(sk.isReadable()) &#123;</span><br><span class="line">            // 使用缓冲区读取</span><br><span class="line">            SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">            ByteBuffer buff = ByteBuffer.allocate(1024);</span><br><span class="line">            String content = &quot;&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                while(sc.read(buff) &gt; 0) &#123;</span><br><span class="line">                    buff.flip();</span><br><span class="line">                    content += charset.decode(buff);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;=======&quot; + content);</span><br><span class="line">                // 将管道设置为准备下一次读取</span><br><span class="line">                sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125; catch(IOException e) &#123;</span><br><span class="line">                // 如果该sk对应的管道出现异常，表明管道的客户端出现异常，</span><br><span class="line">                // 所以从选择器中取消sk</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                sk.cancel();</span><br><span class="line">                if(sk.channel() != null) &#123;</span><br><span class="line">                    sk.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 说明聊天信息不为空</span><br><span class="line">            if(content.length() &gt; 0) &#123;</span><br><span class="line">                // 将聊天信息输入每个选择键对应的管道中</span><br><span class="line">                for(SelectionKey key : selector.keys()) &#123;</span><br><span class="line">                    Channel targetChannel = key.channel();</span><br><span class="line">                    if(targetChannel instanceof SocketChannel) &#123;</span><br><span class="line">                        SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                        dest.write(charset.encode(content));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h3>
<ol>
<li>为什么 Socket 可以通过流来“持续地”读写，而 DatagramSocket 却只能一个一个数据报发哩？<br>
这是由 TCP 和 UDP 的协议决定的，TCP 是面向流的协议，而 UDP 是面向数据报的协议。</li>
<li>可以用 TCP 客户端连接 UDP 服务器吗（或者反过来）？<br>
不能，实验过确实不行，但是我还是心存疑惑，我猜测是因为接收方可以判断数据包的协议类型来确定是否接收。</li>
<li>socket 是怎么实现&quot;全双工&quot;的？</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.programcreek.com/java-api-examples/index.php" target="_blank" rel="noopener">Java Code Examples</a></li>
<li><a href="https://blog.csdn.net/x5fnncxzq4/article/details/83110446" target="_blank" rel="noopener">Java 应用中的日志</a></li>
<li><a href="https://juejin.im/pin/5cc56f7b6fb9a02f00fc869e" target="_blank" rel="noopener">错误处理的推荐实践</a></li>
<li><a href="http://tech.it168.com/a2013/0829/1527/000001527360.shtml" target="_blank" rel="noopener">Java 开发中 10 个最为微妙的最佳编程实践</a></li>
<li>《Effective Java》</li>
<li><a href="https://edu.aliyun.com/course/417?spm=5176.10731542.0.0.akyXwK" target="_blank" rel="noopener">阿里巴巴编码规范（Java）</a></li>
<li><a href="https://blog.csdn.net/xx326664162/article/details/52175283" target="_blank" rel="noopener">Java 泛型中的 PECS 原则</a></li>
</ol>
<h3 id="jni"><a class="header-anchor" href="#jni">¶</a>JNI</h3>
<ol>
<li><a href="http://tldp.org/HOWTO/Program-Library-HOWTO/index.html" target="_blank" rel="noopener">Program Library HOWTO (how to create and use program libraries on Linux)</a></li>
<li><a href="https://devarea.com/java-and-cc-jni-guide/" target="_blank" rel="noopener">Java and C/C++: JNI Guide</a></li>
</ol>
<h3 id="java5-v2"><a class="header-anchor" href="#java5-v2">¶</a>Java5</h3>
<ol>
<li><a href="https://segmentfault.com/a/1190000004417288" target="_blank" rel="noopener">Java5 的新特性</a></li>
<li><a href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html" target="_blank" rel="noopener">New Features and Enhancements J2SE 5.0</a></li>
<li><a href="https://www.cnblogs.com/xll1025/p/6489088.html" target="_blank" rel="noopener">java 泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></li>
</ol>
<h3 id="网络"><a class="header-anchor" href="#网络">¶</a>网络</h3>
<ol>
<li><a href="http://blog.csdn.net/wangpeng047/article/details/19624529" target="_blank" rel="noopener">HttpClient 使用详解</a></li>
<li><a href="http://blog.csdn.net/xietansheng/article/details/51673073" target="_blank" rel="noopener">基于 JavaMail 的 Java 邮件发送：简单邮件发送</a></li>
<li><a href="http://kf.qq.com/faq/120322fu63YV130422nqIrqu.html" target="_blank" rel="noopener">qq 邮箱服务器地址</a></li>
</ol>
<h3 id="工程"><a class="header-anchor" href="#工程">¶</a>工程</h3>
<ol>
<li><a href="https://www.jianshu.com/p/9c65b7613c30" target="_blank" rel="noopener">IntelliJ IDEA 使用教程(2019 图文版) – 从入门到上瘾</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">122</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
