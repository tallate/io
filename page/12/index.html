<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/12/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/12/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1bd01bc3.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1bd01bc3.html" itemprop="url">网络协议之 TCP 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>TCP、HTTP 几乎是 TCP/IP 协议栈中最实用的两个协议，特别是在 Web 开发中。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/1bd01bc3.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b791cedc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/b791cedc.html" itemprop="url">微服务核心技术总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>虚拟化技术将一台服务器虚拟出多个虚拟机来提供服务。<br>
虚拟化技术包括计算虚拟化（服务器虚拟化）、存储虚拟化、网络虚拟化等。<br>
在实际讲解虚拟化之前，我们需要先解释一下隔离技术，在隔离的基础上我们才能任意粒度、自由地分配资源。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/b791cedc.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fe9473bf.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fe9473bf.html" itemprop="url">微服务中的网络相关组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="网关-zuul"><a class="header-anchor" href="#网关-zuul">¶</a>网关 - Zuul</h2>
<h3 id="filter"><a class="header-anchor" href="#filter">¶</a>Filter</h3>
<p><img src="https://tallate.top/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Zuul%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Zuul组件结构" title="Zuul组件结构"><br>
Zuul 基于 Netty 开发，使用 filters 包含了核心业务逻辑，Filter 是使用 Groovy 写的，主要是为了提供动态编译加载的能力，filters 主要包含了三类：</p>
<ul>
<li>Inbound Filters execute before routing to the origin and can be used for things like authentication, dynamic routing, rate limiting, DDoS protection, metrics and decorating the request.</li>
<li>Endpoint Filters can be used to return static responses, otherwise the built-in <code>ProxyEndpoint</code> filter will route the request to the origin.</li>
<li>Outbound Filters execute after getting the response from the origin and can be used for metrics, decorating the response to the user or adding custom headers.</li>
<li>Async<br>
Filter 可以被同步执行或异步执行。<br>
如果 Filter 没有做太重的工作，可以通过继承<code>HttpInboundSyncFilter</code>或<code>HttpOutboundSyncFilter</code>来实现一种同步 Filter，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>Routes.groovy</code>；<br>
反之，如果需要从其他服务、缓存获取数据，或做一些复杂的计算工作，则最好继承<code>HttpInboundFilter</code>或<code>HttpOutboundFilter</code>，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>SampleServiceFilter.groovy</code>。</li>
</ul>
<h4 id="filter属性"><a class="header-anchor" href="#filter属性">¶</a>Filter属性</h4>
<p>Type: most often defines the stage during the routing flow when the Filter will be applied (although it can be any custom string)<br>
Async: define if the filter is sync or async, generally meaning do you need to make an external call or just doing work on-box<br>
Execution Order: applied within the Type, defines the order of execution across multiple Filters<br>
Criteria: the conditions required in order for the Filter to be executed<br>
Action: the action to be executed if the Criteria is met</p>
<h4 id="其他的一些例子"><a class="header-anchor" href="#其他的一些例子">¶</a>其他的一些例子</h4>
<p>这些例子是<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">zuul-sample</a>中的代码。</p>
<ul>
<li>DebugRequest - look for a query param to add extra debug logging for a request</li>
<li>Healthcheck - simple static endpoint filter that returns 200, if everything is bootstrapped correctly</li>
<li>ZuulResponseFilter - add informational headers to provide extra details on routing, request execution, status and error cause</li>
<li>GZipResponseFilter - can be enabled to gzip outbound responses</li>
<li>SurgicalDebugFilter - can be enabled to route specific requests to different hosts for debugging</li>
</ul>
<h3 id="缓存请求体"><a class="header-anchor" href="#缓存请求体">¶</a>缓存请求体</h3>
<p>默认情况下 Zuul 不会缓存请求体，因为 Filter 一般用到请求头就够了，但是如果需要在 inbound 中用到请求头或在 outbound 中用到响应头，则需要明确指定 Zuul 缓存，可以重写 Filter 的<code>needsBodyBuffered()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">boolean needsBodyBuffered(HttpResponseMessage input) &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络协议"><a class="header-anchor" href="#网络协议">¶</a>网络协议</h3>
<p>Zuul 支持修改暴露服务时使用的协议，使用方法见 sample 项目中的<code>SampleServerStartup</code>。</p>
<h3 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h3>
<p><a href="https://github.com/Netflix/zuul/wiki/Core-Features" target="_blank" rel="noopener">Core Features</a></p>
<h3 id="push-messaging"><a class="header-anchor" href="#push-messaging">¶</a>Push Messaging</h3>
<p>Push Messaging 机制可以支持从 Server 端推送消息到 Client 端，支持两种协议：<code>WebSockets</code> 和 <code>Server Sent Events (SSE)</code>。<br>
<a href="https://github.com/Netflix/zuul/wiki/Push-Messaging" target="_blank" rel="noopener">Push Messaging</a><br>
TODO</p>
<h2 id="负载均衡-ribbon"><a class="header-anchor" href="#负载均衡-ribbon">¶</a>负载均衡 - Ribbon</h2>
<h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3>
<p>原生 API 如何使用见：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started" target="_blank" rel="noopener">Netflix / ribbon - Getting Started</a><br>
如果是搭配 Spring Boot，可以参考 Spring Could 文档。</p>
<h3 id="组件结构及实现"><a class="header-anchor" href="#组件结构及实现">¶</a>组件结构及实现</h3>
<h4 id="rule"><a class="header-anchor" href="#rule">¶</a>Rule</h4>
<p>a logic component to determine which server to return from a list</p>
<ul>
<li>RoundRobinRule<br>
简单的轮询策略</li>
<li>AvailabilityFilteringRule<br>
这个 Rule 会跳过那些疑似“电路跳闸”或并发连接数已经很高的服务器。<br>
比如客户端的最后 3 次连接失败，客户端会认为该服务实例已经出现了类似“电路跳闸”的问题而导致无法提供服务，于是在接下来的 30 秒内均保持这种状态，如果之后还是连接失败，这个等待时间会指数增长（1min、2min、4min…）。</li>
<li>WeightedResponseTimeRule<br>
每个 Server 会根据其平均响应时间计算出一个权重，响应时间越长、比重越小，该 Rule 选择 Server 时会根据该权重来计算概率。</li>
</ul>
<h4 id="ping"><a class="header-anchor" href="#ping">¶</a>Ping</h4>
<p>a component running in background to ensure liveness of servers</p>
<h4 id="serverlist"><a class="header-anchor" href="#serverlist">¶</a>ServerList</h4>
<p>this can be static or dynamic. If it is dynamic (as used by <code>DynamicServerListLoadBalancer</code>), a background thread will refresh and filter the list at certain interval</p>
<ul>
<li>静态的 Server 列表<br>
可以在程序里写一个静态列表，将该列表设置到<code>BaseLoadBalancer.setServerList()</code>中。</li>
<li>ConfigurationBasedServerList<br>
默认的 ServerList 实现，可以通过 <code>Archaius ConfigurationManager</code>来设置 Server 列表。</li>
<li>DiscoveryEnabledNIWSServerList<br>
可以通过 Eureka Client 获取服务器列表，服务器集群必须通过 VipAddress 来定义：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="serverlistfilter"><a class="header-anchor" href="#serverlistfilter">¶</a>ServerListFilter</h4>
<p>ServerListFilter 是<code>DynamicServerListLoadBalancer</code>的组件，用于过滤从<code>ServerList</code>返回的服务器列表，现在有两种实现：</p>
<ul>
<li>
<p>ZoneAffinityServerListFilter<br>
过滤掉不在同一个 zone 内的服务器，除非 zone 内没有可用的服务器，这个 Filter 可以通过设置如下属性来启用（假设客户端名为 myclient、客户端的属性空间为 ribbon）：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myclient.ribbon.EnableZoneAffinity=true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ServerListSubsetFilter<br>
可以保证客户端只能看到<code>ServerList</code>返回的全体服务器的一个固定子集，如果有服务器可用性较弱，则可以定期用新服务器替换老服务器。可以通过设置以下属性启用该Filter：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br><span class="line">myClient.ribbon.NIWSServerListFilterClassName=com.netflix.loadbalancer.ServerListSubsetFilter</span><br><span class="line"># only show client 5 servers. default is 20.</span><br><span class="line">myClient.ribbon.ServerListSubsetFilter.size=5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<p>com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateListOfServers<br>
com.netflix.loadbalancer.ServerList#getUpdatedListOfServers<br>
com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery<br>
TODO</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="常见实现"><a class="header-anchor" href="#常见实现">¶</a>常见实现</h3>
<ol>
<li><a href="https://github.com/Netflix/zuul/blob/master/zuul-sample/src/main/java/com/netflix/zuul/sample/SampleServerStartup.java" target="_blank" rel="noopener">Netflix/zuul</a></li>
<li><a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">Netflix/ribbon</a></li>
<li><a href="https://github.com/Netflix/Turbine" target="_blank" rel="noopener">Netflix / Turbine</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/10511d14.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/10511d14.html" itemprop="url">Linux 脚本基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T10:18:28+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>记录一些平时看到或用过的 shell 脚本技巧和代码片段。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/10511d14.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/9acacb00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/9acacb00.html" itemprop="url">Kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="kubectl-的安装"><a class="header-anchor" href="#kubectl-的安装">¶</a>kubectl 的安装</h2>
<p><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-macos" target="_blank" rel="noopener">Install and Set Up kubectl</a></p>
<h2 id="kubernetes-含义"><a class="header-anchor" href="#kubernetes-含义">¶</a>kubernetes 含义</h2>
<h3 id="kubernetes-master"><a class="header-anchor" href="#kubernetes-master">¶</a>Kubernetes Master</h3>
<p>Kubernetes Master 主要负责管理集群，它会协调集群内的所有活动，包括：scheduling applications, maintaining applications’ desired state, scaling applications, and rolling out new updates。<br>
Master 实际上是三个进程的集合，它们运行在集群的一个 Master Node 上，这三个进程包括：</p>
<ul>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" target="_blank" rel="noopener">kube-apiserver</a>：提供<a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">REST-API</a>来操作 Kubernetes Objects，包括 pods、services、replicationcontrollers 等，并可用于控制集群状态。</li>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>：通过 apiserver 监听集群状态并做状态转移操作。</li>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" target="_blank" rel="noopener">kube-scheduler</a>：scheduler 可以根据集群的拓扑结构、性能、容量等动态分配资源。</li>
</ul>
<h3 id="node"><a class="header-anchor" href="#node">¶</a>Node</h3>
<p>Node 是一台虚拟机或物理电脑，在集群中作为 Worker。Master 管理 Cluster，而 Node 则管理应用。<br>
每个 Node 都有一个 Kubelet，是管理 Node 的媒介，且负责与 Kubernetes Master 进行交互。<br>
每个 Node 还需要有工具来处理容器操作，比如 Docker 或 rkt。<br>
一个生产环境的 cluster 必须由至少 3 个 Node 组成。</p>
<h4 id="kubelet"><a class="header-anchor" href="#kubelet">¶</a><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" target="_blank" rel="noopener">kubelet</a></h4>
<p>节点代理，负责和 Kubernetes Master 交互：</p>
<ul>
<li>向 apiserver 注册节点</li>
<li>其他云计算指定逻辑。</li>
</ul>
<h4 id="kube-proxy"><a class="header-anchor" href="#kube-proxy">¶</a><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/" target="_blank" rel="noopener">kube-proxy</a></h4>
<p>运行于每个 Node 上的一个网络代理，可以执行简单的 TCP、UDP、SCTP 流转发或提供多后端进程的负载均衡。<br>
相当于在主机和 Cluster 之间创建了一个连接，让我们能直接访问 API。</p>
<h3 id="pod"><a class="header-anchor" href="#pod">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a></h3>
<p>一个或多个应用容器集合的抽象，并且包含一些共享资源，包括：</p>
<ul>
<li>共享存储，如 Volumes；</li>
<li>网络连接，每个 Pod 具有 Cluster 中唯一的一个 IP 地址；</li>
<li>运行每个容器所必须的信息，比如容器镜像的版本、端口等。</li>
</ul>
<p>Pod 建模了一种“logical host”，可以同时运行多种不同的容器。<br>
当 Pod 所处的 Node 挂了，<code>ReplicaSet</code>会动态地创建新 Pod 来使得 Cluster 回到原来的状态。</p>
<h3 id="service"><a class="header-anchor" href="#service">¶</a><a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service</a></h3>
<p>Service 定义了 Pod 的逻辑集合及其访问规则，虽然每个 Pod 都有一个唯一的 IP 地址（Cluster 范围内），但是如果没有 Service 的话这些 IP 也是没法暴露到 Cluster 外的，可以通过指定 ServiceSpec 中的<code>type</code>来指定暴露服务的方式：</p>
<ul>
<li>ClusterIP (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster.</li>
<li>NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. Superset of ClusterIP.</li>
<li>LoadBalancer - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort.</li>
<li>ExternalName - Exposes the Service using an arbitrary name (specified by <code>externalName</code> in the spec) by returning a CNAME record with the name. No proxy is used. This type requires v1.7 or higher of <code>kube-dns</code>.</li>
</ul>
<h3 id="volumes"><a class="header-anchor" href="#volumes">¶</a><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">Volumes</a></h3>
<h3 id="namespaces"><a class="header-anchor" href="#namespaces">¶</a><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">Namespaces</a></h3>
<h3 id="deployments"><a class="header-anchor" href="#deployments">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a></h3>
<p>负责创建和更新应用实例，创建 Deployment 后，Master 会持续监听并在各 Node 中调度应用实例，一旦有实例挂掉或被删掉，Deployment controller 就会用 Cluster 中另一 Node 上的实例取代之。</p>
<ul>
<li>searched for a suitable node where an instance of the application could be run (we have only 1 available node)</li>
<li>scheduled the application to run on that Node</li>
<li>configured the cluster to reschedule the instance on a new Node when needed</li>
</ul>
<h3 id="daemonset"><a class="header-anchor" href="#daemonset">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">DaemonSet</a></h3>
<h3 id="statefulsets"><a class="header-anchor" href="#statefulsets">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets</a></h3>
<h3 id="replicaset"><a class="header-anchor" href="#replicaset">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet</a></h3>
<h3 id="jobs"><a class="header-anchor" href="#jobs">¶</a><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="noopener">Jobs</a></h3>
<h2 id="kubernetes-使用"><a class="header-anchor" href="#kubernetes-使用">¶</a>kubernetes 使用</h2>
<p>可以采用<code>kubectl</code>命令来和 Cluster 交互，<code>kubectl</code>最常用的操作只有如下 4 种：</p>
<ul>
<li>kubectl get - list resources</li>
<li>kubectl describe - show detailed information about a resource</li>
<li>kubectl logs - print the logs from a container in a pod</li>
<li>kubectl exec - execute a command on a container in a pod</li>
</ul>
<h3 id="创建cluster"><a class="header-anchor" href="#创建cluster">¶</a>创建Cluster</h3>
<p>例子中使用<code>minikube</code>创建 Cluster，然后使用<code>kubectl</code>来和创建的 Cluster 交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">minikube version</span><br><span class="line"># 启动一个Cluster</span><br><span class="line">minikube start</span><br><span class="line"># 查看客户端（kubectl的版本）和服务端（Kubernetes的版本）的版本</span><br><span class="line">kubectl version</span><br><span class="line"># Cluster的详细信息</span><br><span class="line">kubectl cluster-info</span><br><span class="line"># 获取Cluster内的Node列表</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<ol>
<li>创建部署单元（Deployment）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Deploymnet</span><br><span class="line">kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1</span><br><span class="line"># 查看Deployment</span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"># 查看Pod</span><br><span class="line">kubectl get pods</span><br><span class="line"># 查看Pod内Container的属性，比如使用的是什么镜像</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure>
<h3 id="访问"><a class="header-anchor" href="#访问">¶</a>访问</h3>
<ol>
<li>使用 proxy 访问 Service 和 Pod</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建proxy实例</span><br><span class="line">kubectl proxy</span><br><span class="line"># 创建proxy后可以在另一个终端调用REST API来查看Cluster信息</span><br><span class="line">curl http://localhost:8001/version</span><br><span class="line"># 查看Pod的名字</span><br><span class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</span><br><span class="line">echo Name of the Pod: $POD_NAME</span><br><span class="line"># 可以通过proxy直接访问Pod</span><br><span class="line">curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</span><br></pre></td></tr></table></figure>
<ol>
<li>查看日志</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 所有应用发送给STDOUT的信息都会成为Pod容器的日志</span><br><span class="line">kubectl logs $POD_NAME</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 exec 命令访问 Pod</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看Pod内的环境变量</span><br><span class="line">kubectl exec $POD_NAME env</span><br><span class="line"># 在Pod中一个容器内启动一个bash会话，相当于登入了该容器</span><br><span class="line">kubectl exec -ti $POD_NAME bash</span><br></pre></td></tr></table></figure>
<h3 id="service-v2"><a class="header-anchor" href="#service-v2">¶</a>Service</h3>
<ol>
<li>创建 Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看Service</span><br><span class="line">kubectl get services</span><br><span class="line"># 创建一个新的Service并暴露端口（type=NodePort可以用于占用一个Node上的端口来暴露服务）</span><br><span class="line">kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br><span class="line"># 查看Service信息</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<ol>
<li>Deployment 与 Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 8080其实是集群内的一个逻辑端口，可以通过以下命令获取Node上暴露的端口</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line"># 然后我们可以通过curl访问Node上的端口来确认Service已经被暴露到了Cluster外</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line"></span><br><span class="line"># Deployment会自动为Pod创建一个label，可以通过如下命令来查看</span><br><span class="line">kubectl describe deployment</span><br><span class="line"># 通过label查看Pod列表和Service列表</span><br><span class="line">kubectl get pods -l run=kubernetes-bootcamp</span><br><span class="line">kubectl get services -l run=kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<ol>
<li>Service 中的 Pod</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先获取Pod的名字</span><br><span class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</span><br><span class="line">echo Name of the Pod: $POD_NAME</span><br><span class="line"># 通过label命令可以设置一个新的label</span><br><span class="line">kubectl label pod $POD_NAME app=v1</span><br><span class="line"># 之后可以使用describe 命令来查看这些label，也可以使用label来查询Pod</span><br><span class="line">kubectl describe pods $POD_NAME</span><br><span class="line">kubectl get pods -l app=v1</span><br></pre></td></tr></table></figure>
<ol>
<li>删除 Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 删除一个Service</span><br><span class="line">kubectl delete service -l run=kubernetes-bootcamp</span><br><span class="line"># 查看服务列表，该服务已经被删除</span><br><span class="line">kubectl get services</span><br><span class="line"># curl端口确认不再暴露服务</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br><span class="line"># 我们可以在Pod中运行curl来确定应用仍运行于Pod中</span><br><span class="line">kubectl exec -ti $POD_NAME curl localhost:8080</span><br><span class="line"># 如果需要终止应用，则需要同时删除Deployment</span><br></pre></td></tr></table></figure>
<h3 id="app-扩展"><a class="header-anchor" href="#app-扩展">¶</a>app 扩展</h3>
<p><img src="https://tallate.top/imgs/Kubernetes/scaling.svg" alt="scaling" title="scaling"><br>
上图来自<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/" target="_blank" rel="noopener">官网教程</a>，Scaling 即修改 Deployment 中的 Pod 数。</p>
<ol>
<li>扩展 ReplicaSet（Scale Up）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先看下部署了几个Pod</span><br><span class="line">kubectl get deployments</span><br><span class="line"># 查看Deployment创建的ReplicaSet，ReplicaSet名的格式为[DEPLOYMENT-NAME]-[RANDOM-STRING]</span><br><span class="line">kubectl get rs</span><br><span class="line"># 将Deployment扩展为4个复制</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br><span class="line"># 查看Deployment及其中的Pod</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"># 查看Deployment的时间日志</span><br><span class="line">kubectl describe deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure>
<ol>
<li>Load Balancing</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个NODE_PORT环境变量来保存Node暴露的端口</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line"># curl访问多次，会发现请求被负载均衡到了不同的Pod上</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br></pre></td></tr></table></figure>
<ol>
<li>缩小（Scale Down）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 再运行一次scale命令来缩小ReplicaSet</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=2</span><br><span class="line"># 查看伸缩结果</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>
<h3 id="滚动更新-rolling-update"><a class="header-anchor" href="#滚动更新-rolling-update">¶</a>滚动更新（Rolling Update）</h3>
<ol>
<li>更新应用版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 先看看Cluster里有啥</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br><span class="line"># 查看应用当前使用的镜像版本</span><br><span class="line">kubectl describe pods</span><br><span class="line"># 使用set image命令设置应用的镜像版本</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br><span class="line"># 可以通过Pod查看应用的更新过程</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<ol>
<li>验证更新</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 确认应用正在运行中</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br><span class="line"># 用一个NODE_PORT环境变量保存Node暴露的端口，然后用curl确认暴露的服务可以使用</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br><span class="line"># 更新同样可以使用rollout status命令来确认</span><br><span class="line">kubectl rollout status deployments/kubernetes-bootcamp</span><br><span class="line"># 查看应用当前使用的镜像的版本</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure>
<ol>
<li>回滚（Rollback）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置镜像进行更新，但是这个镜像的v10版本是不存在的，因此会引起更新失败</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</span><br><span class="line"># 查看Deployment的当前状态，会发现某些Pod运行不正常</span><br><span class="line">kubectl get deployments</span><br><span class="line"># 查看Pod状态，describe能提供更多信息</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pods</span><br><span class="line"># 发现问题，可以使用rollout undo命令来回滚，rollout命令会复原deployment到上一已知状态。实际上所有更新操作都是版本化的，并且每次更新都可以回滚到之前的任意版本</span><br><span class="line">kubectl rollout undo deployments/kubernetes-bootcamp</span><br><span class="line"># 接下来再查看Pod的状态可以发现所有的Pod都已经恢复运行了</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="noopener">Tutorials</a><br>
<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" target="_blank" rel="noopener">Learn Kubernetes Basics</a><br>
<a href="https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap/" target="_blank" rel="noopener">Configuring Redis using a ConfigMap</a><br>
使用 k8s 搭建 Redis 集群<br>
<a href="https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/" target="_blank" rel="noopener">Exposing an External IP Address to Access an Application in a Cluster</a><br>
如何使用 k8s 搭建一个无状态服务<br>
<a href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/" target="_blank" rel="noopener">StatefulSet Basics</a><br>
如何使用 k8s 搭建一个有状态服务<br>
<a href="https://kubernetes.io/docs/tutorials/clusters/apparmor/" target="_blank" rel="noopener">AppArmor</a><br>
<a href="https://kubernetes.io/docs/tutorials/services/source-ip/" target="_blank" rel="noopener">Using Source IP</a><br>
<a href="linux.com/tutorials/set-cicd-pipeline-kubernetes-part-1-overview/">CICD</a><br>
<a href="https://www.linux.com/tutorials/set-cicd-pipeline-jenkins-pod-kubernetes-part-2/" target="_blank" rel="noopener">https://www.linux.com/tutorials/set-cicd-pipeline-jenkins-pod-kubernetes-part-2/</a><br>
<a href="https://www.linux.com/tutorials/run-and-scale-distributed-crossword-puzzle-app-cicd-kubernetes-part-3/" target="_blank" rel="noopener">https://www.linux.com/tutorials/run-and-scale-distributed-crossword-puzzle-app-cicd-kubernetes-part-3/</a><br>
<a href="https://www.linux.com/tutorials/set-cicd-distributed-crossword-puzzle-app-kubernetes-part-4/" target="_blank" rel="noopener">https://www.linux.com/tutorials/set-cicd-distributed-crossword-puzzle-app-kubernetes-part-4/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/59c58f8f.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/59c58f8f.html" itemprop="url">Linux 三剑客-cut、awk 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在 awk、sed、cut 三个命令中，awk 是功能最强大的，基本能实现所有字符串操作，平时常用于较复杂的日志分析，不过比起别的命令来也会相对复杂一点。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/59c58f8f.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e8597381.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/e8597381.html" itemprop="url">网络架构梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T14:01:28+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>不懂很多网络概念，在一些开会、对接场合出了很多洋相，趁机好好补补。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/e8597381.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/a4caf2c1.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/a4caf2c1.html" itemprop="url">Nginx 原理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T11:32:43+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="为什么要使用-nginx"><a class="header-anchor" href="#为什么要使用-nginx">¶</a>为什么要使用 Nginx</h2>
<h3 id="nginx-优点"><a class="header-anchor" href="#nginx-优点">¶</a>Nginx 优点</h3>
<ol>
<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>
<li>抗并发，nginx 以 epoll 和 kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>
<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>
<li>nginx 的设计高度模块化，编写模块相对简单</li>
<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>
<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>
<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>
<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ol>
<h3 id="nginx-优点-说出原因"><a class="header-anchor" href="#nginx-优点-说出原因">¶</a>Nginx 优点（说出原因）</h3>
<ol>
<li>Nginx 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。</li>
<li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发</li>
<li>内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术<br>
nginx 处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。<br>
节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存<br>
稳定性高：宕机的概率非常小</li>
<li>master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程<br>
接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力<br>
一边接收 web 服务器的返回数据，一边发送给浏览器客户端<br>
网络依赖性比较低，只要 ping 通就可以负载均衡<br>
可以有多台 nginx 服务器</li>
<li>事件驱动：通信机制采用 epoll 模型</li>
</ol>
<h3 id="apache-优点"><a class="header-anchor" href="#apache-优点">¶</a>Apache 优点</h3>
<ol>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 超稳定</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<h3 id="nginx-和-apache-区别总结"><a class="header-anchor" href="#nginx-和-apache-区别总结">¶</a>Nginx 和 Apache 区别总结</h3>
<p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程<br>
一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。<br>
更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>
<h2 id="接入层演进"><a class="header-anchor" href="#接入层演进">¶</a>接入层演进</h2>
<p>通过研究接入层的发展历程，我们可以一窥 Nginx 在互联网架构中的地位。</p>
<h3 id="接入层结构"><a class="header-anchor" href="#接入层结构">¶</a>接入层结构</h3>
<p><img src="https://tallate.top/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%85%A5%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="接入层结构" title="接入层结构"><br>
可以看到，每一个下游都有多个上游调用，只需要做到，<strong>每一个上游都均匀访问每一个下游</strong>，就能实现整体的均匀分摊。</p>
<ol>
<li>客户端层-&gt;反向代理层<br>
DNS 轮询<br>
DNS-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 DNS-server，会轮询返回这些 ip，保证每个 ip 的解析概率是相同的。这些 ip 就是 nginx 的外网 ip，以做到每台 nginx 的请求分配也是均衡的。</li>
<li>反向代理层-&gt;站点层<br>
反向代理层到站点层的负载均衡，是通过“nginx”实现的。<br>
修改 nginx.conf，可以实现多种均衡策略：<br>
2.1 请求轮询：和 DNS 轮询类似，请求依次路由到各个 web-server；<br>
2.2 最少连接路由：哪个 web-server 的连接少，路由到哪个 web-server；<br>
2.3 ip 哈希：按照访问用户的 ip 哈希值来路由 web-server，只要用户的 ip 分布是均匀的，请求理论上也是均匀的，ip 哈希均衡方法可以做到，同一个用户的请求固定落到同一台 web-server 上，此策略适合有状态服务，例如 session；</li>
</ol>
<blockquote>
<p>session 不推荐放到站点层，后期扩展会有问题，更好的方案是放到数据层。</p>
</blockquote>
<ol start="3">
<li>站点层-&gt;服务层<br>
站点层到服务层的负载均衡，是通过“服务连接池”实现的。<br>
上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。除了负载均衡，服务连接池还能够实现故障转移、超时处理、限流限速、ID 串行化等诸多功能。</li>
<li>服务层-&gt;数据层<br>
在数据量很大的情况下，由于数据层（db/cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<br>
<strong>数据的均衡</strong>是指：水平切分后的每个服务（db/cache），数据量是均匀的。<br>
<strong>请求的均衡</strong>是指：水平切分后的每个服务（db/cache），请求量是均匀的。</li>
</ol>
<h3 id="接入层演进-v2"><a class="header-anchor" href="#接入层演进-v2">¶</a>接入层演进</h3>
<ol>
<li>单机架构<br>
客户端用 DNS 解析出来的 IP 就是 web 服务器的地址。<br>
缺点：
<ul>
<li>单点；</li>
<li>扩展性差。</li>
</ul>
</li>
<li>DNS 轮询<br>
在 DNS 服务器上多配几个 IP，由域名服务器的解析策略实现负载均衡。<br>
缺点：
<ul>
<li>非高可用，因为一个 web 服务器挂掉后 DNS 服务器仍然会将请求解析到该服务器对应的 IP 上；</li>
<li>扩容非实时，DNS 服务器有一个配置生效的延时时间；</li>
<li>暴露太多外网 IP。</li>
</ul>
</li>
<li>反向代理 Nginx<br>
DNS 解析到 Nginx 的 IP，然后由 Nginx 将请求负载均衡到 web 服务器。<br>
缺点：基本解决了上一个架构存在的问题，且可以利用 Nginx 的探活机制实现 web 服务器的高可用，但是此时 Nginx 也会成为一个单点。</li>
<li>keepalived<br>
两台 Nginx 组成集群，分别部署上 keepalived，设置成相同的虚 IP，保证 Nginx 的高可用。当一台 Nginx 挂了，keepalived 能够探测到并将流量迁移到另一台 Nginx 上，整个过程对调用方透明。<br>
缺点：
<ul>
<li>资源利用率低；</li>
<li>扩容不方便，如果吞吐量超过 Nginx 性能上线，要加机器配置起来比较麻烦。</li>
</ul>
</li>
<li>lvs/f5<br>
DNS 解析出来的 IP 是 lvs 的地址。由 lvs 反向代理 Nginx 服务器，lvs 的机器上部署 keepalived+VIP 实现高可用；<br>
f5 的性能比 lvs 更高，但是成本也会更高。</li>
<li>DNS 轮询<br>
水平扩展才是解决性能问题的根本方案，能够通过加机器扩充性能的方案才具备最好的扩展性。<br>
<img src="https://tallate.top/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8E%A5%E5%85%A5%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="可扩展高可用接入层架构" title="可扩展高可用接入层架构">
<ul>
<li>通过 DNS 轮询来线性扩展入口 lvs 层的性能；</li>
<li>通过 keepalived 保证高可用；</li>
<li>通过 lvs 来扩展多个 Nginx；</li>
<li>通过 Nginx 实现对业务服务器的七层负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="使用-nginx"><a class="header-anchor" href="#使用-nginx">¶</a>使用 Nginx</h2>
<h3 id="手动安装-nginx"><a class="header-anchor" href="#手动安装-nginx">¶</a>手动安装 Nginx</h3>
<ol>
<li>配置<br>
创建目录<code>/var/temp/nginx</code><br>
这个目录保存临时文件，在安装配置中指定：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure>
<ol>
<li>配置环境变量<br>
在<code>/etc/profile</code>中编辑，这样就可以直接使用 nginx 命令启动了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure>
<ol>
<li>启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line"># 指定配置文件</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>如果不指定-c，nginx 在启动时默认加载 conf/nginx.conf 文件，此文件的地址也可以在编译安装 nginx 时指定./configure 的参数（–conf-path= 指向配置文件（nginx.conf））</p>
<ol>
<li>停止</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop # 相当于先查出nginx进程id再kill</span><br><span class="line">nginx -s quit # 建议使用，这种方法是等nginx进程的任务处理完毕后再停止</span><br></pre></td></tr></table></figure>
<ol>
<li>重启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>要想在修改配置文件 nginx.conf 后生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h3 id="开机自启"><a class="header-anchor" href="#开机自启">¶</a>开机自启</h3>
<ol>
<li>创建<code>/etc/init.d/nginx</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&apos;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<ol>
<li>设置文件访问权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<ol>
<li>设置开机加载<br>
在<code>/etc/rc.local</code>中加入一行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure>
<h3 id="通过-docker-运行-nginx"><a class="header-anchor" href="#通过-docker-运行-nginx">¶</a>通过 Docker 运行 Nginx</h3>
<p>手动进行 Nginx 配置十分繁琐，可以使用 Docker 来简化部署流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<h2 id="nginx-原理-进程"><a class="header-anchor" href="#nginx-原理-进程">¶</a>Nginx 原理 - 进程</h2>
<h3 id="nginx-代码的模块化结构"><a class="header-anchor" href="#nginx-代码的模块化结构">¶</a>Nginx 代码的模块化结构</h3>
<p>Nginx 的代码是由一个核心和一系列的模块组成的。<br>
<strong>核心</strong>主要用于提供 WebServer 的基本功能，以及 Web 和 Mail 反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。<br>
不过，大多跟协议相关的功能和应用特有的功能都是由 nginx 的模块实现的。<br>
换句话说， <strong>每一个功能或操作都由一个模块来实现</strong>。<br>
这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream 和负载均衡几个类别，这些共同组成了 nginx 的 http 功能。<br>
<strong>事件模块</strong>主要用于提供 OS 独立的(不同操作系统的事件机制有所不同)事件通知机制如 kqueue 或 epoll 等。<br>
<strong>协议模块</strong>则负责实现 nginx 通过 http、tls/ssl、smtp、pop3 以及 imap 与对应的客户端建立会话。<br>
在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的。<br>
换句话说，每一个功能或操作都由一个模块来实现。例如：压缩、通过 FastCGI 或 uwsgi 协议与 upstream 服务器通信、以及与 memcached 建立会话等。</p>
<h3 id="进程结构"><a class="header-anchor" href="#进程结构">¶</a>进程结构</h3>
<p>一个 Nginx 服务器实例由一个 master 进程和多个 worker 进程组成。<br>
<img src="https://tallate.top/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"><br>
<strong>master</strong>进程主要用来管理 worker 进程，还有一些对整个服务器的初始化和日志记录等工作。<br>
<strong>管理 worker 的过程</strong>：接收来自外界的信号，向各 worker 进程发送 <strong>信号</strong> ，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动（fork）新的 worker 进程。</p>
<p><strong>master 主要功能</strong>：</p>
<ul>
<li>读取并验证配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止 worker 进程及维护 worker 进程的个数；</li>
<li>无须中止服务而重新配置工作；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式 perl 脚本</li>
</ul>
<p>对请求的实际处理由 <strong>worker</strong> 负责，且每个请求只能由一个 worker 负责（一对一）。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。</p>
<p><strong>worker 主要功能</strong>：</p>
<ul>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx 任何能完成的其它任务</li>
</ul>
<h3 id="nginx-的启动"><a class="header-anchor" href="#nginx-的启动">¶</a>Nginx 的启动</h3>
<p>nginx 启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程（你可以理解为工人和管理员）。</p>
<h3 id="nginx-处理连接过程"><a class="header-anchor" href="#nginx-处理连接过程">¶</a>Nginx 处理连接过程</h3>
<p>nginx 不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的 <strong>循环</strong> 来处理数千个连接。<br>
Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。 <strong>监听套接字</strong> 在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。</p>
<p>一次请求过程大概执行过程为：</p>
<ol>
<li>nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面先初始化好这个监控的 socket，再进行 listen（listenfd）；</li>
<li>由 master 进程 fork 出多个 worker 进程；</li>
<li>此时客户端可以向 nginx 发起连接了，客户端会与 nginx 进行三次握手（TCP），与 nginx 建立好一个连接；</li>
<li>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接</li>
<li>当一个 worker 进程在 accept 这个连接之后，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体，就开始读取请求、解析请求、处理请求（ <strong>异步非阻塞</strong> ），主要是根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换</li>
<li>产生数据后，再返回给客户端，最后才断开连接，或者由客户端主动关闭连接。</li>
</ol>
<h3 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h3>
<p>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的，其原理是<strong>信号机制</strong>，master 对 worker 进程采用信号进行控制。</p>
<h3 id="事件驱动"><a class="header-anchor" href="#事件驱动">¶</a>事件驱动</h3>
<p>所谓<strong>事件驱动</strong>架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会“消费”这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。<br>
传统 web 服务器（如 Apache）的所谓事件局限在 TCP 连接建立、关闭上，其他读写都不再是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 Web 服务器每个事件消费者独占一个进程资源，相对来说，Nginx 只是被事件分发者进程短期调用而已。<br>
nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限，多少个 worker 就能处理多少个并发，那么何来的高并发呢？<br>
其实，Nginx 是采用了<strong>异步非阻塞</strong>的 IO 模型来处理请求的（epoll），异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。<br>
请求的<strong>多阶段异步处理</strong>只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段。<br>
每种事件都有一个事件队列，按触发的先后顺序处理。</p>
<h3 id="惊群现象"><a class="header-anchor" href="#惊群现象">¶</a>惊群现象</h3>
<p>惊群是多个子进程在同一时刻监听同一个端口引起的；<br>
Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。这可以通过锁或互斥量实现。</p>
<h3 id="为什么不使用多线程"><a class="header-anchor" href="#为什么不使用多线程">¶</a>为什么不使用多线程</h3>
<ul>
<li>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。</li>
<li>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</li>
</ul>
<h2 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h2>
<h3 id="模块命名"><a class="header-anchor" href="#模块命名">¶</a>模块命名</h3>
<p><code>ngx_http_[module-name]_[main|srv|loc]_conf_t</code><br>
前缀表示模块名，后面表示模块运行在哪一层</p>
<h3 id="模块化结构"><a class="header-anchor" href="#模块化结构">¶</a>模块化结构</h3>
<p>Nginx由内核和一系列模块组成，内核提供web服务的基本功能,如启用网络协议,创建运行环境,接收和分配客户端请求,处理模块之间的交互。Nginx的各种功能和操作都由模块来实现。<br>
Nginx的模块从结构上分为核心模块、基础模块和第三方模块。</p>
<ul>
<li>核心模块： HTTP模块、EVENT模块和MAIL模块</li>
<li>基础模块： HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li>
<li>第三方模块： HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块及用户自己开发的模块</li>
</ul>
<p>这样的设计使Nginx方便开发和扩展，也正因此才使得Nginx功能如此强大。Nginx的模块默认编译进nginx中，如果需要增加或删除模块，需要重新编译Nginx，这一点不如Apache的动态加载模块方便。如果有需要动态加载模块，可以使用由淘宝网发起的web服务器Tengine，在nginx的基础上增加了很多高级特性，完全兼容Nginx，已被国内很多网站采用。</p>
<p>模块大致结构如下图所示。<br>
<img src="https://tallate.top/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/Nginx%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.png" alt="Nginx模块结构" title="Nginx模块结构"><br>
Nginx模块，简单地讲，就是：在特定地方调用的函数。</p>
<h3 id="模块执行过程"><a class="header-anchor" href="#模块执行过程">¶</a>模块执行过程</h3>
<p>nginx的配置 <strong>指令作用域</strong> 分为以下几种：main，server，location<br>
main作用域的范围为整个配置文件，而server是指某个具体的服务器（通过端口号来区分），而location就是指要访问这个server的哪个location。</p>
<p>Nginx 本身做的工作实际很少，当它接到一个 HTTP 请求时，它仅仅是通过查找配置文件将此次请求映射到一个 locationblock，而此 location 中所配置的各个指令则会启动不同的模块去完成工作。<br>
通常一个 location 中的指令会涉及一个 handler 模块和多个 filter 模块（当然，多个 location 可以复用同一个模块）。handler 模块负责处理请求，完成响应内容的生成，而 filter 模块对响应内容进行处理。<br>
模块处理请求的大致过程如下图所示。<br>
<img src="https://tallate.top/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/Nginx%E6%A8%A1%E5%9D%97%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Nginx模块执行流程" title="Nginx模块执行流程"></p>
<h3 id="http-index模块-ngx-http-index-module"><a class="header-anchor" href="#http-index模块-ngx-http-index-module">¶</a>http index模块（ngx_http_index_module）</h3>
<p>定义将要被作为默认页的文件。 文件的名字可以包含变量。 文件以配置中指定的顺序被 nginx 检查。 列表中的最后一个元素可以是一个带有绝对路径的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /home/ftpuser/www;</span><br><span class="line">    index  index.html index.$haha.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，index 文件会引发内部重定向，请求可能会被其它 location 处理。<br>
比如下面的配置，请求&quot;/“实际上将会在第二个location中作为”/index.html&quot;被处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="http-log模块-ngx-http-log-module"><a class="header-anchor" href="#http-log模块-ngx-http-log-module">¶</a>http log模块（ngx_http_log_module）</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  gzip &apos;$remote_addr-$remote_user[$time_local]&apos;</span><br><span class="line">:&apos;$request$status $bytes_sent&apos;</span><br><span class="line">:&apos;&quot; $ http _ referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&apos;;</span><br><span class="line">access_log  /spool/logs/nginx-access.log  gzip  buffer=32k;</span><br></pre></td></tr></table></figure>
<p>指令 access_log 指派路径、格式和缓存大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">access_log path [format [buffer=size | off ]</span><br><span class="line"># 默认</span><br><span class="line">access_log log/access.log combined</span><br></pre></td></tr></table></figure>
<p>其中参数 “off” 将清除当前级别的所有 access_log 指令。如果未指定格式，则使用预置的 “combined” 格式。缓存不能大于能写入磁盘的文件的最大值（在 FreeBSD 3.0-6.0 ，缓存大小无此限制）。<br>
指令 log_format 指定日志格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">log_format name format [format ...]</span><br><span class="line"># 默认</span><br><span class="line">log_format combined &quot;...&quot;</span><br></pre></td></tr></table></figure>
<h3 id="access模块-ngx-http-access-module"><a class="header-anchor" href="#access模块-ngx-http-access-module">¶</a>Access模块（ngx_http_access_module）</h3>
<p>此模块提供了一个简易的基于主机的访问控制。<br>
ngx_http_access_module 模块让我们可以对特定 IP 客户端进行控制。 规则检查按照第一次匹配的顺序，此模块对网络地址有放行和禁止的权利。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 仅允许网段 10.1.1.0/16 和 192.168.1.0/24 中除 192.168.1.1 之外的 ip 访问</span><br><span class="line">location / &#123;</span><br><span class="line">: deny 192.168.1.1;</span><br><span class="line">: allow 192.168.1.0/24;</span><br><span class="line">: allow 10.1.1.0/16;</span><br><span class="line">: deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>放行语法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow [ address | CIDR | all ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>作用域: http, server, location, limit_except<br>
allow 描述的网络地址有权直接访问</p>
<ol>
<li>禁止语法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deny [ address | CIDR | all ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>作用域: http, server, location, limit_except<br>
deny 描述的网络地址拒绝访问</p>
<h3 id="rewrite模块-ngx-http-rewrite-module"><a class="header-anchor" href="#rewrite模块-ngx-http-rewrite-module">¶</a>Rewrite模块（ngx_http_rewrite_module）</h3>
<p>执行 URL 重定向,允许你去掉带有恶意的 URL，包含多个参数（修改）.利用正则的匹配，分组和引用，达到目的 配置范例：该模块允许使用正则表达式改变 URL，并且根据变量来转向以及选择配置</p>
<ol>
<li>if语法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>作用域: server, location<br>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">: rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;] +)(?:;|$)&quot; ) &#123;</span><br><span class="line">: set $id $1;</span><br><span class="line">&#125;</span><br><span class="line">if ($request_method = POST ) &#123;</span><br><span class="line">: return 405;</span><br><span class="line">&#125;</span><br><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">: break;</span><br><span class="line">: proxy_pass http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">: limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">: return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>return语法<br>
这个指令根据规则的执行情况，返回一个状态值给客户端。可使用值包括：204，400，402-406，408，410，411，413，416 及 500-504。也可以发送非标准的 444 代码-未发送任何头信息下结束连接。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return cod</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>作用域: server, location, if</p>
<ol>
<li>rewrite语法<br>
这个指令根据正则表达式或者待替换的字符串来更改 URL。指令根据配置文件中的先后顺序执行生效。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement flag</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>flag可以有以下取值：<br>
* last :表示完成 rewrite<br>
* break:本规则匹配完成后，终止匹配，不再匹配后面的规则<br>
* redirect:返回 302 临时重定向，地址栏会显示跳转后的地址<br>
* permanent:返回 301 永久重定向，地址栏会显示跳转后的地址<br>
作用域: server, location, if</p>
<h3 id="proxy模块-ngx-http-proxy-module"><a class="header-anchor" href="#proxy模块-ngx-http-proxy-module">¶</a>Proxy模块（ngx_http_proxy_module）</h3>
<p>此模块能代理请求到其它服务器.也就是说允许你把客户端的 HTTP 请求转到后端服务器(这部分的指令非常多，但不是全部都会被用到，详细指令列表可以上<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">官网</a>查看，这里是比较常见的指令简介)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 强制一些被忽略的头传递到客户端</span><br><span class="line">proxy_pass_header Server;</span><br><span class="line"># 允许改写出现在 HTTP 头却被后端服务器触发重定向的 URL,对响应本身不做任何处理</span><br><span class="line">proxy_redirect off;</span><br><span class="line"># 允许你重新定义代理 header 值再转到后端服务器，目标服务器可以看到客户端的原始主机名</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line"># 目标服务器可以看到客户端的真实 ip，而不是转发服务器的 ip</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br></pre></td></tr></table></figure>
<h3 id="upstream模块-ngx-http-upstream-module"><a class="header-anchor" href="#upstream模块-ngx-http-upstream-module">¶</a>upstream模块（ngx_http_upstream_module）</h3>
<p>该指令将来自客户端的一个请求分到多个上行服务器上，即我们常说的负载均衡。<br>
默认情况下采用<strong>轮询</strong>策略，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>
可以使用<strong>weight</strong>来指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server backend2.example.com:8080;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>upstream指令<br>
这个指令描述了一个服务器的集合，该集合可被用于 proxy_pass 和 fastcgi_pass 指令中，作为一个单独的实体。这些服务器可以是监听在不同的端口，另外，并发使用同时监听 TCP 端口和 Unix 套接字的服务器是可能的。 这些服务器能被分配不同的权重。如果没有指定，则都为 1 ，即默认的策略为轮询。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com weight=5;</span><br><span class="line">    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;</span><br><span class="line">    server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过weight参数指定每个上行服务器的权重，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">     server localhost:8080 weight=9;</span><br><span class="line">     server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>ip_hash指令<br>
请求基于客户端的 IP 地址在服务器间进行分发。 IPv4 地址的前三个字节或者 IPv6 的整个地址，会被用来作为一个散列 key。 这种方法可以确保从同一个客户端过来的请求，会被传给同一台服务器。除了当服务器被认为不可用的时候，这些客户端的请求会被传给其他服务器，而且很有可能也是同一台服务器。<br>
如果其中一个服务器想暂时移除，应该加上 down 参数。这样可以保留当前客户端 IP 地址散列分布。<br>
作用域：upstream</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server backend1.example.com;</span><br><span class="line">  server backend2.example.com;</span><br><span class="line">  server backend3.example.com down;</span><br><span class="line">  server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fair（第三方）<br>
按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    fair; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>url_hash(第三方)<br>
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>server指令<br>
定义服务器的地址 address 和其他参数 parameters。 地址可以是域名或者 IP 地址，端口是可选的，或者是指定“unix:”前缀的 UNIX 域套接字的路径。如果没有指定端口，就使用 80 端口。 如果一个域名解析到多个 IP，本质上是定义了多个 server。<br>
作用域：upstream <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="nginx配置文件优化"><a class="header-anchor" href="#nginx配置文件优化">¶</a>nginx配置文件优化</h2>
<h3 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h3>
<p>默认配置文件位置在/usr/local/nginx/conf/nginx.conf，在configue时决定，也可以在运行nginx时指定配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="顶层配置"><a class="header-anchor" href="#顶层配置">¶</a>顶层配置</h3>
<p>顶层配置即nginx.conf中前面、暴露在外面的那几项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">#pid        logs/nginx.pid;</span><br></pre></td></tr></table></figure>
<p><strong>worker_processes</strong> 定义了 nginx 在为你的网站提供服务时，worker 进程的数量。<br>
这个优化值受到包括 CPU 内核数、存储数据的磁盘数、负载值在内的许多因素的影响。如果不确定的话，将其设置为可用的 CPU 内核的数量是一个不错的选择（设置为“auto”，将会尝试自动检测可用的值）。<br>
另外本机的CPU核心信息可以使用下面命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep processor</span><br></pre></td></tr></table></figure>
<h3 id="events模块"><a class="header-anchor" href="#events模块">¶</a>events模块</h3>
<p>events模块包括了 nginx 中处理链接的全部设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    # multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>worker_connections</strong> 设置了一个 worker 进程可以同时打开的链接数。<br>
<strong>multi_accept</strong> 的作用是告诉 nginx 在收到新链接的请求通知时，尽可能接受链接。最好开着</p>
<h3 id="http模块"><a class="header-anchor" href="#http模块">¶</a>http模块</h3>
<p>当外部有 http 请求时，nginx 的 http 模块才是处理这个请求的核心。</p>
<ol>
<li>Basic Settings<br>
<strong>sendfile</strong> 指向 sendfile()函数。sendfile() 在磁盘和 TCP 端口（或者任意两个文件描述符）之间复制数据。<br>
在 sendfile 出现之前，为了传输这样的数据，需要在用户空间上分配一块数据缓存，使用 read() 从源文件读取数据到缓存，然后使用 write() 将缓存写入到网络。<br>
sendfile() 直接从磁盘上读取数据到操作系统缓冲。由于这个操作是在内核中完成的，sendfile() 比 read() 和 write() 联合使用要更加有效率。<br>
<strong>tcp_nopush</strong> 配置 nginx 在一个数据包中发送全部的头文件，而不是一个一个发送。<br>
<strong>tcp_nodelay</strong> 配置 nginx 不要缓存数据，应该快速的发送小数据——这仅仅应该用于频繁发送小的碎片信息而无需立刻获取响应的、需要实时传递数据的应用中。<br>
<strong>keepalive_timeout</strong> 指定了与客户端的 keep-alive 链接的超时时间。服务器会在这个时间后关闭链接。我们可以降低这个值，以避免让 worker 过长时间的忙碌。</li>
<li>Logging Settings<br>
<strong>access_log</strong> 确定了 nginx 是否保存访问日志。将这个设置为关闭可以降低磁盘 IO 而提升速度。<br>
<strong>error_log</strong> 设置 nginx 应当记录错误日志。</li>
<li>Gzip Settings<br>
<strong>gzip</strong> 设置 nginx gzip 压缩发送的数据。这会减少需要发送的数据的数量。<br>
<strong>gzip_disable</strong> 为指定的客户端禁用 gzip 功能。<br>
<strong>gzip_proxied</strong> 允许或禁止基于请求、响应的压缩。设置为 any，就可以 gzip 所有的请求。<br>
<strong>gzip_comp_level</strong> 设置了数据压缩的等级。等级可以是 1-9 的任意一个值，9 表示最慢但是最高比例的压缩。<br>
<strong>gzip_types</strong> 设置进行 gzip 的类型。有下面这些，不过还可以添加更多。</li>
</ol>
<h3 id="mail模块"><a class="header-anchor" href="#mail模块">¶</a>mail模块</h3>
<p>略…</p>
<h2 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">user nginxuser;</span><br><span class="line">worker_processes 4;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 15;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    # server_tokens off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # server_names_hash_bucket_size 64;</span><br><span class="line">    # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Logging Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Gzip Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     gzip_vary on;</span><br><span class="line">     gzip_proxied any;</span><br><span class="line">     gzip_comp_level 9;</span><br><span class="line">     gzip_buffers 16 8k;</span><br><span class="line">     gzip_http_version 1.1;</span><br><span class="line">     gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # nginx-naxsi config</span><br><span class="line">    ##</span><br><span class="line">    # Uncomment it if you installed nginx-naxsi</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #include /etc/nginx/naxsi_core.rules;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # nginx-passenger config</span><br><span class="line">    ##</span><br><span class="line">    # Uncomment it if you installed nginx-passenger</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #passenger_root /usr;</span><br><span class="line">    #passenger_ruby /usr/bin/ruby;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Virtual Host Configs</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mail &#123;</span><br><span class="line">#   # See sample authentication script at:</span><br><span class="line">#   # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="line"># </span><br><span class="line">#   # auth_http localhost/auth.php;</span><br><span class="line">#   # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="line">#   # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="line"># </span><br><span class="line">#   server &#123;</span><br><span class="line">#       listen     localhost:110;</span><br><span class="line">#       protocol   pop3;</span><br><span class="line">#       proxy      on;</span><br><span class="line">#   &#125;</span><br><span class="line"># </span><br><span class="line">#   server &#123;</span><br><span class="line">#       listen     localhost:143;</span><br><span class="line">#       protocol   imap;</span><br><span class="line">#       proxy      on;</span><br><span class="line">#   &#125;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化-linux-最大连接数"><a class="header-anchor" href="#优化-linux-最大连接数">¶</a>优化 - Linux 最大连接数</h2>
<h3 id="查看-linux-连接数"><a class="header-anchor" href="#查看-linux-连接数">¶</a>查看 Linux 连接数</h3>
<p>默认配置下，Linux 只支持有限的连接数。<br>
Linux 的线程其实是一个进程，所以 java 的也是，具体来说，叫做“light weight process(LWP)”—轻量级进程。<br>
LWP 与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个 LWP，这样它们共享大部分资源；LWP 有它自己的进程标识符，并和其他进程有着父子关系；。LWP 由内核管理并像普通进程一样被调度<br>
使用以下命令可以看到某个用户使用了多少进程资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep xjjbot(uid)  | wc -l</span><br></pre></td></tr></table></figure>
<p>使用下面命令可以查看具体每个进程开启了多少线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u xjjbot(uid)  | sort -n</span><br></pre></td></tr></table></figure>
<p>根据 linux 一切都是文件的规则，首先想到的，是修改 ulimit 的参数，然而也不是，因为它已经足够大了。交叉回想一下 elasticsearch，在安装的时候，需要配置一个叫做 nproc 的东西，问题大概就出在这，是进程资源不够用啦。<br>
相关的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>在不同的内核版本上，也有一些小差异。比如：/etc/security/limits.d/*<br>
下的文件，会在某些时候覆盖 limits.conf 的配置。所以配置不生效的情况下，记得检查一下。<br>
鉴于以上原因，可以将 limits.d 中的配置全部注释掉，统一在 limits.conf 中配置。<br>
以下是原始配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<p>将 4096 改为大点的数字，或者直接改成 unlimited 就可以了。</p>
<p>单机支持 100 万连接是可行的，但带宽问题会成为显著的瓶颈。启用压缩的二进制协议会节省部分带宽，但开发难度增加。</p>
<h3 id="操作系统优化"><a class="header-anchor" href="#操作系统优化">¶</a>操作系统优化</h3>
<p>更改进程最大文件句柄数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1048576</span><br></pre></td></tr></table></figure>
<p>复制代码修改单个进程可分配的最大文件数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2097152 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>
<p>复制代码修改/etc/security/limits.conf 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   soft nofile  1048576</span><br><span class="line">*   hard nofile 1048576</span><br><span class="line">*   soft nproc unlimited</span><br><span class="line">root soft nproc unlimited</span><br></pre></td></tr></table></figure>
<p>复制代码记得清理掉/etc/security/limits.d/*下的配置</p>
<h3 id="网络优化"><a class="header-anchor" href="#网络优化">¶</a>网络优化</h3>
<p>打开/etc/sysctl.conf，添加配置然后执行，使用 sysctl 生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#单个进程可分配的最大文件数</span><br><span class="line">fs.nr_open=2097152</span><br><span class="line"></span><br><span class="line">#系统最大文件句柄数</span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line">#backlog 设置</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">net.core.netdev_max_backlog=16384</span><br><span class="line"></span><br><span class="line">#可用知名端口范围配置</span><br><span class="line">net.ipv4.ip_local_port_range=&apos;1000 65535&apos;</span><br><span class="line"></span><br><span class="line">#TCP Socket 读写 Buffer 设置</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.optmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=&apos;1024 4096 16777216&apos;</span><br><span class="line">net.ipv4.tcp_wmem=&apos;1024 4096 16777216&apos;</span><br><span class="line"></span><br><span class="line">#TCP 连接追踪设置</span><br><span class="line">net.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait=30</span><br><span class="line"></span><br><span class="line">#TIME-WAIT Socket 最大数量、回收与重用设置</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line"></span><br><span class="line"># FIN-WAIT-2 Socket 超时设置</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.shiyanlou.com/courses/95" target="_blank" rel="noopener">Linux Web 运维（Nginx）实战</a></li>
<li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx 开发从入门到精通</a></li>
<li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">nginx documentation</a></li>
</ol>
<h3 id="config"><a class="header-anchor" href="#config">¶</a>config</h3>
<p>nginx.conf配置文件详解 <a href="http://www.ha97.com/5194.html" target="_blank" rel="noopener">http://www.ha97.com/5194.html</a><br>
更多配置技巧 <a href="https://www.nginx.com/resources/wiki/start/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/start/</a></p>
<h3 id="nginx-原理"><a class="header-anchor" href="#nginx-原理">¶</a>Nginx 原理</h3>
<ol>
<li><a href="https://segmentfault.com/q/1010000003901360?_ea=416091" target="_blank" rel="noopener">Nginx 内部有使用多线程吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清 epoll 的本质，那就过来掐死我吧！ （1）</a></li>
</ol>
<h3 id="模块-v2"><a class="header-anchor" href="#模块-v2">¶</a>模块</h3>
<ol>
<li>log<br>
<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">Module ngx_http_log_module</a><br>
<a href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html#log_format" target="_blank" rel="noopener">Module ngx_stream_log_module</a><br>
<a href="http://blog.chinaunix.net/uid-29179844-id-4433640.html" target="_blank" rel="noopener">nginx 日志格式及自定义日志配置</a></li>
<li>proxy<br>
<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">Module ngx_http_proxy_module</a></li>
<li>TCP / UDP<br>
<a href="http://nginx.org/en/docs/stream/stream_processing.html" target="_blank" rel="noopener">How nginx processes a TCP/UDP session</a></li>
</ol>
<h3 id="tengine"><a class="header-anchor" href="#tengine">¶</a>Tengine</h3>
<ol>
<li><a href="http://tengine.taobao.org/documentation.html" target="_blank" rel="noopener">Documentation</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d9054d7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/d9054d7.html" itemprop="url">Redis事务和Lua</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-06T09:42:14+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/缓存/" itemprop="url" rel="index">
                    <span itemprop="name">缓存</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这一篇是对在公司内缓存代码应用 Redis-Lua 的一个总结，经过 benchmark 测试，这种方式效率更高，且理论上有更低的可能性。<br>
顺便，一开始先描述一下Redis中的事务的原理，因为Redis-Lua本身是事务的一个替代品，这二者一般放在一起讨论。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/d9054d7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4be4a53c.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/4be4a53c.html" itemprop="url">一些有价值的开源学习资料汇总（updating）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-05T21:37:14+08:00">
                2019-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  304 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>收集从网上找到的学习资料，大部分来自 Github。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/4be4a53c.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">144</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
