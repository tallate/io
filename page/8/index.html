<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/8/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tallate">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/page/8/">







  <title>Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/92a28d62.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/92a28d62.html" itemprop="url">SpringCloud 配置总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。<br>
Spring Cloud 常常被拿来和 Dubbo 比较，实际上 Dubbo 只实现了服务治理，接入 Dubbo 的服务能够实现自动上下线、能通过 Dubbo 协议（其实 Dubbo 还支持其他很多协议）互联，但是 Dubbo 并不提供网关、配置中心、链路追踪等一系列微服务架构常用的技术，需要单独引入。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/92a28d62.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3e0c4ce6.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/3e0c4ce6.html" itemprop="url">Spring 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  844 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>Spring 如何加载注解</h1>
<p>很多注解本身只是提供了一个标识，要实现注解所表示的功能，必然还会有一个扫描器扫描这个注解，然后将必须的Bean注入到Spring容器内，而且很多时候会<strong>为被注解的对象生成一个动态代理</strong>，以实现日志记录、接口幂等、限流等功能。<br>
要自己实现一个注解，关键是如何扫描及如何生成代理并注入到Spring容器这两个步骤，具体的实现可以参考<code>MapperScannerConfigurer</code>，大体逻辑是：</p>
<ol>
<li>在Spring容器加载完毕后，再对指定包下的类进行一次扫描；</li>
<li></li>
</ol>
<h1>Spring 三级缓存</h1>
<h2 id="spring-中产生循环依赖的三种情况"><a class="header-anchor" href="#spring-中产生循环依赖的三种情况">¶</a>Spring 中产生循环依赖的三种情况</h2>
<ol>
<li>构造器注入循环依赖 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>构造器注入构成的循环依赖，此种循环依赖方式是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖。<br>
不能解决的原因是：Spring 解决循环依赖的原理是实例化 Bean 后先把引用存到一个 Map 中，之后初始化成员变量时，可以直接从这个 Map 中取。但是构造器注入相当于<strong>实例化和初始化是同时进行的</strong>，因此无法解决。</p>
<ol>
<li>
<p>singleton 模式 field 属性注入循环依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>prototype 模式 field 属性注入循环依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="spring-创建-bean-的流程"><a class="header-anchor" href="#spring-创建-bean-的流程">¶</a>Spring 创建 Bean 的流程</h2>
<ol>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</li>
<li>populateBean：填充属性，这一步主要是对 bean 的依赖属性进行注入(@Autowired)</li>
<li>initializeBean：回到一些形如 initMethod、InitializingBean 等方法</li>
</ol>
<p>其中，循环依赖可能发生在第一步和第二步，其中第一步是因为构造方法中可能会需要传入其他 Bean。</p>
<h2 id="spring-三级缓存如何解决循环依赖"><a class="header-anchor" href="#spring-三级缓存如何解决循环依赖">¶</a>Spring 三级缓存如何解决循环依赖</h2>
<h3 id="缓存生效时间"><a class="header-anchor" href="#缓存生效时间">¶</a>缓存生效时间</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    // 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用</span><br><span class="line">	/** Cache of singleton objects: bean name --&gt; bean instance */</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</span><br><span class="line"></span><br><span class="line">    // 提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</span><br><span class="line">	/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br><span class="line">	private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);</span><br><span class="line">	</span><br><span class="line">	// 单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</span><br><span class="line">	/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br><span class="line">    private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);</span><br></pre></td></tr></table></figure>
<h3 id="获取单例-bean-的过程"><a class="header-anchor" href="#获取单例-bean-的过程">¶</a>获取单例 Bean 的过程</h3>
<p><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String)</code></p>
<ol>
<li>先从一级缓存 singletonObjects 中去获取，如果获取到就直接 return。</li>
<li>如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存 earlySingletonObjects 中获取，如果获取到就直接 return。</li>
<li>如果还是获取不到，且允许 singletonFactories（allowEarlyReference=true）通过 getObject()获取。就从三级缓存 singletonFactory.getObject()获取，如果获取到了就从 singletonFactories 中移除，并且放进 earlySingletonObjects，其实也就是从三级缓存移动到了二级缓存。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/485e1bd7.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/485e1bd7.html" itemprop="url">Vim 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T20:09:11+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  501 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>平时在 Linux 环境下待的久了，免不了和 Vim 打交道。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/485e1bd7.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fca77f63.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fca77f63.html" itemprop="url">Linux 与 IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>总结Linux中的5种IO模型，其中最常用的是IO多路复用，特别是epoll是各种网络框架的底层IO框架。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/fca77f63.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/283c6d00.html" itemprop="url">Linux 与文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  223 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="文件系统操作"><a class="header-anchor" href="#文件系统操作">¶</a>文件系统操作</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -F filename # 列出目录，使用*等符号标志文件类型，*表示可执行文件，/为目录文件</span><br><span class="line">ls -i filename # 查看文件inode号</span><br><span class="line">mkdir -p dirname # 创建目录，如果有父目录就创建父目录</span><br><span class="line">stat filename # 查看文件详细信息，包括inode号、链接数</span><br><span class="line">mv # 移动/重命名</span><br><span class="line">ln oldfile newfile # 创建硬链接</span><br><span class="line">ln -s sourcefile/sourcedir targetfile/targetdir # 创建软链接</span><br></pre></td></tr></table></figure>
<h3 id="chroot"><a class="header-anchor" href="#chroot">¶</a>chroot</h3>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/" target="_blank" rel="noopener">chroot</a></p>
<h3 id="mount-和-umount"><a class="header-anchor" href="#mount-和-umount">¶</a>mount 和 umount</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t # 查看挂载分区信息</span><br></pre></td></tr></table></figure>
<p>制作目录硬链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 假设当前目录下有a和b两个目录</span><br><span class="line">mount -o bind a b # b成为a的硬链接，其实就是将a挂载到了b上</span><br><span class="line">mount # 通过mount可以看出是bind这个参数起作用</span><br><span class="line">/dev/sda2 on /home/hgc/Downloads/b type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line"># 删除时必须先卸载再删除</span><br><span class="line">umount b</span><br><span class="line">rm -rf b</span><br></pre></td></tr></table></figure>
<h3 id="ln"><a class="header-anchor" href="#ln">¶</a>ln</h3>
<h3 id="fdisk"><a class="header-anchor" href="#fdisk">¶</a>fdisk</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l # 查看硬盘分区信息</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/283c6d00.html" itemprop="url">Linux 基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>并发（Concurrency）</h1>
<p>线程、进程，线程安全，进程同步，可见性，一致性，锁，信号量，并发，并行</p>
<h2 id="线程和进程"><a class="header-anchor" href="#线程和进程">¶</a>线程和进程</h2>
<p>从操作系统概念上说，<strong>线程</strong>是最小的可执行单位，也就是系统调度的最小单位。<strong>进程</strong>是资源分配的最小单位。线程是依赖进程存在的，共享进程内的资源，如内存，cpu，io 等。在操作系统的发展过程中，为了提高系统的稳定性、吞吐量和安全性，操作系统内核和用户态做了隔离，例如 Linux 有内核线程，用户线程，内核进程，用户进程，从根本上 Linux 是没有线程的，线程对 Linux 系统来说是个特殊的进程。那么用户线程和内核线程是一一对应呢？从宏观上看是一一对应的，在用户态的每一个线程，都会在内核有对应的执行线程，但是由于资源的限制，用户态的线程和内核线程是多对一的关系。用户进程和内核进程也类似。具体怎样对应的，这里就不探讨了。<br>
为了提高操作系统的实时性，操作系统是以时间片轮转来实现任务调度的。理论上时间片内是不可以被中断的，可认为是 cpu 最小的单位执行时间。现代操作系统为了提高用户体验，线程都是抢占式的，而中断一般在时间片用完的时候发生。线程、进程和 CPU 都是多对一的关系，所以存在进程线程切换的问题。<br>
线程内部还是有自己内存空间的，所以有个概念叫线程内存模型。线程内部有自己私有的本地内存，故线程和线程之间的本地内存存在可见性问题。例如全局变量 A 在线程 1 修改后，线程 2 并不一定能拿到 A 的修改值，因为线程 1 会把全局变量 A 拷贝到本地内存，修改后并不会马上同步。在编译的时候，编译器为了优化，（例如利用超线程技术）可能会重排指令的执行顺序，这就会存在一致性了。</p>
<h2 id="线程安全"><a class="header-anchor" href="#线程安全">¶</a>线程安全</h2>
<p>在线程安全里面经常要讨论的两个问题就是：可见性和一致性。锁是什么东西呢？锁就是一道内存屏障，保证可见性和一致性的一种策略，由操作系统甚至更底层的硬件提供。加锁是消耗资源的，特别是在多核 CPU 上，现在多核 CPU 一般有 3 级缓存，一级缓存通常是单核独占的，而线程的本地内存很可能就保存在 cpu 的缓存里面，然而加锁就意味着保证可见性和一致性，需要中断同步数据，保证别人拿到的是最新修改值。由于用途不同，锁被设计成各种各样的，如互斥锁，读写锁，自旋锁，同步块，数据库的事务等，如果只要保证可见性的，可以不使用锁，在 java 里面可以使用 volatile 修饰全局变量。虽然在 c／c＋＋，都有同样的修饰符，但是是不是一样的意思呢，请参考其他文章。</p>
<h2 id="死锁-deadlock"><a class="header-anchor" href="#死锁-deadlock">¶</a>死锁（deadlock）</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>多个进程竞争资源造成的互相等待情况。</p>
<h3 id="资源"><a class="header-anchor" href="#资源">¶</a>资源</h3>
<p>可重用性资源：可供重复使用多次的资源<br>
不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程使用完后自动释放<br>
可消耗资源:又叫临时性资源，它是在进程运行期间，由进程动态的创建和消耗的</p>
<h3 id="死锁产生的原因"><a class="header-anchor" href="#死锁产生的原因">¶</a>死锁产生的原因</h3>
<ol>
<li>系统资源的竞争<br>
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。<br>
主要是竞争可重用不可抢占式的资源和可消耗的资源。</li>
<li>进程运行推进顺序不合适<br>
进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</li>
</ol>
<h3 id="死锁产生的条件"><a class="header-anchor" href="#死锁产生的条件">¶</a>死锁产生的条件</h3>
<p><strong>互斥条件</strong> 一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>
<strong>请求与保持条件</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br>
<strong>不可剥夺条件</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br>
<strong>循环等待条件</strong> 若干进程间形成首尾相接循环等待资源的关系<br>
<strong>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong><br>
形象地说，就是有两个酒鬼，一个有开瓶器，一个有酒，这两种资源都只能被一个人占有（互斥），且用完之前不能被另一个人抢去（不可剥夺），他们互相等对方手上的资源（循环等待），但又不肯放开自己手上的资源（请求与保持），因此陷入了死锁。</p>
<h3 id="死锁避免"><a class="header-anchor" href="#死锁避免">¶</a>死锁避免</h3>
<p>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。<br>
书上给出了两种死锁避免策略</p>
<ol>
<li>进程启动拒绝<br>
若对每个资源，能满足现有所有进程再加上新进程的需求，则可以启动这个进程，否则拒绝</li>
<li>资源分配拒绝（银行家算法）</li>
</ol>
<h3 id="死锁预防"><a class="header-anchor" href="#死锁预防">¶</a>死锁预防</h3>
<p>死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。</p>
<ol>
<li>互斥<br>
不可能禁止，比如文件只允许互斥的写访问</li>
<li>占有且等待<br>
可以要求进程一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足，这样就不会再请求新资源了。</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<h1>持久化（Persistent）</h1>
<h2 id="linux-io-模型"><a class="header-anchor" href="#linux-io-模型">¶</a>Linux IO 模型</h2>
<p><img src="https://tallate.top/imgs/Linux/Linux%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="X" title="Linux整体结构"><br>
应用程序调用内核 IO 函数的过程如下图所示：<br>
<img src="https://tallate.top/imgs/Linux/IO%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="X" title="IO系统调用过程"><br>
处于 OS 的安全性等的考虑，进程无法直接操作 I/O 设备，必须通过系统调用来请求内核完成 I/O 动作，而内核会为每个 I/O 设备维护一个 Buffer。</p>
<ol>
<li>用户进程发起请求；</li>
<li>内核接收到请求后，从 I/O 设备中获取数据到 Buffer 中；</li>
<li>将 Buffer 中的数据拷贝到用户进程的地址空间，该用户进程获取到数据后响应给客户端。</li>
</ol>
<p>在整个请求过程中，数据输入至 Buffer 需要时间，从 Buffer 复制数据到进程也需要时间，这个等待时间是限制 I/O 效率的罪魁祸首，根据等待方式的不同，I/O 动作可以分为以下五种模式：</p>
<ul>
<li>阻塞 I/O（Blocking I/O）</li>
<li>非阻塞 I/O（Non-Blocking I/O）</li>
<li>I/O 复用（I/O Multiplexing）</li>
<li>信号驱动的 I/O（Signal Driven I/O）</li>
<li>异步 I/O（Asynchronous I/O）</li>
</ul>
<h2 id="存储器管理"><a class="header-anchor" href="#存储器管理">¶</a>存储器管理</h2>
<h2 id="文件系统"><a class="header-anchor" href="#文件系统">¶</a>文件系统</h2>
<h2 id="io-pipe"><a class="header-anchor" href="#io-pipe">¶</a>IO（pipe）</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line"></span><br><span class="line">int testPipe()&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line"></span><br><span class="line">    int *read_fd = &amp;fd[0];</span><br><span class="line">    int *write_fd = &amp;fd[1];</span><br><span class="line"></span><br><span class="line">    if(pipe(fd) == -1)&#123;</span><br><span class="line">        printf(&quot;pipe create failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == -1)&#123;</span><br><span class="line">        printf(&quot;fork failed&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char string[] = &quot;hahaha&quot;;</span><br><span class="line">        close(*read_fd);</span><br><span class="line">        count = write(*write_fd, string, sizeof(string));</span><br><span class="line">        printf(&quot;写了%d个字符\n&quot;, count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char buffer[100];</span><br><span class="line">        close(*write_fd);</span><br><span class="line">        count = read(*read_fd, buffer, sizeof(buffer));</span><br><span class="line">        printf(&quot;父进程接受到%d字节的数据:%s&quot;, count, buffer);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚拟内存"><a class="header-anchor" href="#虚拟内存">¶</a>虚拟内存</h2>
<h3 id="swap"><a class="header-anchor" href="#swap">¶</a>swap</h3>
<h1>虚拟化（Virtualization）</h1>
<h2 id="驱动管理"><a class="header-anchor" href="#驱动管理">¶</a>驱动管理</h2>
<h1>参考</h1>
<h2 id="linux-应用"><a class="header-anchor" href="#linux-应用">¶</a>Linux 应用</h2>
<ol>
<li>虚拟内存<br>
<a href="https://www.linux.com/news/all-about-linux-swap-space" target="_blank" rel="noopener">All about Linux swap space</a><br>
<a href="https://wiki.archlinux.org/index.php/swap" target="_blank" rel="noopener">Swap</a><br>
<a href="https://haydenjames.io/linux-performance-almost-always-add-swap-space/" target="_blank" rel="noopener">Linux Performance: Why You Should Almost Always Add Swap Space</a></li>
<li>演进<br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-kernel-advances/index.html" target="_blank" rel="noopener">Linux 内核的发展 介绍 2.6.28 和 2.6.29 版本中的新特性</a><br>
<a href="https://linux.cn/article-6179-1.html" target="_blank" rel="noopener">对 Linux 内核的发展方向的展望 - Linux 4.2</a></li>
<li>运维<br>
<a href="https://juejin.im/entry/5c9780335188252d941493d3" target="_blank" rel="noopener">老司机告诉你：正规的运维工作是什么的?</a></li>
<li>并发<br>
<a href="https://blog.csdn.net/u011677209/article/details/78082722" target="_blank" rel="noopener">Linux 原子操作 atomic_cmpxchg()/Atomic_read()/Atomic_set()/Atomic_add()/Atomic_sub()</a></li>
<li>隔离<br>
<a href="https://www.v2ex.com/member/jerry017cn/topics" target="_blank" rel="noopener">cgroup - jerry017cn</a></li>
</ol>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a>操作系统</h2>
<ol>
<li>分时和实时操作系统<br>
<a href="https://www.osrtos.com/" target="_blank" rel="noopener">List of open source real-time operating systems</a></li>
<li>操作系统概念<br>
<a href="https://www.cnblogs.com/leesf456/p/5375198.html" target="_blank" rel="noopener">【操作系统】操作系统综述（一）</a></li>
<li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters" target="_blank" rel="noopener">Operating Systems: Three Easy Pieces</a></li>
</ol>
<h3 id="concurrency"><a class="header-anchor" href="#concurrency">¶</a>Concurrency</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5413517.html" target="_blank" rel="noopener">【操作系统】进程管理（二）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5605193.html" target="_blank" rel="noopener">【操作系统】处理机调度与死锁（三）</a></li>
</ol>
<h3 id="persistent"><a class="header-anchor" href="#persistent">¶</a>Persistent</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5616041.html" target="_blank" rel="noopener">【操作系统】存储器管理（四）</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5626339.html" target="_blank" rel="noopener">【操作系统】文件管理（六）</a></li>
</ol>
<h3 id="virtualization"><a class="header-anchor" href="#virtualization">¶</a>Virtualization</h3>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5622859.html" target="_blank" rel="noopener">【操作系统】设备管理（五）</a></li>
</ol>
<h2 id="linux-内核"><a class="header-anchor" href="#linux-内核">¶</a>Linux 内核</h2>
<ol>
<li>哈工大操作系统<br>
<a href="https://mooc.study.163.com/course/1000002004?_trace_c_p_k2_=6a6064778bf54c5f98396d86c4146823#/info" target="_blank" rel="noopener">操作系统之基础</a><br>
<a href="https://www.shiyanlou.com/courses/115" target="_blank" rel="noopener">操作系统原理与实践</a></li>
<li>NJU<br>
<a href="https://nju-ics.gitbooks.io/ics2016-programming-assignment/content/1.1.html" target="_blank" rel="noopener">在开始愉快的 PA 之旅之前</a><br>
<a href="https://github.com/NJU-ProjectN/LiteNES" target="_blank" rel="noopener">NJU-ProjectN</a></li>
<li><a href="http://www.linfo.org/index.html" target="_blank" rel="noopener">The Linux Information Project</a></li>
<li><a href="https://www.kernel.org/" target="_blank" rel="noopener">The Linux Kernel Archives</a></li>
<li><a href="https://tinylab.gitbooks.io/linux-doc/content/zh-cn/" target="_blank" rel="noopener">Linux 内核文档（中文版）</a></li>
<li><a href="http://www.superfrink.net/athenaeum/OS-FAQ/os-faq.html" target="_blank" rel="noopener">Write Your Own Operating System</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/" target="_blank" rel="noopener">6.828: Operating System Engineering</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/ba7cab3d.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ba7cab3d.html" itemprop="url">并发安全容器-Queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  53 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发安全容器-queue"><a class="header-anchor" href="#并发安全容器-queue">¶</a>并发安全容器（Queue）</h2>
<h3 id="concurrentlinkedqueue"><a class="header-anchor" href="#concurrentlinkedqueue">¶</a>ConcurrentLinkedQueue</h3>
<p>ConcurrentLinkedQueue 是线程安全的无界非阻塞队列，底层数据结构使用单向链表实现，入队和出队操作使用 CAS 来实现线程安全。<br>
2.1 ConcurrentLinkedQueue 类图结构<br>
先简单介绍下 ConcurrentLinkedQueue 的类图结构如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192520988.png" alt="image.png"><br>
如上类图 ConcurrentLinkedQueue 内部的队列是使用单向链表方式实现，其中两个 volatile 类型的 Node 节点分别用来存放队列的首尾节点。从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。<br>
public ConcurrentLinkedQueue() {<br>
head = tail = new Node<e>(null);<br>
}<br>
Node 节点内部则维护一个 volatile 修饰的变量 item 用来存放节点的值，next 用来存放链表的下一个节点，从而链接为一个单向无界链表。<br>
首先一个图来概况该队列构成，读者可以读完本节后在回头体会这个图：<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521208.png" alt="image.png"><br>
2.2 ConcurrentLinkedQueue 原理介绍<br>
本节主要介绍 ConcurrentLinkedQueue 的几个主要的方法的实现原理<br>
2.2.1 offer 操作<br>
offer 操作是在队列末尾添加一个元素，如果传递的参数是 null 则抛出 NPE 异常，否者由于 ConcurrentLinkedQueue 是无界队列该方法一直会返回 true。另外由于使用 CAS 无阻塞算法，该方法不会阻塞调用线程，下面具体看看实现原理。<br>
public boolean offer(E e) {<br>
//（1）e为null则抛出空指针异常<br>
checkNotNull(e);</e></p>
<p>//（2）构造Node节点<br>
final Node<e> newNode = new Node<e>(e);</e></e></p>
<pre><code>//（3）从尾节点进行插入
for (Node&lt;E&gt; t = tail, p = t;;) {

    Node&lt;E&gt; q = p.next;

    //（4）如果q==null说明p是尾节点，则执行插入
    if (q == null) {

        //（5）使用CAS设置p节点的next节点
        if (p.casNext(null, newNode)) {
            //（6）cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点
            if (p != t)
                casTail(t, newNode);  // Failure is OK.
            return true;
        }
    }
    else if (p == q)//(7）
        //多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要
        //重新找新的head，因为新的head后面的节点才是正常的节点。
        p = (t != (t = tail)) ? t : head;
    else
        //（8） 寻找尾节点
        p = (p != t &amp;&amp; t != (t = tail)) ? t : q;
}
</code></pre>
<p>}<br>
上节类图结构时候谈到构造队列时候参构造函数创建了一个 item 为 null 的哨兵节点，并且 head 和 tail 都是指向这个节点，下面通过图形结合来讲解下 offer 操作的代码实现。<br>
首先看下当一个线程调用 offer（item）时候情况：首先代码（1）对传参判断空检查，如果为 null 则抛出 NPE 异常，然后代码（2）则使用 item 作为构造函数参数创建了一个新的节点，代码（3）从队列尾部节点开始循环，意图是从队列尾部添加元素。<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521263.png" alt="image.png"><br>
上图是执行代码（4）时候队列的情况，这时候节点 p,t,head,tail 同时指向了 item 为 null 的哨兵节点，由于哨兵节点的 next 节点为 null, 所以这里 q 指向也是 null。<br>
代码（4）发现q==null则执行代码（5）通过 CAS 原子操作判断 p 节点的 next 节点是否为 null，如果为 null 则使用节点 newNode 替换 p 的 next 节点，然后执行代码（6）由于p==t所以没有设置尾部节点，然后退出 offer 方法，这时候队列的状态图如下：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521325.png" alt="image.png"><br>
上面讲解的是一个线程调用 offer 方法的情况，如果多个线程同时调用，就会存在多个线程同时执行到代码（5），假设线程 A 调用 offer（item1), 线程 B 调用 offer(item2), 线程 A 和 B 同时执行到 p.casNext(null, newNode)。而 CAS 的比较并设置操作是原子性的，假设线程 A 先执行了比较设置操作则发现当前 p 的 next 节点确实是 null 则会原子性更新 next 节点为 newNode，这时候线程 B 也会判断 p 的 next 节点是否为 null，结果发现不是 null（因为线程 A 已经设置了 p 的 next 为 newNode）则会跳到步骤（3），然后执行到步骤（4）时候队列分布图为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521398.png" alt="image.png"><br>
根据这个状态图可知线程 B 会去执行代码（8），然后 q 赋值给了 p，这时候队列状态图为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521501.png" alt="image.png"><br>
然后线程 B 再次跳转到代码（3）执行，当执行到代码（4）时候队列状态图为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521579.png" alt="image.png"><br>
由于这时候 q==null, 所以线程 B 会执行步骤（5），通过 CAS 操作判断当前 p 的 next 节点是否是 null，不是则再次循环后尝试，是则使用 newNode 替换，假设 CAS 成功了，那么执行步骤（6）由于 p!=t 所以设置 tail 节点为 newNode，然后退出 offer 方法。这时候队列分布图为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521654.png" alt="image.png"><br>
分析到现在，offer 代码的执行路径现在就差步骤（7）还没走过，其实这个要在执行 poll 操作后才会出现，这里先看下执行 poll 操作后可能会存在的的一种情况如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522328.png" alt="image.png"><br>
下面分析下当队列处于这种状态时候调用 offer 添加元素代码执行到步骤（4）时候的状态图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521811.png" alt="image.png"><br>
由于 q 节点不为空并且p==q所以执行步骤（7），由于t==tail所以 p 被赋值为了 head，然后进入循环，循环后执行到代码（4）时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521884.png" alt="image.png"><br>
由于q==null, 所以执行步骤（5）进行 CAS 操作，如果当前没有其他线程执行 offer 操作，则 CAS 操作会成功，p 的 next 节点被设置为新增节点，然后执行步骤（6），由于p!=t所以设置新节点为队列为节点，现在队列状态如下：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192521955.png" alt="image.png"><br>
这里自引用的节点会被垃圾回收掉。<br>
总结：可见 offer 操作里面关键步骤是代码（5）通过原子 CAS 操作来进行控制同时只有一个线程可以追加元素到队列末尾，进行 cas 竞争失败的线程则会通过循环一次次尝试进行 cas 操作，直到 cas 成功才会返回，也就是通过使用无限循环里面不断进行 CAS 尝试方式来替代阻塞算法挂起调用线程，相比阻塞算法这是使用 CPU 资源换取阻塞所带来的开销。<br>
2.2.2 poll 操作<br>
poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null，下面看看实现原理。<br>
public E poll() {<br>
//(1) goto标记<br>
restartFromHead:</p>
<pre><code>//（2）无限循环
for (;;) {
    for (Node&lt;E&gt; h = head, p = h, q;;) {

        //（3）保存当前节点值
        E item = p.item;

        //（4）当前节点有值则cas变为null
        if (item != null &amp;&amp; p.casItem(item, null)) {
            //（5）cas成功标志当前节点以及从链表中移除
            if (p != h) 
                updateHead(h, ((q = p.next) != null) ? q : p);
            return item;
        }
        //（6）当前队列为空则返回null
        else if ((q = p.next) == null) {
            updateHead(h, p);
            return null;
        }
        //（7）自引用了，则重新找新的队列头节点
        else if (p == q)
            continue restartFromHead;
        else//(8）
            p = q;
    }
}
</code></pre>
<p>}<br>
final void updateHead(Node<e> h, Node<e> p) {<br>
if (h != p &amp;&amp; casHead(h, p))<br>
h.lazySetNext(h);<br>
}<br>
同理本节也通过图形结合的方式来讲解代码执行逻辑：<br>
poll 操作是从队头获取元素，所以代码（2）内层循环是从 head 节点开始迭代，代码（3）获取当前队头的节点，当队列一开始为空时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522032.png" alt="image.png"><br>
由于 head 节点指向的为 item 为 null 的哨兵节点，所以会执行到代码（6），假设这个过程中没有线程调用 offer 方法，则此时 q 等于 null 如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522112.png" alt="image.png"><br>
所以执行 updateHead 方法，由于 h 等于 p 所以没有设置头结点，poll 方法直接返回 null。<br>
假设执行到代码（6）时候已经有其它线程调用了 offer 方法成功添加一个元素到队列，这时候 q 指向的是新增元素的节点，这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522181.png" alt="image.png"><br>
所以代码（6）判断结果为 false，然后会转向代码（7）执行，而此时 p 不等于 q，所以转向代码（8）执行，执行结果是 p 指向了节点 q，此时队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522254.png" alt="image.png"><br>
然后程序转向代码（3）执行，p 现在指向的元素值不为 null，则执行p.casItem(item, null) 通过 CAS 操作尝试设置 p 的 item 值为 null，如果此时没有其它线程进行 poll 操作，CAS 成功则执行代码（5）由于此时 p!=h 所以设置头结点为 p，poll 然后返回被从队列移除的节点值 item。此时队列状态为:<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522328.png" alt="image.png"><br>
这个状态就是讲解 offer 操作时候，offer 代码的执行路径（7）执行的前提状态。<br>
假如现在一个线程调用了 poll 操作，则在执行代码（4) 时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522382.png" alt="image.png"><br>
可知这时候执行代码（6）返回 null.<br>
现在 poll 的代码还有个分支（7）没有执行过，那么什么时候会执行那？下面来看看，假设线程 A 执行 poll 操作时候当前队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522444.png" alt="image.png"><br>
那么执行p.casItem(item, null) 通过 CAS 操作尝试设置 p 的 item 值为 null。<br>
假设 CAS 设置成功则标示该节点从队列中移除了，此时队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522518.png" alt="image.png"><br>
然后由于 p!=h, 所以会执行 updateHead 方法，假如线程 A 执行 updateHead 前另外一个线程 B 开始 poll 操作这时候线程 B 的 p 指向 head 节点，但是还没有执行到代码（6）这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522583.png" alt="image.png"><br>
然后线程 A 执行 updateHead 操作，执行完毕后线程 A 退出，这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522663.png" alt="image.png"><br>
然后线程 B 继续执行代码（6）q=p.next由于该节点是自引用节点所以p==q所以会执行代码（7）跳到外层循环 restartFromHead，重新获取当前队列队头 head, 现在状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522732.png" alt="image.png"><br>
总结：poll 方法移除一个元素时候只是简单的使用 CAS 操作把当前节点的 item 值设置 null，然后通过重新设置头结点让该元素从队列里面摘除，被摘除的节点就成了孤立节点，这个节点会被在垃圾回收的时候会回收掉。另外执行分支中如果发现头节点被修改了要跳到外层循环重新获取新的头节点。<br>
2.2.3 peek 操作<br>
peek 操作是获取队列头部一个元素（只不获取不移除），如果队列为空则返回 null，下面看看实现原理。<br>
public E peek() {<br>
//(1)<br>
restartFromHead:<br>
for (;;) {<br>
for (Node<e> h = head, p = h, q;;) {<br>
//(2)<br>
E item = p.item;<br>
//(3)<br>
if (item != null || (q = p.next) == null) {<br>
updateHead(h, p);<br>
return item;<br>
}<br>
//(4)<br>
else if (p == q)<br>
continue restartFromHead;<br>
else<br>
//(5)<br>
p = q;<br>
}<br>
}<br>
}<br>
代码结构与 poll 操作类似，不同在于步骤（3）的使用只是少了 castItem 操作，其实这很正常，因为 peek 只是获取队列头元素值并不清空其值，根据前面我们知道第一次执行 offer 后 head 指向的是哨兵节点（也就是 item 为 null 的节点），那么第一次 peek 时候代码（3）中会发现 item==null, 然后会执行 q = p.next, 这时候 q 节点指向的才是队列里面第一个真正的元素或者如果队列为 null 则 q 指向 null。<br>
当队列为空时候这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522799.png" alt="image.png"><br>
这时候执行 updateHead 由于 h 节点等于 p 节点所以不进行任何操作，然后 peek 操作会返回 null。<br>
当队列至少有一个元素时候（这里假设只有一个）这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522872.png" alt="image.png"><br>
这时候执行代码（5）这时候 p 指向了 q 节点，然后执行代码（3）这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192522963.png" alt="image.png"><br>
执行代码（3）发现 item 不为 null，则执行 updateHead 方法，由于 h!=p, 所以设置头结点，设置后队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523042.png" alt="image.png"><br>
也就是剔除了哨兵节点。<br>
总结：peek 操作代码与 poll 操作类似只是前者只获取队列头元素但是并不从队列里面删除，而后者获取后需要从队列里面删除，另外在第一次调用 peek 操作时候，会删除哨兵节点，并让队列的 head 节点指向队列里面第一个元素或者 null。<br>
2.2.4 size 操作<br>
获取当前队列元素个数，在并发环境下不是很有用，因为 CAS 没有加锁所以从调用 size 函数到返回结果期间有可能增删元素，导致统计的元素个数不精确。<br>
public int size() {<br>
int count = 0;<br>
for (Node<e> p = first(); p != null; p = succ§)<br>
if (p.item != null)<br>
// 最大返回Integer.MAX_VALUE<br>
if (++count == Integer.MAX_VALUE)<br>
break;<br>
return count;<br>
}</e></e></e></e></p>
<p>//获取第一个队列元素（哨兵元素不算），没有则为null<br>
Node<e> first() {<br>
restartFromHead:<br>
for (;;) {<br>
for (Node<e> h = head, p = h, q;;) {<br>
boolean hasItem = (p.item != null);<br>
if (hasItem || (q = p.next) == null) {<br>
updateHead(h, p);<br>
return hasItem ? p : null;<br>
}<br>
else if (p == q)<br>
continue restartFromHead;<br>
else<br>
p = q;<br>
}<br>
}<br>
}</e></e></p>
<p>//获取当前节点的next元素，如果是自引入节点则返回真正头节点<br>
final Node<e> succ(Node<e> p) {<br>
Node<e> next = p.next;<br>
return (p == next) ? head : next;<br>
}<br>
2.2.5 remove 操作<br>
如果队列里面存在该元素则删除给元素，如果存在多个则删除第一个，并返回 true，否者返回 false<br>
public boolean remove(Object o) {</e></e></e></p>
<pre><code>//查找元素为空，直接返回false
if (o == null) return false;
Node&lt;E&gt; pred = null;
for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) {
    E item = p.item;

    //相等则使用cas值null,同时一个线程成功，失败的线程循环查找队列中其它元素是否有匹配的。
    if (item != null &amp;&amp;
        o.equals(item) &amp;&amp;
        p.casItem(item, null)) {

        //获取next元素
        Node&lt;E&gt; next = succ(p);

        //如果有前驱节点，并且next不为空则链接前驱节点到next,
        if (pred != null &amp;&amp; next != null)
            pred.casNext(p, next);
        return true;
    }
    pred = p;
}
return false;
</code></pre>
<p>}<br>
注：ConcurrentLinkedQueue 底层使用单向链表数据结构来保存队列元素，每个元素被包装为了一个 Node 节点，队列是靠头尾节点来维护的，创建队列时候头尾节点指向一个 item 为 null 的哨兵节点，第一次 peek 或者 first 时候会把 head 指向第一个真正的队列元素。由于使用非阻塞 CAS 算法，没有加锁，所以获取 size 的时候有可能进行了 offer，poll 或者 remove 操作，导致获取的元素个数不精确，所以在并发情况下 size 函数不是很有用。</p>
<h3 id="linkedblockingqueue"><a class="header-anchor" href="#linkedblockingqueue">¶</a>LinkedBlockingQueue</h3>
<p>前面介绍了使用 CAS 算法实现的非阻塞队列 ConcurrentLinkedQueue，下面就来介绍下使用独占锁实现的阻塞队列 LinkedBlockingQueue 的实现<br>
3.1 LinkedBlockingQueue 类图结构<br>
同理首先看下 LinkedBlockingQueue 的类图结构<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523099.png" alt="image.png"><br>
如上类图可知 LinkedBlockingQueue 也是使用单向链表实现，也有两个 Node 分别用来存放首尾节点，并且里面有个初始值为 0 的原子变量 count 用来记录队列元素个数。另外里面有两个 ReentrantLock 的实例，分别用来控制元素入队和出队的原子性，其中 takeLock 用来控制同时只有一个线程可以从队列获取元素，其它线程必须等待，putLock 控制同时只能有一个线程可以获取锁去添加元素，其它线程必须等待。另外 notEmpty 和 notFull 是信号量，内部分别有一个条件队列用来存放进队和出队时候被阻塞的线程，其实这个是个生产者 - 消费者模型。如下是独占锁创建代码：<br>
/** 执行take, poll等操作时候需要获取该锁 */<br>
private final ReentrantLock takeLock = new ReentrantLock();</p>
<pre><code>/** 当队列为空时候执行出队操作（比如take）的线程会被放入这个条件队列进行等待 */
private final Condition notEmpty = takeLock.newCondition();

/** 执行put, offer等操作时候需要获取该锁*/
private final ReentrantLock putLock = new ReentrantLock();

/**当队列满时候执行进队操作（比如put)的线程会被放入这个条件队列进行等待 */
private final Condition notFull = putLock.newCondition();
</code></pre>
<p>/** 当前队列元素个数 */<br>
private final AtomicInteger count = new AtomicInteger(0);<br>
如下是 LinkedBlockingQueue 无参构造函数代码：<br>
public static final int   MAX_VALUE = 0x7fffffff;</p>
<p>public LinkedBlockingQueue() {<br>
this(Integer.MAX_VALUE);<br>
}</p>
<p>public LinkedBlockingQueue(int capacity) {<br>
if (capacity &lt;= 0) throw new IllegalArgumentException();<br>
this.capacity = capacity;<br>
//初始化首尾节点,指向哨兵节点<br>
last = head = new Node<e>(null);<br>
}<br>
从代码可知默认队列容量为 0x7fffffff; 用户也可以自己指定容量，所以一定程度上 LinkedBlockingQueue 可以说是有界阻塞队列。<br>
首先使用一个图来概况该队列，读者在读完本节后在回头体会下:<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523218.png" alt="image.png"><br>
3.2 LinkedBlockingQueue 原理介绍<br>
3.2.1 offer 操作<br>
向队列尾部插入一个元素，如果队列有空闲容量则插入成功后返回 true，如果队列已满则丢弃当前元素然后返回 false，如果 e 元素为 null 则抛出 NullPointerException 异常，另外该方法是非阻塞的。<br>
public boolean offer(E e) {</e></p>
<pre><code>    //（1）空元素抛空指针异常
    if (e == null) throw new NullPointerException();

    //(2) 如果当前队列满了则丢弃将要放入的元素，然后返回false
    final AtomicInteger count = this.count;
    if (count.get() == capacity)
        return false;

    //(3) 构造新节点，获取putLock独占锁
    int c = -1;
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try {
        //(4)如果队列不满则进队列，并递增元素计数
        if (count.get() &lt; capacity) {
            enqueue(node);
            c = count.getAndIncrement();
            //(5)
            if (c + 1 &lt; capacity)
                notFull.signal();
        }
    } finally {
        //(6)释放锁
        putLock.unlock();
    }
    //(7)
    if (c == 0)
        signalNotEmpty();
    //(8)
    return c &gt;= 0;
}
</code></pre>
<p>private void enqueue(Node<e> node) {<br>
last = last.next = node;<br>
}<br>
步骤（2）判断如果当前队列已满则丢弃当前元素并返回 false<br>
步骤（3）获取到 putLock 锁，当前线程获取到该锁后，则其它调用 put 和 offer 的线程将会被阻塞（阻塞的线程被放到 putLock 锁的 AQS 阻塞队列）。<br>
步骤（4）这里有重新判断了下当前队列是否满了，这是因为在执行代码（2）和获取到 putLock 锁期间可能其它线程通过 put 或者 offer 方法向队列里面添加了新元素。重新判断队列确实不满则新元素入队，并递增计数器。<br>
步骤（5）判断如果新元素入队后队列还有空闲空间，则唤醒 notFull 的条件队列里面因为调用了 notFull 的 await 操作（比如执行 put 方法而队列满了的时候）而被阻塞的一个线程，因为队列现在有空闲所以这里可以提前唤醒一个入队线程。<br>
代码（6) 则释放获取的 putLock 锁，这里要注意锁的释放一定要在 finally 里面做，因为即使 try 块抛异常了，finally 也是会被执行到的。另外释放锁后其它因为调用 put 和 offer 而被阻塞的线程将会有一个获取到该锁。<br>
代码（7）c==0 说明在执行代码（6）释放锁时候队列里面至少有一个元素，队列里面有元素则执行 signalNotEmpty，下面看看 signalNotEmpty 的代码：<br>
private void signalNotEmpty() {<br>
final ReentrantLock takeLock = this.takeLock;<br>
takeLock.lock();<br>
try {<br>
notEmpty.signal();<br>
} finally {<br>
takeLock.unlock();<br>
}<br>
}<br>
可知作用是激活 notEmpty 的条件队列中因为调用 notEmpty 的 await 方法（比如调用 take 方法并且队列为空的时候）而被阻塞的一个线程，这里也说明了调用条件变量的方法前要首先获取对应的锁。<br>
综上可知 offer 方法中通过使用 putLock 锁保证了在队尾新增元素的原子性和队列元素个数的比较和递增操作的原子性。<br>
3.2.2 put 操作<br>
向队列尾部插入一个元素，如果队列有空闲则插入后直接返回 true，如果队列已满则阻塞当前线程直到队列有空闲插入成功后返回 true，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回，另外如果 e 元素为 null 则抛出 NullPointerException 异常。<br>
put 操作的代码结构与 offer 操作类似，代码如下：<br>
public void put(E e) throws InterruptedException {<br>
//（1）空元素抛空指针异常<br>
if (e == null) throw new NullPointerException();<br>
//(2) 构建新节点，并获取独占锁putLock<br>
int c = -1;<br>
Node<e> node = new Node<e>(e);<br>
final ReentrantLock putLock = this.putLock;<br>
final AtomicInteger count = this.count;<br>
putLock.lockInterruptibly();<br>
try {<br>
//(3)如果队列满则等待<br>
while (count.get() == capacity) {<br>
notFull.await();<br>
}<br>
//（4）进队列并递增计数<br>
enqueue(node);<br>
c = count.getAndIncrement();<br>
//(5)<br>
if (c + 1 &lt; capacity)<br>
notFull.signal();<br>
} finally {<br>
//(6)<br>
putLock.unlock();<br>
}<br>
//(7)<br>
if (c == 0)<br>
signalNotEmpty();<br>
}<br>
代码（2）中使用 putLock.lockInterruptibly() 获取独占锁，相比 offer 方法中这个获取独占锁方法意味着可以被中断，具体说是当前线程在获取锁的过程中，如果被其它线程设置了中断标志则当前线程会抛出 InterruptedException 异常，所以 put 操作在获取锁过程中是可被中断的。<br>
代码（3）如果当前队列已满，则调用 notFull 的 await() 把当前线程放入 notFull 的条件队列，当前线程被阻塞挂起并释放获取到的 putLock 锁，由于 putLock 锁被释放了，所以现在其它线程就有机会获取到 putLock 锁了。<br>
另外考虑下代码（3）判断队列是否为空为何使用 while 循环而不是 if 语句那？其实是考虑到当前线程被虚假唤醒的问题，也就是其它线程没有调用 notFull 的 singal 方法时候 notFull.await() 在某种情况下会自动返回。如果使用 if 语句那么虚假唤醒后会执行代码（4）元素入队，并且递增计数器，而这时候队列已经是满了的，导致队列元素个数大于了队列设置的容量，导致程序出错。而使用 while 循环假如 notFull.await() 被虚假唤醒了，那么循环在检查一下当前队列是否是满的，如果是则再次进行等待。<br>
3.2.3 poll 操作<br>
从队列头部获取并移除一个元素，如果队列为空则返回 null，该方法是不阻塞的。<br>
public E poll() {<br>
//(1)队列为空则返回null<br>
final AtomicInteger count = this.count;<br>
if (count.get() == 0)<br>
return null;<br>
//(2)获取独占锁<br>
E x = null;<br>
int c = -1;<br>
final ReentrantLock takeLock = this.takeLock;<br>
takeLock.lock();<br>
try {<br>
//(3)队列不空则出队并递减计数<br>
if (count.get() &gt; 0) {<a href="//3.1">//3.1</a><br>
x = dequeue();<a href="//3.2">//3.2</a><br>
c = count.getAndDecrement();<a href="//3.3">//3.3</a><br>
//(4)<br>
if (c &gt; 1)<br>
notEmpty.signal();<br>
}<br>
} finally {<br>
//(5)<br>
takeLock.unlock();<br>
}<br>
//(6)<br>
if (c == capacity)<br>
signalNotFull();<br>
//(7)返回<br>
return x;<br>
}<br>
private E dequeue() {<br>
Node<e> h = head;<br>
Node<e> first = h.next;<br>
h.next = h; // help GC<br>
head = first;<br>
E x = first.item;<br>
first.item = null;<br>
return x;<br>
}<br>
代码 (1) 如果当前队列为空，则直接返回 null<br>
代码（2）获取独占锁 takeLock，当前线程获取该锁后，其它线程在调用 poll 或者 take 方法会被阻塞挂起<br>
代码 (3) 如果当前队列不为空则进行出队操作，然后递减计数器。<br>
代码（4）如果 c&gt;1 则说明当前线程移除掉队列里面的一个元素后队列不为空（c 是删除元素前队列元素个数），那么这时候就可以激活因为调用 poll 或者 take 方法而被阻塞到 notEmpty 的条件队列里面的一个线程。<br>
代码（6）说明当前线程移除队头元素前当前队列是满的，移除队头元素后队列当前至少有一个空闲位置，那么这时候就可以调用 signalNotFull 激活因为调用 put 或者 offer 而被阻塞放到 notFull 的条件队列里的一个线程，signalNotFull 的代码如下：<br>
private void signalNotFull() {<br>
final ReentrantLock putLock = this.putLock;<br>
putLock.lock();<br>
try {<br>
notFull.signal();<br>
} finally {<br>
putLock.unlock();<br>
}<br>
}<br>
poll 代码逻辑比较简单，值得注意的是获取元素时候只操作了队列的头节点。<br>
3.2.4 peek 操作<br>
获取队列头部元素但是不从队列里面移除，如果队列为空则返回 null，该方法是不阻塞的。<br>
public E peek() {<br>
//(1)<br>
if (count.get() == 0)<br>
return null;<br>
//(2)<br>
final ReentrantLock takeLock = this.takeLock;<br>
takeLock.lock();<br>
try {<br>
Node<e> first = head.next;<br>
//(3)<br>
if (first == null)<br>
return null;<br>
else<br>
//(4)<br>
return first.item;<br>
} finally {<br>
//(5)<br>
takeLock.unlock();<br>
}<br>
}<br>
peek 操作代码也比较简单，这里需要注意的是代码（3）这里还是需要判断下 first 是否为 null 的，不能直接执行代码（4）。正常情况下执行到代码（2）说明队列不为空，但是代码（1）和（2）不是原子性操作，也就是在执行点（1）判断队列不空后，在代码（2）获取到锁前有可能其它线程执行了 poll 或者 take 操作导致队列变为了空，然后当前线程获取锁后，直接执行 first.item 会抛出空指针异常。<br>
3.2.5 take 操作<br>
获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程。如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回。<br>
public E take() throws InterruptedException {<br>
E x;<br>
int c = -1;<br>
final AtomicInteger count = this.count;<br>
//(1)获取锁<br>
final ReentrantLock takeLock = this.takeLock;<br>
takeLock.lockInterruptibly();<br>
try {<br>
//(2)当前队列为空则阻塞挂起<br>
while (count.get() == 0) {<br>
notEmpty.await();<br>
}<br>
//(3)出队并递减计数<br>
x = dequeue();<br>
c = count.getAndDecrement();<br>
//(4)<br>
if (c &gt; 1)<br>
notEmpty.signal();<br>
} finally {<br>
//(5)<br>
takeLock.unlock();<br>
}<br>
//(6)<br>
if (c == capacity)<br>
signalNotFull();<br>
//(7)<br>
return x;<br>
}<br>
代码（1）当前线程获取到独占锁，其它调用 take 或者 poll 的线程将会被阻塞挂起。<br>
代码（2）如果队列为空则阻塞挂起当前线程，并把当前线程放入 notEmpty 的条件队列。<br>
代码（3）进行出队操作并递减计数。<br>
代码（4）如果 c&gt;1 说明当前队列不为空，则唤醒 notEmpty 的条件队列的条件队列里面的一个因为调用 take 或者 poll 而被阻塞的线程。<br>
代码（5）释放锁。<br>
代码（6）如果 c == capacity 则说明当前队列至少有一个空闲位置，则激活条件变量 notFull 的条件队列里面的一个因为调用 put 或者 offer 而被阻塞的线程。<br>
3.2.6 remove 操作<br>
删除队列里面指定元素，有则删除返回 true，没有则返回 false<br>
public boolean remove(Object o) {<br>
if (o == null) return false;</e></e></e></e></e></e></p>
<pre><code>//（1）双重加锁
fullyLock();
try {

    //（2)遍历队列找则删除返回true
    for (Node&lt;E&gt; trail = head, p = trail.next;
         p != null;
         trail = p, p = p.next) {
         //(3)
        if (o.equals(p.item)) {
            unlink(p, trail);
            return true;
        }
    }
    //(4)找不到返回false
    return false;
} finally {
    //(5)解锁
    fullyUnlock();
}
</code></pre>
<p>}<br>
代码（1）通过 fullyLock 获取双重锁，当前线程获取后，其它线程进行入队或者出队的操作时候就会被阻塞挂起。<br>
void fullyLock() {<br>
putLock.lock();<br>
takeLock.lock();<br>
}<br>
代码（2）遍历队列寻找要删除的元素，找不到则直接返回 false，找到则执行 unlink 操作，unlik 操作代码如下：<br>
void unlink(Node<e> p, Node<e> trail) {<br>
p.item = null;<br>
trail.next = p.next;<br>
if (last == p)<br>
last = trail;<br>
如果当前队列满，删除后，也不忘记唤醒等待的线程<br>
if (count.getAndDecrement() == capacity)<br>
notFull.signal();<br>
}<br>
可知删除元素后，如果发现当前队列有空闲空间，则唤醒 notFull 的条件队列中一个因为调 用 put 或者 offer 方法而被阻塞的线程。<br>
代码（5）调用 fullyUnlock 方法使用与加锁顺序相反的顺序释放双重锁<br>
void fullyUnlock() {<br>
takeLock.unlock();<br>
putLock.unlock();<br>
}<br>
总结下，由于 remove 方法在删除指定元素前加了两把锁，所以在遍历队列查找指定元素过程中是线程安全的，并且此时其它调用入队出队操作的线程全部会被阻塞，另外获取多个资源锁与释放的顺序是相反的。<br>
3.2.7 size 操作<br>
int size() : 获取当前队列元素个数。<br>
public int size() {<br>
return count.get();<br>
}<br>
由于在操作出队入队时候操作 Count 的时候是加了锁的，所以相比 ConcurrentLinkedQueue 的 size 方法比较准确。这里考虑下为何 ConcurrentLinkedQueue 中需要遍历链表来获取 size 而不适用一个原子变量那？这是因为使用原子变量保存队列元素个数需要保证入队出队操作和操作原子变量是原子性操作，而 ConcurrentLinkedQueue 是使用 CAS 无锁算法的，所以无法做到这个。<br>
注：LinkedBlockingQueue 内部是通过单向链表实现，使用头尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作，而头尾节点的操作分别使用了单独的独占锁保证了原子性，所以出队和入队操作是可以同时进行的。另外头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队出队操作实现了一个生产消费模型。</e></e></p>
<h3 id="arrayblockingqueue"><a class="header-anchor" href="#arrayblockingqueue">¶</a>ArrayBlockingQueue</h3>
<p>上节介绍了有界链表方式的阻塞队列 LinkedBlockingQueue，本节来研究下有界使用数组方式实现的阻塞队列 ArrayBlockingQueue 的原理<br>
4.1 ArrayBlockingQueue 类图结构<br>
同理为了能从全局一览 ArrayBlockingQueue 的内部构造，先看下类图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523294.png" alt="image.png"><br>
如图 ArrayBlockingQueue 内部有个数组 items 用来存放队列元素，putindex 变量标示入队元素下标，takeIndex 是出队下标，count 统计队列元素个数，从定义可知并没有使用 volatile 修饰，这是因为访问这些变量使用都是在锁块内，而加锁已经保证了锁块内变量的内存可见性了。<br>
另外有个独占锁 lock 用来保证出入队操作原子性，这保证了同时只有一个线程可以进行入队出队操作，另外 notEmpty，notFull 条件变量用来进行出入队的同步。<br>
另外由于 ArrayBlockingQueue 是有界队列，所以构造函数必须传入队列大小参数，构造函数代码如下：<br>
public ArrayBlockingQueue(int capacity) {<br>
this(capacity, false);<br>
}</p>
<pre><code>public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity &lt;= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
}
</code></pre>
<p>可知默认情况下使用的是 ReentrantLock 提供的非非公平独占锁进行出入队操作的加锁。<br>
首先一个图概况该队列，读者可以读完本节后在回头体会下：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523418.png" alt="image.png"><br>
4.2 ArrayBlockingQueue 原理介绍<br>
本节主要讲解下面几个主要函数的原理。<br>
4.2.1 offer 操作<br>
向队列尾部插入一个元素，如果队列有空闲容量则插入成功后返回 true，如果队列已满则丢弃当前元素然后返回 false，如果 e 元素为 null 则抛出 NullPointerException 异常，另外该方法是不阻塞的。<br>
public boolean offer(E e) {<br>
//（1）e为null，则抛出NullPointerException异常<br>
checkNotNull(e);<br>
//（2）获取独占锁<br>
final ReentrantLock lock = this.lock;<br>
lock.lock();<br>
try {<br>
//（3）如果队列满则返回false<br>
if (count == items.length)<br>
return false;<br>
else {<br>
//（4）否者插入元素<br>
enqueue(e);<br>
return true;<br>
}<br>
} finally {<br>
lock.unlock();<br>
}<br>
}<br>
代码（2）获取独占锁，当前线程获取该锁后，其它入队和出队操作的线程都会被阻塞挂起后放入 lock 锁的 AQS 阻塞队列。<br>
代码（3）如果队列满则直接返回 false，否者调用 enqueue 方法后返回 true，enqueue 的代码如下：<br>
private void enqueue(E x) {<br>
//（6）元素入队<br>
final Object[] items = this.items;<br>
items[putIndex] = x;<br>
//（7）计算下一个元素应该存放的下标<br>
if (<ins>putIndex == items.length)<br>
putIndex = 0;<br>
count</ins>;<br>
//(8)<br>
notEmpty.signal();<br>
}<br>
如上代码首先把当前元素放入 items 数组，然后计算下一个元素应该存放的下标，然后递增元素个数计数器，最后激活 notEmpty 的条件队列中因为调用 poll 或者 take 操作而被阻塞的的一个线程。这里由于在操作共享变量比如 count 前加了锁，所以不存在内存不可见问题，加过锁后获取的共享变量都是从主内存获取的，而不是在 CPU 缓存或者寄存器里面的值。<br>
代码（5）释放锁，释放锁后会把修改的共享变量值比如 Count 的值刷新回主内存中，这样其它线程通过加锁在次读取这些共享变量后就可以看到最新的值。<br>
4.2.2 put 操作<br>
向队列尾部插入一个元素，如果队列有空闲则插入后直接返回 true，如果队列已满则阻塞当前线程直到队列有空闲插入成功后返回 true，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回，另外如果 e 元素为 null 则抛出 NullPointerException 异常。<br>
public void put(E e) throws InterruptedException {<br>
//(1)<br>
checkNotNull(e);<br>
final ReentrantLock lock = this.lock;</p>
<pre><code>//(2)获取锁（可被中断）
lock.lockInterruptibly();
try {

    //(3)如果队列满，则把当前线程放入notFull管理的条件队列
    while (count == items.length)
        notFull.await();

    //(4)插入元素
    enqueue(e);
} finally {
    //(5)
    lock.unlock();
}
</code></pre>
<p>}<br>
代码（2）在获取锁的过程中当前线程被其它线程中断了，则当前线程会抛出 InterruptedException 异常而退出。<br>
代码（3）判断如果当前队列满了，则把当前线程阻塞挂起后放入到 notFull 的条件队列，注意这里也是使用了 while 而不是 if。<br>
代码（4）如果队列不满则插入当前元素，此处不再累述。<br>
4.2.3 poll 操作<br>
从队列头部获取并移除一个元素，如果队列为空则返回 null，该方法是不阻塞的。<br>
public E poll() {<br>
//(1)获取锁<br>
final ReentrantLock lock = this.lock;<br>
lock.lock();<br>
try {<br>
//（2）当前队列为空则返回null,否者调用dequeue（）获取<br>
return (count == 0) ? null : dequeue();<br>
} finally {<br>
//(3)释放锁<br>
lock.unlock();<br>
}<br>
}<br>
代码（1）获取独占锁<br>
代码（2）如果队列为空则返回 null，否者调用 dequeue() 方法，dequeue 代码如下：<br>
private E dequeue() {<br>
final Object[] items = this.items;</p>
<pre><code>//（4）获取元素值
@SuppressWarnings(&quot;unchecked&quot;)
E x = (E) items[takeIndex];
//（5）数组中值值为null;
items[takeIndex] = null;

//（6）队头指针计算，队列元素个数减一
</code></pre>
<p>if (++takeIndex == items.length)<br>
takeIndex = 0;<br>
count–;</p>
<pre><code>//（7）发送信号激活notFull条件队列里面的一个线程
notFull.signal();
return x;
</code></pre>
<p>}<br>
可知首先获取当前队头元素保存到局部变量，然后重置队头元素为 null，并重新设置队头下标，元素计数器递减，最后发送信号激活 notFull 的条件队列里面一个因为调用 put 或者 offer 而被阻塞的线程。<br>
4.2.4 take 操作<br>
获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程。如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回。<br>
public E take() throws InterruptedException {<br>
//(1)获取锁<br>
final ReentrantLock lock = this.lock;<br>
lock.lockInterruptibly();<br>
try {</p>
<pre><code>    //（2）队列为空，则等待，直到队列有元素
    while (count == 0)
        notEmpty.await();
    //（3）获取队头元素
    return dequeue();
} finally {
    //(4) 释放锁
    lock.unlock();
}
</code></pre>
<p>}<br>
take 操作的代码也比较简单与 poll 相比只是步骤（2）如果队列为空则把当前线程挂起后放入到 notEmpty 的条件队列，等其它线程调用 notEmpty.signal() 方法后在返回，需要注意的是这里也是使用 while 循环进行检测并等待而不是使用 if。<br>
4.2.5 peek 操作<br>
获取队列头部元素但是不从队列里面移除，如果队列为空则返回 null，该方法是不阻塞的。<br>
public E peek() {<br>
//(1)获取锁<br>
final ReentrantLock lock = this.lock;<br>
lock.lock();<br>
try {<br>
//（2）<br>
return itemAt(takeIndex);<br>
} finally {<br>
//(3)<br>
lock.unlock();<br>
}<br>
}</p>
<p>@SuppressWarnings(“unchecked”)<br>
final E itemAt(int i) {<br>
return (E) items[i];<br>
}<br>
peek 的实现更简单，首先获取独占锁，然后从数组 items 中获取当前队头下标的值并返回，在返回前释放了获取的锁。<br>
4.2.6 size 操作<br>
获取当前队列元素个数。<br>
public int size() {<br>
final ReentrantLock lock = this.lock;<br>
lock.lock();<br>
try {<br>
return count;<br>
} finally {<br>
lock.unlock();<br>
}<br>
}<br>
size 操作是简单的，获取锁后直接返回 count，并在返回前释放锁。也许你会疑问这里有没有修改 Count 的值，只是简单的获取下，为何要加锁那？其实如果 count 声明为 volatile 这里就不需要加锁了，因为 volatile 类型变量保证了内存的可见性，而 ArrayBlockingQueue 的设计中 count 并没有声明为 volatile，是因为 count 的操作都是在获取锁后进行的，而获取锁的语义之一是获取锁后访问的变量都是从主内存获取的，这保证了变量的内存可见性。<br>
注：ArrayBlockingQueue 通过使用全局独占锁实现同时只能有一个线程进行入队或者出队操作，这个锁的粒度比较大，有点类似在方法上添加 synchronized 的意味。ArrayBlockingQueue 的 size 操作的结果是精确的，因为计算前加了全局锁。</p>
<h3 id="priorityblockingqueue"><a class="header-anchor" href="#priorityblockingqueue">¶</a>PriorityBlockingQueue</h3>
<p>PriorityBlockingQueue 是带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素，内部是平衡二叉树堆的实现。<br>
5.1 PriorityBlockingQueue 类图结构<br>
下面首先通过类图来从全局了解下 PriorityBlockingQueue 的结构<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523554.png" alt="image.png"><br>
如图 PriorityBlockingQueue 内部有个数组 queue 用来存放队列元素，size 用来存放队列元素个数，allocationSpinLock 是个自旋锁，用 CAS 操作来保证同时只有一个线程可以扩容队列，状态为 0 或者 1，其中 0 表示当前没有在进行扩容，1 标示当前正在扩容。<br>
如下构造函数，默认队列容量为 11，默认比较器为 null，也就是使用元素的 compareTo 方法进行比较来确定元素的优先级，这意味着队列元素必须实现了 Comparable 接口;<br>
private static final int DEFAULT_INITIAL_CAPACITY = 11;</p>
<p>public PriorityBlockingQueue() {<br>
this(DEFAULT_INITIAL_CAPACITY, null);<br>
}</p>
<pre><code>public PriorityBlockingQueue(int initialCapacity) {
    this(initialCapacity, null);
}

public PriorityBlockingQueue(int initialCapacity,
                             Comparator&lt;? super E&gt; comparator) {
    if (initialCapacity &lt; 1)
        throw new IllegalArgumentException();
    this.lock = new ReentrantLock();
    this.notEmpty = lock.newCondition();
    this.comparator = comparator;
    this.queue = new Object[initialCapacity];
}
</code></pre>
<p>首先通过一个图来对该队列进行概况，读者读完本机后，可以回头在体会下：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523703.png" alt="image.png"><br>
5.2 原理介绍<br>
5.2.1 offer 操作<br>
offer 操作作用是在队列插入一个元素，由于是无界队列，所以一直返回 true，如下是 offer 函数的代码：<br>
public boolean offer(E e) {</p>
<pre><code>if (e == null)
    throw new NullPointerException();

//获取独占锁
final ReentrantLock lock = this.lock;
lock.lock();

int n, cap;
Object[] array;

//如果当前元素个数&gt;=队列容量，则扩容(1)
while ((n = size) &gt;= (cap = (array = queue).length))
    tryGrow(array, cap);

try {
    Comparator&lt;? super E&gt; cmp = comparator;

    //默认比较器为null (2)
    if (cmp == null)
        siftUpComparable(n, e, array);
    else
        //自定义比较器 (3)
        siftUpUsingComparator(n, e, array, cmp);

    //队列元素增加1，并且激活notEmpty的条件队列里面的一个阻塞线程（9）
    size = n + 1;
    notEmpty.signal();//激活调用take（）方法被阻塞的线程
} finally {
    //释放独占锁
    lock.unlock();
}
return true;
</code></pre>
<p>}<br>
如上代码，主流程比较简单，下面主要看看如何进行扩容的和内部如何建堆的，首先看下扩容逻辑：<br>
private void tryGrow(Object[] array, int oldCap) {<br>
lock.unlock(); //释放获取的锁<br>
Object[] newArray = null;</p>
<pre><code>//cas成功则扩容(4)
if (allocationSpinLock == 0 &amp;&amp;
    UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,
                             0, 1)) {
    try {
        //oldGap&lt;64则扩容新增oldcap+2,否者扩容50%，并且最大为MAX_ARRAY_SIZE
        int newCap = oldCap + ((oldCap &lt; 64) ?
                               (oldCap + 2) : // grow faster if small
                               (oldCap &gt;&gt; 1));
        if (newCap - MAX_ARRAY_SIZE &gt; 0) {    // possible overflow
            int minCap = oldCap + 1;
            if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)
                throw new OutOfMemoryError();
            newCap = MAX_ARRAY_SIZE;
        }
        if (newCap &gt; oldCap &amp;&amp; queue == array)
            newArray = new Object[newCap];
    } finally {
        allocationSpinLock = 0;
    }
}

//第一个线程cas成功后，第二个线程会进入这个地方，然后第二个线程让出cpu，尽量让第一个线程执行下面点获取锁，但是这得不到肯定的保证。(5)
if (newArray == null) // back off if another thread is allocating
    Thread.yield();
lock.lock();//(6)
if (newArray != null &amp;&amp; queue == array) {
    queue = newArray;
    System.arraycopy(array, 0, newArray, 0, oldCap);
}
</code></pre>
<p>}<br>
tryGrow 目的是扩容，这里要思考下为啥在扩容前要先释放锁，然后使用 cas 控制只有一个线程可以扩容成功。其实这里不先释放锁，也是可行的，也就是在整个扩容期间一直持有锁，但是扩容是需要花时间的，如果扩容时候还占用锁那么其它线程在这个时候是不能进行出队和入队操作的，这大大降低了并发性。所以为了提高性能，使用 CAS 控制只有一个线程可以进行扩容，并且在扩容前释放了锁，让其它线程可以进行入队出队操作。<br>
spinlock 锁使用 CAS 控制只有一个线程可以进行扩容，CAS 失败的线程会调用 Thread.yield() 让出 cpu，目的意在让扩容线程扩容后优先调用 lock.lock 重新获取锁，但是这得不到一定的保证。有可能 yield 的线程在扩容线程扩容完成前已经退出，并执行代码（6）获取到了锁，这时候获取到的锁的线程发现 newArray 为 null 就会执行代码（1）。如果当前数组扩容还没完毕，当前线程会再次调用 tryGrow 方法，然后释放锁，这又给扩容线程获取锁提供了机会，如果这时候扩容线程还没扩容完毕，则当前线程释放锁后有调用 yield 方法出让 CPU。可知当扩容线程进行扩容期间，其他线程是原地自旋通过代码（1）检查当前扩容是否完毕，等扩容完毕后才退出代码（1）的循环。<br>
当扩容线程扩容完毕后会重置自旋锁变量 allocationSpinLock 为 0，这里并没有使用 UNSAFE 方法的 CAS 进行设置是因为同时只可能有一个线程获取了该锁，并且 allocationSpinLock 被修饰为了 volatile。<br>
当扩容线程扩容完毕后会执行代码 (6) 获取锁，获取锁后复制当前 queue 里面的元素到新数组。<br>
然后看下具体建堆算法：<br>
private static <t> void siftUpComparable(int k, T x, Object[] array) {<br>
Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;</t></p>
<pre><code>//队列元素个数&gt;0则判断插入位置，否者直接入队(7)
while (k &gt; 0) {
    int parent = (k - 1) &gt;&gt;&gt; 1;
    Object e = array[parent];
    if (key.compareTo((T) e) &gt;= 0)
        break;
    array[k] = e;
    k = parent;
}
array[k] = key;(8)
</code></pre>
<p>}<br>
下面用图来解释上面算法过程，假设队列初始化容量为 2, 创建的优先级队列的泛型参数为 Integer。<br>
首先调用队列的 offer(2) 方法，希望插入元素 2 到队列，插入前队列状态如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523815.png" alt="image.png"><br>
首先执行代码（1)，从上图变量值可知判断值为 false，所以紧接着执行代码（2），由于 k=n=size=0 所以代码（7）判断结果为 false，所以会执行代码（8）直接把元素 2 入队，最后执行代码（9）设置 size 的值加 1，这时候队列的状态如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523886.png" alt="image.png"><br>
然后调用队列的 offer(4) 时候，首先执行代码（1)，从上图变量值可知判断为 false，所以执行代码（2），由于 k=1, 所以进入 while 循环，由于 parent=0;e=2;key=4; 默认元素比较器是使用元素的 compareTo 方法，可知 key&gt;e 所以执行 break 退出 siftUpComparable 中的循环; 然后把元素存到数组下标为 1 的地方，最后执行代码（9）设置 size 的值加 1，这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192523939.png" alt="image.png"><br>
然后调用队列的 offer(6) 时候，首先执行代码（1)，从上图变量值知道这时候判断值为 true, 所以调用 tryGrow 进行数组扩容, 由于 2&lt;64 所以 newCap=2 + (2+2)=6; 然后创建新数组并拷贝，然后调用 siftUpComparable 方法，由于 k=2&gt;0 进入 while 循环，由于 parent=0;e=2;key=6;key&gt;e 所以 break 后退出 while 循环; 并把元素 6 放入数组下标为 2 的地方，最后设置 size 的值加 1，现在队列状态：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524002.png" alt="image.png"><br>
然后调用队列的 offer(1) 时候，首先执行代码（1)，从上图变量值知道这次判断值为 false，所以执行代码（2），由于k=3, 所以进入 while 循环，由于parent=0;e=4;key=1; key&lt;e，所以把元素 4 复制到数组下标为 3 的地方，然后 k=0 退出 while 循环；然后把元素 1 存放到下标为 0 地方，现在状态：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524074.png" alt="image.png"><br>
这时候二叉树堆的树形图如下：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524128.png" alt="image.png"><br>
可知堆的根元素是 1，也就是这是一个最小堆，那么当调用这个优先级队列的 poll 方法时候，会一次返回堆里面值最小的元素。<br>
5.2.2 poll 操作<br>
poll 操作作用是获取队列内部堆树的根节点元素，如果队列为空，则返回 null。poll 函数代码如下：<br>
public E poll() {<br>
final ReentrantLock lock = this.lock;<br>
lock.lock();//获取独占锁<br>
try {<br>
return dequeue();<br>
} finally {<br>
lock.unlock();//释放独占锁<br>
}<br>
}<br>
如上代码可知在进行出队操作过程中要先加锁，这意味着，当当前线程进行出队操作时候，其它线程不能再进行入队和出队操作，但是从前面介绍 offer 函数时候知道这时候可以有其它线程进行扩容，下面主要看下具体执行出队操作的 dequeue 方法的代码：<br>
private E dequeue() {</p>
<pre><code>//队列为空，则返回null
int n = size - 1;
if (n &lt; 0)
    return null;
else {

    //获取队头元素(1)
    Object[] array = queue;
    E result = (E) array[0];

    //获取队尾元素，并值null(2)
    E x = (E) array[n];
    array[n] = null;

    Comparator&lt;? super E&gt; cmp = comparator;
    if (cmp == null)//(3)
        siftDownComparable(0, x, array, n);
    else
        siftDownUsingComparator(0, x, array, n, cmp);
    size = n;//（4）
    return result;
}
</code></pre>
<p>}<br>
如上代码，如果队列为空则直接返回 null，否者执行代码（1）获取数组第一个元素作为返回值存放到变量 Result，这里需要注意下数组里面第一个元素是优先级最小或者最大的元素，出队操作就是返回这个元素。 然后代码（2）获取队列尾部元素存放到变量 x, 并且置空尾部节点，然后执行代码（3）插入变量 x 到数组下标为 0 的位置后，重新调成堆为最大或者最小堆，然后返回。这里重要的是看如何去掉堆的根节点后，使用剩下的节点重新调整为一个最大或者最小堆，下面我们看下 siftDownComparable 的代码实现：<br>
private static <t> void siftDownComparable(int k, T x, Object[] array,<br>
int n) {<br>
if (n &gt; 0) {<br>
Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;<br>
int half = n &gt;&gt;&gt; 1;           // loop while a non-leaf<br>
while (k &lt; half) {<br>
int child = (k &lt;&lt; 1) + 1; // assume left child is least<br>
Object c = array[child];（5）<br>
int right = child + 1;（6)<br>
if (right &lt; n &amp;&amp;<br>
((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)(7)<br>
c = array[child = right];<br>
if (key.compareTo((T) c) &lt;= 0)(8)<br>
break;<br>
array[k] = c;<br>
k = child;<br>
}<br>
array[k] = key;(9)<br>
}<br>
}<br>
同理下面我们结合图来模拟上面调整堆的算法过程，接着上节队列的状态继续讲解，上节队列元素序列为 1，2，6，4：<br>
第一次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size =4;n=3;result=1；x=4; 这时候队列状态<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524191.png" alt="image.png"><br>
然后执行代码（3）调整堆后队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524241.png" alt="image.png"><br>
第二次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size =3;n=2;result=2；x=6; 这时候队列状态：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524311.png" alt="image.png"><br>
然后执行代码（3）调整堆后队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524357.png" alt="image.png"><br>
第三次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size =2;n=1;result=4；x=6; 这时候队列状态：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524485.png" alt="image.png"><br>
然后执行代码（3）调整堆后队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524485.png" alt="image.png"><br>
第四次直接返回元素 6.<br>
下面重点说说 siftDownComparable 这个调整堆的算法： 首先说下堆调整的思路，由于队列数组第 0 个元素为树根，出队时候要被移除，这时候数组就不在是最小堆了，所以需要调整堆，具体是要从被移除的树根的左右子树中找一个最小的值来当树根，左右子树又会看自己作为根节点的树的左右子树里面那个是最小值，这是一个递归，直到树叶节点结束递归，如果还不明白，没关系，下面结合图来说明下，假如当前队列内容如下：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524534.png" alt="image.png"><br>
其对应的二叉堆树为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524594.png" alt="image.png"><br>
这时候如果调用了 poll(); 那么 result=2;x=11；队列末尾的元素设置为 null 后，剩下的元素调整堆的步骤如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524671.png" alt="image.png"><br>
如上图（1）树根的 leftChildVal = 4;rightChildVal = 6; 4&lt;6; 所以 c=4; 然后 11&gt;4 也就是 key&gt;c；所以使用元素 4 覆盖树根节点的值，现在堆对应的树如图（2）。<br>
然后树根的左子树树根的左右孩子节点中 leftChildVal = 8;rightChildVal = 10; 8&lt;10; 所以 c=8; 然后发现 11&gt;8 也就是 key&gt;c；所以元素 8 作为树根左子树的根节点，现在树的形状如图（3）, 这时候判断 k&lt;half 为 false 就会退出循环，然后把 x=11 设置到数组下标为 3 的地方，这时候堆树如图（4），至此调整堆完毕，siftDownComparable 返回 result=2，poll 方法也返回了。<br>
5.2.3 put 操作<br>
put 操作内部调用的 offer, 由于是无界队列，所以不需要阻塞<br>
public void put(E e) {<br>
offer(e); // never need to block<br>
}<br>
5.2.4 take 操作<br>
take 操作作用是获取队列内部堆树的根节点元素，如果队列为空则阻塞，如下代码：<br>
public E take() throws InterruptedException {<br>
//获取锁，可被中断<br>
final ReentrantLock lock = this.lock;<br>
lock.lockInterruptibly();<br>
E result;<br>
try {</t></p>
<pre><code>    //如果队列为空，则阻塞，把当前线程放入notEmpty的条件队列
    while ( (result = dequeue()) == null)
        notEmpty.await();//阻塞当前线程
} finally {
    lock.unlock();//释放锁
}
return result;
</code></pre>
<p>}<br>
如上代码，首先通过 lock.lockInterruptibly() 获取独占锁，这个方式获取的锁是对中断进行响应的。然后调用 dequeue 方法返回堆树根节点元素，如果队列为空，则返回 false，然后当前线程调用 notEmpty.await() 阻塞挂起当前线程，直到有线程调用了 offer（）方法（offer 方法内在添加元素成功后调用了 notEmpty.signal 方法会激活一个阻塞在 notEmpty 的条件队列里面的一个线程）。另外这里使用 while 而不是 if 是为了避免虚假唤醒。<br>
5.2.5 size 操作<br>
获取队列元个数，如下代码，在返回 size 前加了锁，保证在调用 size() 方法时候不会有其它线程进行入队和出队操作，另外由于 size 变量没有被修饰为 volatie，这里加锁也保证了多线程下 size 变量的内存可见性。<br>
public int size() {<br>
final ReentrantLock lock = this.lock;<br>
lock.lock();<br>
try {<br>
return size;<br>
} finally {<br>
lock.unlock();<br>
}<br>
}<br>
注：PriorityBlockingQueue 队列内部使用二叉树堆维护元素优先级，内部使用数组作为元素存储的数据结构，这个数组是可扩容的，当当前元素个数 &gt;= 最大容量时候会通过算法扩容，出队时候始终保证出队的元素是堆树的根节点，而不是在队列里面停留时间最长的元素，默认元素优先级比较规则是使用元素的 compareTo 方法来做，用户可以自定义优先级的比较规则。</p>
<h3 id="队列对比"><a class="header-anchor" href="#队列对比">¶</a>队列对比</h3>
<p>上面介绍的各种队列中只有 ConcurrentLinkedQueue 是使用 UNSAFE 类提供的 CAS 非阻塞算法实现的，其他几个队列内部都是使用锁来保证线程安全的。使用 CAS 算法的效率较好，那么是不是所有场景都用 ConcurrentLinkedQueue 那？<br>
其实不然，因为 ConcurrentLinkedQueue 还是无界队列，无界队列使用不当可能造成 OOM。所以当使用 ConcurrentLinkedQueue 的时候在添加元素前应该先判断当前队列元素个数是否已经达到了设定的阈值，如果达到就做一定的处理措施，比如直接丢弃等。这里需要注意判断当前队列元素个数与阈值这个操作不是原子性的，最终会导致队列元素个数比设置的阈值大。<br>
ConcurrentLinkedQueue 在 Tomcat 的的 NioEndPoint 中得到了应用，通过使用 ConcurrentLinkedQueue 将同步转换为异步，可以让 tomcat 同时接受更多请求，模型如下图：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524794.png" alt="image.png"><br>
tomcat 的 NioEndPoint 模式中 acceptor 线程负责接受用户请求，接受后把请求放入到 poll 线程对应的队列，poll 线程从队列里面获取任务后委托给 worker 线程具体处理。<br>
LinkedBlockingQueue 和 ArrayBlockingQueue 都是有界阻塞队列，不同在于一个底层数据结构是链表，一个是数组；另外前者入队出队使用单独的锁，而后者出入队使用同一个锁，所以前者的并发度比后者高。另外创建前者时候可以不指定队列大小，默认队列元素个数为 Integer.MAX_VALUE，而后者必须要指定数组大小。所以使用 LinkedBlockingQueue 时候要记得指定队列大小。<br>
比如比较有名的 LogBack 日志系统的异步日志打印实现中就是用了 ArrayBlockingQueue 作为缓冲队列，如下图，业务检查调用异步 log 进行写入日志时候，实际是把日志放入了 ArrayBlockingQueue 队列就返回了，而具体真正写入日志到磁盘是一个日志线程从队列里面获取任务来做的，这其实是一个多生产单消费模型：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/20180707192524971.png" alt="image.png"><br>
PriorityBlockingQueue 是无界阻塞队列，是一个队列元素有优先级的队列，前面的队列模式都是 FIFO 先进先出，而 PriorityBlockingQueue 而是优先级最高的元素先出队，而不管谁先进入队列的，所以 PriorityBlockingQueue 经常会用在一些任务具有优先级的场景。还比如上面说的 logback 异步日志模型，如果把日志等级分了优先级，比如 error&gt;warn&gt;info，那么上述模型中队列就可以使用 PriorityBlockingQueue，日志线程会先从队列里面首先获取 error 级别的日志，但是需要注意的是如果业务线程一直向队列里面写入 error 级别日志，那么可能先写入到队列的 warn 和 info 级别的日志将很久甚至永远没机会写入到磁盘。还有一点要注意 PriorityBlockingQueue 是无界限队列，要注意判断队列元素个数不要超过设置的阈值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1a8406e8.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1a8406e8.html" itemprop="url">并发和并发安全容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1>无锁栈</h1>
<h2 id="treiber-stack"><a class="header-anchor" href="#treiber-stack">¶</a>Treiber Stack</h2>
<h1>无锁列表</h1>
<h2 id="copyonwritearraylist"><a class="header-anchor" href="#copyonwritearraylist">¶</a>CopyOnWriteArrayList</h2>
<p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，对其进行的修改操作和元素迭代操作都是在底层创建一个拷贝的数组（快照）上进行的，也就是写时拷贝策略。CopyOnWriteArrayList 适合读多写少的场景，但如果应用在写操作频繁的场景下反而会降低性能。<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/CopyOnWriteArrayList%E7%B1%BB%E5%9B%BE.png" alt="CopyOnWriteArrayList类图" title="CopyOnWriteArrayList类图"></p>
<ul>
<li>lock：保证写操作时的并发安全；</li>
</ul>
<h3 id="add-e-e"><a class="header-anchor" href="#add-e-e">¶</a>add(E e)</h3>
<p>添加操作拷贝了份快照，在快照上添加元素，最后替代原数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"></span><br><span class="line">    // 加独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取array</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        // 拷贝array到新数组，添加元素到新数组</span><br><span class="line">        // 新数组长度是原数组长度+1，可见CopyOnWriteArrayList是无界的</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line"></span><br><span class="line">        // 使用新数组替换添加前的数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放独占锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-int-index"><a class="header-anchor" href="#get-int-index">¶</a>get(int index)</h3>
<p>get 操作获取下标处的元素，实际上 get 可以被分解为以下两个步骤：</p>
<ol>
<li>获取 array 的引用；</li>
<li>通过下标访问 array 指定位置的元素。</li>
</ol>
<p>整个过程并没有加锁，如果在访问期间有另一个线程删除了某个元素，实际上因为修改操作是发生在原数组的一个快照上的，get 操作仍然获取的是原数组上的元素，因此不会发生类似数组越界的问题。但同时也不可避免这个过程带来的<strong>弱一致性</strong>，因为元素事实上已经被删除了却仍然可以被访问到。</p>
<h3 id="set-int-index-e-element"><a class="header-anchor" href="#set-int-index-e-element">¶</a>set(int index, E element)</h3>
<p>修改 list 中指定元素的值。</p>
<ul>
<li>如果指定位置的元素不存在则抛出 IndexOutOfBoundsException 异常；</li>
<li>如果指定位置元素与新值不一致，则创建新数组、在新数组上修改，最后设置新数组到 array（COW）。</li>
<li>即使没有变化，也还是需要重新设置一次 array，这主要是因为 array 本身是 volatile 的，set 方法应当提供 volatile 的语义。</li>
</ul>
<h3 id="remove-int-index"><a class="header-anchor" href="#remove-int-index">¶</a>remove(int index)</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    //获取独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        //获取数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line"></span><br><span class="line">        //获取指定元素</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line"></span><br><span class="line">        //如果要删除的是最后一个元素</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            //分两次拷贝除删除后的元素到新数组</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            //使用新数组代替老的                </span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-object-o"><a class="header-anchor" href="#remove-object-o">¶</a>remove(Object o)</h3>
<h3 id="remove-object-o-object-snapshot-int-index"><a class="header-anchor" href="#remove-object-o-object-snapshot-int-index">¶</a>remove(Object o, Object[] snapshot, int index)</h3>
<h3 id="iterator"><a class="header-anchor" href="#iterator">¶</a>iterator</h3>
<p>CopyOnWriteArrayList 中的 iterator 是弱一致性的，其他线程的修改操作对 iterator 不可见的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    //array的快照版本</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    //数组下标</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否遍历结束</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        if (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在该线程使用返回的迭代器遍历元素的过程中，其它线程没有对 list 进行增删改，那么 snapshot 本身就是 list 的 array，因为它们是引用关系。</li>
<li>如果在遍历期间存在其他线程对 list 的增删改操作，那么 snapshot 会成为原 array 的快照，此时其他线程对 list 进行的增删改是不可见的，因为它们操作的是两个不同的数组。</li>
</ul>
<h1>无锁队列</h1>
<h2 id="concurrentlinkedqueue"><a class="header-anchor" href="#concurrentlinkedqueue">¶</a>ConcurrentLinkedQueue</h2>
<ul>
<li>线程安全</li>
<li>无界</li>
<li>非阻塞</li>
</ul>
<h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3>
<p><img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%B1%BB%E5%9B%BE.png" alt="ConcurrentLinkedQueue类图" title="ConcurrentLinkedQueue类图"></p>
<ul>
<li>底层队列使用单向链表实现。</li>
<li>两个volatile的Node节点（head和tail）分别存放队列的首尾节点，从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">    head = tail = new Node(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Node节点内部为一个volatile修饰的变量item用来存放节点的值，next用来存放链表的下一个节点，从而链接成一个单向无界链表，如下图所示：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%9A%84%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="ConcurrentLinkedQueue的队列结构" title="ConcurrentLinkedQueue的队列结构"></li>
<li>入队和出队操作使用CAS来实现线程安全。</li>
</ul>
<h3 id="入队-offer"><a class="header-anchor" href="#入队-offer">¶</a>入队 - offer</h3>
<p>offer操作在队列末尾添加一个元素：</p>
<ul>
<li>如果传入的是null，抛出NPE，表明ConcurrentLinkedQueue是不允许插入null值的；</li>
<li>其他情况下插入任何元素都会返回true，因为该队列是无界队列；</li>
<li>使用CAS操作实现线程安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    // 从尾节点进行插入</span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        </span><br><span class="line">        // 如果q==null说明p是尾节点，则执行插入</span><br><span class="line">        // （1）</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            // 使用CAS设置p节点的next节点</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                // cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点</span><br><span class="line">                if (p != t)</span><br><span class="line">                    casTail(t, newNode); // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // （2）</span><br><span class="line">        else if (p == q)</span><br><span class="line">            // 多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要</span><br><span class="line">            // 重新找新的head，因为新的head后面的节点才是正常的节点。</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        // （3）</span><br><span class="line">        else</span><br><span class="line">            // 寻找尾节点</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的循环体从队列尾部添加元素：</p>
<ol>
<li>刚开始队列为空，代码（1）通过CAS替换p的下一个节点；<br>
注意有一个哨兵节点null，刚开始队列的head和tail节点都是指向该哨兵节点，因此队列中至少都会有一个节点；</li>
<li>如果多个线程同时执行插入，总会有一个线程CAS时插入失败，这时会进入下一次循环<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A51.png" alt="ConcurrentLinkedQueue插入1" title="ConcurrentLinkedQueue插入1"><br>
这时不满足（1）和（2）的条件，在代码（3）处会将q赋值给p<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A52.png" alt="ConcurrentLinkedQueue插入2" title="ConcurrentLinkedQueue插入2"><br>
再到下一次循环时q就会移动到null，这时要么正常插入，要么又被别人通过CAS抢了。</li>
<li>代码（2）是在执行poll时可能出现的情况：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A53.png" alt="ConcurrentLinkedQueue插入3" title="ConcurrentLinkedQueue插入3"><br>
此时由于t==tail，所以p被赋值为head，然后继续循环插入元素。</li>
</ol>
<h3 id="出队-poll"><a class="header-anchor" href="#出队-poll">¶</a>出队 - poll</h3>
<p>poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    // goto标记</span><br><span class="line">    restartFromHead:</span><br><span class="line"></span><br><span class="line">    // （1）无限循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            // 获取当前队头节点</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            // （2）当前节点有值则cas变为null</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                //（6）cas成功标志当前节点以及从链表中移除</span><br><span class="line">                if (p != h) </span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            // （3）当前队列为空则返回null</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // （4）自引用了，则重新找新的队列头节点</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            // （5）</span><br><span class="line">            else</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">    if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>刚开始队列是空的，内层循环代码（3）判断队列为空就直接返回null了；<br>
这时updateHead执行时由于h等于p所以没有设置头节点，poll直接返回null。</li>
<li>如果执行到（3）时已经有其他线程调用了offer方法成功添加一个元素到队列末尾，这时q会指向新增元素的节点<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F1.png" alt="ConcurrentLinkedQueue出队1" title="ConcurrentLinkedQueue出队1"><br>
这时会进入（5），令p也指向新q。<br>
然后在下一次循环时，进入代码（2），执行<code>p.casItem(item, null)</code>时会通过CAS操作设置头节点的值为null。<br>
代码（6）处，此时h指向哨兵节点，而p指向队列头节点，这时将p设置为新的头节点（这时p里的值已经被清掉了是一个空节点）。<br>
此时队列的状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A53.png" alt="ConcurrentLinkedQueue插入3" title="ConcurrentLinkedQueue插入3"><br>
这就是之前讲队列offer时的一种特殊情况。</li>
<li>自引用的情况<br>
假设线程A已经执行到（2）将第一个节点值置为null，这时又有一个线程B开始执行poll操作，如下图所示：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F2.png" alt="ConcurrentLinkedQueue出队2" title="ConcurrentLinkedQueue出队2"><br>
然后线程 A 执行 updateHead 操作，执行完毕后线程 A 退出，这时候队列状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F3.png" alt="ConcurrentLinkedQueue出队3" title="ConcurrentLinkedQueue出队3"><br>
然后线程 B 继续执行代码（3）q=p.next由于该节点是自引用节点所以p==q所以会执行代码（4）跳到外层循环 restartFromHead，重新获取当前队列队头 head, 现在状态为：<br>
<img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F4.png" alt="ConcurrentLinkedQueue出队4" title="ConcurrentLinkedQueue出队4"></li>
</ol>
<h2 id="arrayblockingqueue"><a class="header-anchor" href="#arrayblockingqueue">¶</a>ArrayBlockingQueue</h2>
<p>offer是不会阻塞的，如果满了直接返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果已经超过容量阈值，则直接返回false</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[putIndex] == null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 把它看成一个循环数组，如果超出范围就卷回</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒这个Condition，必须是在加了锁的前提下才能使用</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll同样也不会阻塞，如果空了直接返回null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[takeIndex] != null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    // 回卷</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put操作会等待notFull这个条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take操作同理，会等待notEmpty这个条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="linkedblockingqueue"><a class="header-anchor" href="#linkedblockingqueue">¶</a>LinkedBlockingQueue</h2>
<p>LinkedBlockingQueue 内部是通过单向链表实现，使用头尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作，而头尾节点的操作分别使用了单独的<strong>独占锁</strong>保证了原子性，所以出队和入队操作是可以同时进行的。另外头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队出队操作实现了一个生产消费模型。</p>
<h2 id="priorityblockingqueue"><a class="header-anchor" href="#priorityblockingqueue">¶</a>PriorityBlockingQueue</h2>
<h2 id="队列比较"><a class="header-anchor" href="#队列比较">¶</a>队列比较</h2>
<h2 id="disruptor"><a class="header-anchor" href="#disruptor">¶</a>Disruptor</h2>
<ul>
<li>
<p>无锁内存队列</p>
</li>
<li>
<p>优化 CPU 伪共享</p>
</li>
<li>
<p>RingBuffer<br>
环形队列，使用定长数组存储，长度是 2^N，可以使用位运算提升性能。<br>
无锁：无锁设计减少了竞争。<br>
预热：预先填充好任务/事件，不需要像链表那样每次添加/删除节点时去创建/回收节点，从而可以避免一定的垃圾回收。<br>
缓存行填充解决了 CPU 伪共享问题。</p>
</li>
<li>
<p>WorkPool<br>
存储 WorkProcessor 的池子，Disruptor 可以通过 Executor 并发启动每一个 WorkProcessor</p>
</li>
<li>
<p>WorkProcessor<br>
从 RindBuffer 消费事件/任务，并交由 WorkHandler 处理。</p>
</li>
<li>
<p>WorkHandler<br>
处理任务的工作者，根据任务类型委托给不同的 EventHandler。</p>
</li>
</ul>
<h2 id="logback-框架中异步日志打印中-arrayblockingqueue-的使用"><a class="header-anchor" href="#logback-框架中异步日志打印中-arrayblockingqueue-的使用">¶</a>Logback 框架中异步日志打印中 ArrayBlockingQueue 的使用</h2>
<p>异步模型是业务线程把要打印的日志任务写入一个队列后直接返回，然后使用一个线程专门负责从队列中获取日志任务写入磁盘，对用户线程来说，耗时只有将数据写入队列中。</p>
<h1>并发安全 Map</h1>
<h2 id="concurrenthashmap"><a class="header-anchor" href="#concurrenthashmap">¶</a>ConcurrentHashMap</h2>
<p><img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%BB%93%E6%9E%84.png" alt="ConcurrentHashMap结构" title="ConcurrentHashMap结构"></p>
<h3 id="get"><a class="header-anchor" href="#get">¶</a>get</h3>
<p>代码：java.util.concurrent.ConcurrentHashMap.get</p>
<ol>
<li>计算 key 的散列值，可以使用该散列值定位到散列表中的某个槽。<br>
如果 key 是自定义类型对象，需要实现重写 hash 方法。</li>
<li>找到对象<br>
hash 值是不精确匹配的，hash 值的关键是计算简单而且有一定的区分度，比如取 string 的前 3 位的和作为 hash 值。<br>
要精确匹配需要使用对象的 equals 方法。<br>
ConcurrentHashMap 中哈希槽的实现方法有两种：链表和红黑树，链表和红黑树的查找过程就不必细说了。</li>
</ol>
<h3 id="put"><a class="header-anchor" href="#put">¶</a>put</h3>
<p><img src="https://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C.png" alt="ConcurrentHashMap的put操作" title="ConcurrentHashMap的put操作"><br>
代码：java.util.concurrent.ConcurrentHashMap.put</p>
<ol>
<li>hash</li>
<li>找对象<br>
找对象过程与 get 的区别主要是 put 需要并发控制：
<ul>
<li>如果槽是空的，则通过 CAS 直接赋值；</li>
<li>如果槽非空，则先用<code>synchronized</code>锁住槽，接下来根据槽的数据结构来插入节点，如果槽是链表，则遍历链表找该 Node 是否已存在，不存在的情况下插入到末尾，如果槽是红黑树，则通过二叉树的遍历找目标 Node，找不到的情况下插入到叶子并重新执行红黑平衡。</li>
</ul>
</li>
</ol>
<h3 id="rehash"><a class="header-anchor" href="#rehash">¶</a>rehash</h3>
<p>扩容的触发条件与HashMap一致。<br>
扩容流程大致上是：遍历哈希槽，对每个需要迁移的哈希槽进行<code>synchronized</code>加锁。<br>
当扩容开始后，其他线程必须等扩容完成后才能工作，但其他线程也不是就一直阻塞等扩容完成，而是调用<code>helpTransfer</code>方法一起帮助进行扩容，实际上因为扩容的单位是哈希槽，因此多线程并发执行扩容并不会导致明显的冲突增加。</p>
<p>扩容入口：</p>
<ol>
<li>helpTransfer<br>
写入操作时协助扩容，即判断hash节点是ForwardingNode则调用helpTransfer将</li>
<li></li>
</ol>
<p>全量添加时，需要保证</p>
<ol>
<li></li>
</ol>
<p>扩容代码：<br>
<code>java.util.concurrent.ConcurrentHashMap.transfer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Moves and/or copies the nodes in each bin to new table. See</span><br><span class="line"> * above for explanation.</span><br><span class="line"> */</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    // 创建一个新的两倍大小的新nextTab，将老tab中的元素迁移过去</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    // 标记节点</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果tab当前位置为null，则设置fwd节点</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        // 已经是fwd节点，则遍历下一个位置</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">        // tab当前位置已有节点，则加锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    // 表示链表节点，如果是树节点则fh=-2</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        // 头节点的hash值</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        // 链表的下一节点p</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            // p节点的hash值</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            // 避免成环？</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 将ln和hn转移到nextTab</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        原tab置为fwd，表示已经被转移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="size"><a class="header-anchor" href="#size">¶</a>size</h3>
<p>size操作返回的是一个不精确的值，因为进行统计的过程中，很有可能会有其他线程正在进行插入和删除操作。</p>
<p>1.8之前的size：</p>
<ol>
<li>遍历segments数组，将每个segment的count加起来作为总数，将modCount加起来作为修改总数；<br>
modCount会在每次segment被修改时+1（只增不减），用于比较。</li>
<li>再做一遍遍历，将这次的modCount总数和上一次的比较，如果一致则计数准确直接返回，否则重试；</li>
<li>如果重试了2次都不行，则第三次会对segment加锁再统计。</li>
</ol>
<p>1.8之后，没有了分段锁，size不会每次都遍历segments统计，而是在更新时修改总数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到，<code>ConcurrentHashMap#size</code>的结果就是：<br>
<code>baseCount + sum(counterCells)</code><br>
其中：</p>
<ul>
<li>baseCount：计数，总数发生变化时通过CAS修改</li>
<li>counterCells：如果baseCount CAS修改失败，作为兜底，类似LongAdder的思路。</li>
</ul>
<p>put操作的末尾会调用addCount()更新baseCount的值，如果CAS修改失败了，则使用counterCells，如果CAS修改 counterCells失败了，则使用fullAddCount方法继续死循环操作，直到成功。</p>
<h1>QA</h1>
<ol>
<li>
<p>JUC 并发包中并发组件 CopyOnWriteArrayList 的实现原理，CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？</p>
</li>
<li>
<p>什么是弱一致性？</p>
</li>
<li>
<p>说一下 ConcurrentHashMap。</p>
</li>
<li>
<p>ConcurrentHashMap 怎么实现并发安全？<br>
相对 Hashtable 来说 ConcurrentHashMap 的锁粒度是更小的，Hashtable 中使用 synchronized 实现的一种方法级的悲观锁，相当于把整个散列表锁住了，不利于系统整体吞吐量的提升。<br>
JDK1.7 中它使用的是一种分段锁来保证并发安全，是一种粒度较小的锁，写操作每次只锁住一个哈希槽，<br>
JDK1.8 之后改为通过实现一种基于 CAS 的乐观锁来保证并发安全，当然，和 HashMap 一样，每个哈希槽在增长到一定程度后会自动转换为红黑树。</p>
</li>
</ol>
<h1>参考</h1>
<ol>
<li><a href="http://www.cnblogs.com/leesf456/p/5550043.html" target="_blank" rel="noopener">【目录】JUC 集合框架目录</a></li>
<li><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">并发框架 Disruptor 译文</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4e8abc71.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/4e8abc71.html" itemprop="url">并发和线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T21:07:49+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="线程和状态机"><a class="header-anchor" href="#线程和状态机">¶</a>线程和状态机</h2>
<h3 id="线程和线程任务"><a class="header-anchor" href="#线程和线程任务">¶</a>线程和线程任务</h3>
<p>线程任务区别于线程，可以理解为线程需要执行的逻辑，类似 Thread 中要执行的 Runnable。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/4e8abc71.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/bf77fad5.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/bf77fad5.html" itemprop="url">自制LinuxContainer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.1k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="预备知识"><a class="header-anchor" href="#预备知识">¶</a>预备知识</h2>
<h3 id="进程和clone系统调用"><a class="header-anchor" href="#进程和clone系统调用">¶</a>进程和clone系统调用</h3>
<p>进程（Process）是运行中的程序实例，又可以称为任务（Task），进程在Linux内核中使用一个PCB来表示，主要包含运行状态、信号、进程号、父进程号、运行时间累计值、正在使用的文件（文件描述符表）、本任务的局部描述符及任务状态段信息。<br>
不同于fork，clone系统调用允许子进程共享部分父进程的上下文，如内存空间、文件描述符表、信号等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Prototype for the glibc wrapper function */</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int clone(int (*fn)(void *), void *child_stack,</span><br><span class="line">          int flags, void *arg, ...</span><br><span class="line">          /* pid_t *ptid, void *newtls, pid_t *ctid */ );</span><br><span class="line">/* For the prototype of the raw system call, see NOTES */</span><br></pre></td></tr></table></figure>
<p><code>clone</code>常用于实现<strong>多线程</strong>，因为子进程和父进程可以共享内存。<br>
不同于<code>fork</code>创建的子进程会从调用的位置开始执行，<code>clone</code>创建的子进程会执行实参传入的<code>fn(arg)</code>，并将实参中的<code>arg</code>传入。<br>
当<code>fn(arg)</code>返回后子进程页会终止，返回值即为子进程的exit code，当然子进程在遇到显式的<code>exit</code>调用或终止信号也会立刻退出。<br>
子进程与父进程共享内存，它们不能（也不应该）使用同一个栈，因此必须使用<code>child_stack</code>参数指定子进程使用的栈所在的内存空间。栈是从上向下生长的，因此最好指定最顶层的一个地址。<br>
<code>flags</code>的低位包含子进程退出了发送给父进程的信号，If this signal is specified as anything other than SIGCHLD, then the parent process must specify the __WALL or __WCLONE options when waiting for the child with wait(2). If no signal is specified, then the parent process is not signaled when the child terminates.<br>
<code>flags</code> 还可以指定子进程和父进程间可以共享的内容，具体内容见<code>man clone</code>。</p>
<h3 id="虚拟网络设备和veth-pair"><a class="header-anchor" href="#虚拟网络设备和veth-pair">¶</a>虚拟网络设备和veth pair</h3>
<p>Linux container 中用到一个叫做veth的东西，这是一种新的设备，专门为 container 所建。veth 从名字上来看是 Virtual ETHernet 的缩写，它的作用很简单，就是要把从一个 network namespace 发出的数据包转发到另一个 namespace。veth 设备是成对的，一个是 container 之中，另一个在 container 之外，即在真实机器上能看到的。</p>
<h4 id="veth设备实现原理"><a class="header-anchor" href="#veth设备实现原理">¶</a>veth设备实现原理</h4>
<p>VETH设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。创建并配置正确后，向其一端输入数据，VETH会改变数据的方向并将其送入内核网络子系统，完成数据的注入，而在另一端则能读到此数据。（Namespace，其中往veth设备上任意一端上RX到的数据，都会在另一端上以TX的方式发送出去）veth工作在L2数据链路层，veth-pair设备在转发数据包过程中并不串改数据包内容。<br>
这里写图片描述<br>
显然，仅有veth-pair设备，容器是无法访问网络的。因为容器发出的数据包，实质上直接进入了veth1设备的协议栈里。如果容器需要访问网络，需要使用bridge等技术，将veth1接收到的数据包通过某种方式转发出去。</p>
<blockquote>
<p>VETH: Typically used when you are trying to connect two entities which would want to “get hold of” (for lack of better phrase) an interface to forward/receive frames. These entities could be containers/bridges/ovs-switch etc. Say you want to connect a docker/lxc container to OVS. You can create a veth pair and push the first interface to the docker/lxc (say, as a phys interface) and push the other interface to OVS. You cannot do this with TAP.</p>
</blockquote>
<h4 id="veth设备特点"><a class="header-anchor" href="#veth设备特点">¶</a>veth设备特点</h4>
<ul>
<li>veth和其它的网络设备都一样，一端连接的是内核协议栈</li>
<li>veth设备是成对出现的，另一端两个设备彼此相连</li>
<li>一个设备收到协议栈的数据发送请求后，会将数据发送到另一个设备上去</li>
</ul>
<h4 id="常用命令"><a class="header-anchor" href="#常用命令">¶</a>常用命令</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建veth</span><br><span class="line">ip link add name veth0 type veth0 peer name veth1</span><br></pre></td></tr></table></figure>
<p>其他细节见Linux篇《虚拟化-网络设备》</p>
<h3 id="资源隔离-namespace和cgroup"><a class="header-anchor" href="#资源隔离-namespace和cgroup">¶</a>资源隔离、namespace和cgroup</h3>
<p><strong>namespace</strong>的主要作用是对两个系统内的标识符的命名进行隔离，namespace有以下几种。<br>
<img src="https://tallate.top/imgs/Docker/Linux-namespace%E7%A7%8D%E7%B1%BB.jpg" alt="Linux-namespace种类" title="Linux-namespace种类"><br>
这几个flag 可以在调用clone进行进程创建的时候作为参数传入，从而实现namespace的隔离，从这个角度来说，container主要是进程角度的隔离，而不是传统的虚拟机（一些虚拟机实现同样是基于对操作系统层的虚拟化，所以应该和container是类似的，比如普通vmware），因为container底层用的是同一个内核来调度。</p>
<p><strong>cgroup</strong> 是linux 内核的另外一个控制和隔离进程的特性，他分为cpu ，memory，net，io等几个子系统，从而实现对进程cpu，内存，磁盘，网络等资源使用的控制。</p>
<h3 id="虚拟文件系统-vfs-和chroot"><a class="header-anchor" href="#虚拟文件系统-vfs-和chroot">¶</a>虚拟文件系统（VFS）和chroot</h3>
<p>将根目录设置成另外一个目录</p>
<h2 id="自制容器"><a class="header-anchor" href="#自制容器">¶</a>自制容器</h2>
<p>docker 只是一个工具，container 技术的核心还是linux 内核的cgroup + chroot + namespace 技术。</p>
<h3 id="制作image"><a class="header-anchor" href="#制作image">¶</a>制作image</h3>
<p>制作自己容器，需要一个image ，可以从网上下一个，也可以自己制作，制作很简单，新装一个操作系统，安装一些需要用到的软件包，然后用tar 制作 / 目录下的压缩包，去掉一些虚拟文件系统的文件，本文用的是自己制作的centos 6.5 的image。</p>
<h3 id="容器实现过程"><a class="header-anchor" href="#容器实现过程">¶</a>容器实现过程</h3>
<p>容器实现过程可以归纳为</p>
<ol>
<li>用clone系统调用创建子进程，传入namespace的那几个参数，实现namespace的隔离；</li>
<li>父进程中创建veth pair ，一个veth在自己的namespace，将另一个设置为子进程的namespace，实现container和宿主机的网络通信；</li>
<li>父进程创建cgroup memory和cpuset子系统，将子进程attach到cgroup子系统上，实现container 的资源限制和隔离；</li>
<li>子进程在自己的namespace里，设置主机名，mount proc虚拟文件系统，设置veth ip，chroot到centos 6镜像的位置， 最终将进程镜像替换成/bin/bash；</li>
<li>父进程调用waitpid 等待子进程退出。</li>
</ol>
<h3 id="容器实现"><a class="header-anchor" href="#容器实现">¶</a>容器实现</h3>
<p>见下面的《源码》部分</p>
<h3 id="实验"><a class="header-anchor" href="#实验">¶</a>实验</h3>
<p>在解压好镜像后，该镜像根目录下可能还没有必须的命令文件及其依赖的动态链接库，主要是由于用<code>chroot</code>改变根目录后，原来路径下的一些文件在当前镜像内都找不到了，一般安装完操作系统后这些文件应该都安装好了，如果需要可以<a href="https://ubuntuforums.org/showthread.php?t=1434781" target="_blank" rel="noopener">通过手动移动来解决</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd /bin/bash</span><br><span class="line">cp --parents /lib/x86_64-linux-gnu/libtinfo.so.5 ./</span><br></pre></td></tr></table></figure>
<p>编译执行容器代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc lxc_demo.c -o lxc_demo -lcgroup</span><br><span class="line">sudo ./lxc_demo</span><br></pre></td></tr></table></figure>
<p>接下来分别在宿主机和容器内执行命令，可以得出一些结论：</p>
<ol>
<li>容器和宿主机镜像可能不同，但是内核相同；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># （宿主机内）</span><br><span class="line">hgc@hgc-X555LD:~$ uname -r</span><br><span class="line">4.13.0-45-generic</span><br><span class="line"></span><br><span class="line"># （容器内）</span><br><span class="line">bash-4.4# uname -r</span><br><span class="line">4.13.0-45-generic</span><br></pre></td></tr></table></figure>
<ol>
<li>根目录下的文件不同；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>
<ol>
<li>hostname，宿主机内为用户设定的主机名，容器内为mydocker，说明UTS namespace隔离成功；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure>
<ol>
<li>网络方面有回环网络卡lo和veth1，veth1 169.254.1.2 能ping 通veth0的地址（宿主机上的veth）169.254.2.1，如果在外面加iptables 做nat 转换的话，container里面还可以和外面通信。我们看不到外面宿主机的eth0 和 eth1，说明container 的network namespace 隔离成功。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># （宿主机内）</span><br><span class="line">$ ip addr</span><br><span class="line">......</span><br><span class="line">19: veth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 46:c0:eb:a8:34:8d brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 169.254.1.1/30 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::44c0:ebff:fea8:348d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"># （容器内）网络方面有回环网络卡lo和veth1</span><br><span class="line">bash-4.4# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">18: veth1@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether ce:04:78:b6:5a:2d brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 169.254.1.2/30 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::cc04:78ff:feb6:5a2d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"># 尝试ping宿主机上的veth0设备</span><br><span class="line">bash-4.4# ping 169.254.1.1</span><br><span class="line">PING 169.254.1.1 (169.254.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 169.254.1.1: icmp_seq=1 ttl=64 time=0.101 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ol>
<li>目前container 里面只有/bin/bash , 且进程号为 1，不是我们常见的init进程，或者systemd 。因为/bin/bash 为该namespace 下的第一个进程，说明我们的pid namespace隔离成功。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看进程</span><br><span class="line">bash-4.4# ps -aux </span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">0 1 0.0 0.0 9924 3264 ? S 01:02 0:00 /bin/bash</span><br><span class="line">0 8 0.0 0.0 30524 2820 ? R+ 01:02 0:00 ps -aux</span><br></pre></td></tr></table></figure>
<ol>
<li>mount 显示挂载的文件系统，和宿主机的不一样，说明mount namespace隔离成功。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看挂载情况（这里有点问题，原文里还有rootfs、sysfs等）</span><br><span class="line">bash-4.4# mount</span><br><span class="line">proc on /proc type proc (rw,relatime)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ol>
<li>就cgroup的隔离情况来说，在cgroup文件系统内，memory的限制是我们设置的512M，cpu使用的是0-1号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hgc@hgc-X555LD:~/tools/virtualmachines/ubuntu-16.04$ cd /sys/fs/cgroup/memory/mydocker_1530580167/</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/memory/mydocker_1530580167$ cat memory.limit_in_bytes </span><br><span class="line">536870912</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/memory/mydocker_1530580167$ cd /sys/fs/cgroup/cpuset/mydocker_1530580167/</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ cat cpuset.cpus </span><br><span class="line">0-1</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ cat cpuset.mems </span><br><span class="line">0</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ top</span><br></pre></td></tr></table></figure>
<p>从下面执行情况可以看出，只有0号和1号cpu idle为0 ，其他的都接近100%，说明cgroup隔离效果是很好的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># （宿主机内）执行top命令并点击1查看CPU负载情况</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ top</span><br><span class="line">top - 10:02:22 up 13:19, 1 user, load average: 0.74, 0.68, 0.72</span><br><span class="line">Tasks: 348 total, 1 running, 346 sleeping, 0 stopped, 1 zombi</span><br><span class="line">%Cpu0 : 5.3 us, 2.3 sy, 0.0 ni, 91.7 id, 0.0 wa, 0.0 hi, 0.7</span><br><span class="line">%Cpu1 : 8.3 us, 12.6 sy, 0.0 ni, 78.8 id, 0.0 wa, 0.0 hi, 0.3</span><br><span class="line">%Cpu2 : 4.0 us, 2.0 sy, 0.0 ni, 93.9 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu3 : 3.0 us, 2.4 sy, 0.0 ni, 94.6 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu4 : 7.1 us, 5.7 sy, 0.0 ni, 87.2 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu5 : 4.4 us, 1.4 sy, 0.0 ni, 93.9 id, 0.3 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu6 : 3.3 us, 2.7 sy, 0.0 ni, 93.7 id, 0.0 wa, 0.0 hi, 0.3</span><br><span class="line">%Cpu7 : 3.7 us, 1.3 sy, 0.0 ni, 94.6 id, 0.0 wa, 0.0 hi, 0.3</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># （容器内）执行多个死循环任务，强行使CPU忙碌</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;                   </span><br><span class="line">[1] 10</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[2] 11</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[3] 12</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[4] 13</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[5] 14</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[6] 15</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[7] 16</span><br><span class="line"></span><br><span class="line"># （宿主机内）同样是执行top命令并点击1，可以看到头两个CPU的负载情况有了明显变化</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ top</span><br><span class="line">top - 10:05:05 up 13:22, 1 user, load average: 4.25, 1.68, 1.06</span><br><span class="line">Tasks: 355 total, 1 running, 353 sleeping, 0 stopped, 1 zombi</span><br><span class="line">%Cpu0 : 9.9 us, 34.8 sy, 0.0 ni, 53.2 id, 2.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu1 : 14.4 us, 43.6 sy, 0.0 ni, 40.2 id, 1.7 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu2 : 2.2 us, 0.6 sy, 0.0 ni, 92.0 id, 0.0 wa, 0.0 hi, 5.1</span><br><span class="line">%Cpu3 : 2.6 us, 1.3 sy, 0.0 ni, 95.0 id, 0.0 wa, 0.0 hi, 1.0</span><br><span class="line">%Cpu4 : 6.4 us, 10.0 sy, 0.0 ni, 83.6 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu5 : 2.3 us, 1.2 sy, 0.0 ni, 95.3 id, 0.0 wa, 0.0 hi, 1.2</span><br><span class="line">%Cpu6 : 1.7 us, 0.7 sy, 0.0 ni, 97.6 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu7 : 2.0 us, 2.7 sy, 0.0 ni, 95.3 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mount.h&gt;</span><br><span class="line">// 必须先安装：sudo apt-get install libcgroup-dev</span><br><span class="line">#include &lt;libcgroup.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line">#define MEMORY_LIMIT (512*1024*1024)</span><br><span class="line"></span><br><span class="line">//const char *rootfs = &quot;/data1/centos6/rootfs/&quot;; //centos6 镜像位置</span><br><span class="line">//const char *rootfs = &quot;/home/hgc/tools/virtualmachines/ubuntu-16.04/&quot;; // 镜像位置</span><br><span class="line">//const char *hostname = &quot;mydocker&quot;; //container 主机名</span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">//char *const child_args[] = &#123;</span><br><span class="line">//    &quot;/bin/bash&quot;,</span><br><span class="line">//    NULL</span><br><span class="line">//&#125;;</span><br><span class="line">int pipe_fd[2]; //父子进程同步</span><br><span class="line"></span><br><span class="line">int child_main(void *args) &#123;</span><br><span class="line">  char c;</span><br><span class="line">  // TODO:子进程里无法使用全局变量rootfs和hostname</span><br><span class="line">  // 镜像位置</span><br><span class="line">  const char *rootfs = &quot;/home/hgc/tools/virtualmachines/ubuntu-16.04/&quot;;</span><br><span class="line">  // container 主机名</span><br><span class="line">  const char *hostname = &quot;mydocker&quot;;</span><br><span class="line">  // 在子进程（容器）内执行的任务</span><br><span class="line">  // TODO:因为chroot改变了根目录的位置，所以在保证目标命令存在容器内的基础上（这里是/bin/bash），</span><br><span class="line">  // TODO:必须保证该命令依赖的资源同样存在于容器内（动态链接库，使用ldd查看）</span><br><span class="line">  char *const child_args[] = &#123;</span><br><span class="line">      &quot;/bin/bash&quot;,</span><br><span class="line">      0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  printf(&quot;In child process(container)\n&quot;);</span><br><span class="line">  chroot(rootfs); //用chroot 切换根目录</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;chroot()&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // TODO:这里不能使用sizeof</span><br><span class="line">  //clone 调用中的 CLONE_NEWUTS起隔离主机名和域名的作用</span><br><span class="line">  sethostname(hostname, strlen(hostname));</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;sethostname()!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  //挂载proc子系统，CLONE_NEWNS 起隔离文件系统作用</span><br><span class="line">  // 需要在rootfs目录下创建proc目录</span><br><span class="line">  mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL);</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;Mount(proc)&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  //切换的根目录</span><br><span class="line">  chdir(&quot;/&quot;);</span><br><span class="line">  close(pipe_fd[1]);</span><br><span class="line">  read(pipe_fd[0], &amp;c, 1);</span><br><span class="line">  //设置veth1 网络</span><br><span class="line">  system(&quot;ip link set lo up&quot;);</span><br><span class="line">  system(&quot;ip link set veth1 up&quot;);</span><br><span class="line">  system(&quot;ip addr add 169.254.1.2/30 dev veth1&quot;);</span><br><span class="line">  //将子进程的镜像替换成bash</span><br><span class="line">  printf(&quot;[%s]\n&quot;, child_args[0]);</span><br><span class="line">  if (execv(child_args[0], child_args) == -1) &#123;</span><br><span class="line">    perror(&quot;execv(path, argv)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cgroup *cgroup_control(pid_t pid) &#123;</span><br><span class="line">  struct cgroup *cgroup = NULL;</span><br><span class="line">  int ret;</span><br><span class="line">  ret = cgroup_init();</span><br><span class="line">  char *cgname = malloc(19 * sizeof(char));</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    printf(&quot;error occurs while init cgroup.\n&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  time_t now_time = time(NULL);</span><br><span class="line">  sprintf(cgname, &quot;mydocker_%d&quot;, (int) now_time);</span><br><span class="line">  printf(&quot;%s\n&quot;, cgname);</span><br><span class="line">  cgroup = cgroup_new_cgroup(cgname);</span><br><span class="line">  if (!cgroup) &#123;</span><br><span class="line">    ret = ECGFAIL;</span><br><span class="line">    printf(&quot;Error new cgroup%s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  //添加cgroup memory 和 cpuset子系统</span><br><span class="line">  struct cgroup_controller *cgc = cgroup_add_controller(cgroup, &quot;memory&quot;);</span><br><span class="line">  struct cgroup_controller *cgc_cpuset = cgroup_add_controller(cgroup, &quot;cpuset&quot;);</span><br><span class="line">  if (!cgc || !cgc_cpuset) &#123;</span><br><span class="line">    ret = ECGINVAL;</span><br><span class="line">    printf(&quot;Error add controller %s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  // 内存限制  512M</span><br><span class="line">  if (cgroup_add_value_uint64(cgc, &quot;memory.limit_in_bytes&quot;, MEMORY_LIMIT)) &#123;</span><br><span class="line">    printf(&quot;Error limit memory.\n&quot;);</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  //限制只能使用0和1号cpu</span><br><span class="line">  if (cgroup_add_value_string(cgc_cpuset, &quot;cpuset.cpus&quot;, &quot;0-1&quot;)) &#123;</span><br><span class="line">    printf(&quot;Error limit cpuset cpus.\n&quot;);</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  //限制只能使用0和1块内存</span><br><span class="line">  // TODO:使用0-1作为参数会报错“Invalid argument”</span><br><span class="line">  if (cgroup_add_value_string(cgc_cpuset, &quot;cpuset.mems&quot;, &quot;0&quot;)) &#123;</span><br><span class="line">    printf(&quot;Error limit cpuset mems.\n&quot;);</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = cgroup_create_cgroup(cgroup, 0);</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    printf(&quot;Error create cgroup%s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = cgroup_attach_task_pid(cgroup, pid);</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    printf(&quot;Error attach_task_pid %s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  return cgroup;</span><br><span class="line">  out:</span><br><span class="line">  if (cgroup) &#123;</span><br><span class="line">    cgroup_delete_cgroup(cgroup, 0);</span><br><span class="line">    cgroup_free(&amp;cgroup);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  char *cmd;</span><br><span class="line">  printf(&quot;main process: \n&quot;);</span><br><span class="line">  pipe(pipe_fd);</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;pipe()&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用clone创建子进程，传入namespace的几个flag参数，实现namespace的隔离</span><br><span class="line">  // 子进程执行child_main函数，其堆栈空间使用child_stack参数指定</span><br><span class="line">  // clone与线程的实现息息相关：http://www.xuebuyuan.com/1422353.html</span><br><span class="line">  int child_pid = clone(child_main, child_stack + STACK_SIZE, \</span><br><span class="line">            CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">  struct cgroup *cg = cgroup_control(child_pid);</span><br><span class="line">  // 添加veth pair，设置veth1 在子进程的的namespace，veth0 在父进程的namespace，为了实现container和宿主机之间的网络通信</span><br><span class="line">  // linl3 实现起来太繁琐，借用命令行工具ip 实现</span><br><span class="line">  system(&quot;ip link add veth0 type veth peer name veth1&quot;);</span><br><span class="line">  asprintf(&amp;cmd, &quot;ip link set veth1 netns %d&quot;, child_pid); // asprintf根据字符串长度申请足够的内存空间，但在之后必须手动释放</span><br><span class="line">  system(cmd);</span><br><span class="line">  system(&quot;ip link set veth0 up&quot;);</span><br><span class="line">  system(&quot;ip addr add 169.254.1.1/30 dev veth0&quot;);</span><br><span class="line">  free(cmd);</span><br><span class="line">  //等执行以上命令，通知子进程，子进程设置自己的网络</span><br><span class="line">  close(pipe_fd[1]);</span><br><span class="line">  waitpid(child_pid, NULL, 0);</span><br><span class="line">  if (cg) &#123;</span><br><span class="line">    cgroup_delete_cgroup(cg, 0); //删除cgroup 子系统</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;child process exited.\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="lxc"><a class="header-anchor" href="#lxc">¶</a>LXC</h3>
<ol>
<li><a href="https://linuxcontainers.org/" target="_blank" rel="noopener">Linux Containers</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/" target="_blank" rel="noopener">理解 chroot</a></li>
</ol>
<h3 id="虚拟网络设备"><a class="header-anchor" href="#虚拟网络设备">¶</a>虚拟网络设备</h3>
<ol>
<li><a href="https://blog.csdn.net/sld880311/article/details/77650937" target="_blank" rel="noopener">Linux-虚拟网络设备-veth pair</a></li>
</ol>
<h3 id="clone"><a class="header-anchor" href="#clone">¶</a>clone</h3>
<ol>
<li><a href="https://blog.csdn.net/u013272948/article/details/69218319" target="_blank" rel="noopener">linux的Clone()函数详解</a></li>
</ol>
<h3 id="linux-namespace"><a class="header-anchor" href="#linux-namespace">¶</a>Linux namespace</h3>
<ol>
<li><a href="https://blog.csdn.net/preterhuman_peak/article/details/40857117" target="_blank" rel="noopener">Linux Namespaces机制</a></li>
<li><a href="https://linux.cn/article-5019-1.html" target="_blank" rel="noopener">介绍 Linux 的命名空间</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">144</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
