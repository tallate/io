<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="MySQL,">










<meta name="description" content="事务语法1、开启事务12-- 注意后面的WORK可有可无BEGIN [WORK]; 或者123-- START TRANSACTION和BEGIN的区别主要是前者还能指定事务的访问模式，如果不设置访问模式，则默认是READ WRITE模式START TRANSACTION [READ ONLY | READ WRITE | WITH CONSISTENT SNAPSHOT]; 需要注意的是，be">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL4_1事务">
<meta property="og:url" content="https://tallate.github.io/86b66af2.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="事务语法1、开启事务12-- 注意后面的WORK可有可无BEGIN [WORK]; 或者123-- START TRANSACTION和BEGIN的区别主要是前者还能指定事务的访问模式，如果不设置访问模式，则默认是READ WRITE模式START TRANSACTION [READ ONLY | READ WRITE | WITH CONSISTENT SNAPSHOT]; 需要注意的是，be">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-事务状态.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-undolog.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-版本链.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-数据版本可见性规则.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-ReadView版本链.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-ReadView版本链1.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-当前读.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-死锁.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MVCC与count星查询.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-使用数据库计数解决统计问题.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-当前读例子2.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-幻读导致的数据不一致问题.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-间隙锁引起的死锁.png">
<meta property="og:image" content="https://tallate.top/imgs/MySQL/MySQL-更新丢失.png">
<meta property="og:updated_time" content="2021-06-13T15:16:24.767Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL4_1事务">
<meta name="twitter:description" content="事务语法1、开启事务12-- 注意后面的WORK可有可无BEGIN [WORK]; 或者123-- START TRANSACTION和BEGIN的区别主要是前者还能指定事务的访问模式，如果不设置访问模式，则默认是READ WRITE模式START TRANSACTION [READ ONLY | READ WRITE | WITH CONSISTENT SNAPSHOT]; 需要注意的是，be">
<meta name="twitter:image" content="https://tallate.top/imgs/MySQL/MySQL-事务状态.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/86b66af2.html">







  <title>MySQL4_1事务 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/86b66af2.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MySQL4_1事务</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-25T10:18:28+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  29 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h2 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h2><p>1、开启事务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 注意后面的WORK可有可无</span><br><span class="line">BEGIN [WORK];</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- START TRANSACTION和BEGIN的区别主要是前者还能指定事务的访问模式，如果不设置访问模式，</span><br><span class="line">则默认是READ WRITE模式</span><br><span class="line">START TRANSACTION [READ ONLY | READ WRITE | WITH CONSISTENT SNAPSHOT];</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>begin/start transaction</code>并不是事务的起点，当执行到第一个操作 InnoDB 表的语句时事务才真正启动。或者可以使用<code>start transaction with consistent snapshot</code>来立刻启动。<br>2、提交事务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT [WORK];</span><br></pre></td></tr></table></figure></p>
<p>3、手动中止事务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK];</span><br></pre></td></tr></table></figure></p>
<p>注意，ROLLBACK 语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。<br>4、事务中涉及到的所有表都支持事务<br>目前只有 InnoDB 和 NDB 存储引擎是支持事务的，如果某个事务中操作的表使用的是不支持事务的表，则对这些表所做的修改将无法被回滚。<br>5、自动提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &apos;autocommit&apos;;</span><br></pre></td></tr></table></figure></p>
<p>如果这个自动提交开关是打开的，则只要我们不显式使用 START TRANSACTION 或者 BEGIN 语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的自动提交。<br>6、隐式提交<br>就算 autocommit 开关是关闭的，如果我们输入了某些语句还是会触发隐式的提交，包括：</p>
<ul>
<li>DDL：<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code></li>
<li>对系统表执行的操作：ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD</li>
<li>事务控制或关于锁定的语句：当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务；或原来 autocommit 为 OFF 的情况下将其修改为 ON，也会触发隐式提交；或者使用 LOCK TABLES、UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事务。</li>
<li>加载数据的语句：比如我们使用 LOAD DATA 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</li>
<li>关于 MySQL 复制的一些语句：使用 START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO 等语句时也会隐式的提交前边语句所属的事务。<br>其它的一些语句：使用 ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、 LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET 等语句也会隐式的提交前边语句所属的事务。<br>7、保存点<br>在事务执行的某个阶段设置检查点，下次回滚时可以回滚至此处，而不是从头开始：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT 保存点名称;</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h2><p>事务具有以下 4 个基本特征：</p>
<h3 id="原子性-Atomic"><a href="#原子性-Atomic" class="headerlink" title="原子性(Atomic)"></a>原子性(Atomic)</h3><p>事务中包含的每个操作都被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。（记录之前的版本，允许回滚）。</p>
<h3 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h3><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。换句话说，事务执行前和事务执行后数据内在的逻辑始终是成立的。比如转帐前后两人的存款总和始终不变。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这时数据库就处于一种不正确的状态，或者说是不一致的状态。例如在一在进行转账的操作中，需要从账户 A 取出 100 元转入账户 B。那么就可以定义一个事务，该事物包括两个操作：第一个操作是从账户 A 中减去 100 元，第二个操作是向账户 B 中转入 100 元。这两个操作要么全做，要么全不做。全做或者全不做，数据库就会处于一致性状态。如果只做一个操作，则逻辑上就会发生错误，减少或增加 100 元，数据库就 处于不一致的状态了。所以说一致性和原子性是密不可分的。</p>
<p>但是现在问题来了——<strong>原子性就一定能够保证一致性吗？</strong><br>答案是否定的：原子性不能完全保证一致性。因为在多个事务并行进行的情况下，即使保证了每个事务的原子性，仍然可能导致数据不一致的结果。例如事务 1 需要将 100 元转入账户 A：先读取 A 的账户余额的值，然后在这个值上加上 100.但是，在这两个操作之间，事务 2 修改了账户 A 的值，为它增加了 100 元，那么最后结果应该是 A 增加了 200 元。但事实上，当事务 1 最终完成时，账户 A 只增加了 100 元，因为事务 2 的执行结果被事务 1 覆盖掉了。所以为了保证并发事务的一致性，就引入了事务的隔离性。(事务开始和结束之间的中间状态不会被其他事务看到)</p>
<h3 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h3><p>一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发的执行。关于事务的隔离性数据库提供了多种隔离级别，后面会提到。(适当地破坏一致性来提升性能与并行度 例如：最终一致 ~= 读未提交)</p>
<h3 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h3><p>持久性是指一个事务一旦提交，它对数据库中数据的改变就是永久性的。接下来的操作或故障不应该对其执行结果有影响。(每一次的事务提交之后就会保证不丢失)</p>
<h2 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h2><p>事务是一个抽象的概念，它对应一个或多个数据库操作。根据这些操作所执行的不同阶段，我们可以把事务大致划分为以下几个状态：<br><img src="https://tallate.top/imgs/MySQL/MySQL-事务状态.png" alt="MySQL-事务状态" title="MySQL-事务状态"><br>如上图可知，事务从活动的开始，直到提交或中止状态时生命周期才算结束，当事务是已提交的，它做的修改会持久生效（事务的<strong>持久性</strong>），当事务中止，该事务所做的一切修改都会被回滚（<strong>原子性</strong>）。<br>1、活动的（active）<br>事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。<br>2、部分提交的（partially committed）<br>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。<br>3、失败的（failed）<br>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。<br>4、中止的（aborted）<br>事务执行到一半出错会变为失败状态，此时，需要进行回滚，即撤销失败事务对当前数据库造成的影响，回滚完毕后，事务就处在了中止的状态。<br>比如 A 向 B 转账，A 账户扣除后遇到错误，导致 B 账户余额没变，此时需要将 A 账户的扣减操作回滚，恢复到原来的金额。<br>5、提交的（committed）<br>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="事务并发执行可能遇到的问题"><a href="#事务并发执行可能遇到的问题" class="headerlink" title="事务并发执行可能遇到的问题"></a>事务并发执行可能遇到的问题</h3><p>在不保证串行执行的情况下，多个事务的并行执行可能会导致一些问题，按由重到轻分别为：<br>1、脏写（Dirty Write）：一个事务修改了另一个未提交事务修改过的数据；<br>2、脏读（Dirty Read）：一个事务读到了另一个未提交事务修改过的数据；<br>3、不可重复读（Non-Repeatable Read）：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值；<br>4、幻读（Phantom）：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。</p>
<p>隔离级别越低，越严重的问题就越可能发生，按隔离级别的严格程度由轻到严分别为：<br>1、READ UNCOMMITTED：未提交读。<br>2、READ COMMITTED：已提交读。<br>3、REPEATABLE READ：可重复读。<br>4、SERIALIZABLE：可串行化。</p>
<p>隔离级别    脏读    不可重复读    幻读<br>READ UNCOMMITTED    Possible    Possible    Possible<br>READ COMMITTED    Not Possible    Possible    Possible<br>REPEATABLE READ    Not Possible    Not Possible    Possible<br>SERIALIZABLE    Not Possible    Not Possible    Not Possible</p>
<h3 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h3><p>以可重复读为例，设置某次连接的事务隔离级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br></pre></td></tr></table></figure></p>
<h3 id="隔离级别与-MVCC、锁之间的关系"><a href="#隔离级别与-MVCC、锁之间的关系" class="headerlink" title="隔离级别与 MVCC、锁之间的关系"></a>隔离级别与 MVCC、锁之间的关系</h3><p>接下来我们会讨论如何实现各种隔离级别，原理是利用 MVCC 机制和各种锁，因此这里提前说明一下实现各种隔离级别所需的技术：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>是否使用 MVCC</th>
<th>是否使用行锁</th>
<th>是否使用间隙锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>否</td>
<td>否，忽略其他事务放置的锁</td>
<td>否</td>
</tr>
<tr>
<td>读已提交</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>可重复读</td>
<td>是，与读已提交的区别是创建 ReadView 的时机不同</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>序列化</td>
<td>否，所有事务序列化执行，没有使用 MVCC 的必要了</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<h2 id="事务隔离级别与MVCC"><a href="#事务隔离级别与MVCC" class="headerlink" title="事务隔离级别与MVCC"></a>事务隔离级别与MVCC</h2><p>MVCC 利用 Read View（一致性读视图）来表示数据一个可见的状态，当数据当前的 Read View 是不可见时，能够通过 undo log 串联起来的版本链回溯找到数据可见的版本。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>在 InnoDB 引擎中，聚簇索引都会有 2 个隐藏列：</p>
<blockquote>
<p>row_id 并不是必要的，我们创建的表中有主键或者非 NULL 的 UNIQUE 键时都不会包含 row_id 列</p>
<ul>
<li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务 id 赋值给 trx_id 隐藏列。</li>
<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。<br><img src="https://tallate.top/imgs/MySQL/MySQL-undolog.png" alt="MySQL-undolog" title="MySQL-undolog"></li>
</ul>
</blockquote>
<p>这个<strong>undo log</strong>就是 MVCC 的核心，undo log 的类型包括：<br>1、insert undo：在事务正式提交之后就可以被释放掉了，因为要回滚插入操作直接将记录删掉即可；<br>2、update undo：因为 update undo 还需要支持 MVCC，不能直接释放。</p>
<p>每次修改记录时，都会记录一条 undo log，每条 undo log 都有一个 roll_pointer 属性，因此所有 undo log 实际山可以组成一个链表，称为<strong>版本链</strong>：<br><img src="https://tallate.top/imgs/MySQL/MySQL-版本链.png" alt="MySQL-版本链" title="MySQL-版本链"><br>版本链的头节点就是当前记录最新的值，注意每条 undo log 都含有一个事务 id（trx_id）。</p>
<h3 id="Read-View-一致性读视图"><a href="#Read-View-一致性读视图" class="headerlink" title="Read View (一致性读视图)"></a>Read View (一致性读视图)</h3><p>Read View 只有在 READ COMMITTED、REPEATABLE READ 两种隔离级别下才能生效。<br>READ UNCOMMITTED：由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本；<br>SERIALIZABLE：加锁；<br>READ COMMITTED、REPEATABLE READ：只能读到已提交的事务修改过的记录，因此需要判断一下版本链中的<strong>哪个版本是当前事务可见的</strong>。</p>
<p><img src="https://tallate.top/imgs/MySQL/MySQL-数据版本可见性规则.png" alt="MySQL-数据版本可见性规则" title="MySQL-数据版本可见性规则"><br>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ul>
<li>落在中间部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>落在右边，表示这个版本是由将来启动的事务生成的，不可见；</li>
<li>如果落在左边，若 row trx_id 在数组中，表示这个版本是由还未提交的事务生成的，不可见；若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
<p>总而言之，除了自己的更新总是可见以外，有三种情况：</p>
<ul>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ul>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。<br>虽然期间这行数据可能被修改过，但是事务不论在什么时候查询，看到这行数据的结构都是一致的，所以我们称之为<strong>一致性读</strong>。</p>
<p>前面提过 READ COMMITTED、REPEATABLE READ 都需要维护版本，它们之间的区别主要是<strong>生成 ReadView 的时机</strong>不同。</p>
<h3 id="READ-COMMITTED-每次读取数据前生成一个-ReadView"><a href="#READ-COMMITTED-每次读取数据前生成一个-ReadView" class="headerlink" title="READ COMMITTED - 每次读取数据前生成一个 ReadView"></a>READ COMMITTED - <strong>每次</strong>读取数据前生成一个 ReadView</h3><p>1、首先有两个事务在执行：<br>ID 为 100 的事务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &apos;关羽&apos; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &apos;张飞&apos; WHERE number = 1;</span><br></pre></td></tr></table></figure></p>
<p>ID 为 200 的事务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>此时，表 hero 中 number 为 1 的记录得到的版本链表如下所示：<br><img src="https://tallate.top/imgs/MySQL/MySQL-ReadView版本链.png" alt="MySQL-ReadView版本链" title="MySQL-ReadView版本链"></p>
<p>2、上面两个事务正在执行的过程中，如果有一个使用 READ COMMITTED 隔离级别的事务开始执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&apos;刘备&apos;</span><br></pre></td></tr></table></figure></p>
<p>这个 SELECT1 的执行过程如下：</p>
<ul>
<li>在执行 SELECT 语句时会先生成一个 ReadView，ReadView 中的 trx_id 列表为<code>[100, 200]</code>；</li>
<li>trx_id=100 的事务写入了两个版本，这些版本处在未提交事务集合内，因此不符合可见性要求，跳到下面的版本；</li>
<li>跳到刘备这个版本后，因为 trx_id=80，处于已提交事务集合内，是可见的，因此最终返回的版本就是这条数据。</li>
</ul>
<p>3、提交其中一个事务<br>我们把事务 id 为 100 的事务提交一下，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &apos;关羽&apos; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &apos;张飞&apos; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></p>
<p>然后再到事务 id 为 200 的事务中更新一下表 hero 中 number 为 1 的记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &apos;赵云&apos; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &apos;诸葛亮&apos; WHERE number = 1;</span><br></pre></td></tr></table></figure></p>
<p>此刻，表 hero 中 number 为 1 的记录的版本链如下所示：<br><img src="https://tallate.top/imgs/MySQL/MySQL-ReadView版本链1.png" alt="MySQL-ReadView版本链1" title="MySQL-ReadView版本链1"></p>
<p>4、然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 number 为 1 的记录，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&apos;刘备&apos;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&apos;张飞&apos;</span><br></pre></td></tr></table></figure></p>
<p>这个 SELECT2 的执行过程如下：</p>
<ul>
<li>在执行 SELECT 语句时会<strong>又单独生成一个 ReadView</strong>，该 ReadView 的 trx_id 列表为<code>[200]</code>，此时 trx_id 为 100 的事务已经提交了；</li>
<li>头两个版本诸葛亮、赵云因为版本 trx_id=200 处于未提交事务集合内，因此不可见；</li>
<li>下一个版本张飞可见，因此被返回。</li>
</ul>
<h3 id="REPEATABLE-READ-在第一次读取数据时生成一个-ReadView"><a href="#REPEATABLE-READ-在第一次读取数据时生成一个-ReadView" class="headerlink" title="REPEATABLE READ - 在第一次读取数据时生成一个 ReadView"></a>REPEATABLE READ - 在<strong>第一次</strong>读取数据时生成一个 ReadView</h3><p>READ COMMITTED 会在<strong>每次</strong>读取数据时生成 ReadView，而 REPEATABLE READ 则只在<strong>第一次</strong>读取数据时生成一个 ReadView，之后的查询就不会重复生成了。<br>同上一节中的例子，在 REPEATABLE READ 隔离级别的事务中多次查找这个 number 为 1 的记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&apos;刘备&apos;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值仍为&apos;刘备&apos;</span><br></pre></td></tr></table></figure></p>
<p>这个 SELECT2 的执行过程如下：</p>
<ul>
<li>因为当前事务的隔离级别为 REPEATABLE READ，而之前在执行 SELECT1 时已经生成过 ReadView 了，所以此时直接复用之前的 ReadView，快照中的 trx_id 列表为<code>[100, 200]</code>。</li>
<li>头几个版本诸葛亮、赵云、张飞、关羽均不符合可见性原则；</li>
<li>下一个版本刘备 trx_id 为 80，符合可见性原则，因此返回。</li>
</ul>
<p>之后该事务不论何时查找，结果都会是这样。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新数据都是先读后写的，如果按照之前读取的规则，当前事务应该是读取不到其他更新的事务所做的修改的，但是这样可能会导致其他事务的更新丢失，因此更新操作的读取都是读当前的值，即<strong>当前读（current read）</strong>。</p>
<blockquote>
<p>除了 update 语句外，如果 select 语句加锁也是当前读，可以用 lock in share mock（读锁）或 for update（写锁）语句来加锁。</p>
</blockquote>
<p><img src="https://tallate.top/imgs/MySQL/MySQL-当前读.png" alt="MySQL-当前读" title="MySQL-当前读"><br>如上图所示，事务 A、B 刚开始时就创建了视图，事务 C 没有显式使用 begin/commit，表示该 update 语句本身就是一个事务。</p>
<ol>
<li>刚开始，id 为 1 的记录的字段 k 值为 1；</li>
<li>事务 C 更新 k 为 2；</li>
<li>由于当前读的规则，事务 B 在 update 时能看到 k 为 2，并更新为 3，注意因为更新后最新版本是当前事务写入的，因此当前事务之后的读操作总是可以读到最新的数据。</li>
<li>事务 A 在继续查询时，依据版本链找到可见的 k 为 1。</li>
</ol>
<p>可见，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，我们称之为<strong>一致性读</strong>。</p>
<p>注意，上面的事务 C 更新完后直接提交了，如果不提交，由于二段锁协议，事务 B 将一直等待 C 提交事务。<br><img src="https://tallate.top/imgs/MySQL/MySQL-死锁.png" alt="MySQL-死锁" title="MySQL-死锁"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>DELETE 语句并不会立即将记录从页面中清除，而是执行一个所谓的<strong>delete mark</strong>操作，为此，表的每一行记录都会额外增加一个删除版本号（delete_version）。<br>1、新增<br>| - | - | - |<br>| id | create_version | delete_version |<br>| - | - | - |<br>| 1 | 1 | |</p>
<p>2、更新<br>采用 delete+add 的方式实现，将老数据行标志为删除，然后新增一行新的数据：</p>
<p>| - | - | - |<br>| id | create_version | delete_version |<br>| - | - | - |<br>| 1 | 1 | 2 |<br>| 1 | 2 | |</p>
<p>3、删除<br>删除会直接将数据的删除版本号更新为当前事务的版本号：</p>
<p>| - | - | - |<br>| id | create_version | delete_version |<br>| - | - | - |<br>| 1 | 1 | 2 |<br>| 1 | 2 | 3 |</p>
<p>4、查询<br>为了避免查到旧数据或已经被其他事务更改过的数据，需要满足：</p>
<ul>
<li>当前事务的版本号需要大于等于创建版本号；</li>
<li>当前事务的版本号需要小于删除的版本号。</li>
</ul>
<h3 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h3><p><code>count(*)</code>用于统计表中的数据量，不同的存储引擎的实现方式有所不同：</p>
<ul>
<li>MyISAM：总行数会被存到磁盘，执行 count(*)时直接返回这个值；</li>
<li>InnoDB：把数据一行一行读出然后累积计数。<blockquote>
<p>上述讨论的 count(*)都是不带查询条件的，不然肯定还要用到索引来过滤数据，MyISAM 也不能这么快返回。</p>
</blockquote>
</li>
</ul>
<p>InnoDB 不把数据总数存起来的原因是，由于 MVCC，即使多个查询是在同一时刻发生的，它们该返回多少行数据也是不确定的，如下图所示：<br><img src="https://tallate.top/imgs/MySQL/MVCC与count星查询.png" alt="MVCC与count星查询" title="MVCC与count星查询"><br>三个会话，最后查出的数据总量是不同的。<br><code>show table status</code>命令输出结果中也有一个<code>TABLE_ROWS</code>字段用于显示该表当前有多少行，但是由于误差比较大，不能直接拿来用。</p>
<p>由于上述方法存在的缺陷，当需要获取数据库表记录总数时，我们一般会自己计数：</p>
<ol>
<li>用缓存系统计数<br>由于更新数据库和更新缓存并不是一个原子操作，可能会导致其他线程读到缓存中的计数但是读不到新数据的情况。</li>
<li>在数据库保存计数<br>由于会话 A 的事务还未提交，对表 C 的技术值的修改对会话 B 就是不可见的，因此可以保证逻辑上是一致的。<br><img src="https://tallate.top/imgs/MySQL/MySQL-使用数据库计数解决统计问题.png" alt="MySQL-使用数据库计数解决统计问题" title="MySQL-使用数据库计数解决统计问题"><br>注意，最好先插入操作记录再更新计数表，因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少了事务之间的锁等待，提升了并发度。</li>
</ol>
<p><code>count(主键ID)</code>、<code>count(*)</code>、<code>count(1)</code>、<code>count(字段)</code>之间的比较：</p>
<ul>
<li><code>count(主键ID)</code>：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</li>
<li><code>count(1)</code>：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。<br>因为不取值、不涉及解析数据行及拷贝字段值的操作，所以<code>count(1)</code>会比<code>count(主键ID)</code>要快。</li>
<li><code>count(字段)</code>：如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；<br>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
<li><code>count(*)</code>：并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code> 肯定不是 null，按行累加。<br>因此<code>count(*)</code>会比其他方式更快。</li>
</ul>
<h3 id="MVCC-小结"><a href="#MVCC-小结" class="headerlink" title="MVCC 小结"></a>MVCC 小结</h3><p>从上边的描述中我们可以看出来，所谓的 MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通的 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大不同就是生成 ReadView 的时机不同：</p>
<ul>
<li>READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView；</li>
<li>而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView 就好了。</li>
</ul>
<p>可重复读的核心是一致性读（consistent read），而事务更新数据时，只能用当前读。如果当前的记录的行锁被其他事务占用，则需要进入锁等待。</p>
<h2 id="事务隔离级别与锁"><a href="#事务隔离级别与锁" class="headerlink" title="事务隔离级别与锁"></a>事务隔离级别与锁</h2><h3 id="可重复读解决幻读问题-间隙锁"><a href="#可重复读解决幻读问题-间隙锁" class="headerlink" title="可重复读解决幻读问题 - 间隙锁"></a>可重复读解决幻读问题 - 间隙锁</h3><p><img src="https://tallate.top/imgs/MySQL/MySQL-当前读例子2.png" alt="MySQL-当前读例子2" title="MySQL-当前读例子2"><br>注意上图中的 Q1、Q2、Q3 语句末尾带了<code>for update</code>，说明均为<strong>当前读</strong>，并会加上写锁，可以看到，Q3 语句看到了 Session B 和 Session C 插入的记录，说明发生了<strong>幻读</strong>的现象。</p>
<ol>
<li>在<strong>可重复读隔离级别</strong>下，普通的查询是<strong>快照读</strong>，是不会看到别的事务插入的数据的。因此，幻读在<strong>当前读</strong>下才会出现。<br>当前读包括写操作和加锁的查询语句（<code>for update</code>）。</li>
<li>Q2 读到了 Session B 更新的数据，这个修改结果是可以被<strong>当前读</strong>看到的，但不能称为幻读，幻读特指新插入的行被其他事务读到了。<blockquote>
<p>当前读的规则是要读到所有已经提交的记录的最新值。</p>
</blockquote>
</li>
</ol>
<h4 id="幻读可能导致的问题及解决办法-间隙锁"><a href="#幻读可能导致的问题及解决办法-间隙锁" class="headerlink" title="幻读可能导致的问题及解决办法 - 间隙锁"></a>幻读可能导致的问题及解决办法 - 间隙锁</h4><p>由于当前读只会对<strong>当前可见</strong>的那些记录进行加锁，因此上述两种情况引入的<strong>新记录</strong>都是锁不上的，锁不上一方面导致可重复读的语义被破坏，因为我要把所有满足条件的记录都锁住，但是事务执行期间却有其他事务引入的满足条件的记录没有被锁住；另一方面是数据一致性问题，如下图所示：<br><img src="https://tallate.top/imgs/MySQL/MySQL-幻读导致的数据不一致问题.png" alt="MySQL-幻读导致的数据不一致问题" title="MySQL-幻读导致的数据不一致问题"><br>执行期间：</p>
<ol>
<li>经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的；</li>
<li>经过 T2 时刻，id=0 这一行变成 (0,5,5)；</li>
<li>经过 T4 时刻，表里面多了一行 (1,5,5)；</li>
<li>其他行跟这个执行序列无关，保持不变。</li>
</ol>
<p>但是 binlog 中的内容：</p>
<ol>
<li>T2 时刻，session B 事务提交，写入了两条语句；</li>
<li>T4 时刻，session C 事务提交，写入了两条语句；</li>
<li>T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。</li>
</ol>
<p>注意 binlog 中 T1 的语句位置变到了最后提交的时候执行。</p>
<p>那么 update 和 insert 引入“新记录”有什么区别呢？为什么只有 insert 这种情况被称为幻读而要单独拿出来讲？其实是因为，就算我们在当前读的时候就算把所有记录都加上锁（极端情况），新插入的记录因为其还未被分配存储空间，所以我们是无法为其加锁的。<br>MySQL 中解决幻读的方式是<strong>间隙锁</strong>，在给对应记录加行锁的同时，MySQL 还会给行两边的间隙加间隙锁，行锁和间隙锁又合称<strong>Next-Key Lock</strong>。<br>不同于行锁，间隙锁之间是不存在冲突关系的，跟间隙锁存在冲突关系的，是“往这个间隙中插入一条记录”这个操作。</p>
<h4 id="间隙锁的生效条件"><a href="#间隙锁的生效条件" class="headerlink" title="间隙锁的生效条件"></a>间隙锁的生效条件</h4><ol>
<li>事务的隔离级别是<strong>可重复读</strong></li>
<li>查找过程中访问到的对象才会加锁<br>查找并非特指<code>select</code>，不管是<code>delete</code>还是<code>update</code>，语句执行的第一步都是先找到对象，因此这些语句都会用到锁。</li>
</ol>
<h4 id="间隙锁存在的问题-死锁"><a href="#间隙锁存在的问题-死锁" class="headerlink" title="间隙锁存在的问题 - 死锁"></a>间隙锁存在的问题 - 死锁</h4><p>间隙锁可能会引起<strong>死锁</strong>，如下图所示：<br><img src="https://tallate.top/imgs/MySQL/MySQL-间隙锁引起的死锁.png" alt="MySQL-间隙锁引起的死锁" title="MySQL-间隙锁引起的死锁">……</p>
<ol>
<li>session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上间隙锁 (5,10)；</li>
<li>session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；</li>
<li>session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。</li>
</ol>
<p>可见，两个 session 进入了互相等待的状态，形成了死锁，可见，死锁会导致同样的语句锁住更大的范围，这其实是影响了并发度的。<br>如果需要避免这种死锁，可以：</p>
<ul>
<li>将隔离级别设置为读提交，但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。</li>
</ul>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="如何正确地删除表中的大量数据"><a href="#如何正确地删除表中的大量数据" class="headerlink" title="如何正确地删除表中的大量数据"></a>如何正确地删除表中的大量数据</h3><p>比如，现在想要删除表中的前 10000 条数据，有以下三种方法：</p>
<pre><code>* 直接执行 delete from T limit 10000;
一个大的删除语句，单个语句占用时间长，锁的时间也比较长，且大事务还会导致主从延迟。
* 在一个连接中循环执行 20 次 delete from T limit 500;
相对第 1、3 两种方式较好。
* 在 20 个连接中同时执行 delete from T limit 500。
这 20 个连接互相之间可能会产生锁冲突。
</code></pre><h3 id="下面的更新为什么没有成功"><a href="#下面的更新为什么没有成功" class="headerlink" title="下面的更新为什么没有成功"></a>下面的更新为什么没有成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);</span><br></pre></td></tr></table></figure>
<p>以下事务可能并不能将所有 c 都置为 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t;</span><br><span class="line">update t set c = 0 where id = c;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p>
<p>比如：<br><img src="https://tallate.top/imgs/MySQL/MySQL-更新丢失.png" alt="MySQL-更新丢失" title="MySQL-更新丢失"><br>其中，事务 A 开始后，在还未对数据进行加锁的情况下，被事务 B 修改了数据，这时，读操作由于<strong>快照读规则</strong>，只能读取到老版本数据，而写操作由于<strong>当前读规则</strong>可以读取到事务 B 写入的数据。<br>现实中，给数据加乐观锁时也有可能会出现这种情况。</p>
<h3 id="MySQL-实现各隔离级别的方式"><a href="#MySQL-实现各隔离级别的方式" class="headerlink" title="MySQL 实现各隔离级别的方式"></a>MySQL 实现各隔离级别的方式</h3><p>读未提交和串行化比较简单，读未提交完全没有做任何事务控制，串行化一个个事务轮流执行。<br>读已提交隔离级别下，事务会在每次执行读操作前创建一个 ReadView，记录当前正在执行中的所有事务的 trx_id 集合——当然包括当前事务，读取数据时有一个回溯版本的过程：若判断数据当前版本在 ReadView 内，则说明该事务正在执行中，不可读，因此回溯到上一个版本，直到找到一个版本不在 ReadView 内。<br>可重复读和读已提交原理类似，只是可重复读是在第一次执行读操作的时候生成 ReadView 的。</p>
<h3 id="MySQL-怎么实现事务的-ACID"><a href="#MySQL-怎么实现事务的-ACID" class="headerlink" title="MySQL 怎么实现事务的 ACID"></a>MySQL 怎么实现事务的 ACID</h3><ol>
<li>一致性<br>数据库通过原子性、隔离性、持久性来保证一致性，也就是说 ACID 四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。</li>
<li>原子性<br>利用 undo log，如果事务需要回滚则使用 undo log 撤销所有已经成功执行的 sql 语句。<blockquote>
<p>对 delete 语句回滚即重新 insert 原语句；<br>对 update 回滚即 update 成旧值；<br>对 insert 语句回滚即 delete 该记录。</p>
</blockquote>
</li>
<li>持久性<br>利用 redo log，事务提交前先将记录写入 redo log，提交时将 redo log 刷盘，宕机时会将 redo log 中的内容恢复到数据库，再根据 undo log 和 bin log 的内容决定应该回滚数据还是提交数据。<br>相对数据页来说，redo log 有以下好处：<ul>
<li>redo log 体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li>redo log 是一直往末尾进行追加，属于顺序 IO。效率显然比随机 IO 来的快。</li>
</ul>
</li>
<li>隔离性<br>利用锁和 MVCC 机制保证隔离性。<h3 id="为什么最好不要有长事务"><a href="#为什么最好不要有长事务" class="headerlink" title="为什么最好不要有长事务"></a>为什么最好不要有长事务</h3>一般当系统判断当没有事务再使用到某些回滚日志时，这些回滚日志会被删除。那么系统怎么判断一个回滚日志不会再被使用到呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 </li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/a6d48c65.html" rel="next" title="MySQL3_2索引">
                <i class="fa fa-chevron-left"></i> MySQL3_2索引
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/937fe6d5.html" rel="prev" title="MySQL3_1日志">
                MySQL3_1日志 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">159</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务语法"><span class="nav-number">1.</span> <span class="nav-text">事务语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的属性"><span class="nav-number">2.</span> <span class="nav-text">事务的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性-Atomic"><span class="nav-number">2.1.</span> <span class="nav-text">原子性(Atomic)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性-Consistency"><span class="nav-number">2.2.</span> <span class="nav-text">一致性(Consistency)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离性-Isolation"><span class="nav-number">2.3.</span> <span class="nav-text">隔离性(Isolation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久性-Durability"><span class="nav-number">2.4.</span> <span class="nav-text">持久性(Durability)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的状态"><span class="nav-number">3.</span> <span class="nav-text">事务的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务隔离级别"><span class="nav-number">4.</span> <span class="nav-text">事务隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事务并发执行可能遇到的问题"><span class="nav-number">4.1.</span> <span class="nav-text">事务并发执行可能遇到的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置隔离级别"><span class="nav-number">4.2.</span> <span class="nav-text">设置隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离级别与-MVCC、锁之间的关系"><span class="nav-number">4.3.</span> <span class="nav-text">隔离级别与 MVCC、锁之间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务隔离级别与MVCC"><span class="nav-number">5.</span> <span class="nav-text">事务隔离级别与MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log"><span class="nav-number">5.1.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-View-一致性读视图"><span class="nav-number">5.2.</span> <span class="nav-text">Read View (一致性读视图)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#READ-COMMITTED-每次读取数据前生成一个-ReadView"><span class="nav-number">5.3.</span> <span class="nav-text">READ COMMITTED - 每次读取数据前生成一个 ReadView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#REPEATABLE-READ-在第一次读取数据时生成一个-ReadView"><span class="nav-number">5.4.</span> <span class="nav-text">REPEATABLE READ - 在第一次读取数据时生成一个 ReadView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新"><span class="nav-number">5.5.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-number">5.6.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count"><span class="nav-number">5.7.</span> <span class="nav-text">count(*)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC-小结"><span class="nav-number">5.8.</span> <span class="nav-text">MVCC 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务隔离级别与锁"><span class="nav-number">6.</span> <span class="nav-text">事务隔离级别与锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可重复读解决幻读问题-间隙锁"><span class="nav-number">6.1.</span> <span class="nav-text">可重复读解决幻读问题 - 间隙锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#幻读可能导致的问题及解决办法-间隙锁"><span class="nav-number">6.1.1.</span> <span class="nav-text">幻读可能导致的问题及解决办法 - 间隙锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#间隙锁的生效条件"><span class="nav-number">6.1.2.</span> <span class="nav-text">间隙锁的生效条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#间隙锁存在的问题-死锁"><span class="nav-number">6.1.3.</span> <span class="nav-text">间隙锁存在的问题 - 死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">7.</span> <span class="nav-text">QA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何正确地删除表中的大量数据"><span class="nav-number">7.1.</span> <span class="nav-text">如何正确地删除表中的大量数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下面的更新为什么没有成功"><span class="nav-number">7.2.</span> <span class="nav-text">下面的更新为什么没有成功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-实现各隔离级别的方式"><span class="nav-number">7.3.</span> <span class="nav-text">MySQL 实现各隔离级别的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-怎么实现事务的-ACID"><span class="nav-number">7.4.</span> <span class="nav-text">MySQL 怎么实现事务的 ACID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么最好不要有长事务"><span class="nav-number">7.5.</span> <span class="nav-text">为什么最好不要有长事务</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
