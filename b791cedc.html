<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="微服务,">










<meta name="description" content="微服务是一种架构风格，需要注意的是它并不能与 Docker、Spring Cloud 划等号，只是这些技术栈能更好地实现微服务，这篇文档中我希望总结一下实现微服务最常用的技术。 ¶微服务基本概念 ¶定义 ¶为什么要使用微服务 ¶架构与组织 ¶中台战略与微服务 ¶微服务架构风格 ¶微服务架构 ¶服务发现 - Eureka ¶Eureka 的目标 原来：负载均衡器会根据配好的 IP 和主机名来进行负载">
<meta name="keywords" content="微服务">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务核心技术总结">
<meta property="og:url" content="https://tallate.github.io/b791cedc.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="微服务是一种架构风格，需要注意的是它并不能与 Docker、Spring Cloud 划等号，只是这些技术栈能更好地实现微服务，这篇文档中我希望总结一下实现微服务最常用的技术。 ¶微服务基本概念 ¶定义 ¶为什么要使用微服务 ¶架构与组织 ¶中台战略与微服务 ¶微服务架构风格 ¶微服务架构 ¶服务发现 - Eureka ¶Eureka 的目标 原来：负载均衡器会根据配好的 IP 和主机名来进行负载">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E5%AE%9E%E4%BE%8B%E7%8A%B6%E6%80%81%E6%9C%BA.png">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Zuul%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%9A%94%E7%A6%BB%E5%B1%82%E6%AC%A1.png">
<meta property="og:image" content="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%E9%9A%94%E7%A6%BB.png">
<meta property="og:updated_time" content="2020-09-28T13:15:08.476Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微服务核心技术总结">
<meta name="twitter:description" content="微服务是一种架构风格，需要注意的是它并不能与 Docker、Spring Cloud 划等号，只是这些技术栈能更好地实现微服务，这篇文档中我希望总结一下实现微服务最常用的技术。 ¶微服务基本概念 ¶定义 ¶为什么要使用微服务 ¶架构与组织 ¶中台战略与微服务 ¶微服务架构风格 ¶微服务架构 ¶服务发现 - Eureka ¶Eureka 的目标 原来：负载均衡器会根据配好的 IP 和主机名来进行负载">
<meta name="twitter:image" content="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/b791cedc.html">







  <title>微服务核心技术总结 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b791cedc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">微服务核心技术总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术点总结/" itemprop="url" rel="index">
                    <span itemprop="name">技术点总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>微服务是一种架构风格，需要注意的是它并不能与 Docker、Spring Cloud 划等号，只是这些技术栈能更好地实现微服务，这篇文档中我希望总结一下实现微服务最常用的技术。</p>
<h2 id="微服务基本概念"><a class="header-anchor" href="#微服务基本概念">¶</a>微服务基本概念</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<h3 id="为什么要使用微服务"><a class="header-anchor" href="#为什么要使用微服务">¶</a>为什么要使用微服务</h3>
<h3 id="架构与组织"><a class="header-anchor" href="#架构与组织">¶</a>架构与组织</h3>
<h3 id="中台战略与微服务"><a class="header-anchor" href="#中台战略与微服务">¶</a>中台战略与微服务</h3>
<h3 id="微服务架构风格"><a class="header-anchor" href="#微服务架构风格">¶</a>微服务架构风格</h3>
<h3 id="微服务架构"><a class="header-anchor" href="#微服务架构">¶</a>微服务架构</h3>
<h2 id="服务发现-eureka"><a class="header-anchor" href="#服务发现-eureka">¶</a>服务发现 - Eureka</h2>
<h3 id="eureka-的目标"><a class="header-anchor" href="#eureka-的目标">¶</a>Eureka 的目标</h3>
<p>原来：负载均衡器会根据配好的 IP 和主机名来进行负载均衡，但是对 AWS cloud 这样体量的系统来说，因为服务实例宕机恢复十分频繁，所以负载均衡器还会有一个更复杂的注册 / 注销服务的机制。<br>
现在：Eureka 在中间层提供一种负载均衡的可能。</p>
<h3 id="eureka-vs-zookeeper"><a class="header-anchor" href="#eureka-vs-zookeeper">¶</a>Eureka VS ZooKeeper</h3>
<ul>
<li>Eureka 能提供 REST 接口来动态调整配置、renewals、expiration、cancel 等；</li>
<li>Eureka 倾向于高可用，而不是 ZooKeeper 的高一致性。</li>
<li>Eureka 可以集成到应用中，ZooKeeper 只能作为一个外部组件提供服务，这会增加复杂性、增加系统崩溃的几率。</li>
</ul>
<h3 id="组成部分"><a class="header-anchor" href="#组成部分">¶</a>组成部分</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Eureka组件结构" title="Eureka组件结构"></p>
<ul>
<li>负载均衡：Eureka Client 提供最简单的轮询<strong>负载均衡</strong>策略，可以封装 Eureka 并根据更多的因素（流量、资源使用、异常发生频次等）来提供一种更好的弹性伸缩特性。</li>
<li>分区：每个 Region 有一个 Eureka 集群用于处理该区域服务失败的情况，各 Region 之间是不会互相通信的。</li>
<li>服务注册到 Eureka Server 后每 30 秒发送一次<strong>心跳（heartbeats）<strong>来刷新</strong>租约（lease）</strong>，如果网络出现分区或者 Eureka 宕机了，这种心跳自然会停止，如果达到了<strong>Renews threshold</strong>（即 Server 期望在每分钟中收到的心跳次数，需要考虑是否禁用服务器的自注册、Server/Client 数量等，暂时取默认值 85%就好），Eureka Server 就会将其从服务注册表中移除。</li>
<li>服务注册信息会自动同步到整个 Eureka Server 集群，这也意味着它们是对等的 P2P 集群。</li>
<li>集成到业务服务中的 Eureka Client 可以查询服务注册信息（默认每 30 秒一次）来定位服务及进行远程调用。</li>
</ul>
<h3 id="服务状态机"><a class="header-anchor" href="#服务状态机">¶</a>服务状态机</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E5%AE%9E%E4%BE%8B%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="Eureka实例状态机" title="Eureka实例状态机"></p>
<ul>
<li>STARTING：启动中的状态，应用可以在这个阶段做一些初始化工作</li>
<li>UP：可以正常进行通信；</li>
<li>DOWN：心跳停了，一般是宕机了或者网络出现了分区</li>
<li>OUT_OF_SERVICE：因为某些特殊原因无法提供服务，比如 Elasticsearch 因为没有达到最小可用分片数，或者由于蓝绿发布的需要，新版本如果发布后有问题可以直接将实例状态置为 OUT_OF_SERVICE 来达到回滚的目的。</li>
<li>UNKNOWN：WTF？</li>
</ul>
<h3 id="client-与-server-间的交互"><a class="header-anchor" href="#client-与-server-间的交互">¶</a>Client 与 Server 间的交互</h3>
<h4 id="register"><a class="header-anchor" href="#register">¶</a>Register</h4>
<p>Eureka Client 将信息注册到 Eureka Server，注册过程发生在第一次心跳时（在 30 秒后）。</p>
<h4 id="unregister"><a class="header-anchor" href="#unregister">¶</a>Unregister</h4>
<p>正常情况下，Client 必须显式调用 Unregister 来释放自己的注册信息，除非是由于&quot;unclean termination&quot;而导致心跳丢失超过 3 次。</p>
<h4 id="renew"><a class="header-anchor" href="#renew">¶</a>Renew</h4>
<p>客户端每30秒通过发送一次心跳（heartbeats）来续约（renewal），心跳告知Eureka Server本实例仍然存活，如果Server在90秒内没有收到续约请求，它将从服务注册表中移除该实例。</p>
<h4 id="fetch-registry"><a class="header-anchor" href="#fetch-registry">¶</a>Fetch Registry</h4>
<p>Eureka clients fetches the registry information from the server and csort_bufferhes it locally. After that, the clients use that information to find other services. This information is updated periodically (every 30 seconds) by getting the delta updates between the last fetch cycle and the current one. The delta information is held longer (for about 3 mins) in the server, hence the delta fetches may return the same instances again. The Eureka client automatically handles the duplicate information.</p>
<p>After getting the deltas, Eureka client reconciles the information with the server by comparing the instance counts returned by the server and if the information does not match for some reason, the whole registry information is fetched again. Eureka server caches the compressed payload of the deltas, whole registry and also per application as well as the uncompressed information of the same. The payload also supports both JSON/XML formats. Eureka client gets the information in compressed JSON format using jersey apache client.</p>
<h4 id="cancel"><a class="header-anchor" href="#cancel">¶</a>Cancel</h4>
<p>Eureka client sends a cancel request to Eureka server on shutdown. This removes the instance from the server’s instance registry thereby effectively taking the instance out of traffic.</p>
<p>This is done when the Eureka client shuts down and the application should make sure to call the following during its shutdown.<br>
DiscoveryManager.getInstance().shutdownComponent()</p>
<h4 id="time-lag"><a class="header-anchor" href="#time-lag">¶</a>Time Lag</h4>
<p>All operations from Eureka client may take some time to reflect in the Eureka servers and subsequently in other Eureka clients. This is because of the caching of the payload on the eureka server which is refreshed periodically to reflect new information. Eureka clients also fetch deltas periodically. Hence, it may take up to 2 mins for changes to propagate to all Eureka clients.</p>
<h4 id="communication-mechanism"><a class="header-anchor" href="#communication-mechanism">¶</a>Communication mechanism</h4>
<p>Eureka Client默认使用Jersey发送基于Jackson封装的JSON数据包给Eureka Server。</p>
<h4 id="通信协议"><a class="header-anchor" href="#通信协议">¶</a>通信协议</h4>
<p>Eureka 不限制通信协议，Thrift、HTTP(S)等均可。</p>
<h3 id="高可用"><a class="header-anchor" href="#高可用">¶</a>高可用</h3>
<p>Eureka Client 的高可用设计：</p>
<ul>
<li>Client 中有<strong>服务注册表的缓存</strong>，即使所有 Server 都挂掉了，Client 还是能继续工作。</li>
<li>刚开始，Eureka Client 会尝试与同一 zone（可视为同一局域网）中的 Eureka Server 交互，如果交互出现问题或同一 zone 中没有可用的 Eureka Server，则它将转向其他 zone。</li>
</ul>
<p>Eureka Server 的高可用设计：</p>
<ul>
<li>启动 Server 时<strong>从邻居节点获取注册信息</strong>，一个不行换另一个，直到获取成功，如果从邻居节点均无法获取到注册信息，则它会等待几分钟（默认 5 分钟）让 Client 注册它们的信息<br>
Server 之间获取服务注册信息的机制和 Client 从 Server 获取的一样。<br>
获取成功后，Server 会设置<code>Renewal Threshold</code>并开始接收 Client 的心跳；</li>
<li>保护模式：如果<code>Renews(last min)</code>（上一分钟内收到的心跳次数）达到了<code>Renews threshold</code>（Server 期望在每分钟中收到的心跳次数，一般是 3），或者过去 15 分钟内的统计数据小于<code>eureka.server.renewalPercentThreshold</code>（renews / renews threshold 的比值，默认为 0.85，当在 15 分钟内微服务心跳数低于 85%，则 Server 会进入自我保护状态，在这种情况下 Server 不会删除注册信息），则进入<strong>保护模式</strong>，自我保护状态其实是为了防止突发网络不稳定或断电时微服务心跳数剧减，导致微服务注册信息被大量删除的情况。<br>
在保护模式下，Client 可能从 Server 得到已经不可用的 IP（服务器已不存在或因某些原因无法响应），因此 Client 必须保证这种情况下的弹性高可用，比如快速地超时并重试其他服务器。</li>
<li>退出保护模式：在保护模式下，Eureka Server 会停止移除服务注册信息，直到满足如下条件中的任意之一：
<ol>
<li>心跳<code>Renews</code>达到了<code>Renews threshold</code>；</li>
<li>保护模式被禁用，设置<code>eureka.server.enableSelfPreservation=false</code>。</li>
</ol>
</li>
<li>孤儿 Server：当发生网络分区，一些 Eureka Server 可能会成为<code>orphaned server</code>，一些 Client 会注册到这些 Server 上，导致一些 Client 能看到这些注册信息而其他的一些则不能。<br>
当网络恢复后，Server 的 P2P 集群能正常地交互，注册信息会被自动同步到所有 Server 上。</li>
</ul>
<h3 id="异常情况"><a class="header-anchor" href="#异常情况">¶</a>异常情况</h3>
<p>比如在测试环境中出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>在生产上可以开自注册，部署两个 server</li>
<li>在本机器上测试的时候，可以把比值调低，比如 0.49</li>
<li>或者简单粗暴把自我保护模式关闭：eureka.server.enableSelfPreservation=false</li>
</ul>
<h3 id="eureka-配置"><a class="header-anchor" href="#eureka-配置">¶</a>Eureka 配置</h3>
<p>配置：<br>
<a href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka" target="_blank" rel="noopener">Configuring Eureka</a><br>
Eureka Server 开放的 REST 接口提供动态配置功能：<br>
<a href="https://github.com/Netflix/eureka/wiki/Eureka-REST-operations" target="_blank" rel="noopener">Eureka REST operations</a></p>
<h4 id="添加自定义元数据"><a class="header-anchor" href="#添加自定义元数据">¶</a>添加自定义元数据</h4>
<p>静态设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.metadata.mykey=myvalue</span><br></pre></td></tr></table></figure>
<p>设置后，相当于将<code>mykey:myvalue</code>添加到 eureka 的<code>metadata map</code>中。<br>
动态设置：<br>
需要提供一个自定义的</p>
<p>获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myValue = instanceInfo.getMetadata().get(&quot;myKey&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<h4 id="原生客户端的执行过程"><a class="header-anchor" href="#原生客户端的执行过程">¶</a>原生客户端的执行过程</h4>
<p>EurekaClient</p>
<h4 id="通过-di-依赖注入-使用-eurekaclient"><a class="header-anchor" href="#通过-di-依赖注入-使用-eurekaclient">¶</a>通过 DI（依赖注入）使用 EurekaClient</h4>
<p>ExampleEurekaGovernatedService</p>
<h4 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h4>
<p>DefaultEurekaClientConfig extends EurekaClientConfig<br>
EurekaServerConfig extends DefaultEurekaServerConfig<br>
CloudInstanceConfig extends PropertiesInstanceConfig<br>
MyDataCenterInstanceConfig extends PropertiesInstanceConfig</p>
<p>To dynamically do this, you will need to first provide your own custom implementation of the <code>EurekaInstanceConfig</code> interface. You can then overload the public Map&lt;String, String&gt; getMetadataMap() method to return a metadata map that contains the desired metadata values. See <code>PropertiesInstanceConfig</code> for an example implementation that provides the configuration based system above.</p>
<h2 id="网关-zuul"><a class="header-anchor" href="#网关-zuul">¶</a>网关 - Zuul</h2>
<h3 id="filter"><a class="header-anchor" href="#filter">¶</a>Filter</h3>
<p><img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Zuul%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Zuul组件结构" title="Zuul组件结构"><br>
Zuul 基于 Netty 开发，使用 filters 包含了核心业务逻辑，Filter 是使用 Groovy 写的，主要是为了提供动态编译加载的能力，filters 主要包含了三类：</p>
<ul>
<li>Inbound Filters execute before routing to the origin and can be used for things like authentication, dynamic routing, rate limiting, DDoS protection, metrics and decorating the request.</li>
<li>Endpoint Filters can be used to return static responses, otherwise the built-in <code>ProxyEndpoint</code> filter will route the request to the origin.</li>
<li>Outbound Filters execute after getting the response from the origin and can be used for metrics, decorating the response to the user or adding custom headers.</li>
<li>Async<br>
Filter 可以被同步执行或异步执行。<br>
如果 Filter 没有做太重的工作，可以通过继承<code>HttpInboundSyncFilter</code>或<code>HttpOutboundSyncFilter</code>来实现一种同步 Filter，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>Routes.groovy</code>；<br>
反之，如果需要从其他服务、缓存获取数据，或做一些复杂的计算工作，则最好继承<code>HttpInboundFilter</code>或<code>HttpOutboundFilter</code>，例子见<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul 源码</a>中的<code>SampleServiceFilter.groovy</code>。</li>
</ul>
<h4 id="filter属性"><a class="header-anchor" href="#filter属性">¶</a>Filter属性</h4>
<p>Type: most often defines the stage during the routing flow when the Filter will be applied (although it can be any custom string)<br>
Async: define if the filter is sync or async, generally meaning do you need to make an external call or just doing work on-box<br>
Execution Order: applied within the Type, defines the order of execution across multiple Filters<br>
Criteria: the conditions required in order for the Filter to be executed<br>
Action: the action to be executed if the Criteria is met</p>
<h4 id="其他的一些例子"><a class="header-anchor" href="#其他的一些例子">¶</a>其他的一些例子</h4>
<p>这些例子是<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">zuul-sample</a>中的代码。</p>
<ul>
<li>DebugRequest - look for a query param to add extra debug logging for a request</li>
<li>Healthcheck - simple static endpoint filter that returns 200, if everything is bootstrapped correctly</li>
<li>ZuulResponseFilter - add informational headers to provide extra details on routing, request execution, status and error cause</li>
<li>GZipResponseFilter - can be enabled to gzip outbound responses</li>
<li>SurgicalDebugFilter - can be enabled to route specific requests to different hosts for debugging</li>
</ul>
<h3 id="缓存请求体"><a class="header-anchor" href="#缓存请求体">¶</a>缓存请求体</h3>
<p>默认情况下 Zuul 不会缓存请求体，因为 Filter 一般用到请求头就够了，但是如果需要在 inbound 中用到请求头或在 outbound 中用到响应头，则需要明确指定 Zuul 缓存，可以重写 Filter 的<code>needsBodyBuffered()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">boolean needsBodyBuffered(HttpResponseMessage input) &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络协议"><a class="header-anchor" href="#网络协议">¶</a>网络协议</h3>
<p>Zuul 支持修改暴露服务时使用的协议，使用方法见 sample 项目中的<code>SampleServerStartup</code>。</p>
<h3 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h3>
<p><a href="https://github.com/Netflix/zuul/wiki/Core-Features" target="_blank" rel="noopener">Core Features</a></p>
<h3 id="push-messaging"><a class="header-anchor" href="#push-messaging">¶</a>Push Messaging</h3>
<p>Push Messaging 机制可以支持从 Server 端推送消息到 Client 端，支持两种协议：<code>WebSockets</code> 和 <code>Server Sent Events (SSE)</code>。<br>
<a href="https://github.com/Netflix/zuul/wiki/Push-Messaging" target="_blank" rel="noopener">Push Messaging</a><br>
TODO</p>
<h2 id="负载均衡-ribbon"><a class="header-anchor" href="#负载均衡-ribbon">¶</a>负载均衡 - Ribbon</h2>
<h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3>
<p>原生 API 如何使用见：<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started" target="_blank" rel="noopener">Netflix / ribbon - Getting Started</a><br>
如果是搭配 Spring Boot，可以参考 Spring Could 文档。</p>
<h3 id="组件结构及实现"><a class="header-anchor" href="#组件结构及实现">¶</a>组件结构及实现</h3>
<h4 id="rule"><a class="header-anchor" href="#rule">¶</a>Rule</h4>
<p>a logic component to determine which server to return from a list</p>
<ul>
<li>RoundRobinRule<br>
简单的轮询策略</li>
<li>AvailabilityFilteringRule<br>
这个 Rule 会跳过那些疑似“电路跳闸”或并发连接数已经很高的服务器。<br>
比如客户端的最后 3 次连接失败，客户端会认为该服务实例已经出现了类似“电路跳闸”的问题而导致无法提供服务，于是在接下来的 30 秒内均保持这种状态，如果之后还是连接失败，这个等待时间会指数增长（1min、2min、4min…）。</li>
<li>WeightedResponseTimeRule<br>
每个 Server 会根据其平均响应时间计算出一个权重，响应时间越长、比重越小，该 Rule 选择 Server 时会根据该权重来计算概率。</li>
</ul>
<h4 id="ping"><a class="header-anchor" href="#ping">¶</a>Ping</h4>
<p>a component running in background to ensure liveness of servers</p>
<h4 id="serverlist"><a class="header-anchor" href="#serverlist">¶</a>ServerList</h4>
<p>this can be static or dynamic. If it is dynamic (as used by <code>DynamicServerListLoadBalancer</code>), a background thread will refresh and filter the list at certain interval</p>
<ul>
<li>静态的 Server 列表<br>
可以在程序里写一个静态列表，将该列表设置到<code>BaseLoadBalancer.setServerList()</code>中。</li>
<li>ConfigurationBasedServerList<br>
默认的 ServerList 实现，可以通过 <code>Archaius ConfigurationManager</code>来设置 Server 列表。</li>
<li>DiscoveryEnabledNIWSServerList<br>
可以通过 Eureka Client 获取服务器列表，服务器集群必须通过 VipAddress 来定义：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="serverlistfilter"><a class="header-anchor" href="#serverlistfilter">¶</a>ServerListFilter</h4>
<p>ServerListFilter 是<code>DynamicServerListLoadBalancer</code>的组件，用于过滤从<code>ServerList</code>返回的服务器列表，现在有两种实现：</p>
<ul>
<li>
<p>ZoneAffinityServerListFilter<br>
过滤掉不在同一个 zone 内的服务器，除非 zone 内没有可用的服务器，这个 Filter 可以通过设置如下属性来启用（假设客户端名为 myclient、客户端的属性空间为 ribbon）：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myclient.ribbon.EnableZoneAffinity=true</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ServerListSubsetFilter<br>
可以保证客户端只能看到<code>ServerList</code>返回的全体服务器的一个固定子集，如果有服务器可用性较弱，则可以定期用新服务器替换老服务器。可以通过设置以下属性启用该Filter：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br><span class="line">myClient.ribbon.NIWSServerListFilterClassName=com.netflix.loadbalancer.ServerListSubsetFilter</span><br><span class="line"># only show client 5 servers. default is 20.</span><br><span class="line">myClient.ribbon.ServerListSubsetFilter.size=5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码-v2"><a class="header-anchor" href="#源码-v2">¶</a>源码</h3>
<p>com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateListOfServers<br>
com.netflix.loadbalancer.ServerList#getUpdatedListOfServers<br>
com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery<br>
TODO</p>
<h2 id="hystrix"><a class="header-anchor" href="#hystrix">¶</a>Hystrix</h2>
<p><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">wiki</a></p>
<h2 id="turbine"><a class="header-anchor" href="#turbine">¶</a>Turbine</h2>
<p><a href="https://github.com/Netflix/Turbine/wiki" target="_blank" rel="noopener">wiki</a></p>
<h2 id="微服务基础设施-配置中心"><a class="header-anchor" href="#微服务基础设施-配置中心">¶</a>微服务基础设施 - 配置中心</h2>
<p>在设计微服务架构的时候常会提到一个<strong>无状态</strong>的概念，我们要求每个服务都是无状态的，因此可以做到一次编译到处运行，这也是<strong>云原生</strong>的基本要求——云环境下服务的实例集群可以弹性伸缩，</p>
<h3 id="配置分类"><a class="header-anchor" href="#配置分类">¶</a>配置分类</h3>
<p>应用服务中的配置主要分为静态配置和动态配置两类：<strong>静态配置</strong>主要和应用所处的环境有关，另外与其他服务器连接所需的用户名、密码等也需要在应用运行伊始便准备好，</p>
<ul>
<li>
<p>静态配置-环境相关：</p>
</li>
<li>
<p>静态配置-安全配置：</p>
</li>
<li>
<p>动态配置-应用配置：</p>
</li>
<li>
<p>动态配置-</p>
</li>
</ul>
<h3 id="apollo"><a class="header-anchor" href="#apollo">¶</a>Apollo</h3>
<h2 id="微服务基础设施-rpc"><a class="header-anchor" href="#微服务基础设施-rpc">¶</a>微服务基础设施 - RPC</h2>
<h2 id="微服务基础设施-后台框架"><a class="header-anchor" href="#微服务基础设施-后台框架">¶</a>微服务基础设施 - 后台框架</h2>
<h2 id="微服务基础设施-监控"><a class="header-anchor" href="#微服务基础设施-监控">¶</a>微服务基础设施 - 监控</h2>
<h2 id="微服务基础设施-服务-sla-service-level-agreement"><a class="header-anchor" href="#微服务基础设施-服务-sla-service-level-agreement">¶</a>微服务基础设施 - 服务 SLA（Service Level Agreement）</h2>
<p>熔断、限流、降级</p>
<h2 id="微服务基础设施-持续交付-continuous-delivery-简称-cd"><a class="header-anchor" href="#微服务基础设施-持续交付-continuous-delivery-简称-cd">¶</a>微服务基础设施 - 持续交付（Continuous delivery，简称 CD）</h2>
<h2 id="虚拟化"><a class="header-anchor" href="#虚拟化">¶</a>虚拟化</h2>
<p>虚拟化技术将一台服务器虚拟出多个虚拟机来提供服务。<br>
虚拟化技术包括计算虚拟化（服务器虚拟化）、存储虚拟化、网络虚拟化等。<br>
在实际讲解虚拟化之前，我们需要先解释一下隔离技术，在隔离的基础上我们才能任意粒度、自由地分配资源。</p>
<h3 id="隔离的作用"><a class="header-anchor" href="#隔离的作用">¶</a>隔离的作用</h3>
<ul>
<li>实现更细粒度的资源管理，比如将一个物理 CPU 的计算能力分给多台云主机，再将这台云主机卖给多个人。</li>
<li>控制故障的影响范围，一个 Tomcat 中可以运行多个 Web 服务器，一台 Web 服务器崩溃并不会令其他服务器一并崩溃。</li>
</ul>
<h3 id="隔离的分类"><a class="header-anchor" href="#隔离的分类">¶</a>隔离的分类</h3>
<p>广义的隔离技术包括如下几类</p>
<ul>
<li>硬件：虚拟机，如 KVM、Xen</li>
<li>操作系统：容器，如 LXC、Docker</li>
<li>Web 服务器：如 Servlet 容器</li>
<li>依赖版本：虚拟环境</li>
<li>运行环境：语言虚拟机，如JVM</li>
<li>语言：DSL</li>
</ul>
<p>前两种隔离是<strong>虚拟化技术</strong>的基础，主要用于物理资源的池化，进而弹性地分配给用户。<br>
作为一个例子，下面是一个运行时服务器中各抽象层次所采取的隔离技术的示意图：<br>
<img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%9A%94%E7%A6%BB%E5%B1%82%E6%AC%A1.png" alt="隔离层次" title="隔离层次"></p>
<p>上述隔离技术探讨的是单机环境下的资源分配，在微服务中聚焦的是如何提供更好的服务，因此可以在以下几个方向实施<strong>数据隔离</strong>：</p>
<ul>
<li>应用数据隔离<br>
多个业务服务器使用不同的数据库服务器，虽然有隔离故障、提高数据安全等好处，但是也引入了分布式事务的问题。</li>
<li>租户隔离<br>
提供统一的云服务，但是对不同的用户分组单独使用一些服务实例来提供服务，这样这些服务实例挂掉了也只会影响对应分组的用户，这样的用户分组称为<strong>租户</strong>。<br>
对于单独的一个租户，有独立服务独立数据库、共享服务独立数据库和共享服务共享数据库三种方式，可以根据成本和安全性来考虑选择哪种方案。</li>
</ul>
<p>对于业务服务器来说，更重要的是业务层面上的隔离：</p>
<ul>
<li>业务层<br>
平台与业务，业务与业务。</li>
<li>Provider，即服务提供者<br>
如订单服务和库存服务，使用上面提到的虚拟化来实现隔离，如果；</li>
<li>Consumer，即服务消费者<br>
下游服务调用多个上游服务（upstream）的时候，如果不对上游服务做服务隔离，一个服务出现问题，就会导致下游服务不可用，这种情况下，可选的隔离方案可以是给每个上游服务都准备一个线程池，称为<strong>线程池隔离</strong>：<br>
<img src="http://47.88.24.11/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%E9%9A%94%E7%A6%BB.png" alt="服务消费者端隔离" title="服务消费者端隔离"><br>
这种情况下，就算其中一个服务不可用导致线程池被迅速占满，下游服务仍可以根据预定义的降级方案来忽略这个服务。<br>
另一种可行的隔离方式是<strong>信号量隔离</strong>，常见的框架包括 Hytrix、Sentinel、以及 Resilience4j。</li>
</ul>
<h3 id="网络虚拟化"><a class="header-anchor" href="#网络虚拟化">¶</a>网络虚拟化</h3>
<p>我们暴露服务时使用的 IP 一般不是业务服务器网卡的真实 IP，而是另外配置的一个虚拟 IP，请求先被打到该 IP，然后由 LVS 等负载均衡技术来找到一个真实 IP。</p>
<p><strong>虚拟网卡</strong>通过实现一个字符设备来支持物理层，从而使应用层和物理层就通过这个字符设备联系起来，从这个字符设备读出来的就是虚拟网卡发往物理层的字节流，写入字符设备的数据作为字节流被虚拟网卡接收。<br>
虚拟网卡可以像网卡一样进行配置，常见的虚拟网卡有<strong>TUN/TAP</strong>和<strong>VEth</strong>。<br>
**虚拟网桥（Bridge）**也是一种虚拟设备，用于将多块网卡（包括虚拟网卡）连接起来。<br>
值得注意的是， Linux 中虚拟网桥是通用网络设备抽象的一种，能够绑定 IP 地址。因此在把网卡接入到网桥上后，网卡原来绑定的 IP 会失效，如果还要像原来那样收发数据，需要把该 IP 绑定到网桥上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加网桥br0</span><br><span class="line">ip link add br0 type bridge</span><br><span class="line"># 把网卡接入网桥，在把eth0和eth1接入到br0后，两个网卡就可以进行通信了。</span><br><span class="line">ip link set eth0 master br0</span><br><span class="line">ip link set eth1 master br0</span><br><span class="line"># 为网桥绑定ip</span><br><span class="line">ip addr add xx.xx.xx.xx/xx dev br0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">        inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:17ff:fe6b:bb81 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:17:6b:bb:81 txqueuelen 0 (Ethernet)</span><br><span class="line">        RX packets 0 bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">        TX packets 151 bytes 16620 (16.6 KB)</span><br><span class="line">        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br><span class="line"></span><br><span class="line">veth780318a: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">        inet6 fe80::2c08:2dff:fea1:b996 prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 2e:08:2d:a1:b9:96 txqueuelen 0 (Ethernet)</span><br><span class="line">        RX packets 0 bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">        TX packets 227 bytes 24338 (24.3 KB)</span><br><span class="line">        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br></pre></td></tr></table></figure>
<p>由 Docker Daemon 创建的虚拟网卡 docker0 其实就是一个网桥，可以使用 ethtool 查看设备类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -i docker0</span><br><span class="line"># 输出</span><br><span class="line">driver: bridge</span><br><span class="line">version: 2.3</span><br><span class="line">firmware-version: N/A</span><br><span class="line">expansion-rom-version: </span><br><span class="line">bus-info: N/A</span><br><span class="line">supports-statistics: no</span><br><span class="line">supports-test: no</span><br><span class="line">supports-eeprom-access: no</span><br><span class="line">supports-register-dump: no</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure>
<p>根据官方文档，Docker 通过 docker0 网桥在内核层连通了其他的物理或虚拟网卡，从而将所有容器和宿主都放到同一个物理网络下。<br>
veth780318a 是一个 VEth 设备，在容器启动后动态创建。每次启动一个容器的时候，Docker 会新建一对 VETH 设备，其中一个插在 docker0 上，另一个插在该容器里，然后从可用的地址段中选择一个空闲的 IP 地址分配给容器的 VEth，使用 docker0 的 IP 作为默认网关，从而实现宿主机和容器的双向数据通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -S veth780318a</span><br><span class="line"># 输出</span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 8</span><br><span class="line"></span><br><span class="line">$ ip link</span><br><span class="line"># 输出</span><br><span class="line">9: veth780318a@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 2e:08:2d:a1:b9:96 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>
<p>上边的 veth780318a@if8 的 peer_ifindex 为 9，和其对应的 VEth 设备的 peer_ifindex 为 8。</p>
<p>接下来可以进入容器查看是否存在对应的 peer_ifindex 为 9 的虚拟网卡（下面的是教程中的执行效果，我并没有执行成功，因为普通的容器镜像里面一般没有安装常用的网络工具）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@4c04df175784:/# ip route show</span><br><span class="line">default via 172.17.42.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.1</span><br><span class="line"></span><br><span class="line"># 从这里可以看出veth741a889的“伙伴”确实是在容器中，被重命名为eth0作为容器的网卡，并绑定了ip172.17.0.5，网关为网桥的ip172.17.42.1。</span><br><span class="line">root@4c04df175784:/# ifconfig</span><br><span class="line">eth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:05</span><br><span class="line">          inet addr:172.17.0.5 Bcast:0.0.0.0 Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:5/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:648 (648.0 B) TX bytes:648 (648.0 B)</span><br><span class="line"></span><br><span class="line">root@4c04df175784:/# ethtool -S eth0</span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 24</span><br><span class="line"></span><br><span class="line">root@4c04df175784:/# ethtool -i eth0</span><br><span class="line">driver: veth</span><br><span class="line">version: 1.0</span><br><span class="line">firmware-version:</span><br><span class="line">bus-info:</span><br><span class="line">supports-statistics: yes</span><br><span class="line">supports-test: no</span><br><span class="line">supports-eeprom-access: no</span><br><span class="line">supports-register-dump: no</span><br><span class="line">supports-priv-flags: no</span><br></pre></td></tr></table></figure>
<h4 id="tun-tap-tunnel"><a class="header-anchor" href="#tun-tap-tunnel">¶</a>TUN/TAP(Tunnel)</h4>
<p>TUN 工作在 OSI 第三层(network)，实现了 IP 包的转发，相当于路由。<br>
TAP 工作在 OSI 第二层(data link)，实现了 Ethernet 帧的转发，相当于网桥。<br>
操作系统通过 TUN/TAP 设备向绑定该设备的用户空间的程序发送数据，反之，用户空间的程序也可以像操作硬件网络设备那样通过 TUN/TAP 设备发送数据，然后 TUN/TAP 设备会向操作系统的网络栈 push（或 inject）数据包，从而模拟从外部接受数据的过程。<br>
TUN 常用于 VPN，通过使用 TUN，VPN 能够在 IP 包被发出去之前将其进行加密。<br>
TAP 常用于虚拟机，为虚拟机提供网卡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip tuntap add mode tap # 创建tap</span><br><span class="line">ip tuntap add mode tun # 创建tun</span><br></pre></td></tr></table></figure>
<h4 id="veth-virtual-ethernet"><a class="header-anchor" href="#veth-virtual-ethernet">¶</a>VEth（Virtual Ethernet）</h4>
<p>VEth 是成对出现的，它的作用是反转通讯数据的方向，当数据从网络栈发送到 VEth 的一端时，数据被传送到 VEth 的另外一端流出，然后放回网络栈，相当于把需要接受的数据转换成需要发送的数据，<br>
常用于虚拟化中穿透 network namespace，把从一个 network namespace 发出的数据包转发到另一个 namespace。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth1 type veth peer name veth2 # 创建一对VEth，名为veth1和veth2</span><br></pre></td></tr></table></figure>
<h3 id="服务器虚拟化"><a class="header-anchor" href="#服务器虚拟化">¶</a>服务器虚拟化</h3>
<h4 id="插槽-内核和内核线程"><a class="header-anchor" href="#插槽-内核和内核线程">¶</a>插槽、内核和内核线程</h4>
<p>虚拟机如何分配 CPU 数：<a href="https://www.it610.com/article/3322954.htm" target="_blank" rel="noopener">vSphere 中 CPU 资源如何分配</a></p>
<h4 id="xen-kvm-与-lxc"><a class="header-anchor" href="#xen-kvm-与-lxc">¶</a>Xen、KVM 与 LXC</h4>
<p>TODO<br>
服务器虚拟化的三种比较常见的技术。<br>
Xen：<br>
KVM：<br>
LXC：</p>
<h4 id="lxc-的使用方法"><a class="header-anchor" href="#lxc-的使用方法">¶</a>LXC 的使用方法</h4>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lxc</span><br><span class="line">lxc-checkconfig # 安装完成后, 用这个命令检查系统是否可以使用 lxc</span><br><span class="line"># 我执行后没有发现missing的情况，如果没有挂载cgroup可能会出现“Cgroup namespace: CONFIG_CGROUP_NSmissing”的错误，可以挂载一个cgroup</span><br><span class="line">mount -t cgroup cgroup /mnt/cgroup</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc-create -n test -t debian # # 创建一个 debian 系统</span><br></pre></td></tr></table></figure>
<p>这样创建的容器默认在 /var/lib/lxc/test 中, 为了将容器创建在我们指定的位置, 可以写个简单的配置文件 lxc.conf, 里面只需要一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc.rootfs = /home/lxc/test</span><br></pre></td></tr></table></figure>
<p>然后重新创建容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc-create -n test -t debian -f /path/to/lxc.conf</span><br></pre></td></tr></table></figure>
<p>这样, 就把容器创建在了 /home/lxc/test 中了, /var/lib/lxc/test 中只有一个 config 文件(这个 config 文件可以作为 lxc-create 命令 -f 参数对应配置文件的参考)</p>
<ol start="3">
<li>启动容器<br>
启动后就进行入了虚拟机的控制台了. (果然像传说一样, 几秒就启动完成了 <sup>_</sup>)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-start -n test</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>停止容器<br>
在主机中输入停止的命令.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc-stop -n test</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>销毁容器<br>
销毁之前, 可以通过 lxc-ls 来查看有几个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc-ls</span><br><span class="line">  test</span><br><span class="line">lxc-destroy -n test</span><br><span class="line">lxc-ls</span><br></pre></td></tr></table></figure>
<h4 id="使用示例-配置-python-uliweb-开发环境"><a class="header-anchor" href="#使用示例-配置-python-uliweb-开发环境">¶</a>使用示例（配置 python uliweb 开发环境）</h4>
<p>尝试在容器配置一次开发环境, 然后通过复制容器, 形成多个虚拟机.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 主机中</span><br><span class="line">root@debian-113:~# uliweb # 主机中没有安装uliweb 软件包</span><br><span class="line">-bash: uliweb: command not found</span><br><span class="line">root@debian-113:~# lxc-start -n test</span><br><span class="line"># 虚拟机登录界面, 输入用户名和密码</span><br><span class="line"># 虚拟机中</span><br><span class="line">root@test:~# apt-get install python</span><br><span class="line">root@test:~# apt-get install python-pip</span><br><span class="line">root@test:~# pip install Uliweb</span><br><span class="line">root@test:~# uliweb --version</span><br><span class="line">Uliweb version is 0.3.1</span><br></pre></td></tr></table></figure>
<p>主机中设置网桥, 虚拟机用桥接方式上网, 确保每个虚拟机有独立的 IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 主机中</span><br><span class="line">root@debian-113:~# lxc-stop -n test</span><br><span class="line">root@debian-113:~# apt-cache search bridge-utils</span><br><span class="line">root@debian-113:~# brctl addbr br0</span><br><span class="line"># 配置主机的网桥</span><br><span class="line">root@debian-113:/var/lib/lxc/test# cat /etc/network/interfaces </span><br><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># and how to activate them. For more information, see interfaces(5).</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">#auto eth0</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 追加的网桥配置    </span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 192.168.1.113</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">   bridge_ports eth0</span><br><span class="line">   bridge_stp on</span><br><span class="line">   bridge_fd 0</span><br><span class="line"></span><br><span class="line">root@debian-113:/var/lib/lxc/test# /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>
<p>配置容器的网络(也是在主机中修改容器的配置文件)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@debian-113:/var/lib/lxc/test# cat /var/lib/lxc/test/config</span><br><span class="line">... ... (很多默认生成的配置)</span><br><span class="line"># network &lt;-- 这个 network 相关的是要追加的</span><br><span class="line">lxc.network.type = veth</span><br><span class="line">lxc.network.flags = up</span><br><span class="line">lxc.network.link = br0</span><br><span class="line">lxc.network.name = eth0</span><br></pre></td></tr></table></figure>
<p>启动 Linux 容器, 进入虚拟机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@debian-113:/var/lib/lxc/test# lxc-start -n test</span><br><span class="line"># 登录进入虚拟机, 确认虚拟机的IP</span><br><span class="line">root@test:~# cat /etc/network/interfaces &lt;-- 默认是自动获取IP</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">root@test:~# ifconfig &lt;-- 我的机器自动分配的 192.168.1.167</span><br><span class="line"># 创建一个简单的uliweb工程</span><br><span class="line">root@test:~# cd /home/</span><br><span class="line">root@test:/home# mkdir CM-web</span><br><span class="line">root@test:/home# cd CM-web/</span><br><span class="line">root@test:/home/CM-web# uliweb makeproject test</span><br><span class="line">root@test:/home/CM-web# cd test/</span><br><span class="line">root@test:/home/CM-web/test# uliweb makeapp first_app</span><br><span class="line">root@test:/home/CM-web/test# uliweb runserver -h 0.0.0.0</span><br></pre></td></tr></table></figure>
<p>启动 Web 服务后, 就可以在主机的浏览器中 通过 <a href="http://192.168.1.167:8000/" target="_blank" rel="noopener">http://192.168.1.167:8000/</a> 来访问虚拟机中的 web 服务了.<br>
最后, 复制一个新的容器, 也就是再重新生成一个上面的 python uliweb 开发环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在主机中</span><br><span class="line">root@debian-113:~# cd /var/lib/lxc</span><br><span class="line">root@debian-113:/var/lib/lxc# cp -r test test2</span><br><span class="line"># 修改 test2/config 如下</span><br><span class="line">lxc.utsname = test2 &lt;-- 修改名称</span><br><span class="line">xc.rootfs = /home/lxc/test2 &lt;-- 修改 rootfs位置</span><br><span class="line">... ... &lt;-- 其它部分不用修改, 和 test 一样就行</span><br><span class="line">root@debian-113:/var/lib/lxc# cd /home/lxc/</span><br><span class="line">root@debian-113:/home/lxc# cp -r test test2 &lt;-- 重新复制一份 rootfs</span><br><span class="line">root@debian-113:/home/lxc# lxc-start -n test2 &lt;-- 启动 test2 虚拟机, 其中环境和 test一样, IP会不一样, 自动获取的</span><br><span class="line"># 进入 test2 虚拟机中, 可以直接启动之前的 uliweb 测试工程, 也可以从主机中访问其web服务.</span><br></pre></td></tr></table></figure>
<h3 id="lxc"><a class="header-anchor" href="#lxc">¶</a>LXC</h3>
<h4 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h4>
<p>通过 namespace 进行资源的隔离,Gust1 下的进程与 Guset2 下的进程是独立的，可以看作运行在两台物理机上一样。Contaniner 管理工具就是对 Guest 进行管理的(创建、销毁)。<br>
下图是对 LXC 架构的介绍。</p>
<h3 id="虚拟化管理平台"><a class="header-anchor" href="#虚拟化管理平台">¶</a>虚拟化管理平台</h3>
<p>虚拟化虽然可以用于自由分配资源，但是在生产环境内如果要一台一台机器安装及配置并不现实，一般来说都会尝试使用一个管理平台来自动化、批量化虚拟机的管理，或者从零开始使用 Libvirt 这样的库来实现自己需要的功能。<br>
如 <strong>Libvirt</strong> 库提供了一套用于管理虚拟机和其他虚拟化功能的 Linux API，它支持各种虚拟机监控程序，包括 Xen 和 KVM，以及 QEMU 和用于其他操作系统的一些虚拟产品。</p>
<h3 id="容器管理平台"><a class="header-anchor" href="#容器管理平台">¶</a>容器管理平台</h3>
<p>容器管理平台与其他虚拟化平台有所不同，因为和微服务关系密切，所以更关注高可用、弹性扩展等特性，如Docker Swam、Kubernetes。</p>
<h2 id="集群-分布式系统与云服务"><a class="header-anchor" href="#集群-分布式系统与云服务">¶</a>集群、分布式系统与云服务</h2>
<h3 id="集群与分布式系统"><a class="header-anchor" href="#集群与分布式系统">¶</a>集群与分布式系统</h3>
<p>集群与分布式系统是容易混淆的概念，很多时候会被混用，具体来说：</p>
<ul>
<li>集群是一个业务部署在多个服务器上，目标是高可用；</li>
<li>分布式系统是一个业务被拆分成多个子业务部署在不同的服务器上，目标是高性能。</li>
</ul>
<h3 id="数据层-分库分表"><a class="header-anchor" href="#数据层-分库分表">¶</a>数据层 - 分库分表</h3>
<h3 id="业务层-负载均衡"><a class="header-anchor" href="#业务层-负载均衡">¶</a>业务层 - 负载均衡</h3>
<p>二层：通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；<br>
三层：通过一个 VIP 地址接收请求，然后再分配到真实的 IP 地址；<br>
四层：传输层（一般是 TCP），通过 VIP+端口接收请求，然后再分配到真实的服务器，如 F5、LVS、seesaw；<br>
七层：应用层，通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器，如 Nginx（同样支持在四层工作）、HAProxy。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<h3 id="常见实现"><a class="header-anchor" href="#常见实现">¶</a>常见实现</h3>
<ol>
<li><a href="https://cloud.spring.io/spring-cloud-netflix/reference/html/" target="_blank" rel="noopener">Document - Spring Cloud Netflix</a></li>
<li><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Netflix/eureka</a></li>
<li><a href="https://github.com/Netflix/zuul/blob/master/zuul-sample/src/main/java/com/netflix/zuul/sample/SampleServerStartup.java" target="_blank" rel="noopener">Netflix/zuul</a></li>
<li><a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">Netflix/ribbon</a></li>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Netflix / Hystrix</a></li>
<li><a href="https://github.com/Netflix/Turbine" target="_blank" rel="noopener">Netflix / Turbine</a></li>
</ol>
<h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3>
<ol>
<li><a href="https://github.com/cfregly/fluxcapacitor" target="_blank" rel="noopener">Flux Capacitor</a></li>
<li><a href="https://github.com/Netflix/recipes-rss" target="_blank" rel="noopener">Netflix Recipes-RSS Reader</a></li>
</ol>
<h3 id="隔离"><a class="header-anchor" href="#隔离">¶</a>隔离</h3>
<ol>
<li><a href="https://blog.csdn.net/ceshi986745/article/details/51787424" target="_blank" rel="noopener">猿学~程序员必知的六种隔离技术</a></li>
<li><a href="https://mp.weixin.qq.com/s/M1AePRMGWh49mXcN9MyXGw" target="_blank" rel="noopener">谈谈怎么做【服务隔离】</a></li>
</ol>
<h3 id="虚拟化-v2"><a class="header-anchor" href="#虚拟化-v2">¶</a>虚拟化</h3>
<ol>
<li>网络设备虚拟化<br>
<a href="http://blog.sina.com.cn/s/blog_b5e965e80102wos3.html" target="_blank" rel="noopener">网络设备设备虚拟化</a><br>
<a href="http://mp.weixin.qq.com/s/SC_j1cCm-kgOkCPKPjL5SQ" target="_blank" rel="noopener">一文搞懂网络虚拟化</a><br>
<a href="http://mp.weixin.qq.com/s/2KaHYOxyvZw1B6PhmjN_vw" target="_blank" rel="noopener">从 Bridge 到 OVS，探索虚拟交换机</a><br>
<a href="https://feisky.gitbooks.io/sdn/linux/virtual-device.html" target="_blank" rel="noopener">虚拟网络设备</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/index.html" target="_blank" rel="noopener">Linux 上的基础网络设备详解</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77840343" target="_blank" rel="noopener">Linux-虚拟网络设备-LinuxBridge</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77854651" target="_blank" rel="noopener">Linux-虚拟网络设备-tun/tap</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/77650937" target="_blank" rel="noopener">Linux-虚拟网络设备-veth pair</a><br>
<a href="https://blog.csdn.net/sld880311/article/details/78021303" target="_blank" rel="noopener">Linux-虚拟网络设备-OpenvSwitch(持续更新)</a></li>
<li>硬件虚拟化<br>
<a href="http://www.360doc.com/content/12/0213/14/7982302_186299987.shtml" target="_blank" rel="noopener">硬件虚拟化技术浅析</a><br>
<a href="http://veck.logdown.com/posts/200566-compare-of-kvm-and-lxc" target="_blank" rel="noopener">Compare of Xen, KVM, LXC and Traditional VM</a></li>
<li>Libvirt<br>
<a href="https://libvirt.org/" target="_blank" rel="noopener">Libvirt</a></li>
<li>Xen<br>
<a href="https://www.xenproject.org/" target="_blank" rel="noopener">Xen</a></li>
<li>KVM<br>
<a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">Kernel Virtual Machine（KVM）</a><br>
<a href="http://oenhan.com/kvm-src-1" target="_blank" rel="noopener">KVM 源代码分析 1:基本工作原理</a><br>
<a href="https://mp.weixin.qq.com/s/WzpH653x1hS9_PBVrIJFuw" target="_blank" rel="noopener">在 Centos6.5 上部署 kvm 虚拟化技术</a></li>
<li>LXC<br>
<a href="https://www.cnblogs.com/xidongyu/p/5767020.html" target="_blank" rel="noopener">LXC 的介绍</a><br>
<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LinuX Container（LXC）</a><br>
<a href="http://www.cnblogs.com/wang_yb/p/3923040.html" target="_blank" rel="noopener">Linux 容器的使用</a></li>
<li>Docker<br>
<a href="http://dockone.io/article/2050" target="_blank" rel="noopener">使用 NGINX 和 NGINX Plus 进行 Docker Swarm 负载均衡</a><br>
DockerSwarm 提供的负载均衡运行于每个节点上（应该是 DockerService 中的某个 Job），提供有限的负载均衡服务（TCP 层负载均衡），因此引入 Nginx 是有道理的。<br>
据说 Nginx Plus 可以实现<strong>服务弹性伸缩</strong>的功能，但还没试过。</li>
</ol>
<h3 id="集群-分布式系统与云服务-v2"><a class="header-anchor" href="#集群-分布式系统与云服务-v2">¶</a>集群、分布式系统与云服务</h3>
<ol>
<li>负载均衡<br>
<a href="https://github.com/google/seesaw" target="_blank" rel="noopener">google/seesaw</a></li>
<li>云原生<br>
<a href="https://mp.weixin.qq.com/s/gwXNBZzvygKV5xW1dfiQTA" target="_blank" rel="noopener">关于云原生，这是最详细的技术知识</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/微服务/" rel="tag"># 微服务</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/10511d14.html" rel="next" title="Linux 脚本基础">
                <i class="fa fa-chevron-left"></i> Linux 脚本基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/caf2d9ed.html" rel="prev" title="网络协议之 HTTP 总结">
                网络协议之 HTTP 总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基本概念"><span class="nav-number">1.</span> <span class="nav-text">¶微服务基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">1.1.</span> <span class="nav-text">¶定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用微服务"><span class="nav-number">1.2.</span> <span class="nav-text">¶为什么要使用微服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#架构与组织"><span class="nav-number">1.3.</span> <span class="nav-text">¶架构与组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中台战略与微服务"><span class="nav-number">1.4.</span> <span class="nav-text">¶中台战略与微服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微服务架构风格"><span class="nav-number">1.5.</span> <span class="nav-text">¶微服务架构风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微服务架构"><span class="nav-number">1.6.</span> <span class="nav-text">¶微服务架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务发现-eureka"><span class="nav-number">2.</span> <span class="nav-text">¶服务发现 - Eureka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eureka-的目标"><span class="nav-number">2.1.</span> <span class="nav-text">¶Eureka 的目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eureka-vs-zookeeper"><span class="nav-number">2.2.</span> <span class="nav-text">¶Eureka VS ZooKeeper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组成部分"><span class="nav-number">2.3.</span> <span class="nav-text">¶组成部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务状态机"><span class="nav-number">2.4.</span> <span class="nav-text">¶服务状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client-与-server-间的交互"><span class="nav-number">2.5.</span> <span class="nav-text">¶Client 与 Server 间的交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#register"><span class="nav-number">2.5.1.</span> <span class="nav-text">¶Register</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unregister"><span class="nav-number">2.5.2.</span> <span class="nav-text">¶Unregister</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#renew"><span class="nav-number">2.5.3.</span> <span class="nav-text">¶Renew</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fetch-registry"><span class="nav-number">2.5.4.</span> <span class="nav-text">¶Fetch Registry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cancel"><span class="nav-number">2.5.5.</span> <span class="nav-text">¶Cancel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-lag"><span class="nav-number">2.5.6.</span> <span class="nav-text">¶Time Lag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#communication-mechanism"><span class="nav-number">2.5.7.</span> <span class="nav-text">¶Communication mechanism</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通信协议"><span class="nav-number">2.5.8.</span> <span class="nav-text">¶通信协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高可用"><span class="nav-number">2.6.</span> <span class="nav-text">¶高可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常情况"><span class="nav-number">2.7.</span> <span class="nav-text">¶异常情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eureka-配置"><span class="nav-number">2.8.</span> <span class="nav-text">¶Eureka 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#添加自定义元数据"><span class="nav-number">2.8.1.</span> <span class="nav-text">¶添加自定义元数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码"><span class="nav-number">2.9.</span> <span class="nav-text">¶源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原生客户端的执行过程"><span class="nav-number">2.9.1.</span> <span class="nav-text">¶原生客户端的执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过-di-依赖注入-使用-eurekaclient"><span class="nav-number">2.9.2.</span> <span class="nav-text">¶通过 DI（依赖注入）使用 EurekaClient</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置"><span class="nav-number">2.9.3.</span> <span class="nav-text">¶配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网关-zuul"><span class="nav-number">3.</span> <span class="nav-text">¶网关 - Zuul</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">3.1.</span> <span class="nav-text">¶Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filter属性"><span class="nav-number">3.1.1.</span> <span class="nav-text">¶Filter属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他的一些例子"><span class="nav-number">3.1.2.</span> <span class="nav-text">¶其他的一些例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存请求体"><span class="nav-number">3.2.</span> <span class="nav-text">¶缓存请求体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络协议"><span class="nav-number">3.3.</span> <span class="nav-text">¶网络协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他功能"><span class="nav-number">3.4.</span> <span class="nav-text">¶其他功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push-messaging"><span class="nav-number">3.5.</span> <span class="nav-text">¶Push Messaging</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#负载均衡-ribbon"><span class="nav-number">4.</span> <span class="nav-text">¶负载均衡 - Ribbon</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用"><span class="nav-number">4.1.</span> <span class="nav-text">¶使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件结构及实现"><span class="nav-number">4.2.</span> <span class="nav-text">¶组件结构及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rule"><span class="nav-number">4.2.1.</span> <span class="nav-text">¶Rule</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ping"><span class="nav-number">4.2.2.</span> <span class="nav-text">¶Ping</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serverlist"><span class="nav-number">4.2.3.</span> <span class="nav-text">¶ServerList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serverlistfilter"><span class="nav-number">4.2.4.</span> <span class="nav-text">¶ServerListFilter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码-v2"><span class="nav-number">4.3.</span> <span class="nav-text">¶源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hystrix"><span class="nav-number">5.</span> <span class="nav-text">¶Hystrix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#turbine"><span class="nav-number">6.</span> <span class="nav-text">¶Turbine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基础设施-配置中心"><span class="nav-number">7.</span> <span class="nav-text">¶微服务基础设施 - 配置中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置分类"><span class="nav-number">7.1.</span> <span class="nav-text">¶配置分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apollo"><span class="nav-number">7.2.</span> <span class="nav-text">¶Apollo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基础设施-rpc"><span class="nav-number">8.</span> <span class="nav-text">¶微服务基础设施 - RPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基础设施-后台框架"><span class="nav-number">9.</span> <span class="nav-text">¶微服务基础设施 - 后台框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基础设施-监控"><span class="nav-number">10.</span> <span class="nav-text">¶微服务基础设施 - 监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基础设施-服务-sla-service-level-agreement"><span class="nav-number">11.</span> <span class="nav-text">¶微服务基础设施 - 服务 SLA（Service Level Agreement）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#微服务基础设施-持续交付-continuous-delivery-简称-cd"><span class="nav-number">12.</span> <span class="nav-text">¶微服务基础设施 - 持续交付（Continuous delivery，简称 CD）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟化"><span class="nav-number">13.</span> <span class="nav-text">¶虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离的作用"><span class="nav-number">13.1.</span> <span class="nav-text">¶隔离的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离的分类"><span class="nav-number">13.2.</span> <span class="nav-text">¶隔离的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络虚拟化"><span class="nav-number">13.3.</span> <span class="nav-text">¶网络虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tun-tap-tunnel"><span class="nav-number">13.3.1.</span> <span class="nav-text">¶TUN/TAP(Tunnel)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#veth-virtual-ethernet"><span class="nav-number">13.3.2.</span> <span class="nav-text">¶VEth（Virtual Ethernet）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器虚拟化"><span class="nav-number">13.4.</span> <span class="nav-text">¶服务器虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插槽-内核和内核线程"><span class="nav-number">13.4.1.</span> <span class="nav-text">¶插槽、内核和内核线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xen-kvm-与-lxc"><span class="nav-number">13.4.2.</span> <span class="nav-text">¶Xen、KVM 与 LXC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lxc-的使用方法"><span class="nav-number">13.4.3.</span> <span class="nav-text">¶LXC 的使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用示例-配置-python-uliweb-开发环境"><span class="nav-number">13.4.4.</span> <span class="nav-text">¶使用示例（配置 python uliweb 开发环境）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lxc"><span class="nav-number">13.5.</span> <span class="nav-text">¶LXC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-number">13.5.1.</span> <span class="nav-text">¶原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟化管理平台"><span class="nav-number">13.6.</span> <span class="nav-text">¶虚拟化管理平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器管理平台"><span class="nav-number">13.7.</span> <span class="nav-text">¶容器管理平台</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群-分布式系统与云服务"><span class="nav-number">14.</span> <span class="nav-text">¶集群、分布式系统与云服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集群与分布式系统"><span class="nav-number">14.1.</span> <span class="nav-text">¶集群与分布式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据层-分库分表"><span class="nav-number">14.2.</span> <span class="nav-text">¶数据层 - 分库分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#业务层-负载均衡"><span class="nav-number">14.3.</span> <span class="nav-text">¶业务层 - 负载均衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">15.</span> <span class="nav-text">¶参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见实现"><span class="nav-number">15.1.</span> <span class="nav-text">¶常见实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">15.2.</span> <span class="nav-text">¶例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离"><span class="nav-number">15.3.</span> <span class="nav-text">¶隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟化-v2"><span class="nav-number">15.4.</span> <span class="nav-text">¶虚拟化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群-分布式系统与云服务-v2"><span class="nav-number">15.5.</span> <span class="nav-text">¶集群、分布式系统与云服务</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
