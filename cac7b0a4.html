<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="动态代理,">










<meta name="description" content="�">
<meta name="keywords" content="动态代理">
<meta property="og:type" content="article">
<meta property="og:title" content="多级缓存原理">
<meta property="og:url" content="https://tallate.github.io/cac7b0a4.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="�">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tallate.top/imgs/Java/%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png">
<meta property="og:updated_time" content="2020-12-19T11:58:32.352Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多级缓存原理">
<meta name="twitter:description" content="�">
<meta name="twitter:image" content="https://tallate.top/imgs/Java/%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/cac7b0a4.html">







  <title>多级缓存原理 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/cac7b0a4.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">多级缓存原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T23:13:20+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>�</p>
<a id="more"></a>
<h2 id="反射"><a class="header-anchor" href="#反射">¶</a>反射</h2>
<h3 id="类存储结构和反射"><a class="header-anchor" href="#类存储结构和反射">¶</a>类存储结构和反射</h3>
<p>**反射（Reflection）**是 Java 的高级特性之一，是框架实现的基础。<br>
定义：Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。<br>
反射是对类元属性的封装，支持运行时访问和修改类属性，包括从 Class 中获取信息、创建对象、调用方法、访问属性值等。<br>
说到类就不得不提类的加载过程，类是方法区中的一个数据结构，创建类时首先由类加载器读入字节码，然后进行验证、分配内存和初始化等过程，每个类加载器都有其命名空间，用于保存类结构，<strong>反射就是对这个类的结构的访问接口</strong>。<br>
一般而言，当用户使用一个类的时候，应该获取这个类，而后通过这个类实例化对象，但是使用反射则可以相反的通过对象获取类中的信息。<br>
通俗的讲反射就是可以在程序运行的时候动态装载类，查看类的信息，生成对象，或操作生成的对象。它允许运行中的 Java 程序获取自身的信息，自己能看到自己，就像照镜子一样。�<br>
另外，为什么要有反射这个“后门”呢？首先我们要区分静态和动态编译的概念：</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象�<br>
两者的区别在于，<strong>动态编译可以最大程度地支持多态，多态最大的意义在于降低类的耦合性</strong>，而 Java 语言确是静态编译（如：int a=3；要指定类型），Java 反射很大程度上弥补了这一不足：<strong>解耦以及提高代码的灵活性</strong>，所以 Java 也被称为是<strong>准动态语言</strong>。<br>
尽管反射有诸多优点，但是反射也有缺点：</li>
</ul>
<ol>
<li>由于反射会额外消耗一定的系统资源，因此，<strong>反射操作的效率要比那些非反射操作低得多</strong>。</li>
<li>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用<strong>反射可能会导致意料之外的副作用</strong>（代码有功能上的错误）。所以能用其它方式实现的就尽量不去用反射。�</li>
</ol>
<h3 id="获取类信息"><a class="header-anchor" href="#获取类信息">¶</a>获取类信息�</h3>
<p>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM 已经帮我们创建好了。<br>
如果知道一个实例，那么可以通过实例的“getClass()”方法获得运行实例的 Class（该类型的字节码文件对象），如果你知道一个类型，那么你也可以使用“.class”的方法获得运行实例的 Class。�<br>
一般获取 Class 的方法有三种：�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 方式1：通过 Class 类的静态方法获取 Class 类对象 (推荐) </span><br><span class="line">Class c = Class.forName(&quot;java.util.List&quot;); </span><br><span class="line">// 方式2：因为所有类都继承 Object 类。因而可通过调用 Object 类中的 getClass 方法来获取 </span><br><span class="line">Object o = new Object();</span><br><span class="line">o.getClass();</span><br><span class="line">// 方式3：任何数据类型（包括基本数据类型）都有一个“静态”的 class 属性 </span><br><span class="line">Class c = Object.class; </span><br></pre></td></tr></table></figure>
<p>以下示例中，obj 表示要解析的对象实例，clazz 表示获取到的该对象对应的字节码，用于分析包、类等信息  �</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 1 通过对象得到java的字节码 </span><br><span class="line">Class clazz = obj.getClass(); </span><br><span class="line">// clazz对象是 java内存的对象的字节码 </span><br><span class="line">// 2通过字节码获取包名 </span><br><span class="line">Package pk = clazz.getPackage(); </span><br><span class="line">String pname = pk.getName(); </span><br><span class="line">// demo.neusoft.po </span><br><span class="line">System.out.println(&quot;该类包：&quot; + pname); </span><br><span class="line">// 3通过字节码对象得到类的全路径 </span><br><span class="line">String fullpath = clazz.getName(); </span><br><span class="line">System.out.println(&quot;类全路径：&quot; + fullpath); </span><br><span class="line">// 4通过字节码对象得到类的名字 </span><br><span class="line">String simpleName = clazz.getSimpleName(); </span><br><span class="line">System.out.println(&quot;类名：&quot; + simpleName); </span><br><span class="line">// 5通过字节码对象得到类的父类 </span><br><span class="line">Class fatherClazz = clazz.getSuperclass(); </span><br><span class="line">System.out.println(simpleName + &quot;类的父类：&quot; + fatherClazz.getSimpleName()); </span><br><span class="line">// 6通过字节码对象得到类的接口 </span><br><span class="line">Class[] interfaces = clazz.getInterfaces(); </span><br><span class="line">for (Class iclazz : interfaces) &#123; </span><br><span class="line">    System.out.println(simpleName + &quot;类的接口：&quot; + iclazz.getName()); </span><br><span class="line">&#125; </span><br><span class="line">// 7返回表示数组组件类型的 Class。如果此类是数组则返回表示此类组件类型的Class，如果此类不表示数组类，则此方法返回 null </span><br><span class="line">Object[] o = new Object[4];</span><br><span class="line">Class&lt;?&gt; componentType = o.getClass().getComponentType(); </span><br></pre></td></tr></table></figure>
<h3 id="获取类加载器"><a class="header-anchor" href="#获取类加载器">¶</a>获取类加载器�</h3>
<p><img src="https://tallate.top/imgs/Java/%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="获取类加载器" title="获取类加载器">�<br>
返回该类的类加载器。有些实现可能使用 null 来表示引导类加载器，如果该类由引导类加载器加载，则此方法在这类实现中将返回 null，比如 Object。�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1、获取一个系统的类加载器</span><br><span class="line">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(&quot;系统的类加载器--&gt;&quot; + classLoader);</span><br><span class="line">//2、获取系统类加载器的父类加载器(扩展类加载器（extensions classLoader）)</span><br><span class="line">classLoader = classLoader.getParent();</span><br><span class="line">System.out.println(&quot;扩展类加载器--&gt;&quot; + classLoader);</span><br><span class="line">//3、获取扩展类加载器的父类加载器</span><br><span class="line">//输出为Null,引导类加载器无法被Java程序直接引用</span><br><span class="line">classLoader = classLoader.getParent();</span><br><span class="line">System.out.println(&quot;启动类加载器--&gt;&quot; + classLoader);</span><br><span class="line">//4、测试当前类由哪个类加载器进行加载 ,结果就是系统的类加载器</span><br><span class="line">classLoader = Class.forName(&quot;com.tallate.repackage_2018.reflect.ClassTest&quot;).getClassLoader();</span><br><span class="line">System.out.println(&quot;当前类由哪个类加载器进行加载--&gt;&quot;+classLoader);</span><br><span class="line">//5、测试JDK提供的Object类由哪个类加载器负责加载的</span><br><span class="line">classLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();</span><br><span class="line">System.out.println(&quot;JDK提供的Object类由哪个类加载器加载--&gt;&quot; + classLoader); </span><br></pre></td></tr></table></figure>
<p>如果存在安全管理器，并且调用者的类加载器不是 null，也不同于或是请求其类加载器的类的类加载器的祖先，则此方法通过 RuntimePermission(“getClassLoader”)权限调用此安全管理器 checkPermission 方法，以确保可以访问该类的类加载器。如果此对象表示一个基本类型或 void，则返回 null。�</p>
<h3 id="实例化对象"><a class="header-anchor" href="#实例化对象">¶</a>实例化对象�</h3>
<p>可能会抛出 InstantiationException 异常  �</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object newObj =null; </span><br><span class="line">// 7.通过字节码对象实例化一个对象 </span><br><span class="line">newObj = clazz.newInstance();//相当于按类实例化一个对象 </span><br><span class="line">System.out.println(&quot;比较参数对象：&quot;+newObj==obj); </span><br><span class="line">// 8.通过全路径实例化对象 </span><br><span class="line">Class&lt;?&gt; newObj2 = Class.forName(fullpath); </span><br><span class="line">System.out.println(&quot;比较全路径对象：&quot;+newObj2==obj); </span><br></pre></td></tr></table></figure>
<h3 id="分析属性"><a class="header-anchor" href="#分析属性">¶</a>分析属性�</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 9.通过字节码对象 分析属性 </span><br><span class="line">Field[] fields = clazz.getFields();//得到非私有属性 </span><br><span class="line">fields=clazz.getDeclaredFields();//获取私有属性 </span><br><span class="line">for (Field f : fields) &#123; </span><br><span class="line">    //获取属性名 </span><br><span class="line">    String fname = f.getName(); </span><br><span class="line">    //属性的类型 </span><br><span class="line">    Class type = f.getType(); </span><br><span class="line">    //针对私有属性的访问，临时放开权限 </span><br><span class="line">    f.setAccessible(true); </span><br><span class="line">    //获取属性的值 </span><br><span class="line">    Object fval = f.get(obj);//get方法获取内存中的值，参数要求 </span><br><span class="line">    //针对属性设置 </span><br><span class="line">    //set(当前对象本身,属性设置的值); </span><br><span class="line">    //f.set(newObj, value); </span><br><span class="line">    //将当前对象的内存传递过来 </span><br><span class="line">    System.out.println(&quot;属性名称：&quot;+fname+ </span><br><span class="line">            &quot;,属性类型&quot;+type.getSimpleName()+ </span><br><span class="line">            &quot;,属性值：&quot;+fval); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="分析方法"><a class="header-anchor" href="#分析方法">¶</a>分析方法�</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 10.通过字节码文件得到当前类的方法 </span><br><span class="line">//clazz.getMethod(name, parameterTypes) </span><br><span class="line">Method[] methods = clazz.getMethods(); // 只获取public的 </span><br><span class="line">methods=clazz.getDeclaredMethods(); // 获取全部 </span><br><span class="line">for (Method method : methods) &#123; </span><br><span class="line">//分析方法结构 </span><br><span class="line">//得到方法返回类型 </span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType(); </span><br><span class="line">//方法名称 </span><br><span class="line">String name = method.getName(); </span><br><span class="line">//方法中参数类型集合 </span><br><span class="line">Class&lt;?&gt;[] pts = method.getParameterTypes(); </span><br><span class="line">String s=&quot;&quot;; </span><br><span class="line">for (Class&lt;?&gt; pclazz : pts) &#123; </span><br><span class="line">String ptype = pclazz.getSimpleName(); </span><br><span class="line">   s=s+ptype+&quot;,&quot;; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(&quot;方法返回类型：&quot;+returnType+ </span><br><span class="line">   &quot;方法名:&quot;+name+ </span><br><span class="line">   &quot;方法参数类型：&quot;+s); </span><br><span class="line">&#125; </span><br><span class="line">// 11.方法反射执行 </span><br><span class="line">//A：得到指定名称的方法对象的声明 </span><br><span class="line">Method method = clazz.getMethod(&quot;getStuname&quot;); </span><br><span class="line">//B: 通过方法对象反射执行 </span><br><span class="line">//invoke(方法的当前对象本身,方法执行需要的实际参数) </span><br><span class="line">Object val = method.invoke(obj); </span><br><span class="line">System.out.println(&quot;getStuname方法返回：&quot;+val); </span><br><span class="line">// 12.通过字节码对象得到构造方法 </span><br><span class="line">Constructor[] constructors = clazz.getConstructors(); </span><br><span class="line">for (Constructor constructor : constructors) &#123; </span><br><span class="line">//得到构造器的名称 </span><br><span class="line">String name = constructor.getName(); </span><br><span class="line">Class[] cps = constructor.getParameterTypes(); </span><br><span class="line">//构造器的反射执行 </span><br><span class="line">//constructor.newInstance(initargs) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>*** 例子�</p>
<ol>
<li>这个例子通过反射实例化一个 MyIOC 类，然后找到它类型为 AttributeType 的成员变量，然后调用对应的 setter 方法设置属性�</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String toUpperStr(String str) &#123; </span><br><span class="line">    return Character.toUpperCase(str.charAt(0)) + str.substring(1); </span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        Class c = Class.forName(&quot;MyIOC&quot;); </span><br><span class="line">        Object o = c.newInstance(); </span><br><span class="line">        Field[] declaredFields = c.getDeclaredFields(); </span><br><span class="line">        for (Field f : declaredFields) &#123; </span><br><span class="line">            if (f.getType() == AttributeType.class) &#123; </span><br><span class="line">                Method set = c.getDeclaredMethod(&quot;set&quot; </span><br><span class="line">                        + toUpperStr(f.getName()), AttributeType.class); </span><br><span class="line">                set.invoke(o, new AttributeType(&quot;Hello&quot;)); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; catch(Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="绕过-private-final-限制"><a class="header-anchor" href="#绕过-private-final-限制">¶</a>绕过 private、final 限制�</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field field = getField(target, fieldName);</span><br><span class="line">// 设置private可访问</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">// 设置final可修改</span><br><span class="line">Field modifierField = Field.class.getDeclaredField(&quot;modifiers&quot;);</span><br><span class="line">modifierField.setAccessible(true);</span><br><span class="line">modifierField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field.set(target, value); </span><br></pre></td></tr></table></figure>
<h3 id="越过范型检查"><a class="header-anchor" href="#越过范型检查">¶</a>越过范型检查�</h3>
<p>泛型作用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的。�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void test10() throws Exception&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(100);</span><br><span class="line">    list.add(200);</span><br><span class="line">    Method method = list.getClass().getMethod(&quot;add&quot;, Object.class);</span><br><span class="line">    method.invoke(list, &quot;Java反射机制实例。&quot;);</span><br><span class="line">    //遍历集合  </span><br><span class="line">    for(Object obj : list)&#123;  </span><br><span class="line">        System.out.println(obj);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="通过反射机制获得数组信息并修改数组的大小和值"><a class="header-anchor" href="#通过反射机制获得数组信息并修改数组的大小和值">¶</a>通过反射机制获得数组信息并修改数组的大小和值</h3>
<p>下面的方法可以扩展数组到新的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object arrayInc(Object oldArr, int newLen) &#123;</span><br><span class="line">  Class&lt;?&gt; arr = oldArr.getClass().getComponentType();</span><br><span class="line">  Object newArr = Array.newInstance(arr, newLen);</span><br><span class="line">  int originLength = Array.getLength(oldArr);</span><br><span class="line">  System.arraycopy(oldArr, 0, newArr, 0, originLength);</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码通过反射来修改数组某一位置的值。�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.set(arr, 0, 100); </span><br></pre></td></tr></table></figure>
<h3 id="反射应用于工厂模式"><a class="header-anchor" href="#反射应用于工厂模式">¶</a>反射应用于工厂模式</h3>
<p>平时在使用数据库的时候我们一般都需要在配置文件中设置所需的驱动器类，实际上就是应用了工厂模式，比如如果需要使用 MySQL 数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">``` </span><br><span class="line">### 使用反射实现简易ORM框架</span><br><span class="line">#### 属性声明</span><br></pre></td></tr></table></figure>
<p>public class BaseDao {<br>
private Connection con;<br>
private PreparedStatement pstm;<br>
private ResultSet rs;<br>
// 连接的一些属性<br>
private String driver;<br>
private String url;<br>
private String uname;<br>
private String pwd;<br>
…<br>
}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态块加载连接属性</span><br></pre></td></tr></table></figure>
<p>static {<br>
Properties p = new Properties();<br>
try {<br>
FileInputStream rd = new FileInputStream(“db.properties”);<br>
p.load(rd);<br>
} catch(IOException e) {<br>
e.printStackTrace();<br>
}<br>
driver = p.getProperty(“driver”);<br>
url = p.getProperty(“url”);<br>
name = p.getProperty(“name”);<br>
pwd = p.getProperty(“pwd”);<br>
}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 提取访问数据库的公共代码</span><br></pre></td></tr></table></figure>
<p>private Object run(IDao idao,String sql,Object…objs){<br>
Object obj=null;//执行 CRUD 返回的具体值<br>
try {<br>
// 1.提取 CRUD 中重复代码<br>
Class.forName(driver);<br>
con = DriverManager.getConnection(url, uname, pwd);<br>
pstm = con.prepareStatement(sql);<br>
// 2.为 sql 语句中问号赋值<br>
for (int i = 0; i &lt; objs.length; i++) {<br>
pstm.setObject(i + 1, objs[i]);<br>
}<br>
// 3.利用第一个参数提供 crud 模板对象，执行具体的 crud 并返回结果<br>
obj=idao.init(pstm);<br>
} catch (ClassNotFoundException e) {<br>
e.printStackTrace();<br>
} catch (SQLException e) {<br>
e.printStackTrace();<br>
}finally{<br>
try {<br>
if(rs!=null)<br>
rs.close();<br>
if (pstm != null)<br>
pstm.close();<br>
if (con != null)<br>
con.close();<br>
} catch (SQLException e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
return obj;<br>
}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中IDao是数据库操作的回调接口</span><br></pre></td></tr></table></figure>
<p>public interface IDao {<br>
public Object init(PreparedStatement pstm)throws SQLException;<br>
}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 插入和更新操作</span><br></pre></td></tr></table></figure>
<p>public int saveOrUpdate(String sql, Object… objs) {<br>
return (Integer) run(new IDao() {<br>
@Override<br>
public Object init(PreparedStatement pstm) throws SQLException {<br>
return pstm.executeUpdate();<br>
}<br>
},sql,objs);<br>
}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 查询操作</span><br><span class="line">首先定义我们的数据库表和字段注解，数据库中对应的名字由注解给出</span><br></pre></td></tr></table></figure>
<p>@Retention(RetentionPolicy.RUNTIME)<br>
@Target(ElementType.TYPE)<br>
public @interface Xtable {<br>
String value();<br>
}<br>
enum Genor {<br>
Auto<br>
}<br>
@Retention(RetentionPolicy.RUNTIME)<br>
@Target(ElementType.FIELD)<br>
public @interface Xid {<br>
String value();<br>
//主键生成方式<br>
Genor Gen();<br>
}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义基础查询方法</span><br></pre></td></tr></table></figure>
<p>List<object> find(String sql, Class poclazz, Object… objs) {<br>
Object result = run(new IDao() {<br>
@Override<br>
public Object onExec(PreparedStatement pstm) throws SQLException {<br>
// 执行查询,返回结果集<br>
rs = pstm.executeQuery();<br>
//实例化一个集合对象，封装实体对象<br>
List<object> pos = new ArrayList<object>();<br>
try {<br>
//遍历结果集<br>
while(rs.next()) {<br>
// 实例化每个查询到的结果<br>
Object po = poclazz.newInstance();<br>
Field[] fs = poclazz.getDeclaredFields();<br>
// 使用查询结果填充实体类的属性<br>
//通过实体类中的属性，属性与物理表中的列一致规则，得到对应列是值<br>
for(Field f : fs) {<br>
// 列名<br>
String fname = f.getName();<br>
// 列值<br>
Object fval = rs.getObject(fname);<br>
// 使用 set 方法<br>
Method setMethod = poclazz.getDeclaredMethod(<br>
“set” + StringUtil.toUpper(fname), f.getType());<br>
/**<br>
* 注意有些类型还未写全——比如 Double，有用到时记得补上<br>
*/<br>
if(fval instanceof Boolean) {<br>
setMethod.invoke(po, (Boolean) fval);<br>
} else if(fval instanceof Integer) {<br>
setMethod.invoke(po, new Integer(fval.toString()));<br>
} else if(fval instanceof Long) {<br>
setMethod.invoke(po, new Long(fval.toString()));<br>
} else if(fval instanceof String) {<br>
setMethod.invoke(po, fval.toString());<br>
} else {<br>
setMethod.invoke(po, fval.toString());<br>
}<br>
}<br>
// 将构造的对象添加到集合中<br>
pos.add(po);<br>
}<br>
} catch (Exception e) {<br>
e.printStackTrace();<br>
}<br>
// 返回查询到的结果<br>
return pos;<br>
}<br>
}, sql, objs);<br>
// 转换结果类型返回<br>
return (List<object>) result;<br>
}</object></object></object></object></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义查询方法（通过id查询）</span><br></pre></td></tr></table></figure>
<p>Object findById(final Class poclazz, Serializable id) {<br>
// 1.生成 sql 语句<br>
String sql = &quot;select * from &quot;;<br>
// 反射注解得到表的名称<br>
Table xtable =<br>
(Table) poclazz.getAnnotation(Table.class);<br>
sql = sql + xtable.value();<br>
// 2.获取主键名称<br>
Field[] fs = poclazz.getDeclaredFields();<br>
for (Field field : fs) {<br>
Id xid = field.getAnnotation(Id.class);<br>
if(xid!=null){<br>
String sid = xid.value();//主键名称<br>
sql = sql + &quot; where &quot; + sid + “=?”;<br>
break;<br>
}<br>
}<br>
// 3.执行操作，返回查询到的对象<br>
List<object> result = find(sql, poclazz, id);<br>
return result.get(0);<br>
}</object></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稍作修改得到查询方法（查询所有记录）</span><br></pre></td></tr></table></figure>
<p>List<object> findAll(final Class poclazz) {<br>
// 1.生成 sql 语句<br>
String sql = &quot;select * from &quot;;<br>
Table xtable = (Table) poclazz.getAnnotation(Table.class);<br>
sql += xtable.value();<br>
return (List<object>)(List)find(sql, poclazz);<br>
}</object></object></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 动态代理实现方案</span><br><span class="line">### 代理实现方法</span><br><span class="line">1. 静态代理</span><br><span class="line">在编译时确定的称为静态代理（或者说委托，因为代理类的实际实现是调用了目标对象的相应方法），静态代理的实现参考代理模式。  </span><br><span class="line">1. 动态代理</span><br><span class="line">Java中可以通过Proxy.newProxyInstance来创建代理对象，代理类和被代理类需要同一套接口，而且还需要实现一个InvocationHandler类作为中介。   </span><br><span class="line">### 使用Jdk Proxy实现动态代理 </span><br><span class="line">####  InvocationHandler和newProxyInstance()的使用 </span><br></pre></td></tr></table></figure>
<p>public interface InvocationHandler {�<br>
// proxy 被代理对象，method 该对象的方法，args 该方法的参数�<br>
Object invoke(Object proxy, Method method, Object[] args);�<br>
}�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当调用目标对象的方法时，该调用会转发到invoke方法中，因此可以在invoke方法中定义统一处理逻辑，在方法层面上来说也可以当成中介者。   </span><br></pre></td></tr></table></figure>
<p>// loader 代理类的类加载器，interfaces 代理类实现的接口列表，h 调用处理器 InvocationHandler�<br>
public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例化代理类时需要使用Proxy.newProxyInstance静态方法创建，并不是直接实例化一个代理对象，它会根据代理接口的方法列表来反射定义方法体，对代理对象的方法调用都会被转发到中介对象的invoke方法。   </span><br><span class="line">newProxyInstance用于创建代理类实例，其执行过程大致如下： </span><br><span class="line">1. getProxyClass，查看缓存中是否已经使用loader创建了和interfaces相关的代理类对象，Proxy类中使用一个静态Map对象保存类装载器对象到其对应代理对象的缓存   </span><br><span class="line">1. 调用ProxyGenerator的generateProxyClass产生代理类的**字节码** </span><br><span class="line">1. 使用反射获取构造函数并生成代理类实例   </span><br><span class="line">#### 原理 </span><br><span class="line">1. 生成类的定义文件（字节码文件） </span><br></pre></td></tr></table></figure>
<p>Proxy.newProxyInstance(loader, interfaces, this);�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">newProxyInstance完成了什么工作？ </span><br><span class="line">在运行时，jdk为根据目标接口(Service)信息，生成代理类的字节码文件，并通过制定的Classloader来完成字节码文件的加载和解析，并返回一个代理类的Class。最后通过该Class的构造函数完成代理类实例的创建。  </span><br><span class="line">java.lang.reflect.Proxy#getProxyClass0 </span><br><span class="line">-&gt; proxyClassCache.get 第一次调用缓存不命中，调ProxyClassFactory生成实例 </span><br><span class="line">-&gt; ProxyClassFactory.apply </span><br><span class="line">    -&gt; ProxyGenerator.generateProxyClass 生成字节码文件 </span><br><span class="line">    -&gt; java.lang.reflect.Proxy#defineClass0 加载字节码文件并解析为Class对象 </span><br><span class="line">1. 调用传递 </span><br><span class="line">从生成的代理类Class可以看出，在代理类内部完成了对InvocationHandler的绑定。那么调用就可以顺利成章的传递到相应的InvocationHandler中。 </span><br><span class="line">程序运行完后会在指定目录下生成Class文件 </span><br></pre></td></tr></table></figure>
<p>public class ReflectTests {�<br>
public interface Service {�<br>
}�<br>
public static class ServiceImpl implements Service {�<br>
}�<br>
public static void main(String[] args) throws IOException {�<br>
Service service = new ServiceImpl();�<br>
byte[] classFile = ProxyGenerator.generateProxyClass(“com.sun.proxy.$Proxy.1”, service.getClass().getInterfaces());�<br>
FileOutputStream out = new FileOutputStream(&quot;/tmp/com.sun.proxy.$Proxy.1.class&quot;);�<br>
out.write(classFile);�<br>
out.flush();�<br>
}�<br>
}�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对字节码文件反编译可以看一下生成的是一个什么样的Class： </span><br></pre></td></tr></table></figure>
<p>public final class 1 extends Proxy implements Service {�<br>
private static Method m1;�<br>
private static Method m2;�<br>
private static Method m0;�<br>
public _/* $FF was: 1*/(InvocationHandler var1) throws {�<br>
super(var1);�<br>
}�<br>
public final boolean equals(Object var1) throws {�<br>
try {�<br>
return (Boolean)super.h.invoke(this, m1, new Object[]{var1});�<br>
} catch (RuntimeException | Error var3) {�<br>
throw var3;�<br>
} catch (Throwable var4) {�<br>
throw new UndeclaredThrowableException(var4);�<br>
}�<br>
}�<br>
public final String toString() throws {�<br>
try {�<br>
return (String)super.h.invoke(this, m2, (Object[])null);�<br>
} catch (RuntimeException | Error var2) {�<br>
throw var2;�<br>
} catch (Throwable var3) {�<br>
throw new UndeclaredThrowableException(var3);�<br>
}�<br>
}�<br>
public final int hashCode() throws {�<br>
try {�<br>
return (Integer)super.h.invoke(this, m0, (Object[])null);�<br>
} catch (RuntimeException | Error var2) {�<br>
throw var2;�<br>
} catch (Throwable var3) {�<br>
throw new UndeclaredThrowableException(var3);�<br>
}�<br>
}�<br>
static {�<br>
try {�<br>
m1 = Class.forName(“java.lang.Object”).getMethod(“equals”, Class.forName(“java.lang.Object”));�<br>
m2 = Class.forName(“java.lang.Object”).getMethod(“toString”);�<br>
m0 = Class.forName(“java.lang.Object”).getMethod(“hashCode”);�<br>
} catch (NoSuchMethodException var2) {�<br>
throw new NoSuchMethodError(var2.getMessage());�<br>
} catch (ClassNotFoundException var3) {�<br>
throw new NoClassDefFoundError(var3.getMessage());�<br>
}�<br>
}�<br>
}�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.代理类的名称为1； </span><br><span class="line">2.代理类继承了Proxy类，并实现了Service(自定义)接口； </span><br><span class="line">3.根据父类信息，代理类定义了四个成员变量，都是Method类型，其中m3为Service中的service方法； </span><br><span class="line">4.在代理类内部依赖了InvocationHandler，也就是完成了代理类跟目标类的绑定； </span><br><span class="line">5.在调用阶段直接调用了InvocationHandler的invoke方法；</span><br><span class="line">6.在代理类内部依赖了InvocationHandler； </span><br><span class="line">7.InvocationHandler后面的内容可以参考上面的解释。 </span><br><span class="line">#### JdkProxy例子 </span><br><span class="line">下面的代码使用Jdk进行动态代理： </span><br></pre></td></tr></table></figure>
<p>// 实现一个被委托类，实现实际的处理逻辑<br>
class Target implements Inter {<br>
public void print() {<br>
System.out.println(“target”);<br>
}<br>
}<br>
// 实现一个委托类，它的方法不会被实际调用<br>
class Invoker implements Inter {<br>
public void print() {<br>
System.out.println(“invoker”);<br>
}<br>
}<br>
class DynamicProxy implements InvocationHandler {<br>
private Object obj; // 委托对象，即 invoker 对象<br>
public DynamicProxy(Object o) {<br>
this.obj = o;<br>
}<br>
@Override<br>
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>
System.out.println(“before”);<br>
Object result = method.invoke(obj, args);<br>
System.out.println(“after”);<br>
return result;<br>
}<br>
}<br>
class JdkProxyTest {<br>
public static void main(String[] args) {<br>
// 创建中介对象<br>
DynamicProxy proxy = new DynamicProxy(new Target());<br>
// 生成$Proxy0.class 文件，即代理类文件<br>
System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);<br>
Inter invoker = (Inter) Proxy.newProxyInstance(<br>
Inter.class.getClassLoader(), new Class[]{Inter.class}, proxy);<br>
// 通过代理对象调用被委托对象的方法<br>
invoker.print();<br>
}<br>
}�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 另一个JdkProxy例子 </span><br></pre></td></tr></table></figure>
<p>/*</p>
<ul>
<li>实现 jdk 动态代理模式的代理对象</li>
<li>功能主要有两个：</li>
<li>被代理对象方法拦截，方法的执行在当前代理对象中完成；</li>
<li>生成代理对象，通过当前的代理方法返回一个代理对象，代码中</li>
<li>运行的是代理对象中的方法；<br>
<em>/<br>
public class MyProxy implements InvocationHandler {<br>
// 1.被代理对象（当前对象实现指定接口）<br>
Object target;<br>
public MyProxy(Object t) {<br>
this.target = t;<br>
}<br>
// 2.返回代理后的对象<br>
public Object getInstances() {<br>
//jdk 动态代理提供 Proxy 类<br>
/</em> newProxyInstance方法参数<br>
* ① 当前代理类的类加载器<br>
* ② 被代理类的接口的集合<br>
* ③ 当前代理对象，作用当前外部执行代理对象中的方法，<br>
* 反向调用当前代理对象中 invoke 方法，完成执行方法的拦截<br>
* <em>/<br>
return Proxy.newProxyInstance(<br>
target.getClass().getClassLoader(),<br>
target.getClass().getInterfaces(),<br>
this);<br>
}<br>
/</em>*
<ul>
<li>功能：拦截被代理对象的中所有的执行方法</li>
<li>@param proxy 拦截方法的代理对象（向外输出）</li>
<li>@param method 所拦截的方法</li>
<li>@param args 拦截方法执行时的实际参数值</li>
<li>@return 方法执行后返回的结果<br>
*/<br>
@Override<br>
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>
// 方法执行前的代码<br>
Object v = null;<br>
Date d = new Date();<br>
SimpleDateFormat sf = new SimpleDateFormat(“hh:mm:ss SSS”);<br>
String s = sf.format(d);<br>
System.out.println(s+“开始执行：” + method.getName() +<br>
&quot;,传递的参数：&quot; + Arrays.toString(args));<br>
// 执行被拦截的方法<br>
v = method.invoke(target, args);<br>
// 方法执行后的代码<br>
d = new Date();<br>
s = sf.format(d);<br>
System.out.println(s + &quot;, &quot; + method.getName() + “方法执行结束”);<br>
return v;<br>
}<br>
}�</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试 </span><br></pre></td></tr></table></figure>
<p>Hello h = (Hello) new MyProxy(new HelloWorld()).getInstances();<br>
h.doPrint();�</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 使用CGLIB实现动态代理 </span><br><span class="line">1. 动态生成一个要代理类的子类（使用字节码处理框架ASM，来转换字节码并生成新的类），子类重写要代理的类的所有不是final的方法 </span><br><span class="line">1. 在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑 </span><br><span class="line"> </span><br><span class="line">下面的代码是使用CGLIB实现动态代理的示例： </span><br><span class="line">``` </span><br><span class="line">// 需要CGlib动态代理的目标类</span><br><span class="line">class TargetObject &#123;</span><br><span class="line">  public String method1(String paramName) &#123;</span><br><span class="line">    return paramName;</span><br><span class="line">  &#125;</span><br><span class="line">  public int method2(int count) &#123;</span><br><span class="line">    return count;</span><br><span class="line">  &#125;</span><br><span class="line">  public int method3(int count) &#123;</span><br><span class="line">    return count;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;TargetObject []&quot; + getClass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 目标对象拦截器，实现MethodInterceptor</span><br><span class="line">class TargetInterceptor implements MethodInterceptor &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 重写方法拦截在方法前和方法后加入业务</span><br><span class="line">   *</span><br><span class="line">   * @param obj obj为目标对象</span><br><span class="line">   * @param method method为目标方法</span><br><span class="line">   * @param params params 为参数，</span><br><span class="line">   * @param proxy CGlib方法代理对象</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public Object intercept(Object obj, Method method, Object[] params,</span><br><span class="line">                          MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;调用前: &quot; + method);</span><br><span class="line">    Object result = proxy.invokeSuper(obj, params);</span><br><span class="line">    System.out.println(&quot;调用result: &quot; + result);</span><br><span class="line">    System.out.println(&quot;调用后&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CGLIBTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    // 这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    // 将被代理类TargetObject设置成父类</span><br><span class="line">    enhancer.setSuperclass(TargetObject.class);</span><br><span class="line">    // 设置拦截器TargetInterceptor</span><br><span class="line">    enhancer.setCallback(new TargetInterceptor());</span><br><span class="line">    // 动态生成代理类</span><br><span class="line">    TargetObject targetObject2 = (TargetObject) enhancer.create();</span><br><span class="line">    System.out.println(targetObject2); // 直接输出其实调用了toString()方法，也会触发intercept方法</span><br><span class="line">    targetObject2.method1(&quot;hello&quot;);</span><br><span class="line">    targetObject2.method2(100);</span><br><span class="line">    targetObject2.method3(200);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 比较JdkProxy和CGLIB </span><br><span class="line">1. 性能 </span><br><span class="line">CGLIB的性能比JDK自带的动态代理要高。   </span><br><span class="line">1. 功能 </span><br><span class="line">JDK动态代理只能接口代理，如果目标类没有实现接口是不能创建代理的，而CGLIB支持类代理。   </span><br><span class="line">1. 代理的实现原理</span><br><span class="line">JdkProxy是通过实现接口来进行代理的，如果目标类没有实现接口或者想要拦截的方法不在接口声明中则不能被代理。CGLIB是通过继承子类来进行动态代理的，因此，CGLIB对final方法无法进行代理（final方法不能被继承）。</span><br><span class="line">1. 多级代理</span><br><span class="line">JdkProxy中可以很方便地实现多级代理：</span><br></pre></td></tr></table></figure>
<p>DynamicProxy proxy = new DynamicProxy(new Target());<br>
Inter invoker = (Inter) Proxy.newProxyInstance(<br>
Inter.class.getClassLoader(), new Class[]{Inter.class}, proxy);<br>
DynamicProxy proxy1 = new DynamicProxy(invoker);<br>
Inter invoker1 = (Inter) Proxy.newProxyInstance(<br>
Inter.class.getClassLoader(), new Class[]{Inter.class}, proxy1);<br>
invoker1.print();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">但是在使用Spring框架的过程中发现多级代理后注册到Bean容器内会出现问题，类型会变成Proxy类，可以改为CGLIB实现，但是CGLIB在实现多级代理时必须在两个代理之间加入一层中间代理： </span><br><span class="line">``` </span><br><span class="line">CglibMultiInterceptor proxy = new CglibMultiInterceptor();</span><br><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(TargetObject.class);</span><br><span class="line">enhancer.setCallback(proxy);</span><br><span class="line">TargetObject target = (TargetObject) enhancer.create();</span><br><span class="line">proxy.setTargetObj(new TargetObject());</span><br><span class="line">// 第二级</span><br><span class="line">CglibMultiInterceptor proxy1 = new CglibMultiInterceptor();</span><br><span class="line">Enhancer enhancer1 = new Enhancer();</span><br><span class="line">enhancer1.setSuperclass(TargetObject.class);</span><br><span class="line">enhancer1.setCallback(proxy1);</span><br><span class="line">proxy1.setTargetObj(target);</span><br><span class="line">TargetObject target1 = (TargetObject) enhancer1.create();</span><br><span class="line">target1.method1(&quot;123&quot;); </span><br><span class="line">``` </span><br><span class="line">其中使用到了一个中间代理CglibMultiInterceptor，如下所示： </span><br><span class="line">``` </span><br><span class="line">public class CglibMultiInterceptor implements MethodInterceptor &#123;</span><br><span class="line">  private Object targetObj;</span><br><span class="line">  private MethodInterceptor nextInterceptor;</span><br><span class="line">  @Override</span><br><span class="line">  public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">    // 出于需求考虑可以排除Object类中的toString等方法</span><br><span class="line">    // boolean belongs2Object = Object.class.getName().equals(method.getDeclaringClass().getName());</span><br><span class="line">    Object res;</span><br><span class="line">    System.out.println(&quot;调用前&quot;);</span><br><span class="line">    if (nextInterceptor != null) &#123;</span><br><span class="line">      res = nextInterceptor.intercept(targetObj, method, args, methodProxy);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 使用invokeSuper()会调用f2.invoke()，会调用SuperClass的对应方法</span><br><span class="line">      // 使用invoke()会调用f1.invoke()，会先调用Proxy的方法</span><br><span class="line">      // res = methodProxy.invokeSuper(targetObj, args);</span><br><span class="line">      res = methodProxy.invoke(targetObj, args);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;调用后&quot;);</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setTargetObj(Object target) &#123;</span><br><span class="line">    this.targetObj = target;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setNextInterceptor(MethodInterceptor methodInterceptor) &#123;</span><br><span class="line">    this.nextInterceptor = methodInterceptor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line">#### 应用 </span><br><span class="line">Hibernate 底层使用了 javassist（默认）和 cglib，Spring 使用了 cglib 和 jdk 动态代理。 </span><br><span class="line"> </span><br><span class="line">#### 原理 </span><br><span class="line">cglib 底层实现依赖于 ASM。 </span><br><span class="line"></span><br><span class="line">### javassist 动态代理 </span><br><span class="line">#### 示例 </span><br><span class="line">public interface BookApi &#123;</span><br><span class="line">   void sell();</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">private static BookApi createJavassistBytecodeDynamicProxy() throws Exception &#123;</span><br><span class="line">    ClassPool mPool = new ClassPool(true);</span><br><span class="line">    CtClass mCtc = mPool.makeClass(BookApi.class.getName() + &quot;JavaassistProxy&quot;);</span><br><span class="line">    mCtc.addInterface(mPool.get(BookApi.class.getName()));</span><br><span class="line">    mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));</span><br><span class="line">    mCtc.addMethod(CtNewMethod.make(</span><br><span class="line">            &quot;public void sell() &#123; System.out.print(\&quot;\&quot;) ; &#125;&quot;, mCtc));</span><br><span class="line">    Class&lt;?&gt; pc = mCtc.toClass();</span><br><span class="line">    BookApi bytecodeProxy = (BookApi) pc.newInstance();</span><br><span class="line">    return bytecodeProxy;</span><br><span class="line">&#125;</span><br><span class="line">需要引入 javassist 依赖： </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.21.0-GA&lt;/version&gt; </span><br><span class="line">#### 应用 </span><br><span class="line">除了Hibernate外，dubbo也使用javassist作为底层动态代理实现框架，其主要考虑因素是性能。 </span><br><span class="line">#### 原理 </span><br><span class="line">类似ASM，javassist同样要求直接操作字节码文件。 </span><br><span class="line"></span><br><span class="line">## QA</span><br><span class="line">1. 反射创建Class实例的三种方式是什么？ </span><br><span class="line">方式1：通过 Class 类的静态方法获取 Class 类对象 (推荐)</span><br><span class="line">方式2：因为所有类都继承 Object 类。因而可通过调用 Object 类中的 getClass 方法来获取</span><br><span class="line">方式3：任何数据类型（包括基本数据类型）都有一个“静态”的 class 属性 </span><br><span class="line">1. 反射中，Class.forName 和 ClassLoader 区别？ </span><br><span class="line">Class.forName(className)方法，其实调用的方法是 Class.forName(className,true,classloader); 第 2 个参数表示在 loadClass 后必须初始化。根据 JVM 加载类的知识，我们知道在执行过此方法后，目标对象的 static 块代码已经被执行，static 参数也已经被初始化。</span><br><span class="line">而 ClassLoader.loadClass(className) 方法，实际调用的方法是 ClassLoader.loadClass(className,false); 第 2 个参数表示目标对象被装载后不进行链接，这就意味着不会去执行该类静态块中间的内容。</span><br><span class="line">例如，在 JDBC 使用中，常看到这样的用法，Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 如果换成了 getClass().getClassLoader().loadClass(&quot;com.mysql.jdbc.Driver&quot;)，就不行。根据 com.mysql.jdbc.Driver 的源代码，Driver 在 static 块中会注册自己到 java.sql.DriverManager。而 static 块就是在 Class 的初始化中被执行。所以这个地方就只能用 Class.forName(className)。</span><br><span class="line">1. 描述动态代理的几种实现方式，分别说出相应的优缺点</span><br><span class="line">JDK 动态代理和 CGLIB 动态代理。JDK 动态代理是由 Java 内部的反射机制来实现的，CGLIB 动态代理底层则是借助 ASM 框架来实现的，实现了无反射机制进行代理，利用空间来换取了时间，代理效率高于 JDK 。总的来说，**反射机制在生成类的过程中比较高效，而 ASM 在生成类之后的相关执行过程中比较高效**（可以通过将 ASM 生成的类进行缓存，这样解决 ASM 生成类过程低效问题）。还有一点必须注意：**JDK 动态代理的应用前提，必须是目标类基于统一的接口**。如果没有上述前提，JDK 动态代理不能应用。由此可以看出，JDK 动态代理有一定的局限性，**CGLIB 这种第三方类库实现的动态代理应用更加广泛**，且在效率上更有优势。 </span><br><span class="line"></span><br><span class="line">## Spring AOP</span><br><span class="line">### 面向切口 </span><br><span class="line">注意这样的情形，软件的多个模块都有部分相同的行为，AOP希望使用“横切”的方法来减少这种代码的冗余。   </span><br><span class="line">具体的，就是把这些与业务无关的、却被业务模块所共同调用的子程序封装起来。比较典型的应用比如事务和日志。   </span><br><span class="line">1. 横切关注点   </span><br><span class="line">希望被拦截的方法及拦截后怎么处理，比如调用后台管理接口前需要先做日志；   </span><br><span class="line">1. 切面（aspect）   </span><br><span class="line">类是对物体的抽象，而切面是横切关注点的抽象，比如所有需要做日志的接口；   </span><br><span class="line">1. 连接点（joinpoint）   </span><br><span class="line">可以被拦截到的方法，可以是方法、字段或构造器；   </span><br><span class="line">1. 切入点（pointcut）   </span><br><span class="line">对连接点的拦截的定义，对哪些方法进行拦截，主要用于筛选连接点；   </span><br><span class="line">1. 通知（advice）   </span><br><span class="line">拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕五种；   </span><br><span class="line">1. 目标对象   </span><br><span class="line">被代理的对象；   </span><br><span class="line">1. 织入（weave）   </span><br><span class="line">将切面应用到目标对象并导致代理对象创建的过程，也就是引入的具体过程；   </span><br><span class="line">1. 引入（introduction）   </span><br><span class="line">在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段；   </span><br><span class="line"> </span><br><span class="line">### JavaWeb的Filter </span><br><span class="line">JavaWeb中的Filter就是aop的一个例子。   </span><br><span class="line">比如定义了一个过滤器LoginFilter用于过滤所有/*的请求，此时来了一个请求/user/login，本来应该触发UserController.login，但是被LoginFilter拦截了，拦截器方法是doFilter。   </span><br><span class="line">``` </span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response,   </span><br><span class="line">            FilterChain chain) throws IOException, ServletException &#123; </span><br><span class="line">    doBefore(); </span><br><span class="line">    chain.doFilter(request, response); </span><br><span class="line">    doAfter(); </span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line">其中，横切关注点是登录验证，切面是所有需要登录验证的接口，连接点是login，切入点是&quot;/*&quot;，通知是doBefore和doAfter这些方法，目标对象是UserController，织入过程由web容器完成，即为请求创建FilterChain的过程，引入即为UserController添加登录验证功能的过程。   </span><br><span class="line"> </span><br><span class="line">### Spring-AOP </span><br><span class="line">Spring的核心模块Spring-AOP支持面向切面编程，配置又有配置文件（&lt;aop:config&gt;）和注解（@Aspect）两种方式，下面是配置文件的简单设置 </span><br></pre></td></tr></table></figure>
<p>&lt;aop:config&gt;<br>
<!--比如com.hgc.auth.user.service.IAuthUserService.create(AuthUser)plainplainplain
    .*这种格式的需要和路径匹配、不能少，..*可以匹配中间任意多个包--><br>
&lt;aop:advisor advice-ref=&quot;txAdvice&quot;<br>
pointcut=“execution(* com.hgc…<em>.service.</em>.*(…))”/&gt;<br>
&lt;/aop:config&gt;</p>
<pre><code class="language-�">�
## 参考
1. [Java 使用JDK的动态代理如何实现多级代理](https://segmentfault.com/q/1010000004605731)�
1. [Springboot与shiro整合遇到的坑（SpringBoot使用多级代理时必须强制使用CGLIB）](https://zhuanlan.zhihu.com/p/29161098)�
1. [CGLIB原理和功能介绍](http://blog.csdn.net/zghwaicsdn/article/details/50957474)�
1. [CGLib动态代理的介绍及用法（单回调、多回调、不处理、固定值、懒加载）](https://blog.csdn.net/difffate/article/details/70552056)
1. [cglib动态代理实现（多级代理）](https://chenfeifeng.github.io/2017/06/12/cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0/)
</code></pre>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/动态代理/" rel="tag"># 动态代理</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/6e8a6bb7.html" rel="next" title="服务治理——限流">
                <i class="fa fa-chevron-left"></i> 服务治理——限流
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/5ac9459.html" rel="prev" title="多级缓存原理">
                多级缓存原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">1.</span> <span class="nav-text">¶反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类存储结构和反射"><span class="nav-number">1.1.</span> <span class="nav-text">¶类存储结构和反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类信息"><span class="nav-number">1.2.</span> <span class="nav-text">¶获取类信息�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类加载器"><span class="nav-number">1.3.</span> <span class="nav-text">¶获取类加载器�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例化对象"><span class="nav-number">1.4.</span> <span class="nav-text">¶实例化对象�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析属性"><span class="nav-number">1.5.</span> <span class="nav-text">¶分析属性�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析方法"><span class="nav-number">1.6.</span> <span class="nav-text">¶分析方法�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绕过-private-final-限制"><span class="nav-number">1.7.</span> <span class="nav-text">¶绕过 private、final 限制�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#越过范型检查"><span class="nav-number">1.8.</span> <span class="nav-text">¶越过范型检查�</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过反射机制获得数组信息并修改数组的大小和值"><span class="nav-number">1.9.</span> <span class="nav-text">¶通过反射机制获得数组信息并修改数组的大小和值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射应用于工厂模式"><span class="nav-number">1.10.</span> <span class="nav-text">¶反射应用于工厂模式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
