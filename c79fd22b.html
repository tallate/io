<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="头两家虽然也是小公司，虽然最后都阴差阳错没拿到offer，但是给我的印象特别深刻，所以单独进行了记录，这里记录另外面试的几家小公司的经过，因为个人在精力的投入上比较少，所以相对来说收获、印象也浅一些，放到一块来统一进行一个总结和复盘，所有问题都按我的个人理解进行回答，如果有不同意的，来怼我啊！">
<meta property="og:type" content="article">
<meta property="og:title" content="面筋-几家小公司">
<meta property="og:url" content="https://tallate.github.io/c79fd22b.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="头两家虽然也是小公司，虽然最后都阴差阳错没拿到offer，但是给我的印象特别深刻，所以单独进行了记录，这里记录另外面试的几家小公司的经过，因为个人在精力的投入上比较少，所以相对来说收获、印象也浅一些，放到一块来统一进行一个总结和复盘，所有问题都按我的个人理解进行回答，如果有不同意的，来怼我啊！">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-29T12:38:47.553Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面筋-几家小公司">
<meta name="twitter:description" content="头两家虽然也是小公司，虽然最后都阴差阳错没拿到offer，但是给我的印象特别深刻，所以单独进行了记录，这里记录另外面试的几家小公司的经过，因为个人在精力的投入上比较少，所以相对来说收获、印象也浅一些，放到一块来统一进行一个总结和复盘，所有问题都按我的个人理解进行回答，如果有不同意的，来怼我啊！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/c79fd22b.html"/>







  <title>面筋-几家小公司 | Tallate</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/c79fd22b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面筋-几家小公司</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T21:49:30+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  15.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  57 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>头两家虽然也是小公司，虽然最后都阴差阳错没拿到offer，但是给我的印象特别深刻，所以单独进行了记录，这里记录另外面试的几家小公司的经过，因为个人在精力的投入上比较少，所以相对来说收获、印象也浅一些，放到一块来统一进行一个总结和复盘，所有问题都按我的个人理解进行回答，如果有不同意的，来怼我啊！</p>
<a id="more"></a>
<h3 id="第三家-念力"><a class="header-anchor" href="#第三家-念力">¶</a>第三家-念力</h3>
<p>主要业务是云手游和可玩广告，主要实现思路（和技术负责人确认大概如此）是在服务器上跑运行手游的Android实例，对Android进行录屏，传输回浏览器客户端进行解析显示，主要难点是虚拟机实例（可能是容器，不确定运行Android实例的是虚拟机还是容器）管理优化、流媒体传输优化。</p>
<h4 id="一面"><a class="header-anchor" href="#一面">¶</a>一面</h4>
<p>一面爆炸，因为技术栈不对口，念力需要的是在C++（服务端）、Javascript（客户端）方面有经验的程序员，但我面的是Java…。<br>
可能也是希望缩短面试流程，一面直接上来了两名技术。</p>
<ol>
<li>介绍自己最熟悉的一个项目</li>
<li>写一道算法题：如何判断链表有没有环？<br>
用map记录已经遍历过的节点即可。</li>
<li>算法的复杂度是多少？<br>
O(nlogn)</li>
<li>map操作的复杂度为什么是O(logn)？<br>
上一题我用的是C<ins>的语法，所以面试官问的应该是C</ins>中map结构操作的复杂度，因为map底层是用红黑树实现的，所以复杂度应该是O(logn)没错。<br>
Java中HashMap的底层实现是散列表——更准确地说应该是分离链接散列表——所以复杂度不能简单的说是O(logn)，平均情况下散列表的复杂度需要考虑<strong>负载因子</strong>——即实际装载的对象数 / 哈希槽数，理想情况下每个哈希槽存放一个对象或为空，那么每次计算一次hash函数就可以确定找到目标对象或没找着了，不理想情况下所有对象都堆积到一个哈希槽中，散列表就会退化成链表，那么操作的复杂度就变成O(n)了，所以HashMap的效率主要看两个：
<ul>
<li>负载因子load_factor和初始容量initial_capacity的设置，如果当前场景是读频繁，不妨把initial_capacity设置得小一些，迭代遍历时能快一些，若写频繁，不妨设置得大一些，以免经常需要rehash。</li>
<li>对象上定义的hashCode()合不合理，一般来说会设置成一个比较大的素数。</li>
</ul>
</li>
</ol>
<h3 id="第四家-洋钱罐"><a class="header-anchor" href="#第四家-洋钱罐">¶</a>第四家-洋钱罐</h3>
<p>互联网金融，商业模式为P2P，业务大概为一方用户投钱，经过审批，将钱分给另一批贷款用户，平台收取服务费，比较需要关注的是资金链的健康问题，主要措施包括：如果投钱用户少了则增加宣传力度，贷款的用户太多则在审批流程上卡人。</p>
<h4 id="一面-v2"><a class="header-anchor" href="#一面-v2">¶</a>一面</h4>
<p>一面爆炸，发现很多Java基础都忘光了，真是丢人，接下来得好好补补。<br>
主要考集合框架、多线程、并发、设计模式、算法、中间件、框架这些方面，部分问题比较抠细节，如果不是平时注意细节（或抱佛脚）估计有点难回答上来。</p>
<ol>
<li>
<p>说下对集合框架的理解。<br>
容器的目的：容纳其他Java对象。<br>
容器的设计要素：泛型，可以容纳不同类型的对象，编译器会执行泛型擦除，并在使用到容器内对象的地方插入强制转换命令；内存管理，Java不需要额外管理容器的内存空间，因为GC自动包揽了一切，还有就是容器中存放的是对象的引用，因此不存在C++容器的复制拷贝问题。<br>
容器的继承结构：Collection和Map其实没有关系，平时使用比较多的接口包括List、Queue、Set、Map：</p>
<ul>
<li>List：ArrayList的底层实现是变长数组，LinkedList的底层实现是双向链表；</li>
<li>Queue：LinkedList其实也实现了Queue接口（其实是其子接口Deque），PriorityQueue虽然也叫队列，但其底层实现是堆。</li>
<li>Set：Set一般是对Map进行了一层浅包装，Value不重要，直接使用一个Object类型的PRESENT对象来表示，比如HashSet对HashMap进行了包装，TreeSet对TreeMap进行了包装。</li>
<li>Map：HashMap的底层实现是散列表，而且在1.8之后每个哈希槽如果增长到一定长度（&gt;=7个），会自动转变为红黑树结构；TreeMap的底层实现是红黑树，所有增删改差操作复杂度基本都是O(logN)。</li>
</ul>
</li>
<li>
<p>LinkedList除了List还实现了哪个接口？<br>
Deque，因为LinkedList的底层实现是双向链表，同时支持两头的增删操作。</p>
</li>
<li>
<p>ConcurrentHashMap怎么实现并发安全？<br>
相对Hashtable来说ConcurrentHashMap的锁粒度是更小的，Hashtable中使用synchronized实现的一种方法级的悲观锁，相当于把整个散列表锁住了，不利于系统整体吞吐量的提升。<br>
JDK1.7中它使用的是一种分段锁来保证并发安全，是一种粒度较小的锁，写操作每次只锁住一个哈希槽，<br>
JDK1.8之后改为通过实现一种基于CAS的乐观锁来保证并发安全，当然，和HashMap一样，每个哈希槽在增长到一定程度后会自动转换为红黑树。</p>
</li>
<li>
<p>synchronized和ReentrantLock的底层实现了解吗？<br>
锁的底层是使用AQS支持的，？？？</p>
</li>
<li>
<p>CAS操作是什么含义？<br>
Compare And Swap，在更新的时候会比较手头上的数据和内存中的数据是否相等，只有相等的时候才会更新成功。</p>
</li>
<li>
<p>乐观锁和悲观锁分别是什么？<br>
乐观锁在实际更新的时候才会进行加锁，加锁时主要和旧值进行比对，如果相同才会更新成功，一般会使用时间戳或版本号来表示乐观锁，在ConcurrentHashMap中乐观锁通过CAS机制来实现。<br>
悲观锁会在线程进入临界区代码前加锁，并在退出后释放。</p>
</li>
<li>
<p>线程池有哪些实现？<br>
Executors中提供了几种常用线程池的工厂方法：</p>
<ul>
<li>newCachedThreadPool：有任务就插入workQueue，并尝试使用创建线程来执行任务；</li>
<li>newFixedThreadPool：固定数量线程，若都处于繁忙状态则将新任务添加进workQueue中；</li>
<li>newSingleThreadPool：只允许一个线程处于执行状态，其他线程会自动进入阻塞队列。</li>
<li>newScheduledThreadPool：可以调用scheduleAtFixedRate控制周期性地执行任务，如果所有线程均处于繁忙状态，则新任务会进入DelayedWorkQueue队列，这是一种按照超时时间排序的队列结构。</li>
</ul>
</li>
<li>
<p>ThreadPoolExecutor各参数的含义分别是（要求默写到纸上）？<br>
corePoolSize：核心线程数，如果来了新任务且当前线程池容量小于corePoolSize则会新建一个新的线程，否则就会将任务暂时压入workQueue。<br>
maximumPoolSize：最大工作线程数，当workQueue已满时就会调用maximumPoolSize资源。<br>
workQueue：如果workQueue未满，则会等待核心线程被释放，若workQueue已满且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务，当提交的任务超过maximumPoolSize时，新提交任务交由RejectedExecutionHandler来处理。<br>
keepAliveTime：如果某个线程处于空闲状态的时间超过了这个时间且当前线程数已超过corePoolSize则直接退出该线程，保持线程池中的线程数为corePoolSize。<br>
RejectedExecutionHandler：饱和策略，比如AbortPolicy表示丢弃任务并抛出RejectedExecutionException异常，DiscardPolicy表示丢弃任务但不抛出异常，DiscardOldestPolicy表示丢弃队列最前面的任务，然后重新尝试执行任务，CallerRunsPolicy表示由调用线程处理该任务。</p>
</li>
<li>
<p>设计模式了解哪些？<br>
单例<br>
工厂<br>
建造者<br>
代理<br>
中介者</p>
</li>
<li>
<p>代理模式有几种实现方式？<br>
JDK Proxy和CGLIB，</p>
</li>
<li>
<p>Redis是怎么用的？</p>
</li>
<li>
<p>ZooKeeper是怎么用的？</p>
</li>
<li>
<p>ZooKeeper只用到一个分布式锁吗？还有别的应用吗？</p>
</li>
<li>
<p>MyBatis的执行过程（有哪些主要组件，分别负责什么工作）？</p>
</li>
<li>
<p>SpringCloud了解哪些？</p>
</li>
<li>
<p>SpringCloud有哪些组件？比如用Eureka处理服务发现，用Hystrix处理服务降级。</p>
</li>
<li>
<p>（编程题）求一棵树的层序遍历。<br>
很简单，用一个队列来缓存遍历到的子树根节点即可。需要注意：</p>
<ul>
<li>队列接口名不要写错——当然白板过程一般不会强制要求把接口名都写对；</li>
<li>遇到null节点就直接打印一个null；</li>
<li>队列需要指定类型参数，即泛型，否则会有警告；</li>
<li>队列的Java中没有提供Queue的实现，除了BlockingQueue，可以直接使用LinkedList，因为LinkedList实现了Deque接口——它其实是一个双端队列。<br>
下面用Java重写了一遍，已确认可以跑通：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      TreeNode cur = queue.removeFirst();</span><br><span class="line">      System.out.println(<span class="keyword">null</span> == cur ? <span class="keyword">null</span> : cur.val);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != cur) &#123;</span><br><span class="line">        queue.add(cur.left);</span><br><span class="line">        queue.add(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> Main().traverse(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要把每一层都分开来打印怎么做？每一层遍历打印完毕之后就向队列中压入一个特殊的节点，表示开始下一层。</p>
<ol>
<li>（编程题）求最长公共子序列长度。<br>
比较简单的动态规划题，但是需要注意子序列的定义。<br>
子序列：将部分字符拿出连接而成的序列；<br>
子串：相邻字符组成的子序列。<br>
比如abcdef和acdz的最长公共子序列长度就是3（acd）。<br>
计算最长公共子序列的最常见方法就是DP，状态递推式为dp[i][j] = s1[i] == s2[j] ? dp[i - 1][j - 1] + 1 : max(dp[i][j - 1], dp[i - 1][j])，或者也用递归来实现，重合的部分用一个二维数组进行缓存，实现起来会简单一些，但是相对迭代方式来说效率会低一些。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j ? i : j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">      dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = s1.charAt(<span class="number">0</span>) == s2.charAt(<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = s1.charAt(i) == s2.charAt(<span class="number">0</span>) ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      res = max(res, dp[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][j] = s1.charAt(<span class="number">0</span>) == s2.charAt(j) ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">      res = max(res, dp[<span class="number">0</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">        dp[i][j] = s1.charAt(i) == s2.charAt(j) ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        res = max(res, dp[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Main().solve(<span class="string">"abcdef"</span>, <span class="string">"acdz"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第五家-小米-智米"><a class="header-anchor" href="#第五家-小米-智米">¶</a>第五家-小米（智米）</h3>
<p>智能硬件，主要业务是做一个内部的信息管理系统，业务包括但不限于：把天猫商城上的小米智能商品的订单转换为仓库发货清单、显示智能硬件被发到哪些地方了。业务并发量不高，对算法等的需求也并不高，而且接下来技术栈会往.net转。</p>
<h4 id="一面-技术"><a class="header-anchor" href="#一面-技术">¶</a>一面-技术</h4>
<p>这轮技术面一次来了两个人，但是基本全程在玩手机，没问什么问题。</p>
<ol>
<li>（笔试）求两个链表的交点。<br>
常规链表题，需要注意
<ul>
<li>链表是否为空；</li>
<li>链表是否有环这些情况。<br>
示例代码如下。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">findIntersects</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> == h1 || <span class="keyword">null</span> == h2) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;ListNode&gt; existed1 = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    Set&lt;ListNode&gt; existed2 = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != h1) &#123;</span><br><span class="line">      <span class="keyword">if</span>(existed1.contains(h1)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      existed1.put(h1);</span><br><span class="line">      h1 = h1.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != h2) &#123;</span><br><span class="line">      <span class="keyword">if</span>(existed2.contains(h2)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      existed2.put(h2);</span><br><span class="line">      <span class="keyword">if</span>(existed1.contains(h2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">      &#125;</span><br><span class="line">      h2 = h2.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>（笔试）求菲波那契前n项的和。<br>
需要注意：
<ul>
<li>是求前n项和，而不是求第n项；</li>
<li>参数不能为负数；</li>
<li>注意溢出</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumFiboN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能小于0"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] fibo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  fibo[<span class="number">1</span>] = fibo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    fibo[i] = fibo[i - <span class="number">1</span>] + fibo[i - <span class="number">2</span>];</span><br><span class="line">    res += fibo[i];</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"溢出！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>HashSet的contains方法的执行过程？<br>
先用<code>hashCode &amp; length - 1</code>定位到散列表的某个哈希槽，然后从这个哈希槽中使用equals找到目标key，根据哈希槽是链表还是红黑树查询的效率也有所不同。</li>
<li>项目中的一些细节…</li>
</ol>
<h4 id="二面-经理"><a class="header-anchor" href="#二面-经理">¶</a>二面-经理</h4>
<p>二面经理不大懂技术细节，上来就是产品架构（业务有哪些，用了哪些工具），聊的主要内容也是对产品的理解。</p>
<ol>
<li>用友产品的竞品有哪些？<br>
用友的竞争对手当然也是ToB的厂商，比如金蝶，然后我想到前不久面试的一家明世数据，跟我在用友所待的部门做的是类似的产品，我就把那家的情况详细说了说。</li>
</ol>
<h4 id="三面-hr"><a class="header-anchor" href="#三面-hr">¶</a>三面-HR</h4>
<p>HR面主要试探我的人品，问了一些个人的优点缺点爱好等，后面据说还有一轮CEO+CFO面，再在人品上把把关。</p>
<h3 id="第六家-本木医疗"><a class="header-anchor" href="#第六家-本木医疗">¶</a>第六家-本木医疗</h3>
<p>互联网医疗，做的是三甲医院的挂号-问诊-开处方-发药等一系列流程的自动化，并且还涉及到轮椅等硬件的调配（当然是委托第三方制作的）。</p>
<h4 id="一-二面-技术"><a class="header-anchor" href="#一-二面-技术">¶</a>一、二面-技术</h4>
<p>一、二面由两位小团队Leader负责，问的内容主要涉及Java基础、框架。因为问题很多、且这两面问的问题有些相似之处，所以我放到一块，不关注提问顺序。</p>
<ol>
<li>HashMap的实现原理。<br>
HashMap插入重复的元素会覆盖，可以插入null（key和value都可以为null）。HashMap的底层数据结构是散列表，使用一个静态数组来表示，数组每一项是一个哈希槽，哈希槽刚开始使用链表表示，插入操作时对key计算key.hashCode() % length来定位到散列表的某个哈希槽，并插入到链表的首位置，如果长度达到某个程度哈希槽的结构会转换为红黑树。</li>
<li>为什么要转成红黑树？<br>
一方面维持红黑树结构需要一定的时间和空间损耗，所以不会为每个哈希槽都维持一个红黑树；另一方面红黑树的所有操作的时间复杂度都是O(logN)，相对链表来说有更高的查询效率，所以在链表到达一定长度（TREEIFY_THRESHOLD = 8）后会被转换为红黑树，当然在减少到一定数量（UNTREEIFY_THRESHOLD = 6）后会重新转换回链表。</li>
<li>除了红黑树还认识什么树？<br>
AVL树：以高度作为平衡的标准，递归过程中如果碰到两棵子树的高度差大于1的情况则进行一次调整。<br>
伸展树：将每次访问到的节点旋转到树的根部。<br>
B树、线索树、Trie树、Huffman树、堆（完全二叉树）等。</li>
<li>HashMap的rehash执行过程。<br>
HashMap的resize方法就是rehash函数，它会首先创建一个大一倍的newTab，然后将旧&lt;K, V&gt;插入到newTab中。<br>
散列表的大小需要保证为2的幂，这样在计算位置（hash）的时候可以直接用<code>e.hash &amp; (newCap - 1)</code>来计算出位置。</li>
<li>hashCode和equals的作用？<br>
默认情况下，hashCode是个native方法，可以返回对象的地址，equals直接使用’=='比较两个对象的地址，其实也是直接比较两个对象的地址。<br>
出于散列函数的有效性，还可以在子类中重写hashCode，比如String中的重写逻辑就是<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>，常见的散列函数有平方散列、双散列等，但是实际中会综合类中的所有关键属性来计算散列值。<br>
定义一些自定义类型时，可能没有必要非得地址相同才是相等的对象，比如两个User类型的对象如果ID相同就认为是相等的，由具体业务定义决定。</li>
<li>hashCode和equals的应用场景？<br>
使用HashMap时一般都需要考虑重新定义hashCode和equals方法、提高散列表的利用率。</li>
<li>wait和notify是干什么用的？<br>
协调同步多个线程。<br>
调用这两个方法前需要先获取对象上的监视器锁，wait会挂起线程，notify会随机唤醒等待该对象的一个线程。</li>
<li>为什么要获取监视器锁？<br>
因为wait操作会更新堆中对象域中的属性，加锁是为了保证不会发生多个线程争相更新对象域导致的不一致情况。</li>
<li>创建线程有哪几种方式？<br>
三种：继承Thread、实现Runnable、实现Callable。</li>
<li>线程池有哪几种（下面core表示corePoolSize、maximum表示maximumPoolSize）？<br>
newFixedThreadPool：固定长度的线程池，core = maximum = n，workQueue = LinkedBlockingQueue，同时只允许n个线程处于执行中状态，后续线程任务将被添加到workQueue中。<br>
newSingleThreadPool：相当于newFixedThreadPool的特殊情况，core = maximum = 1，workQueue = LinkedBlockingQueue，同时只允许一个线程处于执行中状态，后续线程任务将被添加到workQueue中。<br>
newCachedThreadPool：core = 0，maximum = Integer.MAX_VALUE，workQueue = SynchronousQueue是一种无缓冲的等待队列，可以认为它总是满的。因此，线程池只要有一个线程任务进来就会创建一个新线程。<br>
newScheduledThreadPool：core = n，maximum = Integer.MAX_VALUE，workQueue = DelayedWorkQueue，这是一种按照超时时间排序的队列结构。主要用于执行延迟任务或周期性任务。<br>
newWorkStealingPool：1.8引入的新线程池。需要传一个并行级别参数，并根据并行级别来创建多个队列，可以更好地利用多CPU的优势。</li>
<li>ThreadPoolExecutor的主要参数corePoolSize、maximumPoolSize、workQueue的作用？<br>
corePoolSize：定义核心线程数。<br>
maximumPoolSize：定义最大线程数。<br>
workQueue：等待队列。<br>
添加新线程任务后会发生什么：如果线程数 &lt; core，则创建新线程执行；否则若线程数 &lt; maximum且workQueue未满，则将线程任务添加到workQueue中；否则若线程数 &lt; maximum，则创建新线程执行；否则使用rejectedExecutionHandler来执行拒绝逻辑。</li>
<li>corePoolSize直接开1000合适吗？<br>
当时我回答需要根据应用场景来分析，如果一次执行的任务少就不需要开那么大了。<br>
但是面试官不大满意，其实应该结合硬件条件来分析，core数表示可以同时处于执行中状态的线程数，如果CPU只有2个核心，每个核心有2个线程，那么并发数应该被控制在2*2=4（当然实际应用不会那么简单，如果线程任务含有数据库操作那么还要考虑到磁盘IO带来的影响，会导致CPU空闲下来），则core开得太大可能会导致频繁的线程切换，从而影响系统整体吞吐量。</li>
<li>项目里用的什么垃圾收集器？<br>
在用友参与的项目没有对垃圾收集器有要求，如要硬要说用到了什么垃圾收集器的话，那就是默认的垃圾收集器，因为项目里用的是JDK1.7，因此默认垃圾收集器为Parallel Scavenge、Parallel Old：
<ul>
<li>Parallel Scavenge：新生代的多线程收集器，使用复制算法，以吞吐量优先。</li>
<li>Parallel Old：老年代的多线程收集器，使用标记-整理算法，以吞吐量优先，适合与Parallel Scavenge搭配使用。</li>
</ul>
</li>
<li>CMS了解吗？<br>
不了解。<br>
补充：CMS（Concurrent Mark Sweep）使用标记清除算法，并发标记和并发清除两个阶段可以和用户线程并发执行，不会阻塞用户线程，所以效率会快一些，是以获取最短回收停顿时间为目标的收集器，但是也会带来大量的内存碎片，需要另外配置参数执行压缩（如-XX:+UseCMSCompactAtFullCollection、-XX:+CMSFullGCsBeforeCompaction）。</li>
<li>那怎么处理高并发？<br>
项目对并发要求不高…</li>
<li>垃圾收集算法有哪些？<br>
主要有标记清除、复制、标记整理、分代收集算法这4种。<br>
标记清除：第一轮先使用可达性分析算法判断一个对象是否为可回收的，第二轮统一回收所有被标记的对象。优点是简单，缺点是效率低，且会产生大量不连续的内存碎片。<br>
复制：将可用内存划分为大小相等的两半，对每一块使用指针碰撞的方法为对象分配空间，如果这一块的内存用完，就将还存活的对象复制到另一半块上，并将原来的这一半一次清理掉。优点是简单且不需要考虑内存碎片的问题，缺点是比较浪费空间、存活率高的时候效率低。<br>
标记整理：标记过程和标记清理算法一样，但是不直接清除，而是让存活的对象向前移动，再清理端边界外的内存。<br>
分代收集：将堆分为新生代和老年代，根据各年代的特点采取适当的收集算法。</li>
<li>怎么检测一个对象是可以被回收的？<br>
垃圾检测算法主要有引用计数和可达性分析这两种。<br>
引用计数：给堆中每个对象的对象域中添加一个引用计数器，当发生对象创建、赋值、回收等时会更新这个引用计数器，如果归0则回收。缺点是无法解决循环引用的问题。<br>
可达性分析：使用一系列的GCRoots（虚拟机栈、方法区、本地方法栈）对象作为起点，向下遍历搜索其他相关的对象，如果一个对象没有引用链了则可以回收。</li>
<li>JVM内存被分成了哪几块？<br>
方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>
堆：存放对象实例。<br>
本地方法栈：访问本地方法（native）时使用到的栈。<br>
线程栈（或者简称为栈）：每个线程中调用方法会向栈中插入栈帧，和C语言中的栈结构很相似。<br>
程序计数器：记录线程中代码当前执行位置。</li>
<li>Class和.class的区别？<br>
.class文件存储的是Java代码被编译后的字节码，这些字节码会被类加载器经过一系列的过程（加载-验证-准备-解析-初始化）加载到内存中，在加载阶段JVM会在堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li>
<li>类加载器有什么用？<br>
将.class文件或二进制流格式的字节码数据经过加载、验证等过程转换为内存中的数据格式。</li>
<li>final有什么用？<br>
final可以加到类上，这样类就不能被继承了，比如String、Date就是；加到方法上，方法不能被重写；加到成员变量上，不能被修改。<br>
JVM为了实现final也需要一套重排序规则（happens-before），比如在构造方法中对一个final域的写入就和将这个对象的引用赋值给一个引用变量的操作不能重排序。<br>
一般final是能用则用，可以增加不变性，提高并发安全。</li>
<li>volatile有什么用？<br>
可以保证内存可见性，</li>
<li>缓存在哪（接上一题）？<br>
高速缓存cache、CPU缓存这些。</li>
<li>ThreadLocal有什么用？<br>
线程独立变量。<br>
每个线程都会维持一个Map&lt;ThreadLocal, value&gt;来保存自己的线程独立变量，ThreadLocal中其实操作的是当前线程中的这个Map。</li>
<li>假设用ThreadLocal实现购物车，如果一次请求往ThreadLocal里放商品，在请求结束后没有删除掉会有什么问题？<br>
因为线程是通过线程池来管理的，可能这些ThreadLocal并没有被清除，导致下一次请求进来发现购物车里已经有商品了。</li>
<li>MyBatis怎么实现SQL语句的打印？<br>
如果是用SpringBoot作为后台框架，那它本身（指的是MyBatis对应的starter）有其拦截器做这件事，当然也可以自己定义一个Interceptor拦截StatementHandler打印其中的SQL语句。</li>
<li>SpringMVC和Spring有哪些区别？具体增加了哪些特性？<br>
SpringMVC是基于Spring功能之上添加的Web框架，提供请求路径映射、视图解析、异常处理等功能。</li>
<li>来了一个请求是如何转发给Controller中的接口的？<br>
SpringMVC的执行流程：<br>
1、用户发送请求至前端控制器DispatcherServlet；<br>
2、DispatcherServlet收到请求调用HandlerMapping处理器映射器；<br>
3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>
4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器，执行处理器(Controller，也叫后端控制器)；<br>
5、Controller执行完成返回ModelAndView，并返回给HandlerAdapter，HandlerAdapter将结果返回给DispatcherServlet；<br>
6、DispatcherServlet将ModelAndView传给ViewReslover视图解析器，ViewReslover解析后返回具体View给DispatcherServlet；<br>
7、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）后返回给给客户</li>
<li>IOC和AOP的关系？<br>
IOC定义了一个Bean的注册中心，在注册中心实例化对象时其实对对象进行了动态代理，在动态代理中实现拦截目标方法并在前后执行自定义逻辑，即为AOP。</li>
<li>什么场景下会用到AOP？<br>
对一些关注点，比如登录后要做日志、Service接口要添加事务功能、访问数据库前要记录执行过的SQL，如果用传统的方法需要添加大量相似的代码，但是AOP只需要定义一个PointCut和Advice即可。</li>
<li>BeanFactory和FactoryBean有什么区别？<br>
BeanFactory是Bean的注册中心，FactoryBean是一个Bean，它被注册到BeanFactory中，但是在获取其类型时会调用getObjectType，实例化时会调用getObject。</li>
<li>Redis有哪几种数据结构？<br>
主要是String、Hash、List、Set、ZSet这五种。</li>
<li>zset是怎么保证有序的？<br>
每个元素都关联一个double类型的权重score，集合中的元素能够按score进行排列。</li>
<li>排序算法知道哪些？<br>
按时间复杂度分：<br>
O(n^2)的包括冒泡排序、插入排序、选择排序。<br>
O(nlogn)的包括堆排、快排、归并排序、希尔排序（不严格是）。<br>
O(n)的包括计数排序、基数排序、桶排序。<br>
O(?)的如猴子排序…</li>
<li>快排能手写吗？原理是什么？ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">  a[i] = b[j];</span><br><span class="line">  b[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lb &gt;= rb) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> j = lb - <span class="number">1</span>, mid = nums[rb];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lb; i &lt;= rb; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">      swap(nums, nums, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(nums, lb, j - <span class="number">1</span>);</span><br><span class="line">  quickSort(nums, j + <span class="number">1</span>, rb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, -<span class="number">1</span>, <span class="number">23</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  quickSort(nums, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>快排的原理是分治法，对一个数组，先选出一个中枢，然后按这个中枢将原数组分成两个子数组，对这两个子数组分别递归调用快排函数。</p>
<ol>
<li>
<p>数据库用过哪些？<br>
MySQL。</p>
</li>
<li>
<p>怎么加索引？<br>
索引的底层数据结构是B+树，加索引需要遵循以下几条准则：</p>
<ol>
<li>并非越多越好：索引会额外占用磁盘空间，而且会影响INSERT、DELETE、UPDATE的性能，因为需要同时更新索引的结构。</li>
<li>更新少、列尽量少：因为列很多、经常更新的情况下，会导致花费过多的时间在更新索引结构上。</li>
<li>尽量使用短字段索引，对长字段应使用前缀索引，这样能提高索引效率。</li>
<li>数据量小的表最好不要加索引，可能会起不到优化的目的；</li>
<li>在条件表达式上不同值多的列上建立索引，在不同值少的列上不要建立索引。</li>
<li>当唯一性是某种数据本身的特征时，制定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</li>
<li>在频繁进行排序、分组、联合（group by, order by, join on）的列上建立索引。如果待排序的列有多个，可以在这些列上建立组合索引。</li>
</ol>
</li>
<li>
<p>一些重复性大的字段上可以加索引吗？比如用户表的性别字段。<br>
最好不要。因为这是一种非聚集索引，在实际取select的字段值时会跳到聚集索引，频繁的来回读取会拖慢查询速度，反而得不偿失。</p>
</li>
<li>
<p>索引是怎么实现的？<br>
在MySQL中支持哈希索引、B树索引、全文索引，其中B树索引最常用，其底层结构为B+树。</p>
</li>
<li>
<p>为什么用B+树？<br>
因为B+树相对其他结构更好：</p>
<ul>
<li>相对红黑树来说，红黑树在数据量大的时候，树的高度会比较大，查询会比较慢，且每个节点只存储一个记录，可能会导致一次查询有很多次磁盘IO，而B+树能更好地利用&quot;局部性原理&quot;；</li>
<li>相对散列表来说，散列表的确查询速度更快，但是对于有排序查询的SQL需求来说，哈希型的索引时间复杂度会退化为O(n)，而树型索引的有序特性可以保证仍有O(logn)的高效率；</li>
<li>相对B树来说，B树的内部节点（非叶节点）会存储数据，在进行范围查找的时候中序遍历过程中可能会需要回溯。</li>
</ul>
</li>
<li>
<p>乐观锁怎么实现？<br>
在数据上加一个版本号（version）或时间戳（ts）字段，假设下面用的是版本号。</p>
</li>
<li>
<p>怎么写SQL语句实现乐观锁？<br>
update user set version = oldVersion + 1 where version = oldVersion</p>
</li>
<li>
<p>怎么知道乐观锁检测到的并发异常？<br>
如果没有更新成功就是有并发异常了。</p>
</li>
<li>
<p>你怎么知道没有更新成功是因为乐观锁引起的？<br>
可以在业务层检查，查出来后在Service层代码里检查时间戳是否相同，如果相同才允许更新，否则抛出异常。</p>
</li>
<li>
<p>数据库层怎么实现？<br>
对数据加行锁。</p>
</li>
<li>
<p>那还要乐观锁干嘛？<br>
补充：对乐观锁理解还是不够，因为在用友乐观锁是在Service层检测的，架构师显然对效率不怎么关注。<br>
现在回到那个问题：怎么知道更新失败是版本号引起的？<br>
没想到特别好的方法，实在不行可以利用存储过程，将旧数据放到output参数中返回，然后在Service中比对客户端传过来的版本号和数据库中旧的版本号，如果相同才能更新成功，Hibernate还有对乐观锁的支持，会在版本号对不上时抛出特定的异常。</p>
</li>
<li>
<p>数据库怎么实现事务？<br>
如果要开启事务，需要先执行BEGIN TRANSACTION命令开启事务，如果执行成功就调用COMMIT提交事务，如果失败则调用ROLLBACK回滚事务。<br>
事务有4个特性，原子性、一致性、持久性、隔离性，前面三个是通过记录日志来实现的，而隔离性是通过加锁来实现的，也是最复杂的一个性质。<br>
事务有四种隔离级别，未提交读、提交读、可重复读和序列化，前面三者大体都是通过共享读锁，独占写锁来实现的，而序列化单纯用锁是无法实现的。</p>
</li>
<li>
<p>什么情况下需要事务？事务的应用场景？<br>
事务是为了防止复杂业务操作中断导致的数据一致性问题。比如创建订单后减库存，如果在创建订单之后程序报错退出了，就会出现只有订单但是库存没减的情况，也就是出现了数据一致性问题。</p>
</li>
<li>
<p>动态代理有几种实现方式？<br>
JDK Proxy，实现了被代理类的某个接口，然后在方法实现中调用了目标被代理类中的相应方法。<br>
CGLIB，继承了被代理类，然后在方法实现中调用了父类的相应方法，但是如果被代理类有final方法是不能代理的，这是一个缺点。<br>
补充：还有一种javassist。</p>
</li>
<li>
<p>内部是怎么实现的？<br>
JDK Proxy是JDK提供的，首先会为接口创建代理类的字节码文件，使用ClassLoader将字节码文件加载到JVM，创建代理类实例对象，执行对象的目标方法。<br>
CGLIB是用ASM框架操作字节码实现的。</p>
</li>
<li>
<p>ASM有用过吗？<br>
没有…（？？？）</p>
</li>
<li>
<p>怎么分服务？<br>
按DDD的设计思路，根据业务模块之间的边界进行划分。</p>
</li>
<li>
<p>服务之间怎么调用？<br>
使用RPC调用。</p>
</li>
<li>
<p>RPC使用什么框架？<br>
没有用框架，是自己在HTTP基础上包了一层。</p>
</li>
<li>
<p>RPC的执行过程是怎么样的？<br>
RPC是将对本地方法的调用转换为网络请求，它会将方法签名、参数等包装到请求体内，然后用类似HTTP之类的协议向另一个服务发起请求，另一个服务的对应&quot;RemoteCall&quot;接口接收到请求后再利用反射创建服务接口实现类的实例，并调用对应的方法。</p>
</li>
<li>
<p>怎么处理超时？降级？等等<br>
不知道…（？？？）</p>
</li>
<li>
<p>HTTP是哪一层的？<br>
应用层。</p>
</li>
<li>
<p>下面是什么？<br>
TCP。</p>
</li>
<li>
<p>HTTP消息头里有哪些字段？<br>
Accept-Charset：客户端可以接受的字符集。<br>
Content-Type：正文格式。<br>
Cache-control：控制缓存，当客户端发送的请求中包含max-age指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源，当指定max-age为0，那么缓存层通常需要将请求转发给应用集群。<br>
If-Modified-Since：也是关于缓存的。如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源，如果没有更新，服务端会返回&quot;304 Not Modified&quot;的响应，那客户端就不需要下载了。</p>
</li>
<li>
<p>传json和传表单有什么区别？<br>
传json时：Content-Type=application/json，请求体中是json字符串；<br>
传表单时：Content-Type=x-www-form-urlencoded，请求体中是一些键值对。</p>
</li>
<li>
<p>Content-Type有什么用？<br>
协调客户端和服务端对数据的处理，不能随便设置，一方面是符合规范，一方面是浏览器对一些文件、图片格式的请求体会有特殊的处理方式。</p>
</li>
<li>
<p>301和302有什么区别？<br>
这两个状态码都会出现在实现重定向的场景内，用户都可以看到URL被替换为了一个新的，然后发出请求。<br>
301 Moved Permanently：告知客户端被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。即永久重定向。除非额外指定，否则这个响应也是可缓存的。<br>
302 Found：请求的资源需要从不同的URI响应请求，客户端以后应继续向原有地址发送请求获取该资源。即临时重定向。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>
补充：302重定向是暂时的，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索引擎认为新的网址是暂时的。而301重定向是永久的，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。<br>
补充：测试时发现访问http://www.baidu.com会重定向到https://www.baidu.com，状态码是307，其实和302是差不多的意思。<br>
以nginx服务器中的配置为例：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//把来自veryyoung.me的请求301跳到 www.veryyoung.me</span><br><span class="line">if ($host != 'veryyoung.me') &#123;</span><br><span class="line">    rewrite ^/(.*)$ http://www.veryyoung.me/$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">//把来自veryyoung.me的请求302跳到 www.veryyoung.me</span><br><span class="line">if ($host != 'veryyoung.me') &#123;</span><br><span class="line">    rewrite ^/(.*)$ http://www.veryyoung.me/$1 redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>HTTPS是什么？<br>
HTTPS = HTTP + TLS<br>
有非对称加密和对称加密两个过程，非对称加密的公钥私钥主要用于传输对称加密的密钥，下面说明一下大致过程：</p>
<ol>
<li>客户端给出支持的TLS版本、加密套件候选列表、压缩算法候选列表等信息还有一个随机数；</li>
<li>服务端确认加密所使用的协议版本、加密套件、压缩算法等，以及一个证书；</li>
<li>客户端用自己信任的CA仓库中的公钥去解密这个证书；</li>
<li>客户端使用证书中的公钥将一个随机数Pre-master加密，再发送给服务端，服务端可以用私钥解密出来；</li>
<li>通过之前的随机数可以在客户端和服务端产生相同的对称密钥，接下来服务端和客户端就使用对称密钥来进行加密传输了。</li>
</ol>
</li>
</ol>
<h4 id="三面-hr-v2"><a class="header-anchor" href="#三面-hr-v2">¶</a>三面-HR</h4>
<p>HR面中规中举，到了这个阶段是比较轻松的了，应付了一些像离职原因这样的常规问题后，就是由我方进行提问了，准备的问题也只有那几个方面，包括：商业模式、风险、后续公司发展方向、技术发展方向、个人发展方向、人员组织结构，以及薪资福利这些方面。</p>
<h4 id="四面-hrd"><a class="header-anchor" href="#四面-hrd">¶</a>四面-HRD</h4>
<p>HRD是一位东北人，思维敏捷口才了得，但是有点咄咄逼人，先从地域问题炒热气氛，后对我的大学生涯、选择上家企业的原因、跳槽原因等问题进行了发问，且回答若不满意就会一直追问到底。</p>
<h3 id="第七家-今日头条"><a class="header-anchor" href="#第七家-今日头条">¶</a>第七家-今日头条</h3>
<p>头条（更准确说应该是字节跳动）已经成长为一家比较大的互联网公司，因为产品是以各种算法为核心的，业内的地位难以动摇。主要业务——按我自己的理解——就是通过对用户关联度等的分析来匹配用户喜欢的新闻，提高用户的粘性。<br>
头条是交叉面试，两个业务线分别进行面试，面试问题比较自由，但是相对校招来说还是会多抠一点细节，用一连串的问题来考察面试者是真懂还是背的。一面磕磕碰碰算是过了，二面答得不怎么样，HR从头到尾都没给什么好脸色，最后没给消息估计是黄了。</p>
<h4 id="一面-二面"><a class="header-anchor" href="#一面-二面">¶</a>一面 &amp; 二面</h4>
<p>一面面试官似乎比较喜欢Linux底层的内容，虽然我面的是Java，但是Java问题一个都没有。<br>
二面面试官是做go语言的，但是问起Java来也一点不含糊。<br>
头条据说是互联网公司里问问题数一数二难的，就我个人体验来说，确实很多问题比一般公司要更深挖一点，这里记一下印象比较深的问题。</p>
<ol>
<li>
<p>自我介绍。</p>
</li>
<li>
<p>网站QPS是多少？<br>
QPS表示每秒查询数，在ToC产品中应该是比较常用的度量性能的指标，但是ToB的产品——至少我在用友参与的产品——是不怎么考虑并发性能的，之前开展“百人测试”活动的时候还经常出现崩溃（就当QPS能达到100吧？）。</p>
</li>
<li>
<p>说个比较熟悉的功能实现。<br>
事先一定要熟悉一遍，至少对某个功能要做到能背出来，而且要有一定的技术难点。</p>
</li>
<li>
<p>事务补偿是怎么实现的？画个流程图。<br>
项目里用到的事务补偿机制非常简单，就是在异常抛出后调用一下逆操作。</p>
</li>
<li>
<p>分布式事务还有哪些实现方法？<br>
2PC、3PC、TCC。</p>
</li>
<li>
<p>3PC和TCC的区别是什么？<br>
3PC在2PC的基础上：1.引入了超时机制；2.在第一阶段和第二阶段中插入了一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。<br>
TCC类似3PC，它将业务操作分为三个阶段，Trying阶段主要进行检测和资源预留，根据Trying执行是否成功调用Confirming或Canceling，Confirming阶段主要进行业务提交，Canceling阶段是对业务做回滚、释放已预留的资源。</p>
</li>
<li>
<p>有遇到什么问题吗？<br>
对这样的提问，必须准备好自己有把握的问题，并且对可能的连环提问做好准备。比如我可能会准备下面的问题：</p>
<ul>
<li>服务发现模块Eureka报错。为了解决这个问题，必须先明白Eureka的原理，</li>
<li>台帐功能效率太低。优化措施包括批量查询（不能在循环体中调用查询接口）、手动分页、数据库表加索引、缓存。</li>
</ul>
</li>
<li>
<p>数据库表是怎么设计的？<br>
把dr和ts字段说了下，ts是乐观锁。（可能面试官更希望听到索引是怎么加的）</p>
</li>
<li>
<p>为什么使用乐观锁？悲观锁相对乐观锁有什么缺陷？<br>
乐观锁会在要更新的时候检查一下，悲观锁的粒度更大，需要在进入临界区代码前获取锁，然后让别的线程等待这个线程执行完毕释放锁。<br>
悲观锁需要提防死锁。</p>
</li>
<li>
<p>为什么会发生死锁？<br>
死锁的产生有四大必要条件，用一个例子来说明，就是有两个酒鬼，他们分别拿着酒和开瓶器，每个资源只能由一个人来使用（互斥条件），他们互相请求对方手里的资源（请求并持有条件），资源不能被其他人抢占（不可剥夺条件），资源之间的占有、请求关系形成了一个环形链（环路等待条件）。</p>
</li>
<li>
<p>内存锁了解哪些？<br>
synchronized、ReentrantLock、ReentrantReadWriteLock。</p>
</li>
<li>
<p>底层怎么实现的？<br>
？？？<br>
补充：</p>
</li>
<li>
<p>synchronized可以加到哪两种上边？<br>
不是特别理解这题的用意，因为可以加的地方还是蛮多的，真要说的话应该是可以加到对象或方法上，对象包括普通意义上的对象或Class对象，方法包括普通方法、静态方法和代码块，其实也等同于加到对象上。</p>
</li>
<li>
<p>HashMap中是怎么比较两个对象的？<br>
先用hash值来比较，因为hash值是整型，相对equals来说更快，而且对于一些字符串的比较equals往往还需要将各位字符加起来。<br>
当插入对象的时候会用一个Entry进行包装，将hashCode值缓存起来，在比较的时候不必再调用hashCode方法。<br>
比较两个对象的时候先比较hash值，如果相同再用equals比较。<br>
但是如果对象内部成员变量的值变了、hashCode结果也变了怎么办？这种情况相对来说比较少。</p>
</li>
<li>
<p>数据库索引的结构？<br>
B+树。</p>
</li>
<li>
<p>B+树和B树有什么区别？<br>
B+树将所有数据保存到叶子节点上，并且叶子间首尾相连形成链表。<br>
这样的结构在数据库中有很多好处：</p>
<ol>
<li>相邻数据可以存储在同一磁盘块上从而加强局部性原理的作用，高度低、定位速度快，这些优点相对B树来说更加明显；</li>
<li>可以支持范围查找，定位min和max后，处于中间的叶子节点就是结果集，不用中序回溯；</li>
<li>叶子节点存储实际数据，比较紧密，适合大数据量的磁盘存储，非叶子节点存储记录的PK，用于查询加速，适合内存存储；</li>
<li>非叶子节点，不存储实际记录而只存储key，因此在相同内存的情况下，B+树能够存储更多索引。</li>
</ol>
</li>
<li>
<p>对语句<code>select from user where id &gt; 50 and name like 'a%'</code>怎么使用索引（怎么在B+树上找到目标记录）？<br>
MySQL执行语句需要经过连接器、查询缓存、分析器、优化器、执行器这些组件的处理，然后由存储引擎来负责数据的存储和提取。<br>
B+树是存储引擎中组织数据的核心数据结构，该题考的就是存储引擎中对B+树的组织。<br>
？？？</p>
</li>
<li>
<p>Linux进程间的通信方式有哪几种？<br>
进程间的通信需要借助一些多进程都可以共享的资源，比如内存（共享内存）、磁盘（共享文件、管道pipe、消息队列）、网络（socket）。<br>
内部实现？？？</p>
</li>
<li>
<p>Linux怎么实现多路复用？<br>
select、poll、epoll。</p>
</li>
<li>
<p>epoll的执行过程是怎么样的？<br>
？？？</p>
</li>
<li>
<p>HTTP下面是什么协议？<br>
TCP。</p>
</li>
<li>
<p>301和302的区别是什么？<br>
301表示资源被永久移动了，302表示临时的。比如登录是用的302进行的重定向。</p>
</li>
<li>
<p>Session是怎么校验的？<br>
第一次访问时在服务端创建用户登录信息，将这些信息保存到Session中，在返回消息中添加Set-Cookie2项，客户端接收到消息后为该Server新建Cookie，保存为&lt;Server, Cookie&gt;的键值对，保存到浏览器的内存中，当对该服务器发起后续请求时会将属于该服务器的Cookie带上。</p>
</li>
<li>
<p>如果禁用了Cookie怎么办？<br>
可以将登录信息带到URL后面。</p>
</li>
<li>
<p>tcp怎么实现流量控制？<br>
滑动窗口协议。</p>
</li>
<li>
<p>滑动窗口是怎么运行的？<br>
其执行过程大致如下所示：</p>
<ol>
<li>发送方和接收方维持一个缓存，</li>
<li>？？？</li>
</ol>
</li>
<li>
<p>事务有哪四种特性？<br>
ACID：原子性、一致性、隔离性、持久性。</p>
</li>
<li>
<p>隔离性又有哪几种级别？<br>
SERIALIZABLE：串行，实现方式是对事务本身加锁；<br>
REPEATABLE READ：可重复读，实现方式是加乐观锁，保证一个事务不会修改已经由另一个事务读取但未提交的数据，可以避免脏读和不可重复读的情况；<br>
READ COMMITTED：读已提交，不会读取到另一个并行事务已修改但未提交的数据，可以避免脏读；<br>
READ UNCOMMITTED：读未提交。<br>
怎么实现这些隔离级别？？？</p>
</li>
<li>
<p>读未提交和读已提交的区别是什么？<br>
？？？</p>
</li>
<li>
<p>线程有哪些状态？<br>
new：创建新线程后；<br>
runnable：调用start()，开始准备执行，或者在running执行中调用yield()；<br>
running：线程获得CPU执行时间，开始执行run()方法；<br>
blocked：被同步块（synchronized）或IO阻塞；<br>
time waiting：主动睡眠（sleep(seconds)、wait(seconds)、join(seconds)）；<br>
waiting：主动等待（wait()、join()）；<br>
dead：running异常中断（interrupt()）或执行完毕（run()执行完毕或stop()）。</p>
</li>
<li>
<p>有几种线程创建方式？<br>
三种：实现Runnable接口、继承Thread类、实现Callable接口。</p>
</li>
<li>
<p>Runnable和Callable有什么区别？<br>
Callable是在Java5中加入的，支持返回线程执行结果，且支持声明抛出异常。Callable必须和Future搭配使用，Future是其执行器。</p>
</li>
<li>
<p>JVM的内存结构？<br>
方法区、堆、线程栈、本地方法栈、程序计数器。</p>
</li>
<li>
<p>消息队列了解哪些？<br>
RabbitMQ。</p>
</li>
<li>
<p>消息队列保证的是顶多一个送达还是多个送达？<br>
RabbitMQ能保证消息送达，但是在服务器消费完毕又没有按预期返回的情况下，消息队列会重发，如果这是由于网络异常等情况导致的，会导致消息被消费多次，因此需要额外使用幂等性组件保证“顶多消费一次”的特性。</p>
</li>
<li>
<p>设计你所说的幂等性功能？<br>
每个消息都要带上一个调用ID，服务端在接收到消息之后，并将调用信息缓存到Redis服务器上，而且在每次调用前都需要校验该调用是否。<br>
但是还要注意因为意外情况没有消费成功，需要使用重试机制来保证方法调用尽可能成功，调用信息需要带上调用情况，包括SUCCESS、FINISHED、FAILED。</p>
</li>
<li>
<p>必须轮询Redis服务器吗？没有别的方法吗？<br>
可以改成用ZooKeeper，Watcher机制可以自动通知节点的改变情况。</p>
</li>
<li>
<p>Watcher是什么原理？<br>
Watcher机制主要涉及到三个对象：ZooKeeper、Client、WatchManager。<br>
执行过程主要分为三个步骤：客户端注册Watcher、服务器处理Watcher和客户端回调Watcher，其内部各组件之间的关系如图。<br>
其中客户端在向ZooKeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatchManager中。当ZooKeeper服务器触发Watcher事件后，会向客户端发送通知，客户端线程从WatchManager的实现类中取出对应的Watcher对象来执行回调逻辑。</p>
</li>
<li>
<p>为什么要分服务？<br>
将服务分成多个子服务，就可以根据每个服务的流量来分配实例数（复制并用Nginx负载均衡）。</p>
</li>
<li>
<p>服务降级、融断这些怎么做的？<br>
项目里没有实现这些。</p>
</li>
<li>
<p>如果让你来怎么做？<br>
用SpringCloud实现。</p>
</li>
<li>
<p>翻转偶数位置的节点。<br>
比如1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;9应该转换为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9。<br>
实现及简单的测试代码如下所示：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">int</span> val) : val(val) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">int</span> val, struct ListNode *next) : val(val), next(next) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">reverseEven</span><span class="params">(ListNode *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先提取所有偶数位置的节点</span></span><br><span class="line">  ListNode *evenList = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  ListNode *head = <span class="built_in">list</span>, *nextHead = <span class="literal">NULL</span>, *prev = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">set</span>&lt;ListNode *&gt; existed;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="comment">// 判环</span></span><br><span class="line">    <span class="keyword">if</span> (existed.find(head) != existed.end()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == counter) &#123;</span><br><span class="line">      nextHead = head-&gt;next;</span><br><span class="line">      head-&gt;next = evenList;</span><br><span class="line">      evenList = head;</span><br><span class="line">      prev-&gt;next = nextHead;</span><br><span class="line">      counter = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == counter) &#123;</span><br><span class="line">      nextHead = head-&gt;next;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    existed.insert(head);</span><br><span class="line">    prev = head;</span><br><span class="line">    head = nextHead;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将偶数节点链表添加到原链表内</span></span><br><span class="line">  head = <span class="built_in">list</span>;</span><br><span class="line">  ListNode *originNextHead, *evenNextHead;</span><br><span class="line">  <span class="keyword">while</span> (evenList) &#123;</span><br><span class="line">    originNextHead = head-&gt;next;</span><br><span class="line">    evenNextHead = evenList-&gt;next;</span><br><span class="line">    evenList-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = evenList;</span><br><span class="line">    head = originNextHead;</span><br><span class="line">    evenList = evenNextHead;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ListNode *head;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  ListNode *tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">      tmp = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">      head = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp-&gt;next = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">      tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reverseEven(head);</span><br><span class="line">  ListNode *cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cur-&gt;val;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode *next;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    next = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写个并发控制程序<br>
10个线程，每个线程执行一个求和任务，将1~100的数字加到一个全局的sum变量上，每加一个数字就输出一次，要求按从小到大的顺序输出。<br>
当时我就震惊了，因为我以为白板过程都是写常规算法题的，这会竟然出了一道多线程的题，我发现自己对很多并发控制工具的接口都是不甚了解的，还自告奋勇要用CAS来实现（以提高并发效率），结果写得乱七八糟。<br>
其实相对读者写者这种问题来说还是比较简单的，如果是用Java，方法主要有synchronized、ReentrantLock、CAS这几种。</p>
<ul>
<li>CAS必须和volatile搭配使用；</li>
<li>CAS可以使用AtomicInteger或UNSAFE实现（UNSAFE是AtomicInteger的底层实现；</li>
<li>可以使用ThreadPoolExecutor协调多个线程，也可以改成使用CountDownLatch来协调。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="电信云计算公司-天翼云"><a class="header-anchor" href="#电信云计算公司-天翼云">¶</a>电信云计算公司（天翼云）</h3>
<p>公司不必介绍了，据说是第一家运营商级的云计算公司，有一定的技术实力。</p>
<h4 id="一面-v3"><a class="header-anchor" href="#一面-v3">¶</a>一面</h4>
<p>问题很基础，但是我比较怀疑面试官是不是真懂自己问的东西，因为对每个问题基本都不会往细节进一步问下去。</p>
<ol>
<li>
<p>ArrayList和LinkedList有什么区别？<br>
ArrayList是用数组实现的，LinkedList是用链表实现的。</p>
</li>
<li>
<p>String、StringBuffer、StringBuilder的区别？<br>
String是用定长数组实现的；<br>
StringBuffer是变长数组，且保证并发安全性；<br>
StringBuilder类似StringBuffer，但不保证并发安全。</p>
</li>
<li>
<p>synchronized与Lock的区别？<br>
（存在层次）前者由jvm提供实现，后者在JUC中提供实现；（锁的释放）前者由jvm管理锁的占有和释放，后者需要在finally中释放锁不然容易造成线程死锁；（锁的获取）前者如果A线程获得锁并阻塞，那么B线程也会一直等待，后者根据对锁的使用方式不同可以不用一直等待；（锁状态）前者无法判断，后者可以；（锁类型）前者可重入、不可中断、非公平，后者可重入、可判断、可公平；（性能）前者适用于少量同步的情况，后者能在大量线程竞争的情况保持较高的性能。</p>
</li>
<li>
<p>readLock与writeLock的区别？<br>
多个读锁间能共享一个资源，读锁和写锁互斥，写锁和写锁之间也互斥。</p>
</li>
<li>
<p>常用的集合类及区别？<br>
Collection、List、Map、Set这些属于顶层接口，它们具有一些普遍意义上的特点：</p>
<ul>
<li>List可以存储重复元素，元素是有序的，可以通过List的脚标来获取指定位置元素，也可以通过Iterator迭代方式来获取元素，而Vector多了一种枚举（Enumeration）的方式；
<ol>
<li>ArrayList：线程不安全，查询速度快；</li>
<li>Vector：线程安全；</li>
<li>LinkedList：链表结构，对元素的增删速度较快；</li>
</ol>
</li>
<li>Set不可以有重复元素，元素是无序，通过迭代的方式获取元素；
<ol>
<li>HashSet：要保证元素唯一性，需要覆盖掉元素类型的equals和hashCode方法；</li>
<li>TreeSet：红黑树来组织元素，可以对元素进行排序（元素实现Comparable接口，或建立一个Comparator）</li>
</ol>
</li>
<li>Map中元素是成对出现的，以键值对的形式体现出来，键要保证唯一性，可以通过keySet或entrySet获取内容然后迭代遍历。
<ol>
<li>HashMap：线程不安全，允许存放null键和null值；</li>
<li>Hashtable：线程安全，不允许存放null键和null值；</li>
<li>TreeMap：可以对键进行排序。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>写出单例模式。</p>
</li>
<li>
<p>使用wait、notify实现线程的等待、唤醒。</p>
</li>
<li>
<p>简述jvm分代垃圾回收策略。</p>
</li>
<li>
<p>列出http常用方法及区别。</p>
</li>
<li>
<p>写出快速排序算法。</p>
</li>
<li>
<p>两个线程交替对变量AtomicInteger i加1，并交替打印i，直到i值为1000为止。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进程和线程的区别？<br>
（根本区别）进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位；<br>
（开销）每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小；<br>
（所处环境）在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）；<br>
（内存分配）系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源；<br>
（包含关系）没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。</p>
</li>
<li>
<p>如何终止一个线程？<br>
主要有stop、interrupt、设置条件变量这三种方式。</p>
</li>
<li>
<p>interrupt是怎么执行的？<br>
interrupt只能修改中断状态，可以尝试在run方法体中的循环体中判断线程的状态或捕获InterruptedException来执行退出操作。</p>
</li>
<li>
<p>如何选择TreeMap和HashMap？<br>
TreeMap基于红黑树实现，适用于写多的场景，继承了AbstractMap；<br>
HashMap基于散列表实现，适用于查询多的情景，继承了SortedMap，保持键的有序顺序。<br>
因此，HashMap的效率往往比TreeMap要高一些，而TreeMap更适合在有排序需求的时候使用。</p>
</li>
<li>
<p>HashMap插入过程？</p>
</li>
<li>
<p>equals和hashCode区别？</p>
</li>
<li>
<p>单例还有哪些实现方式？</p>
</li>
<li>
<p>Put和Post的区别？</p>
</li>
<li>
<p>TCP做了什么？</p>
</li>
<li>
<p>为什么是三次握手？</p>
</li>
<li>
<p>（补充）三次握手机制是否完善？time_out是什么？端口是否有限制？</p>
</li>
<li>
<p>HTTPS做了什么？</p>
</li>
<li>
<p>快排原理是什么？</p>
</li>
<li>
<p>（手写代码）二叉树insert操作，如果key已存在则忽略。<br>
递归方法实现起来比较简单，如果要用迭代方法实现还需要一个栈或队列——取决于是DFS还是BFS。</p>
</li>
<li>
<p>（手写代码）一个矩阵，每一格都含有一个开销，现需要从左上角走到右下角，每一步可以选择往右或往下，每走一步会将沿路的开销加起来，求如何走使得开销和最小？<br>
简单的DP问题，LeetCode上有类似的问题：<a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">62. Unique Paths</a>。</p>
</li>
<li>
<p>如何实现一个LRU缓存？<br>
即最近最少被访问到的先被清除。<br>
这个问题只让说明思路，不过LeetCode上也有题目：<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache</a>。<br>
当然不能用数组来实现，这样每次都必须遍历一次数组。<br>
可以用优先队列来实现，使用加入时间作为比较目标，每次添加或删除元素都会将当前最早加入的元素挪动到堆首。但是这样查询的效率就会非常低了，所以应该另外再维护一个索引，比如用红黑树来记录每个元素的地址，这样能够更快定位一个元素。这样操作基本能在O(logn)时间复杂度内实现，但是实现起来并不简单。<br>
另一种更好的方法是用双向链表保存元素，头部的是最近被访问到的元素，然后另外用一个散列表来保存所有元素的地址，以提高查询的效率。</p>
</li>
</ol>
<h4 id="二面"><a class="header-anchor" href="#二面">¶</a>二面</h4>
<p>二面应该是部门的经理，发现我参与过的项目没什么意思、也没有高并发编程经验后就基本对我没什么兴趣了，后续提的都是些粒度很大的“你了解吗XX”的问题了，比较难回答。</p>
<ol>
<li>
<p>Java内存模型了解吗？</p>
</li>
<li>
<p>线程池了解哪些？<br>
线程池分为JDK自带的和开源成熟方案两大类，如果没有明确要求可以两类都说一下。<br>
JDK线程池分为</p>
</li>
<li>
<p>锁了解哪些？</p>
</li>
<li>
<p>单例模式的原理是什么？</p>
</li>
<li>
<p>MySQL连接复用怎么实现？</p>
</li>
<li>
<p>你还了解Java的哪些内容？<br>
这题比较有挑衅的意味了。</p>
</li>
</ol>
<h3 id="58"><a class="header-anchor" href="#58">¶</a>58</h3>
<p>感觉是至今为止遇到的面试前登记最繁琐的一家，填的内容比较有意思的包括“愿不愿意加班”、“愿不愿意出差”、“旧东家有没有保密协议”，不知道是不是遇到过很多这些方面的纠纷、所以才特别关注这些方面？<br>
这家也是离我旧据点最远的，走过去花了2个半小时，迟到了半小时的时间，以后对这种含有不确定因素的情况应该留更多的容错空间才对。</p>
<h4 id="一面-v4"><a class="header-anchor" href="#一面-v4">¶</a>一面</h4>
<p>一位看起来人狠话不多的面试官，问的问题能挖得很深。</p>
<ol>
<li>
<p>在项目里做了什么？</p>
</li>
<li>
<p>Redis怎么用的？</p>
</li>
<li>
<p>Redis怎么实现高可用？<br>
持久化（Snap、AOF）、集群（Cluster、Sentinel）。</p>
</li>
<li>
<p>Cluster怎么实现扩容？</p>
</li>
<li>
<p>ZooKeeper怎么用的？</p>
</li>
<li>
<p>换你来怎么实现分布式锁？</p>
</li>
<li>
<p>Redis怎么实现分布式锁？</p>
</li>
<li>
<p>Redis是单线程模型还是多线程模型？为什么？</p>
</li>
<li>
<p>进程和线程的区别？</p>
</li>
<li>
<p>为什么要有双亲委派模型？</p>
</li>
<li>
<p>类加载过程了解吗？</p>
</li>
<li>
<p>HashMap结构是怎么样的？</p>
</li>
<li>
<p>并发安全容器怎么选择？</p>
</li>
<li>
<p>它是怎么保证并发安全的？</p>
</li>
<li>
<p>乐观锁是什么原理？</p>
</li>
<li>
<p>红黑树操作的复杂度？</p>
</li>
<li>
<p>红黑树和平衡树的区别？</p>
</li>
<li>
<p>synchronized和Lock的区别？</p>
</li>
<li>
<p>synchronized可重入吗？能自己推断出它能不能重入吗？</p>
</li>
<li>
<p>垃圾收集算法和垃圾回收器了解吗？<br>
Mark-Sweep、Copying、Mark-Compact、Generational Collection。</p>
</li>
<li>
<p>怎么检测垃圾？<br>
引用计数、可达性分析。</p>
</li>
<li>
<p>怎么样才能确定一个对象可以被回收？</p>
</li>
<li>
<p>为什么数据库要加索引？</p>
</li>
<li>
<p>B+树是怎样的结构？画出来。</p>
</li>
<li>
<p>网络编程了解吗？NIO？</p>
</li>
<li>
<p>（写代码）写单例。<br>
单例模式的写法比较多，包括懒汉式（线程不安全）、懒汉式（线程安全）、饿汉式、双检锁式、静态内部类式、枚举类式。下面这种是双检锁的实现例子：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现双检锁有一些注意事项：</p>
<ol>
<li>给构造方法加private，可以避免被调用new实例化；</li>
<li>给实例加volatile修饰符，可以避免遇到内存可见性问题（两次检查instance == null可能检查的是高速缓存中的值）；</li>
</ol>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/25c6e926.html" rel="next" title="发现代码中的“坏味道”(Updating)">
                <i class="fa fa-chevron-left"></i> 发现代码中的“坏味道”(Updating)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/d07fb167.html" rel="prev" title="OpenSSH使用入门">
                OpenSSH使用入门 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第三家-念力"><span class="nav-number">1.</span> <span class="nav-text">¶第三家-念力</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一面"><span class="nav-number">1.1.</span> <span class="nav-text">¶一面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四家-洋钱罐"><span class="nav-number">2.</span> <span class="nav-text">¶第四家-洋钱罐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一面-v2"><span class="nav-number">2.1.</span> <span class="nav-text">¶一面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五家-小米-智米"><span class="nav-number">3.</span> <span class="nav-text">¶第五家-小米（智米）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一面-技术"><span class="nav-number">3.1.</span> <span class="nav-text">¶一面-技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二面-经理"><span class="nav-number">3.2.</span> <span class="nav-text">¶二面-经理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三面-hr"><span class="nav-number">3.3.</span> <span class="nav-text">¶三面-HR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六家-本木医疗"><span class="nav-number">4.</span> <span class="nav-text">¶第六家-本木医疗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一-二面-技术"><span class="nav-number">4.1.</span> <span class="nav-text">¶一、二面-技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三面-hr-v2"><span class="nav-number">4.2.</span> <span class="nav-text">¶三面-HR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四面-hrd"><span class="nav-number">4.3.</span> <span class="nav-text">¶四面-HRD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第七家-今日头条"><span class="nav-number">5.</span> <span class="nav-text">¶第七家-今日头条</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一面-二面"><span class="nav-number">5.1.</span> <span class="nav-text">¶一面 &amp; 二面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电信云计算公司-天翼云"><span class="nav-number">6.</span> <span class="nav-text">¶电信云计算公司（天翼云）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一面-v3"><span class="nav-number">6.1.</span> <span class="nav-text">¶一面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二面"><span class="nav-number">6.2.</span> <span class="nav-text">¶二面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58"><span class="nav-number">7.</span> <span class="nav-text">¶58</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一面-v4"><span class="nav-number">7.1.</span> <span class="nav-text">¶一面</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"modle":"wanko","pluginModelPath":"assets/","mobile":{"show":false},"display":{"position":"left","width":150,"height":300},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
