<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="幂等,">










<meta name="description" content="幂等性描述一项操作被执行多次后，不会改变第一次执行产生的副作用。 练手项目，解决项目中的幂等性检查要求，代码地址:point_right: Github - TIdempotent。  [x] BlockingChecker、NonblockingChecker ； [x] 加入 MySQL 作为 KeyStore （JdbcKeyStore）； [x] 加入 Redis 作为 KeyStore">
<meta name="keywords" content="幂等">
<meta property="og:type" content="article">
<meta property="og:title" content="实现接口幂等检查器">
<meta property="og:url" content="https://tallate.github.io/d9c44370.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="幂等性描述一项操作被执行多次后，不会改变第一次执行产生的副作用。 练手项目，解决项目中的幂等性检查要求，代码地址:point_right: Github - TIdempotent。  [x] BlockingChecker、NonblockingChecker ； [x] 加入 MySQL 作为 KeyStore （JdbcKeyStore）； [x] 加入 Redis 作为 KeyStore">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png">
<meta property="og:image" content="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/sidp-%E7%8A%B6%E6%80%81%E6%89%AD%E8%BD%AC.png">
<meta property="og:image" content="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/sidp-BlockingIdpChecker%E4%B8%8ETracing%E7%BB%84%E4%BB%B6%E9%85%8D%E5%90%88.png">
<meta property="og:image" content="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E4%BA%8B%E5%8A%A1MVCC%E4%B8%8D%E8%83%BD%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB.png">
<meta property="og:image" content="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E4%BA%8B%E5%8A%A1MVCC%E4%B8%8D%E8%83%BD%E9%81%BF%E5%85%8D%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.png">
<meta property="og:updated_time" content="2020-12-19T11:58:32.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现接口幂等检查器">
<meta name="twitter:description" content="幂等性描述一项操作被执行多次后，不会改变第一次执行产生的副作用。 练手项目，解决项目中的幂等性检查要求，代码地址:point_right: Github - TIdempotent。  [x] BlockingChecker、NonblockingChecker ； [x] 加入 MySQL 作为 KeyStore （JdbcKeyStore）； [x] 加入 Redis 作为 KeyStore">
<meta name="twitter:image" content="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/d9c44370.html">







  <title>实现接口幂等检查器 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d9c44370.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">实现接口幂等检查器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-22T22:58:29+08:00">
                2019-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>幂等性描述一项操作被执行多次后，不会改变第一次执行产生的副作用。<br>
练手项目，解决项目中的幂等性检查要求，代码地址:point_right: <a href="http://www.github.com/tallate/TIdempotent" target="_blank" rel="noopener">Github - TIdempotent</a>。</p>
<ul>
<li>[x] BlockingChecker、NonblockingChecker ；</li>
<li>[x] 加入 MySQL 作为 KeyStore （JdbcKeyStore）；</li>
<li>[x] 加入 Redis 作为 KeyStore （RedisKeyStore）；</li>
<li>[x] 只存储正确的返回结果，返回值压缩 + 缓存；</li>
<li>[x] 加入 Spring 便于整合进业务系统；</li>
</ul>
<a id="more"></a>
<h2 id="〇-初衷"><a class="header-anchor" href="#〇-初衷">¶</a>〇、初衷</h2>
<p>幂等性检查在非幂等的远程调用中几乎是必须的，而且这样的场景很多，一般我们都是直接在业务代码里写上，但很多时候容易用错中间件，或者是没有考虑到一些极端条件、在代码中埋下隐患。<br>
在抛砖之前，我们先来分析一下幂等功能的大概实现模式：</p>
<ol>
<li>每次请求都在中心化的数据库上保存这次请求的 id；</li>
</ol>
<blockquote>
<p>如何标识一次请求？</p>
</blockquote>
<ol>
<li>因为存储容量限制，我们不会放任数据堆积到数据库中，而是设置一个时间戳，每隔一段时间清理掉老的数据；</li>
</ol>
<blockquote>
<p>如果数据库支持的话，可以直接设置数据的过期时间。</p>
</blockquote>
<ol>
<li>之后就可以根据数据库中是否有这个 id 来判断是否已经执行了这个调用。</li>
</ol>
<p>这种实现比较简单，有时候和接口重试的初衷是冲突的。一般情况下我们实现幂等检查时，会将对应&lt;业务+数据 id&gt;拼接起来存到缓存中间件中，我们姑且称之为 IdpKey，后续请求会查到该 IdpKey，发现已经被调用过了，就直接返回之前执行过的结果。但是这种思路存在漏洞，如下图所示：<br>
<img src="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E5%B9%82%E7%AD%89%E6%A3%80%E6%9F%A5%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.png" alt="幂等检查和接口重试之间的冲突" title="幂等检查和接口重试之间的冲突"><br>
IdpKey 是只有在幂等检查结束后才会被保存下来的，如果下游服务还没执行完毕，触发上游 RPC 的超时重试机制，就会重新再发一次请求，这时如果上一次请求，仍然没有执行完毕，就会导致请求被执行了两次。<br>
这里的漏洞是：进入下游 API 入口处的幂等检查逻辑，会经过查 IdpKey -&gt; 保存 IdpKey -&gt; 设置超时时间这个过程，可能会因为网络抖动而花费特别长的时间。如果超时是因此而导致的，幂等性检查就起不到作用了。<br>
解决的办法是保证幂等检查的<strong>原子性</strong>，并且还需要注意存储的<strong>隔离性</strong>，这在一般的存储设计中是必须要考虑的。</p>
<blockquote>
<p>在这里吐槽一下我公司的实现，采用的是<code>setnx + expire</code>的方式，如果<code>setnx</code>后、<code>expire</code>前出错了，之后对该接口的重试也会直接被拦截了，也就是说幂等检查组件影响了正常的业务执行流程。</p>
</blockquote>
<h2 id="一-使用时机"><a class="header-anchor" href="#一-使用时机">¶</a>一、使用时机</h2>
<h3 id="服务-api"><a class="header-anchor" href="#服务-api">¶</a>服务 API</h3>
<p>接口幂等性是在设计 RPC 时必然被提到的话题，因为远程调用为了减少突发性的网络抖动影响、尽可能提高一次请求成功的几率，会在失败后重试几次，但是服务消费者此时其实并不知道服务提供者是真得没接收到请求、或者只是响应在中间走丢了、亦或者是别的什么情况，所以服务框架普遍会在服务提供者处设置幂等性检查。一般情况下有以下几种策略：</p>
<ol>
<li>和业务逻辑耦合，比如是涉及订单的业务，订单会有状态，下单后状态会相应的改变，所以我们只需要在业务处理开始的地方检查一下状态就可以起到幂等性检查的目的；</li>
<li>提取幂等性检查的逻辑作为框架的一部分，使用注解等方式来为目标接口添加幂等检查功能，可以有效减少冗余代码，不过执行效率会低一些；</li>
</ol>
<h3 id="http-协议的幂等性"><a class="header-anchor" href="#http-协议的幂等性">¶</a>HTTP 协议的幂等性</h3>
<p>根据协议规定，PUT 等方法天生具有幂等性的语义，因为 PUT 会覆盖数据而不是在原来数据的基础上增加，发一次和发多次请求某一资源应该会产生相同的副作用。<br>
道理我们都懂，但是要在幂等检查中特别关注并忽略掉这些情况又不大适合，因为根据我看的大部分代码的感受而言，大家基本上不会特别严格地遵守 REST 协议（或者说风格？）：每个接口都讨论一遍怎么套用各 HTTP 方法来解释太影响效率，所以大不了读的就用 GET，写的就用 POST，以及链接中随意使用动词、返回状态码等。因此我认为不特地地根据 HTTP 方法进行过滤也没有关系。</p>
<h3 id="web-api"><a class="header-anchor" href="#web-api">¶</a>WEB API</h3>
<p>API 有时候也会考虑“幂等性”，但这严格来说不属于我们这里讨论的范畴，我们主要关注 RPC 中重试的幂等性，这里只是稍微提一下。比如在确认下单的时候用户多点了几下（还包括刷单、 DDoS 攻击等），后台就会收到同一用户在很短的时间内发来的多个相同请求，除了在网关层限流，往往后台还会对用户的请求频率进行限制，比如使用从请求上下文里得到的用户登录 token（唯一标识一个用户）和订单 ID （唯一标识一个业务）拼接一个 IdempotentKey （以下简称 IdpKey ），保存到缓存中间件并设置过期时间：</p>
<div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 判断用户是否刚下过单</span><br><span class="line">private boolean justOrdered(String orderId) &#123;</span><br><span class="line">  String idempotentKey = UserContext.getUserId() + orderId;</span><br><span class="line">  // setIfAbsent接口封装了Redis的setnx命令，当key不存在时设置成功并返回true，否则返回false</span><br><span class="line">  if(redisClient.setIfAbsent(idempotentKey, &quot;true&quot;)) &#123;</span><br><span class="line">    // 设置key的过期时间</span><br><span class="line">    redisClient.expire(idempotentKey, 3, TimeUnit.SECONDS);</span><br><span class="line">    return false;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<blockquote>
<p>这段代码有问题，因为 setIfAbsent 和 expire 是分成两次请求的、并不是原子的，如果在 expire 出错，就会导致缓存项成为“死数据”，解决办法是利用 set 命令就够了，set 命令有很多参数，其中就包括设置原子性和设置过期时间的。</p>
</blockquote>
<h3 id="写数据库"><a class="header-anchor" href="#写数据库">¶</a>写数据库</h3>
<p>产生幂等问题的根源是数据库写操作执行了多次，所以一种最简单的实现方法是为表加唯一索引，并使用<code>on duplicate key update</code>语句来保证幂等性，假设<code>user</code>表中的<code>name</code>字段加了索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insert into user (</span><br><span class="line">  name,</span><br><span class="line">  pwd</span><br><span class="line">) values (</span><br><span class="line">  &apos;Mike&apos;,</span><br><span class="line">  &apos;123456&apos;</span><br><span class="line">)</span><br><span class="line">on duplicate key update</span><br><span class="line">pwd = #&#123;pwd&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，如果表中没有这种唯一索引，这种方法就不好使了。</p>
<h2 id="二-设计思路"><a class="header-anchor" href="#二-设计思路">¶</a>二、设计思路</h2>
<h3 id="如何标识一次请求"><a class="header-anchor" href="#如何标识一次请求">¶</a>如何标识一次请求</h3>
<p>IdpKey 需要能唯一标识一个请求，服务 Producer 在重试时，需要将这个标识符带上，这样就可以在服务 Consumer 的调用上下文找到这个标识符，从而唯一确定一个请求。<br>
实行服务链路追踪功能的组件一般称为 Tracing 组件，Tracing 组件中有两个基本工作单元 TraceId 和 SpanId，我们先来讨论一下一种开源实现——Spring Cloud Sleuth 能否满足我们的需求：</p>
<ul>
<li>TraceId 唯一标识一条请求链路，主要用来追踪链路执行情况；</li>
<li>SpanId 表示一个基本的工作单元，比如一次消息发送、Http 请求，当然也可以简单理解成一次远程调用。<strong>重试时会将刚开始生成的 SpanId 重发几次</strong>，所以 SpanId 是合适的。</li>
</ul>
<blockquote>
<p>如何传其实还是由具体实现说了算，我看到的另一种实现是：对于基于消息的 RPC，这个 SpanId 会加到 Message 内，对于基于 HTTP 的 RPC，这个 SpanId 会加到请求头部。不管是哪种方式，每个 request 对象只会生成一次，然后重试时使用该 request 重发几次。</p>
</blockquote>
<p>还有一个合理但是略丑的方式是在请求参数中强行添加上一个<code>InvocationId</code>，但是这样代价就太高了。</p>
<blockquote>
<p>注意事项：<br>
Consumer 接口不应该是递归的，递归会使得一个 IdpKey 被不必要地重复检查、导致链路意外中断。</p>
</blockquote>
<p>IdpKey 的存储非常灵活，可以将其保存到全局的并发安全容器内，也可以选择其他的存储中间件，如果有较强的一致性需求，最好使用 MySQL 等数据库中间件，并将 idp 数据库和业务数据库建到同一个服务器上，这样它们才能受到同一个事务管理。</p>
<p>远程调用的发生是非常频繁的，随着服务器的运行， KeyStore 中保存的 IdpKey 也会占用非常可观的内存或磁盘空间（根据具体实现而定），所以需要定时地去清理不用的数据。一般请求的重试过程不会持续太久，频繁的全表扫描也会一定程度上拖慢服务器的性能，所以 10 分钟清理一次我认为是比较合理的。一般 NoSQL 数据库都会提供为保存的 key 设置过期时间的功能，而 SQL 数据库（如 MySQL ）则需要在服务器里另起一个线程来执行清除操作。</p>
<p>实际上，只要具备链路追踪功能的框架都可以作为替代，比如<code>Spring Sleuth</code>、<code>Zipkin</code>、<code>SkyWalking</code>。</p>
<h3 id="接口执行状态"><a class="header-anchor" href="#接口执行状态">¶</a>接口执行状态</h3>
<p><img src="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/sidp-%E7%8A%B6%E6%80%81%E6%89%AD%E8%BD%AC.png" alt="sidp-状态扭转" title="sidp-状态扭转"></p>
<ol>
<li>BlockingIdpChecker 主要用于异步调用，这种场景下希望请求能够尽可能成功。</li>
<li>NonblockingIdpChecker 可以用于同步调用的场景下，调用者重试意味着放弃了之前发送的请求，没有必要在上个请求仍处于 EXECUTING 状态下时阻塞等待其执行完毕。</li>
</ol>
<p>生成 IdpKey 或持久化 IdpKey 时可能发生异常，一般这两个过程是比较稳定的，万一出现问题，会影响实际业务的执行，它们的可用性需要采取其他措施来保证（一般是集群化）。<br>
<code>BlockingIdpChecker</code> 中在发现存在其他线程正在执行该 IdpKey 对应的请求时，会阻塞，每隔 50ms、100ms、200ms 轮询数据库，使用这几个值的原因是我在实际中发现大部分接口在正常情况下都能在 50ms 内处理完毕（要么执行成功要么抛出异常），部分比较重量级的接口基本也能在 200ms 内执行完毕。如果在这段时间内没有处理完毕，其实继续等待下去意义也不大了。<br>
详细描述待定…</p>
<h3 id="结果缓存-压缩"><a class="header-anchor" href="#结果缓存-压缩">¶</a>结果缓存+压缩</h3>
<p>幂等性的定义中描述操作的多次执行只会产生一次副作用，这意味着每一次都可以得到相同的结果，为了在后续执行中可以返回第一次成功时产生的返回值，我们需要对结果进行缓存。<br>
与缓存系统的交互一般通过 TCP 连接来传输，在代码中，我使用 Json 来序列化数据，保证数据的可读性，然后用 GZIP 算法来进行压缩，提升传输效率。</p>
<h3 id="sql-数据库"><a class="header-anchor" href="#sql-数据库">¶</a>SQL 数据库</h3>
<p>当使用数据库来持久化 IdpKey 时——以 MySQL 为例——需要创建一个 idpkey 表来保存 IdpKey ，建表语句如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists idpkey</span><br><span class="line">(</span><br><span class="line">  `id`           varchar(36) not null,</span><br><span class="line">  `key_state`    char(12)    not null default &apos;&apos;,</span><br><span class="line">  `created_time` timestamp   not null default now(),</span><br><span class="line">  `content`      blob        null,</span><br><span class="line">  primary key (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该表非常简单，但是还是多说两句为什么要这么建，特别是索引的考虑。</p>
<ol>
<li>id 为什么是 varchar(36)类型？<br>
36 是 UUID 的长度，一般不会有比这个更长的了，但是不确定会不会使用别的计算方式，</li>
<li>为什么 key_state 使用 char 而不是 varchar？<br>
因为该字段值长度稳定，不能很好发挥变长字符串的威力，而且更新频率高，当字段值变长时，可能需要存储引擎做额外的工作（比如分裂页等），总而言之，varchar 更适合存字段值长度变化大、更新频率小的。</li>
<li>为什么 key_state 字段没加索引？<br>
状态的取值只有固定的几个，没必要加索引，一方面字段选择性小（只取几个值），数据库无法有效过滤行，另一方面在 key_state 索引中查出大量行后数据库还需要回到聚集索引中“反查”到其他字段值，反查得过于频繁可能需要置入过多的磁盘块。</li>
<li>为什么 created_time 不加索引？<br>
created_time 标识一条数据的创建时间，清理的时候会执行一个范围过滤的删除，其中的大部分数据都会被直接删除掉，如果加了索引，虽然匹配速度会稍微快一点，但是数据量大（接近一半）又导致回表和重建索引的过程非常耗时，甚至还不如全表扫描，这可以通过建测试表来验证。</li>
<li>为什么 content（结果缓存）是 blob 类型的？<br>
因为结果被压缩成了，保存的不是原文而是字节数组。</li>
</ol>
<h3 id="kv-数据库-rediskeystore"><a class="header-anchor" href="#kv-数据库-rediskeystore">¶</a>KV 数据库（RedisKeyStore）</h3>
<p>代码里使用 Redis 作为数据库实现了一种 idpKey 的存储策略，Lua 脚本的语法并不难，难的是如何以 Redis 环境为基础进行调试，具体逻辑见 <code>RedisKeyStore</code>。这里来分析一下为什么要用 Lua 实现？</p>
<ul>
<li>Redis 自带的命令很多，但还是不能覆盖所有的使用场景，比如我在代码里需要实现“putIfAbsent + expire + 返回覆盖前的值”的<strong>复杂逻辑</strong>就没有原生命令支持。</li>
<li>Redis 提供的 Lua 机制可以保证<strong>隔离性</strong>，因为 Redis 本身是<strong>单线程模型</strong>，天然保证了串行化执行，即间接实现了串行化隔离级别，而不管是 Lua 脚本还是事务，都是通过批量执行任务来保证这种隔离性的。</li>
</ul>
<blockquote>
<p>Sentinel 集群可以保证只有一个 master 能执行写命令，因为 Sentinel 服务器本身不支持任何写命令，而 slave 又被设置为了只读。<br>
Cluster 集群会将 key hash 到某个分片上，同样也能避免了竞争。</p>
</blockquote>
<ul>
<li>但 Lua 本身<strong>不能保证原子性</strong>，Redis 也没有<code>undo log</code>这一说，如果执行到一半出现宕机（Crash）或者数据漂移也可能会出现数据不一致的问题。因此，如果 Lua 脚本中执行的是<code>set+expire</code>，则有必要在启动的时候进行一个清理动作：删除服务器上旧的 IdpKey。</li>
</ul>
<blockquote>
<p>一般不会使用<code>set+expire</code>实现加缓存、加锁等操作，而是使用一条带缓存时间的 set 命令。</p>
</blockquote>
<ul>
<li>虽然 Lua 不能满足原子性，但是它<strong>最小化了网络的影响</strong>，它将所有需要调用的命令和逻辑打包传到服务器上执行，而且只需要上传一次，之后可以通过 SHA 值来指定服务器上的一个脚本。</li>
</ul>
<blockquote>
<p>Redis 内置 Lua 脚本的调试方法：<a href="https://redis.io/topics/ldb" target="_blank" rel="noopener">Redis Lua scripts debugger</a><br>
其实除了 Lua 脚本，还可以通过<strong>watch</strong>机制（类似 ZooKeeper 中的 Watcher）实现乐观锁来取代，优点是简单、不需要维护 lua 代码，但缺点是需要轮询、效率更低。<br>
或者通过 Redis 的事务机制来实现，Redis 会将一个事务范围内的所有命令打包发到服务器上，直到 exec 才会批量执行，具有和 lua 脚本类似的特性，但是上传多条命令有一定时间损耗，需要权衡使用。</p>
</blockquote>
<h3 id="如果存储服务器宕机重启？数据漂移"><a class="header-anchor" href="#如果存储服务器宕机重启？数据漂移">¶</a>如果存储服务器宕机重启？数据漂移</h3>
<p>可用性是分布式系统的主要关注点之一（CAP），当</p>
<ul>
<li><strong>重启</strong>，像 MySQL 这种传统关系型数据库，底层使用文件存储，搭建主从集群后，基本不需要担心数据丢失，而 Redis 这样的内存数据库，待定…。</li>
</ul>
<blockquote>
<p>也不能完全相信操作系统，因为为了效率，数据会被先保存到高速缓存，并以某种频率同步到磁盘上，数据会先被保存到高速缓存，这提高了写效率，也隐含了数据丢失的隐患。</p>
</blockquote>
<ul>
<li><strong>分库分表</strong>的时候需要先将原表按某种策略拆到多个表，再按需要拆到多个库中，这个过程就叫数据漂移，待定…。</li>
</ul>
<p>退一步讲，重启和漂移只会在很少的情况下发生，如果只遵循最基本的<code>BASE</code>，让大部分请求可用，万一不小心碰到了一些请求重试了也不可用的情况，用户也只需刷新一下即可。</p>
<h2 id="三-耦合"><a class="header-anchor" href="#三-耦合">¶</a>三、耦合</h2>
<h3 id="spring-aop"><a class="header-anchor" href="#spring-aop">¶</a>Spring AOP</h3>
<p>幂等性检查的场景比较多，属于比较典型的横切关注点，适合采用 AOP 的方式进行简化。</p>
<h3 id="多种-idpkey-生成方式"><a class="header-anchor" href="#多种-idpkey-生成方式">¶</a>多种 IdpKey 生成方式</h3>
<p>正如之前提到的，IdpKey 的 ID 属性可以用 Tracing 组件的 SpanId 来代替，是因为一般链路追踪组件中， 在每次重试时附带的 SpanId 都是同一个，当然是否合适还是要看具体的实现。</p>
<h3 id="多种-idpkey-保存方式"><a class="header-anchor" href="#多种-idpkey-保存方式">¶</a>多种 IdpKey 保存方式</h3>
<p>KeyStore 中定义了几个我认为必须原子化的操作（putIfAbsent、putIfAbsentOrInStates），如果能在持久化层实现这些操作的原子性当然最好，这样就不用额外添加分布式锁了。<br>
我提供了两种实现：</p>
<ol>
<li>SQLKeyStore 中主要通过数据库的行锁来实现。</li>
<li>RedisKeyStore 中主要通过 Redis 的 Lua 扩展来实现。</li>
</ol>
<h3 id="与-tracing-组件如何配合"><a class="header-anchor" href="#与-tracing-组件如何配合">¶</a>与 Tracing 组件如何配合</h3>
<p><img src="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/sidp-BlockingIdpChecker%E4%B8%8ETracing%E7%BB%84%E4%BB%B6%E9%85%8D%E5%90%88.png" alt="与Tracing组件配合后的交互流程" title="BlockingIdpChecker与Tracing组件配合"><br>
以代码中的幂等检查器 BlockingIdpChecker 为例，上图是与 Tracing 组件配置后 BlockingIdpChecker 的大概工作方式。<br>
详细描述待定…</p>
<h2 id="四-并发控制"><a class="header-anchor" href="#四-并发控制">¶</a>四、并发控制</h2>
<h3 id="为什么使用行锁-version-sqlkeystore"><a class="header-anchor" href="#为什么使用行锁-version-sqlkeystore">¶</a>为什么使用行锁+version（SQLKeyStore）</h3>
<p>在 SQLKeyStore 中实现一些复合操作时，为什么不使用乐观锁，而是用行锁+version 的方式？<br>
具体的伪代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select id, key_state, version from idpkey where id = #&#123;id&#125; or key_state in (#&#123;state1&#125;, #&#123;state2&#125;, ...) for update; -- 锁数据</span><br><span class="line">...</span><br><span class="line">insert into idpkey (id, key_state) values(?, ?) on duplicate key update key_state = ?; -- 更新锁住的数据</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>如果是乐观锁则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ..., version from idpkey where id = #&#123;id&#125;;</span><br><span class="line">...</span><br><span class="line">update idpkey set id = #&#123;id&#125; and key_state in (#&#123;state1&#125;, #&#123;state2&#125;, ...);</span><br></pre></td></tr></table></figure>
<p>这里 key_state 其实起着类似乐观锁的作用，因为只有在某些状态下才能更新成功，但是会有点问题：</p>
<ul>
<li>idpKey 有三类状态：pass（由具体规则而定）, blocking（相当于 EXECUTING）, reject（由具体规则而定，但是都会包含 SUCCESS），当为 pass 状态时是可以更新的，但是更新失败时可能是 blocking 或 reject 的，必须要把更新时数据库里的值返回回来判断，所以要使用行锁来同步其他线程，实现一种类似 swap 的原子操作；</li>
</ul>
<p>看 SQLKeyStore 中一些复合操作（如 putIfAbsent）返回值为什么要加上更新的数量？先看以下四种可能情况：</p>
<ol>
<li>数据库中不存在该 idpKey，则插入数据，数据库中 idpKey 状态为 EXECUTING，返回数据状态为 EXECUTING，此时程序应该继续执行；</li>
<li>数据库中存在该 idpKey，且状态属于 pass，则更新成功，数据库中 idpKey 状态为 EXECUTING，返回数据状态为 EXECUTING，此时程序应该继续执行；</li>
<li>数据库中存在该 idpKey，且状态属于 blocking，则更新失败，返回数据状态为 EXECUTING，此时程序应该被阻塞</li>
<li>数据库中存在该 idpKey，且状态属于 reject，则更新失败，返回数据状态属于 reject 集合，则该次调用应该被放弃。</li>
</ol>
<p>其中，情况 2 和 3 可以使用成复杂状态机系统设计功更新数量来区分，因此在返回值中加上了这个更新数量。</p>
<h3 id="隔离性及可能导致的安全问题"><a class="header-anchor" href="#隔离性及可能导致的安全问题">¶</a>隔离性及可能导致的安全问题</h3>
<p>基于数据库的幂等性检查需要查询数据库，第一反应是可以并入业务本身的事务、利用现成的事务管理器来执行数据库操作，如果是 Spring，可以通过传入一个 TransactionManager 实现，代码量不会很大。但是最终没有采用，下面讨论这么做的动机。</p>
<blockquote>
<p>其实也实现了一个 TransactionManager 的版本，叫 TxKeyStore。</p>
</blockquote>
<p>一方面的问题来自事务的原子性：事务要么执行完，要么失败回滚，但是这种回滚会将接口调用状态的扭转变得更加复杂，难于管理。<br>
还有一方面的问题来自隔离性，隔离性是在设计数据库时必然会提到的话题，从最简单的读未提交到最严格的串行化，隔离性描述了事务之间互相影响的程度，其中，读未提交没有作任何限制，读已提交和可重复读这两个等级一般采用 MVCC 机制来实现，MySQL 的默认级别就是读提交，而串行化的方式一般是采用加锁来实现的，事务只能一个一个执行，粒度较大，效率太低一般不采用。所以现在的问题是：为什么可重复读不满足我们的需求？<br>
我们知道可重复读是通过 MVCC 实现的，简而言之，在进行操作的时候会利用<code>undo log</code>来拿到数据在访问前的状态，这样可以在不使用锁的前提下保证并发安全性。但是，为了效率起见，MVCC 的实现有时候并不排除幻读和丢失更新现象：</p>
<ol>
<li>一个事务中有多次查询，在后面的查询中能查到之前不存在的数据，这就是常提到的幻读现象。<br>
幻读有时候会被误认为能用 MVCC 来解决，看下面的事务执行图：<br>
<img src="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E4%BA%8B%E5%8A%A1MVCC%E4%B8%8D%E8%83%BD%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB.png" alt="事务MVCC不能避免幻读" title="事务MVCC不能避免幻读"><br>
事务 2 是在事务 1 之前执行的，这意味着事务 2 插入的数据能被事务 1 看到，事务 1 第一次读数据的时候，数据尚不存在，之后事务 2 插入了数据，事务 1 再读就能读出来了。<br>
解决幻读的方法主要是 Next-Key Lock，包括处理某个确定值的行锁和处理某个区间的 gap 锁。</li>
<li>脏读、不可重复读、幻读三个问题考虑的场景基本上都是一个事务写一个事务<strong>只读</strong>，但没有考虑两个事务都在对数据进行修改的情况。如下图所示：<br>
<img src="https://tallate.top/imgs/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E2%80%94%E2%80%94%E5%B9%82%E7%AD%89/%E4%BA%8B%E5%8A%A1MVCC%E4%B8%8D%E8%83%BD%E9%81%BF%E5%85%8D%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.png" alt="事务MVCC不能避免丢失更新问题" title="事务MVCC不能避免丢失更新问题"><br>
两个事务都读取数据 A 然后对其执行写操作，但因为事务 2 是后写的，所以事务 A 作的修改就被覆盖掉了，这就是丢失更新问题。<br>
丢失更新问题一般通过加锁来解决，更具体地说，是行锁中的排他锁（共享锁就不行了，而且共享锁很容易导致死锁），在读出数据的时候使用 “for update” 子句来加锁，使两个事务不能同时对该条数据进行读写操作。<br>
在代码中，幂等检查是更加复合的操作，加行锁可以保证一次请求的多次重试之间互斥，但又不必像设置成串行化隔离级别会将所有请求的事务都调整成互斥的，这样粒度太大、影响并发性能。</li>
</ol>
<p><strong>总而言之</strong>，代码中的 JdbcKeyStore 没有采取并入业务操作所在事务的方案，而是使用了数据库行锁来保证并发安全性，行锁可以保证操作同一条数据的两个事务能够按先后顺序进入临界区，这同时解决了幻读问题。至于为什么不用乐观锁，这在上边已经提到过了。</p>
<h2 id="五-测试"><a class="header-anchor" href="#五-测试">¶</a>五、测试</h2>
<p>幂等检查器的原理是给所有非幂等的接口织入检查代码（AOP），这样的接口是比较多的，因此性能的好坏可以直接影响业务逻辑的执行效率。因此：</p>
<ul>
<li>一方面需要保证幂等检查本身是正确无误的；</li>
<li>另一方面需要评估它对业务本身造成的影响、是否在可接受的性能损耗范围内。</li>
</ul>
<h3 id="功能测试-并发"><a class="header-anchor" href="#功能测试-并发">¶</a>功能测试（并发）</h3>
<p>检查组件是否正常工作的手段主要是将同一请求发多次到一个接口，观察成功执行的情况下是否只执行了一次，失败的情况下是否有重试。根据执行状态有下面几个测试点：</p>
<ol>
<li>同时发 3 个请求，1 次正常执行，其他被抛弃；</li>
<li>同时发 3 个请求，1 次超时，其他被抛弃；</li>
<li>同时发 3 个请求，1 次抛出 Exception 异常，重试一次成功，其他被抛弃；</li>
<li>同时发 3 个请求，1 次抛出 RuntimeException（或 Error）异常，其他被抛弃。</li>
</ol>
<p>第 2 条不管超时后是否有执行成功都会抛弃掉其他重试请求，因为特别长时间的超时影响用户体验，本身就没有继续执行下去的必要。<br>
第 3、4 条区别是异常的类型——也就是必检和免检的区别，免检异常一般是代码有漏洞或无法恢复的系统崩溃这些情况，重试几次一般也不会有什么作用，所以不如直接放弃好了。</p>
<p>具体测试用例见 <a href="http://www.github.com/tallate/TIdempotent" target="_blank" rel="noopener">项目下的 tidp-test 模块</a> 。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="https://github.com/spring-cloud/spring-cloud-sleuth" target="_blank" rel="noopener">Spring Cloud Sleuth</a><br>
<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">zipkin</a><br>
<a href="https://github.com/opentracing/specification/blob/master/specification.md" target="_blank" rel="noopener">OpenTracing</a></p>
<ol>
<li><a href="https://www.zhihu.com/question/19867883" target="_blank" rel="noopener">怎样正确做 Web 应用的压力测试？</a></li>
<li><a href="https://www.cnblogs.com/Detector/p/8684658.html" target="_blank" rel="noopener">【测试设计】性能测试工具选择：wrk？jmeter？locust？还是 LR？</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/幂等/" rel="tag"># 幂等</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/cd87e5dd.html" rel="next" title="司库云系统简析">
                <i class="fa fa-chevron-left"></i> 司库云系统简析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/755a34bb.html" rel="prev" title="实现一个服务熔断器">
                实现一个服务熔断器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">132</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#〇-初衷"><span class="nav-number">1.</span> <span class="nav-text">¶〇、初衷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一-使用时机"><span class="nav-number">2.</span> <span class="nav-text">¶一、使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务-api"><span class="nav-number">2.1.</span> <span class="nav-text">¶服务 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http-协议的幂等性"><span class="nav-number">2.2.</span> <span class="nav-text">¶HTTP 协议的幂等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web-api"><span class="nav-number">2.3.</span> <span class="nav-text">¶WEB API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写数据库"><span class="nav-number">2.4.</span> <span class="nav-text">¶写数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-设计思路"><span class="nav-number">3.</span> <span class="nav-text">¶二、设计思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何标识一次请求"><span class="nav-number">3.1.</span> <span class="nav-text">¶如何标识一次请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口执行状态"><span class="nav-number">3.2.</span> <span class="nav-text">¶接口执行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果缓存-压缩"><span class="nav-number">3.3.</span> <span class="nav-text">¶结果缓存+压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sql-数据库"><span class="nav-number">3.4.</span> <span class="nav-text">¶SQL 数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kv-数据库-rediskeystore"><span class="nav-number">3.5.</span> <span class="nav-text">¶KV 数据库（RedisKeyStore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果存储服务器宕机重启？数据漂移"><span class="nav-number">3.6.</span> <span class="nav-text">¶如果存储服务器宕机重启？数据漂移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-耦合"><span class="nav-number">4.</span> <span class="nav-text">¶三、耦合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop"><span class="nav-number">4.1.</span> <span class="nav-text">¶Spring AOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多种-idpkey-生成方式"><span class="nav-number">4.2.</span> <span class="nav-text">¶多种 IdpKey 生成方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多种-idpkey-保存方式"><span class="nav-number">4.3.</span> <span class="nav-text">¶多种 IdpKey 保存方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与-tracing-组件如何配合"><span class="nav-number">4.4.</span> <span class="nav-text">¶与 Tracing 组件如何配合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-并发控制"><span class="nav-number">5.</span> <span class="nav-text">¶四、并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用行锁-version-sqlkeystore"><span class="nav-number">5.1.</span> <span class="nav-text">¶为什么使用行锁+version（SQLKeyStore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离性及可能导致的安全问题"><span class="nav-number">5.2.</span> <span class="nav-text">¶隔离性及可能导致的安全问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-测试"><span class="nav-number">6.</span> <span class="nav-text">¶五、测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#功能测试-并发"><span class="nav-number">6.1.</span> <span class="nav-text">¶功能测试（并发）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">¶参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
