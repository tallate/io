<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Distributed System,">










<meta name="description" content="执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。">
<meta name="keywords" content="Distributed System">
<meta property="og:type" content="article">
<meta property="og:title" content="异步任务和线程池">
<meta property="og:url" content="https://tallate.github.io/e3d5c2fc.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://47.88.24.11/imgs/异步任务/线程池执行流程.png">
<meta property="og:image" content="http://47.88.24.11/imgs/异步任务/服务端异步.png">
<meta property="og:updated_time" content="2019-10-03T11:00:49.471Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="异步任务和线程池">
<meta name="twitter:description" content="执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。">
<meta name="twitter:image" content="http://47.88.24.11/imgs/异步任务/线程池执行流程.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/e3d5c2fc.html">







  <title>异步任务和线程池 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e3d5c2fc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">异步任务和线程池</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。</p>
<a id="more"></a>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程任务特性分析"><a href="#线程任务特性分析" class="headerlink" title="线程任务特性分析"></a>线程任务特性分析</h3><p>任务的性质：CPU密集型任务、IO密集型任务、混合型任务。<br>任务的优先级：高、中、低。<br>任务的执行时间：长、中、短。<br>任务的依赖性：是否依赖其他系统资源，如数据库连接等。</p>
<h3 id="线程池容量评估"><a href="#线程池容量评估" class="headerlink" title="线程池容量评估"></a>线程池容量评估</h3><p>评估线程池要开多大一般会借助于一个公式：<br><code>TN = CN * CU * (1 + w/c)</code><br><code>TN = 线程池中总线程数</code><br><code>CN = CPU核心数</code><br><code>CU = CPU使用率</code><br><code>w = 等待时间</code><br><code>c = 计算时间</code></p>
<blockquote>
<p>《java并发编程实践》和《Java 虚拟机并发编程》都有描述。</p>
</blockquote>
<p>对线程池大小的计算需要区分所需执行的任务特点：</p>
<ul>
<li>IO密集型<br>若任务对其他系统资源有依赖，如某个任务依赖数据库的连接返回的结果，这时候等待的时间越长，则CPU空闲的时间越长，那么线程数量应设置得越大，才能更好的利用CPU。<br>一般情况下，如果存在IO，那么肯定w/c&gt;1（阻塞耗时一般都是计算耗时的很多倍）,但是需要考虑系统内存有限（每开启一个线程都需要内存空间），这里需要上服务器测试具体多少个线程数适合（CPU占比、线程数、总耗时、内存消耗）。如果不想去测试，保守点取1即：<br><code>TN = 2CN</code></li>
<li>计算密集型<br>假设没有等待或者近似为没有等待w=0，则w/c=0，有：<br><code>TN = CN</code><br>对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率，这样，即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费，但也同时会多一个CPU上下文切换。</li>
<li>混合型<br>如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。</li>
</ul>
<p>总而言之：</p>
<ol>
<li>高并发、任务执行时间短的业务<br>线程池线程数可以设置为<strong>CPU核数+1</strong>，减少线程上下文的切换 </li>
<li>并发不高、任务执行时间长的业务<br>要区分开看： <ul>
<li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以<strong>适当加大线程池中的线程数目</strong>，让CPU处理更多的业务 </li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 </li>
</ul>
</li>
<li>并发高、业务执行时间长<br>解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，然后再考虑如何设置线程池属性。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li>
</ol>
<p>当然具体合理设置线程池大小，需要结合系统实际情况，在大量的尝试下比较才能得出，以上只是前人总结的规律。</p>
<h2 id="JDK-ExecutorService"><a href="#JDK-ExecutorService" class="headerlink" title="JDK - ExecutorService"></a>JDK - ExecutorService</h2><p>Executor是Java1.5引入的线程执行器，主要用于负责线程的创建和调度，程序中不用再显示地调用new Thread().start()（实现业务逻辑和线程创建、调度间的解耦）。<br> 接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个 ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的 ExecutorService 的实现就是一个线程池的实现。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><h4 id="execute、submit-任务提交"><a href="#execute、submit-任务提交" class="headerlink" title="execute、submit - 任务提交"></a>execute、submit - 任务提交</h4><ul>
<li>execute(Runnable)<br>接收一个 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。如下是一个使用 ExecutorService 执行 Runnable 的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">executorService.execute(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用 接收 Callable 参数的 execute() 方法，后者将会在下文中提到。</p>
<ul>
<li><p>submit(Runnable)<br>会返回一个Future， Future 对象可以用于判断 Runnable 是否结束执行。如下是一个 ExecutorService 的 submit() 方法的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//如果任务结束执行则返回 null</span><br><span class="line">System.out.println(&quot;future.get()=&quot; + future.get());</span><br></pre></td></tr></table></figure>
</li>
<li><p>submit(Callable)<br>接收一个Callable参数，Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(new Callable()&#123;</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous Callable&quot;);</span><br><span class="line">        return &quot;Callable Result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;future.get() = &quot; + future.get());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="invokeAll、invokeAny-调用Callable任务"><a href="#invokeAll、invokeAny-调用Callable任务" class="headerlink" title="invokeAll、invokeAny - 调用Callable任务"></a>invokeAll、invokeAny - 调用Callable任务</h4><ul>
<li>invokeAll()<br>方法 invokeAll() 会<strong>调用所有</strong>存在于参数集合中的 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每個 Callable 的执行结果。<br>需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过 Future 对象来了解到这個差异。</li>
<li>invokeAny()<br>方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。<br>如果一个任务运行完毕或者抛出异常，方法会取消其它的 Callable 的执行。<h4 id="shutdown-终止"><a href="#shutdown-终止" class="headerlink" title="shutdown - 终止"></a>shutdown - 终止</h4>当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态，ExecutorService中仍处于执行状态的用户线程会阻止Java虚拟机的关闭。</li>
<li>shutdown<br>ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorService 才会真的关闭。</li>
<li><del>shutdownNow</del><br>立刻终止，这个方法不推荐使用，如果线程正在执行重要任务，直接中断掉可能破坏数据一致性。</li>
</ul>
<p>shutdown虽然可以保证应用能安全退出，但是不能排除某些情况下线程陷入了死循环或遇到一些特别耗时的任务、导致线程池无法退出的情况，这时最好设置一个超时退出的机制，可以使用<code>awaitTermination</code>来实现。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor是ExecutorService的实现类，也是最常使用的线程池实现类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">        int maximumPoolSize,</span><br><span class="line">        long keepAliveTime,</span><br><span class="line">        TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">        ThreadFactory threadFactory,</span><br><span class="line">        RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></p>
<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程，即当前线程总数小于corePoolSize的情况下新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程。<br>这里需要注意的是：在刚刚创建ThreadPoolExecutor的时候，线程并不会立即启动，而是要等到有任务提交时才会启动，除非调用了prestartCoreThread/prestartAllCoreThreads事先启动核心线程。再考虑到keepAliveTime和allowCoreThreadTimeOut超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corePoolSize。</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是largestPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么说是曾经呢？因为线程池创建之后，可以调用setMaximumPoolSize()改变运行的最大线程的数目。</p>
<h4 id="poolSize"><a href="#poolSize" class="headerlink" title="poolSize"></a>poolSize</h4><p>线程池中当前线程的数量，当该值为0的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize不会超过maximumPoolSize。</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会按照keepAliveTime的值判断是否会超时退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut。<br>在压力很大的情况下，线程池中的所有线程都在处理新提交的任务或者是在排队的任务，这个时候线程池处在忙碌状态。如果压力很小，那么可能很多线程池都处在空闲状态，这个时候为了节省系统资源，回收这些没有用的空闲线程，就必须提供一些超时机制，这也是线程池大小调节策略的一部分。通过corePoolSize和maximumPoolSize，控制如何新增线程；通过allowCoreThreadTimeOut和keepAliveTime，控制如何销毁线程。</p>
<h4 id="TimeUnit-unit"><a href="#TimeUnit-unit" class="headerlink" title="TimeUnit unit"></a>TimeUnit unit</h4><p>keepAliveTime 的单位，TimeUnit 是一个 枚举类型，其包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 </span><br><span class="line">MILLISECONDS ： 1毫秒 = 1秒 /1000 </span><br><span class="line">SECONDS ： 秒 </span><br><span class="line">MINUTES ： 分 </span><br><span class="line">HOURS ： 小时</span><br><span class="line">DAYS ： 天</span><br></pre></td></tr></table></figure></p>
<h4 id="BlockingQueue-workQueue"><a href="#BlockingQueue-workQueue" class="headerlink" title="BlockingQueue workQueue"></a>BlockingQueue<runnable> workQueue</runnable></h4><p>该线程池中的任务队列，维护着等待执行的 Runnable 对象。<br>当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。<br>常用的workQueue类型： </p>
<ul>
<li>SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize 一般指定成 Integer.MAX_VALUE，即无限大 </li>
<li>LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了 maximumPoolSize 的设定失效，因为总线程数永远不会超过 corePoolSize </li>
<li>ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到 corePoolSize 的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程 (非核心线程) 执行任务，又如果总线程数到了 maximumPoolSize，并且队列也满了，则发生错误 </li>
<li>DelayQueue：队列内元素必须实现 Delayed 接口，这就意味着你传进去的任务必须先实现 Delayed 接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务<h4 id="ThreadFactory-threadFactory"><a href="#ThreadFactory-threadFactory" class="headerlink" title="ThreadFactory threadFactory"></a>ThreadFactory threadFactory</h4>创建线程的方式，这是一个接口，你 new 他的时候需要实现他的Thread newThread(Runnable r)方法，一般用不上。<br>比如 AsyncTask ，它是对线程池的封装，新建线程池的 threadFactory 参数源码如下，非常简单：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new ThreadFactory() &#123;</span><br><span class="line">    private final AtomicInteger mCount = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">    public Thread new Thread(Runnable r) &#123;</span><br><span class="line">           return new Thread(r,&quot;AsyncTask#&quot;+mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="RejectedExecutionHandler-handler"><a href="#RejectedExecutionHandler-handler" class="headerlink" title="RejectedExecutionHandler handler"></a>RejectedExecutionHandler handler</h4><p>抛出异常专用，比如上面提到的两个错误发生了，就会由这个handler抛出异常，不指定的话，这个参数会取默认值ThreadPoolExecutor.AbortPolicy，所有类型如下： </p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常 </li>
<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常 </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） </li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务<h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><img src="http://47.88.24.11/imgs/异步任务/线程池执行流程.png" alt="线程池执行流程" title="线程池执行流程"></li>
</ul>
<ol>
<li>如果线程池的当前poolSize &lt; corePoolSize，那么就新增加一个线程处理新提交的任务，即使此时线程池中存在空闲线程； </li>
<li>如果当前poolSize已经达到corePoolSize，就将新提交的任务提交到workQueue排队，等候处理workQueue.offer(command)；</li>
<li>如果workQueue容量已达上限，并且当前poolSize &lt; maximumPoolSize，那么就新增线程来处理任务；</li>
<li>如果workQueue已满，并且当前poolSize &gt;= maximumPoolSize，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务，新提交任务由RejectedExecutionHandler处理。<h4 id="线程回收策略"><a href="#线程回收策略" class="headerlink" title="线程回收策略"></a>线程回收策略</h4></li>
</ol>
<ul>
<li>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程</li>
<li>当设置<code>allowCoreThreadTimeOut(true)</code>时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭<h4 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h4>J.U.C提供的ThreadPoolExecutor只支持任务在内存中排队，通过BlockingQueue暂存还没有来得及执行的任务。<br>常用的有SynchronousQueue，LinkedBlockingQueue，ArrayBlockingQueue三种阻塞队列。<br>一般如果线程池任务队列采用<strong>LinkedBlockingQueue</strong>队列的话，那么不会拒绝任何任务（因为队列大小没有限制），这种情况下，ThreadPoolExecutor最多仅会按照最小线程数来创建线程，也就是说线程池大小被忽略了。<br>如果线程池任务队列采用<strong>ArrayBlockingQueue</strong>队列的话，那么ThreadPoolExecutor将会采取一个非常负责的算法，比如假定线程池的最小线程数为4，最大为8所用的ArrayBlockingQueue最大为10。随着任务到达并被放到队列中，线程池中最多运行4个线程（即最小线程数）。即使队列完全填满，也就是说有10个处于等待状态的任务，ThreadPoolExecutor也只会利用4个线程。如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。<br>这个算法背后的理念是：该池大部分时间仅使用核心线程（4个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4>AbortPolicy: 直接抛异常<br>CallerRunsPolicy: 用调用者的线程来运行任务<br>DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>DiscardPolicy: 直接将新任务丢弃</li>
</ul>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>Executors提供了一些工厂方法，用于创建一些适用于特定场景的线程池。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                              60L, TimeUnit.SECONDS,</span><br><span class="line">                              new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；<br>若池中线程空闲时间超过指定大小，则该线程会被销毁。</p>
<ul>
<li>优势：1.线程数无限制 2.有空闲线程则复用空闲线程，若无空闲线程则新建线程 3.一定程序减少频繁创建/销毁线程，减少系统开销</li>
<li>适用：执行很多短期异步的小程序或者负载较轻的服务器<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4>返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue() 无界阻塞队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                              new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；<br>如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)。</p>
<ul>
<li>优势：1.可控制线程最大并发数（同时执行的线程数） 2.超出的线程会在队列中等待</li>
<li>适用：执行长期的任务，性能好很多<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4>FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue() 无解阻塞队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</p>
<ul>
<li>优势：1.有且仅有一个工作线程执行任务 2.所有任务按照指定顺序执行，即遵循队列的入队出队规则</li>
<li>适用：一个任务一个任务执行的场景<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4>创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">//ScheduledThreadPoolExecutor()</span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构<br>适用：定时及周期性执行任务的场景</p>
<h3 id="线程池预热"><a href="#线程池预热" class="headerlink" title="线程池预热"></a>线程池预热</h3><p>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，（除非调用了 prestartAllCoreThreads() 或者 prestartCoreThread() 方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程）。</p>
<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><p>参数的设置跟系统的负载有直接的关系，下面为系统负载的相关参数：</p>
<ul>
<li>tasks：每秒需要处理的最大任务数量</li>
<li>tasktime：处理第个任务所需要的时间</li>
<li>responsetime：系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒。</li>
</ul>
<p>下面结合线程池原理来解释ThreadPoolExecutor参数应该怎么设置：</p>
<ul>
<li>corePoolSize<br>每个任务需要 tasktime 秒处理，则每个线程每秒可处理 1 / tasktime 个任务。<br>系统每秒有 tasks 个任务需要处理，则需要的线程数为：tasks / ( 1 / tasktime )，即 tasks <em> tasktime 个线程数。<br>假设系统每秒任务数为 100 ~ 1000，每个任务耗时 0.1 秒，则需要 100 </em> 0.1 至 1000 * 0.1，即 10 ~ 100 个线程。<br>那么 corePoolSize 应该设置为大于 10，具体数字最好根据 8020 原则，即 80 % 情况下系统每秒任务数，若系统80%的情况下第秒任务数小于 200，最多时为 1000，则 corePoolSize 可设置为 20。</li>
<li>queueCapacity<br>任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。 队列长度可以设置为 ( corePoolSize / tasktime ) <em> responsetime ： ( 20 / 0.1 ) </em> 2 = 400，即队列长度可设置为 400。<br>队列长度设置过大，会导致任务响应时间过长，切忌以下写法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue queue = new LinkedBlockingQueue();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这实际上是将队列长度设置为Integer.MAX_VALUE，将会导致线程数量永远为corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。</p>
<ul>
<li>maxPoolSize<br>当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。<br>每秒 200 个任务需要 20 个线程，那么当每秒达到 1000 个任务时，则需要 ( 1000 - queueCapacity ) * ( 20 / 200 )，即 60 个线程，可将 maxPoolSize 设置为 60。<br>若结合 CPU 的情况，比如，当线程数量达到 50 时，CPU 达到 100%，则将 maxPoolSize 设置为 60 也不合适，此时若系统负载长时间维持在每秒 1000个 任务，则超出线程池处理能力，应设法降低每个任务的处理时间 ( tasktime )。</li>
<li>keepAliveTime:<br>线程数量只增加不减少也不行。当负载降低时，可减少线程数量，如果一个线程空闲时间达到 keepAliveTiime，该线程就退出。 默认情况下线程池最少会保持 corePoolSize 个线程。</li>
<li>allowCoreThreadTimeout:<br>默认情况下核心线程不会退出，可通过将该参数设置为 true，让核心线程也退出。</li>
</ul>
<h3 id="Spring-ThreadPoolTaskExecutor"><a href="#Spring-ThreadPoolTaskExecutor" class="headerlink" title="Spring - ThreadPoolTaskExecutor"></a>Spring - ThreadPoolTaskExecutor</h3><p>Spring的TaskExecutor接口等同于Java.util.concurrent.Executor接口。 实际上，它存在的主要原因是为了在使用线程池的时候，将对Java 5的依赖抽象出来，在需要时给其他Spring组件提供一个线程池的抽象。 这个接口只有一个方法execute(Runnable task)，它根据线程池的语义和配置，来接受一个执行任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;taskExecutor&quot; name=&quot;taskExecutor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;  </span><br><span class="line">    &lt;!-- 核心线程数 线程池维护线程的最少数量 --&gt;</span><br><span class="line">    &lt;property name=&quot;corePoolSize&quot; value=&quot;10&quot; /&gt;  </span><br><span class="line">    &lt;!-- 线程池维护线程所允许的空闲时间 --&gt;</span><br><span class="line">    &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;200&quot; /&gt;  </span><br><span class="line">    &lt;!-- 线程池维护线程的最大数量 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot; /&gt;  </span><br><span class="line">    &lt;!-- 线程池所使用的缓冲队列 --&gt;</span><br><span class="line">    &lt;property name=&quot;queueCapacity&quot; value=&quot;100&quot; /&gt; </span><br><span class="line">    &lt;!-- 线程池对拒绝任务(无线程可用)的处理策略 ThreadPoolExecutor.CallerRunsPolicy策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃. --&gt;</span><br><span class="line">    &lt;property name=&quot;rejectedExecutionHandler&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot; /&gt;</span><br><span class="line">    &lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name = &quot;taskExecutor&quot;)</span><br><span class="line">private ThreadPoolTaskExecutor taskExecutor;</span><br></pre></td></tr></table></figure>
<p>提交线程任务主要有以下两个API：</p>
<ul>
<li>void taskExecutor.execute(…)</li>
<li>Future taskExecutor.submit(…)</li>
</ul>
<p>任务处理的逻辑和JDK ExecutorService类似：<br>如果此时线程池中的数量<strong>小于</strong>corePoolSize，即使线程池中的线程都处于空闲状态，也要<strong>创建新的线程</strong>来处理被添加的任务。<br>如果此时线程池中的数量<strong>等于</strong>corePoolSize，但是缓冲队列 workQueue未满，那么<strong>任务被放入缓冲队列</strong>。<br>如果此时线程池中的数量<strong>大于</strong>corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maxPoolSize，建新的线程来处理被添加的任务。<br>如果此时线程池中的数量<strong>大于</strong>corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maxPoolSize，那么通过handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程 maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。<br>当线程池中的线程数量<strong>大于</strong>corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</p>
<ul>
<li>SimpleAsyncTaskExecutor 类<br>这个实现不重用任何线程，或者说它每次调用都启动一个新线程。但是，它还是支持对并发总数设限，当超过线程并发总数限制时，阻塞新的调用，直到有位置被释放。如果你需要真正的池，请继续往下看。</li>
<li>SyncTaskExecutor类<br>这个实现不会异步执行。相反，每次调用都在发起调用的线程中执行。它的主要用处是在不需要多线程的时候，比如简单的test case。</li>
<li>ConcurrentTaskExecutor 类<br>这个实现是对Java 5 java.util.concurrent.Executor类的包装。有另一个备选, ThreadPoolTaskExecutor类，它暴露了Executor的配置参数作为bean属性。很少需要使用ConcurrentTaskExecutor, 但是如果ThreadPoolTaskExecutor不敷所需，ConcurrentTaskExecutor是另外一个备选。</li>
<li>SimpleThreadPoolTaskExecutor 类<br>这个实现实际上是Quartz的SimpleThreadPool类的子类，它会监听Spring的生命周期回调。当你有线程池，需要在Quartz和非Quartz组件中共用时，这是它的典型用处。</li>
<li>ThreadPoolTaskExecutor 类<br>它不支持任何对java.util.concurrent包的替换或者下行移植。Doug Lea和Dawid Kurzyniec对java.util.concurrent的实现都采用了不同的包结构，导致它们无法正确运行。<br>这个实现只能在Java 5环境中使用，但是却是这个环境中最常用的。它暴露的bean properties可以用来配置一个java.util.concurrent.ThreadPoolExecutor，把它包装到一个TaskExecutor中。如果你需要更加先进的类，比如ScheduledThreadPoolExecutor,我们建议你使用ConcurrentTaskExecutor来替代。</li>
<li>TimerTaskExecutor类<br>这个实现使用一个TimerTask作为其背后的实现。它和SyncTaskExecutor的不同在于，方法调用是在一个独立的线程中进行的，虽然在那个线程中是同步的。</li>
<li>WorkManagerTaskExecutor类<br>CommonJ 是BEA和IBM联合开发的一套规范。这些规范并非java ee的标准，但它是BEA和IBM的应用服务器实现的共同标准<br>这个实现使用了CommonJ WorkManager作为其底层实现，是在Spring context中配置CommonJ WorkManager应用的最重要的类。和SimpleThreadPoolTaskExecutor类似，这个类实现了WorkManager接口，因此可以直接作为WorkManager使用。</li>
</ul>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>Work-stealing机制更好地提升并发效率<br>TODO</p>
<h3 id="Guava-MoreExecutors"><a href="#Guava-MoreExecutors" class="headerlink" title="Guava - MoreExecutors"></a>Guava - MoreExecutors</h3><p>TODO</p>
<h2 id="RPC中的异步"><a href="#RPC中的异步" class="headerlink" title="RPC中的异步"></a>RPC中的异步</h2><h3 id="客户端-OR-服务端-异步"><a href="#客户端-OR-服务端-异步" class="headerlink" title="客户端 OR 服务端 异步"></a>客户端 OR 服务端 异步</h3><p>客户端异步比较常见，因为任何网络调用基本都可以方便地包装成异步调用，朴实无华且枯燥，下载这段代码是一个简单的demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ClientAsync &#123;</span><br><span class="line"></span><br><span class="line">    private static class ClientAsyncExecutor &#123;</span><br><span class="line"></span><br><span class="line">        private ExecutorService threadPool;</span><br><span class="line">        private Supplier&lt;String&gt; dataSupplier;</span><br><span class="line">        private Consumer&lt;String&gt; callback;</span><br><span class="line"></span><br><span class="line">        public ClientAsyncExecutor(ExecutorService threadPool,</span><br><span class="line">                Supplier&lt;String&gt; dataSupplier,</span><br><span class="line">                Consumer&lt;String&gt; callback) &#123;</span><br><span class="line">            this.threadPool = threadPool;</span><br><span class="line">            this.dataSupplier = dataSupplier;</span><br><span class="line">            this.callback = callback;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void call() &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                String data = dataSupplier.get();</span><br><span class="line">                callback.accept(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        ClientAsyncExecutor executor = new ClientAsyncExecutor(</span><br><span class="line">                threadPool,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(3000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return &quot;done&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                res -&gt; System.out.println(&quot;结果：&quot; + res));</span><br><span class="line">        executor.call();</span><br><span class="line">        System.out.println(&quot;call returned&quot;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadPool.awaitTermination(10000, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端异步是一种伪异步，本质上仍是同步调用，只不过等待是放到另外一个线程中去做的，如果这样等待的线程比较多，对客户端的线程池容易造成压力，。<br>服务端的异步实现起来就比较费劲了，因为客户端需要额外提供一个入口来接收服务端执行完毕的结果：<br><img src="http://47.88.24.11/imgs/异步任务/服务端异步.png" alt="服务端异步" title="服务端异步"></p>
<h3 id="良好习惯"><a href="#良好习惯" class="headerlink" title="良好习惯"></a>良好习惯</h3><p>不论是桌面应用还是 Web 应用，多线程代码都是比较难玩得转的，玩不明白的结果就是一大堆令人毛骨悚然且难以捉摸、难以调试的问题——实际上，一旦你意识到正在处理一个并发问题，你可能就不得不完全放弃调试了，并转而手动检查代码。<br>鉴于此，我们当然是希望尽量避免并发问题的，理想情况下希望完全避免多线程错误，同样，不存在那种一刀切的方法，但这有一些调试和防止多线程错误的实际考虑因素：</p>
<ol>
<li>避免全局状态<br>首先，牢记 “全局状态” 问题。如果你正创建一个多线程应用，那么应该密切关注任何可能全局修改的内容，如果可能的话，将他们全部删掉，如果部分全局变量确实有理由保留，那么应该仔细保证其并发安全，并对程序性能进行跟踪，以确定不会因为引入新的等待时间而导致系统性能降低（并发修改时需要同步多个线程）。</li>
<li>避免可变性<br>这点直接来自于 函数式编程，并且适用于 OOP，声明应该避免类和对象状态的改变。简而言之，这意味着放弃 setter 方法，并在需要避免可变性的类或字段上拥有私有的 final 字段，它们的值唯一发生变化的时间是在构造期间。这样，你可以确定不会出现争用问题，且访问对象属性将始终提供正确的值。</li>
<li>日志及报警<br>评估你的程序可能会在何处发生异常，并预先记录所有关键数据。如果发生错误，你将很高兴可以得到信息说明收到了哪些请求，并可更好地了解你的应用程序为什么会出现错误。需要再次注意的是，日志记录引入了额外的文件 I/O，可能会严重影响应用的性能，因此请不要滥用日志。<br>在记日志的基础上，有必要根据SLA记录一些指标的报警阈值，比如订单中心下单失败，考虑可能是网络出现抖动引起超时（如果用到三方服务这个问题会更明显），因此报警阈值可以稍微调高一些，比如1分钟3次失败就打电话报警。</li>
<li>复用现存实现<br>每当你需要创建自己的线程时（例如：向不同的服务发出异步请求），复用现有的安全实现来代替创建自己的解决方案。这在很大程度上意味着要使用 ExecutorService 和 Java 8 简洁的函数式 CompletableFuture 来创建线程。Spring 还允许通过 DeferredResult 类来进行异步请求处理。</li>
</ol>
<h3 id="反模式-异步狂热"><a href="#反模式-异步狂热" class="headerlink" title="反模式-异步狂热"></a>反模式-异步狂热</h3><p>上边我们已经讨论过异步存在的优势和劣势，实际上在我读过的项目代码中，确实存在不少那种不异步不开心的“炫技代码”，给维护带来很大困难。<br>下面是一个非常直观的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String punch(People t) &#123;</span><br><span class="line">    return &quot;Oh, No&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过一个莫名其妙的异步包装，原来的可扩展性、性能均没有提升，甚至性能成功降低了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Function doPunch(People t) &#123;</span><br><span class="line">    return t -&gt; &#123;</span><br><span class="line">        return &quot;Oh, No&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String punch(People t) &#123;</span><br><span class="line">    Function f = doPunch(t);</span><br><span class="line">    return f.apply(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际情况可能会复杂得多，这样的代码不够简单直观、容易暗藏 Bug、不符合 KISS 原则，但是即便如此，还是有很多人会觉得特别绕的代码能体现一个人的水平、对代码的驾驭能力、能灵活运用设计模式的能力，我觉得大部分情况下事实并非如此。</p>
<h2 id="Spring-DeferredResult"><a href="#Spring-DeferredResult" class="headerlink" title="Spring - DeferredResult"></a>Spring - DeferredResult</h2><p>TODO</p>
<h2 id="Hystrix-Command"><a href="#Hystrix-Command" class="headerlink" title="Hystrix - Command"></a>Hystrix - Command</h2><p>Hystrix 的 Command 框架在CompletableFuture的基础上提供了合并请求的特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class BatchGetDataCommand extends HystrixCommand&lt;List&lt;Double&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Collection&lt;CollapsedRequest&lt;Double, Long&gt;&gt; requests;</span><br><span class="line"></span><br><span class="line">    public BatchGetDataCommand(Collection&lt;CollapsedRequest&lt;Double, Long&gt;&gt; requests) &#123;</span><br><span class="line">        super(Setter.withGroupKey(</span><br><span class="line">                HystrixCommandGroupKey.Factory.asKey(&quot;batchGetData&quot;)));</span><br><span class="line">        this.requests = requests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected List&lt;Double&gt; run() throws Exception &#123;</span><br><span class="line">        // TODO: 做些批量查询操作，这里作为示范直接返回</span><br><span class="line">        return requests.stream()</span><br><span class="line">                .map(CollapsedRequest::getArgument)</span><br><span class="line">                .map(arg -&gt; (double) arg)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleGetDataCommand extends HystrixCollapser&lt;List&lt;Double&gt;, Double, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    public SimpleGetDataCommand(Long id) &#123;</span><br><span class="line">        super(HystrixCollapser.Setter</span><br><span class="line">                .withCollapserKey(HystrixCollapserKey.Factory.asKey(&quot;getData&quot;))</span><br><span class="line">                .andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter()</span><br><span class="line">                        .withMaxRequestsInBatch(2)</span><br><span class="line">                        .withTimerDelayInMilliseconds(5)</span><br><span class="line">                        // 允许缓存request的结果</span><br><span class="line">                        .withRequestCacheEnabled(true))</span><br><span class="line">                .andScope(Scope.REQUEST));</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long getRequestArgument() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected HystrixCommand&lt;List&lt;Double&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;Double, Long&gt;&gt; collapsedRequests) &#123;</span><br><span class="line">        return new BatchGetDataCommand(collapsedRequests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void mapResponseToRequests(final List&lt;Double&gt; batchResponse, Collection&lt;CollapsedRequest&lt;Double, Long&gt;&gt; collapsedRequests) &#123;</span><br><span class="line">        final AtomicInteger count = new AtomicInteger();</span><br><span class="line">        collapsedRequests.forEach(request -&gt; &#123;</span><br><span class="line">            request.setResponse(</span><br><span class="line">                    batchResponse.get(count.getAndIncrement()));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            // Hystrix内部将多个查询合并成一个</span><br><span class="line">            SimpleGetDataCommand command1 = new SimpleGetDataCommand(1L);</span><br><span class="line">            SimpleGetDataCommand command2 = new SimpleGetDataCommand(2L);</span><br><span class="line">            // 这里需要先使用queue而不是execute</span><br><span class="line">            Future&lt;Double&gt; f1 = command1.queue();</span><br><span class="line">            Future&lt;Double&gt; f2 = command2.queue();</span><br><span class="line">            System.out.println(f1.get());</span><br><span class="line">            System.out.println(f2.get());</span><br><span class="line">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol>
<li>当设置allowCoreThreadTimeOut = true时，long keepAliveTime会转而作用于核心线程，那么同时时我还想设置非核心线程的闲置超时时常要怎样做呢？<br>allowCoreThreadTimeOut 的职不管是false 还是true，都会对非核心线程起作用的。只不过在为true 时，对核心线程也会起作用！</li>
<li>线程的创建 / 销毁伴随着系统开销 具体是指什么？<br>分两个部分说<br>第一点：我们会在服务器上创建线程的大小，现在默认1M。这个是一个很大的内存。<br>第二点：需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被清空,切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。 所以多线程在某些情况下并不是100% 能提高效率，反而会比单线程慢。当然池化后，可以降低一部分创建，销毁的开销， 但是调度的资源是一定会被浪费的。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/leesf456/p/5453091.html" target="_blank" rel="noopener">【目录】JUC锁框架目录</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5550043.html" target="_blank" rel="noopener">【目录】JUC集合框架目录</a><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3></li>
<li><a href="https://github.com/liuzhengyang/hsdis" target="_blank" rel="noopener">liuzhengyang/hsdis</a></li>
<li><a href="https://blog.csdn.net/moakun/article/details/100171632" target="_blank" rel="noopener">面试官问：为什么 Java 线程没有 Running 状态？我懵了</a></li>
<li><a href="http://ifeve.com/context-switch-definition/" target="_blank" rel="noopener">上下文切换详解</a><h3 id="线程任务"><a href="#线程任务" class="headerlink" title="线程任务"></a>线程任务</h3></li>
<li><a href="https://www.zhihu.com/question/36560619" target="_blank" rel="noopener">多线程并发读写是否一定要加锁？</a><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3></li>
<li><a href="https://juejin.im/post/5cd6cf685188256964773543" target="_blank" rel="noopener">手动造一个线程池(Java)</a></li>
<li><a href="http://www.baeldung.com/java-executor-wait-for-threads" target="_blank" rel="noopener">ExecutorService – Waiting for Threads to Finish</a></li>
<li><a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">如何合理地估算线程池大小？</a><br>提供了一个<code>Dark Magic</code>方法来计算线程池大小。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Distributed-System/" rel="tag"># Distributed System</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/226416.html" rel="next" title="使用 jq 解析 json 数据">
                <i class="fa fa-chevron-left"></i> 使用 jq 解析 json 数据
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/9d02e43e.html" rel="prev" title="服务治理——异步任务的定义">
                服务治理——异步任务的定义 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">1.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程任务特性分析"><span class="nav-number">1.1.</span> <span class="nav-text">线程任务特性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池容量评估"><span class="nav-number">1.2.</span> <span class="nav-text">线程池容量评估</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-ExecutorService"><span class="nav-number">2.</span> <span class="nav-text">JDK - ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">2.1.</span> <span class="nav-text">ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#execute、submit-任务提交"><span class="nav-number">2.1.1.</span> <span class="nav-text">execute、submit - 任务提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokeAll、invokeAny-调用Callable任务"><span class="nav-number">2.1.2.</span> <span class="nav-text">invokeAll、invokeAny - 调用Callable任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown-终止"><span class="nav-number">2.1.3.</span> <span class="nav-text">shutdown - 终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">2.2.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#corePoolSize"><span class="nav-number">2.2.1.</span> <span class="nav-text">corePoolSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maximumPoolSize"><span class="nav-number">2.2.2.</span> <span class="nav-text">maximumPoolSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poolSize"><span class="nav-number">2.2.3.</span> <span class="nav-text">poolSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keepAliveTime"><span class="nav-number">2.2.4.</span> <span class="nav-text">keepAliveTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeUnit-unit"><span class="nav-number">2.2.5.</span> <span class="nav-text">TimeUnit unit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue-workQueue"><span class="nav-number">2.2.6.</span> <span class="nav-text">BlockingQueue workQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadFactory-threadFactory"><span class="nav-number">2.2.7.</span> <span class="nav-text">ThreadFactory threadFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RejectedExecutionHandler-handler"><span class="nav-number">2.2.8.</span> <span class="nav-text">RejectedExecutionHandler handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行策略"><span class="nav-number">2.2.9.</span> <span class="nav-text">执行策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程回收策略"><span class="nav-number">2.2.10.</span> <span class="nav-text">线程回收策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排队策略"><span class="nav-number">2.2.11.</span> <span class="nav-text">排队策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#饱和策略"><span class="nav-number">2.2.12.</span> <span class="nav-text">饱和策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors"><span class="nav-number">2.3.</span> <span class="nav-text">Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">2.3.1.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">2.3.2.</span> <span class="nav-text">newFixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">2.3.3.</span> <span class="nav-text">newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">2.3.4.</span> <span class="nav-text">newScheduledThreadPool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池预热"><span class="nav-number">2.4.</span> <span class="nav-text">线程池预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数调优"><span class="nav-number">2.5.</span> <span class="nav-text">参数调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-ThreadPoolTaskExecutor"><span class="nav-number">2.6.</span> <span class="nav-text">Spring - ThreadPoolTaskExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">2.7.</span> <span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Guava-MoreExecutors"><span class="nav-number">2.8.</span> <span class="nav-text">Guava - MoreExecutors</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC中的异步"><span class="nav-number">3.</span> <span class="nav-text">RPC中的异步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端-OR-服务端-异步"><span class="nav-number">3.1.</span> <span class="nav-text">客户端 OR 服务端 异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#良好习惯"><span class="nav-number">3.2.</span> <span class="nav-text">良好习惯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反模式-异步狂热"><span class="nav-number">3.3.</span> <span class="nav-text">反模式-异步狂热</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-DeferredResult"><span class="nav-number">4.</span> <span class="nav-text">Spring - DeferredResult</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hystrix-Command"><span class="nav-number">5.</span> <span class="nav-text">Hystrix - Command</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">6.</span> <span class="nav-text">QA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">7.1.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程任务"><span class="nav-number">7.2.</span> <span class="nav-text">线程任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池-1"><span class="nav-number">7.3.</span> <span class="nav-text">线程池</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
