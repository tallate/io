<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="并发,">










<meta name="description" content="执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。">
<meta name="keywords" content="并发">
<meta property="og:type" content="article">
<meta property="og:title" content="并发和线程池">
<meta property="og:url" content="https://tallate.github.io/e3d5c2fc.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ThreadPoolExecutor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ForkJoinPool%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/FutureTask%E7%8A%B6%E6%80%81%E6%9C%BA.png">
<meta property="og:image" content="http://tallate.top/imgs/%E6%B1%A0%E5%8C%96/commons-pool2%E7%B1%BB%E5%9B%BE.png">
<meta property="og:updated_time" content="2020-12-19T08:19:24.841Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并发和线程池">
<meta name="twitter:description" content="执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。">
<meta name="twitter:image" content="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tallate.github.io/e3d5c2fc.html">







  <title>并发和线程池 | Tallate</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tallate</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不乱于心，不困于情，不畏将来，不念过往</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>

      <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e3d5c2fc.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tallate">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">并发和线程池</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。</p>
<a id="more"></a>
<h2 id="jdk-executorservice"><a class="header-anchor" href="#jdk-executorservice">¶</a>JDK - ExecutorService</h2>
<p>Executor 是 Java5 引入的线程执行器，主要用于负责线程的创建和调度，程序中不用再显示地调用 new Thread().start()（实现业务逻辑和线程创建、调度间的解耦）。<br>
接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个 ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的 ExecutorService 的实现就是一个线程池的实现。</p>
<h3 id="executorservice"><a class="header-anchor" href="#executorservice">¶</a>ExecutorService</h3>
<h4 id="execute-submit-任务提交"><a class="header-anchor" href="#execute-submit-任务提交">¶</a>execute、submit - 任务提交</h4>
<ul>
<li>execute(Runnable)<br>
接收一个 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。如下是一个使用 ExecutorService 执行 Runnable 的例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">executorService.execute(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
<p>使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用 接收 Callable 参数的 execute() 方法，后者将会在下文中提到。</p>
<ul>
<li>submit(Runnable)<br>
会返回一个 Future， Future 对象可以用于判断 Runnable 是否结束执行。如下是一个 ExecutorService 的 submit() 方法的例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//如果任务结束执行则返回 null</span><br><span class="line">System.out.println(&quot;future.get()=&quot; + future.get());</span><br></pre></td></tr></table></figure>
<ul>
<li>submit(Callable)<br>
接收一个 Callable 参数，Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(new Callable()&#123;</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Asynchronous Callable&quot;);</span><br><span class="line">        return &quot;Callable Result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;future.get() = &quot; + future.get());</span><br></pre></td></tr></table></figure>
<h4 id="invokeall-invokeany-调用-callable-任务"><a class="header-anchor" href="#invokeall-invokeany-调用-callable-任务">¶</a>invokeAll、invokeAny - 调用 Callable 任务</h4>
<ul>
<li>invokeAll()<br>
方法 invokeAll() 会<strong>调用所有</strong>存在于参数集合中的 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每個 Callable 的执行结果。<br>
需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过 Future 对象来了解到这個差异。</li>
<li>invokeAny()<br>
方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。<br>
如果一个任务运行完毕或者抛出异常，方法会取消其它的 Callable 的执行。</li>
</ul>
<h4 id="shutdown-终止"><a class="header-anchor" href="#shutdown-终止">¶</a>shutdown - 终止</h4>
<p>当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态，ExecutorService 中仍处于执行状态的用户线程会阻止 Java 虚拟机的关闭。</p>
<ul>
<li>shutdown<br>
ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorService 才会真的关闭。</li>
<li>shutdownNow<br>
立刻终止，这个方法不推荐使用，如果线程正在执行重要任务，直接中断掉可能破坏数据一致性。</li>
</ul>
<p>shutdown 虽然可以保证应用能安全退出，但是不能排除某些情况下线程陷入了死循环或遇到一些特别耗时的任务、导致线程池无法退出的情况，这时最好设置一个超时退出的机制，可以使用<code>awaitTermination</code>来实现。</p>
<h3 id="threadpoolexecutor"><a class="header-anchor" href="#threadpoolexecutor">¶</a>ThreadPoolExecutor</h3>
<p>ThreadPoolExecutor 是 ExecutorService 的实现类，也是最常使用的线程池实现类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">        int maximumPoolSize,</span><br><span class="line">        long keepAliveTime,</span><br><span class="line">        TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">        ThreadFactory threadFactory,</span><br><span class="line">        RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<h4 id="corepoolsize"><a class="header-anchor" href="#corepoolsize">¶</a>corePoolSize</h4>
<p>线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程，即当前线程总数小于 corePoolSize 的情况下新建的是核心线程，如果超过 corePoolSize，则新建的是非核心线程。<br>
这里需要注意的是：在刚刚创建 ThreadPoolExecutor 的时候，线程并不会立即启动，而是要等到有任务提交时才会启动，除非调用了 prestartCoreThread/prestartAllCoreThreads 事先启动核心线程。再考虑到 keepAliveTime 和 allowCoreThreadTimeOut 超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是 corePoolSize。</p>
<h4 id="maximumpoolsize"><a class="header-anchor" href="#maximumpoolsize">¶</a>maximumPoolSize</h4>
<p>线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于 maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是 largestPoolSize，该变量记录了线程池在整个生命周期中曾经出现的最大线程个数。为什么说是曾经呢？因为线程池创建之后，可以调用 setMaximumPoolSize()改变运行的最大线程的数目。</p>
<h4 id="poolsize"><a class="header-anchor" href="#poolsize">¶</a>poolSize</h4>
<p>线程池中当前线程的数量，当该值为 0 的时候，意味着没有任何线程，线程池会终止；同一时刻，poolSize 不会超过 maximumPoolSize。</p>
<h4 id="keepalivetime"><a class="header-anchor" href="#keepalivetime">¶</a>keepAliveTime</h4>
<p>如果一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。举个例子，如果线程池的核心大小 corePoolSize=5，而当前大小 poolSize =8，那么超出核心大小的线程，会按照 keepAliveTime 的值判断是否会超时退出。如果线程池的核心大小 corePoolSize=5，而当前大小 poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于 allowCoreThreadTimeOut。<br>
在压力很大的情况下，线程池中的所有线程都在处理新提交的任务或者是在排队的任务，这个时候线程池处在忙碌状态。如果压力很小，那么可能很多线程池都处在空闲状态，这个时候为了节省系统资源，回收这些没有用的空闲线程，就必须提供一些超时机制，这也是线程池大小调节策略的一部分。通过 corePoolSize 和 maximumPoolSize，控制如何新增线程；通过 allowCoreThreadTimeOut 和 keepAliveTime，控制如何销毁线程。</p>
<h4 id="timeunit-unit"><a class="header-anchor" href="#timeunit-unit">¶</a>TimeUnit unit</h4>
<p>keepAliveTime 的单位，TimeUnit 是一个 枚举类型，其包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 </span><br><span class="line">MILLISECONDS ： 1毫秒 = 1秒 /1000 </span><br><span class="line">SECONDS ： 秒 </span><br><span class="line">MINUTES ： 分 </span><br><span class="line">HOURS ： 小时</span><br><span class="line">DAYS ： 天</span><br></pre></td></tr></table></figure>
<h4 id="blockingqueue-runnable-workqueue"><a class="header-anchor" href="#blockingqueue-runnable-workqueue">¶</a>BlockingQueue<runnable> workQueue</runnable></h4>
<p>该线程池中的任务队列，维护着等待执行的 Runnable 对象。<br>
当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。<br>
常用的 workQueue 类型：</p>
<ul>
<li>SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了 maximumPoolSize 而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize 一般指定成 Integer.MAX_VALUE，即无限大</li>
<li>LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了 maximumPoolSize 的设定失效，因为总线程数永远不会超过 corePoolSize</li>
<li>ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到 corePoolSize 的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程 (非核心线程) 执行任务，又如果总线程数到了 maximumPoolSize，并且队列也满了，则发生错误</li>
<li>DelayQueue：队列内元素必须实现 Delayed 接口，这就意味着你传进去的任务必须先实现 Delayed 接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</li>
</ul>
<h4 id="threadfactory-threadfactory"><a class="header-anchor" href="#threadfactory-threadfactory">¶</a>ThreadFactory threadFactory</h4>
<p>创建线程的方式，这是一个接口，你 new 他的时候需要实现他的 Thread newThread(Runnable r)方法，一般用不上。<br>
比如 AsyncTask ，它是对线程池的封装，新建线程池的 threadFactory 参数源码如下，非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new ThreadFactory() &#123;</span><br><span class="line">    private final AtomicInteger mCount = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">    public Thread new Thread(Runnable r) &#123;</span><br><span class="line">           return new Thread(r,&quot;AsyncTask#&quot;+mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rejectedexecutionhandler-handler"><a class="header-anchor" href="#rejectedexecutionhandler-handler">¶</a>RejectedExecutionHandler handler</h4>
<p>抛出异常专用，比如上面提到的两个错误发生了，就会由这个 handler 抛出异常，不指定的话，这个参数会取默认值 ThreadPoolExecutor.AbortPolicy，所有类型如下：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出 RejectedExecutionException 异常</li>
<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li>
</ul>
<h4 id="执行策略"><a class="header-anchor" href="#执行策略">¶</a>执行策略</h4>
<p><img src="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池执行流程" title="线程池执行流程"></p>
<ol>
<li>如果线程池的当前 <code>poolSize &lt; corePoolSize</code>，那么就新增加一个线程处理新提交的任务，即使此时线程池中存在空闲线程；</li>
<li>如果当前 <code>poolSize</code> 已经达到 <code>corePoolSize</code>，就将新提交的任务提交到 <code>workQueue</code> 排队，等候处理 <code>workQueue.offer(command)</code>；</li>
<li>如果 <code>workQueue</code> 容量已达上限，并且当前 <code>poolSize &lt; maximumPoolSize</code>，那么就新增线程来处理任务；</li>
<li>如果 <code>workQueue</code> 已满，并且当前 <code>poolSize &gt;= maximumPoolSize</code>，那么意味着线程池的处理能力已经达到了极限，此时需要拒绝新增加的任务，新提交任务由 <code>RejectedExecutionHandler</code> 处理。</li>
</ol>
<h4 id="线程池状态"><a class="header-anchor" href="#线程池状态">¶</a>线程池状态</h4>
<p><img src="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt="线程池状态" title="线程池状态"></p>
<ol>
<li>RUNNING<br>
线程池正处于运行中状态，可接收新任务，也可执行已添加的任务。<br>
线程池刚创建时就处于这个状态，此时线程池中没有任何任务。</li>
<li>SHUTDOWN<br>
线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</li>
<li>STOP<br>
线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>
<li>TIDYING<br>
当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。<br>
当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理，可以通过重载terminated()函数来实现。</li>
<li>TERMINATED<br>
线程池彻底终止，就变成TERMINATED状态。</li>
</ol>
<h4 id="线程回收策略"><a class="header-anchor" href="#线程回收策略">¶</a>线程回收策略</h4>
<ul>
<li>当线程池中超过 corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程</li>
<li>当设置<code>allowCoreThreadTimeOut(true)</code>时，线程池中 corePoolSize 线程空闲时间达到 keepAliveTime 也将关闭</li>
</ul>
<h4 id="排队策略"><a class="header-anchor" href="#排队策略">¶</a>排队策略</h4>
<p>J.U.C 提供的 ThreadPoolExecutor 只支持任务在内存中排队，通过 BlockingQueue 暂存还没有来得及执行的任务。<br>
常用的有 SynchronousQueue，LinkedBlockingQueue，ArrayBlockingQueue 三种阻塞队列。<br>
一般如果线程池任务队列采用<strong>LinkedBlockingQueue</strong>队列的话，那么不会拒绝任何任务（因为队列大小没有限制），这种情况下，ThreadPoolExecutor 最多仅会按照最小线程数来创建线程，也就是说线程池大小被忽略了。<br>
如果线程池任务队列采用<strong>ArrayBlockingQueue</strong>队列的话，那么 ThreadPoolExecutor 将会采取一个非常负责的算法，比如假定线程池的最小线程数为 4，最大为 8 所用的 ArrayBlockingQueue 最大为 10。随着任务到达并被放到队列中，线程池中最多运行 4 个线程（即最小线程数）。即使队列完全填满，也就是说有 10 个处于等待状态的任务，ThreadPoolExecutor 也只会利用 4 个线程。如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。<br>
这个算法背后的理念是：该池大部分时间仅使用核心线程（4 个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。</p>
<h4 id="饱和策略"><a class="header-anchor" href="#饱和策略">¶</a>饱和策略</h4>
<p>AbortPolicy: 直接抛异常<br>
CallerRunsPolicy: 用调用者的线程来运行任务<br>
DiscardOldestPolicy: 丢弃线程队列里最近的一个任务，执行新提交的任务<br>
DiscardPolicy: 直接将新任务丢弃</p>
<p>如果使用 Executors 的工厂方法创建的线程池，那么饱和策略都是采用默认的 AbortPolicy，所以如果我们想当线程池已满的情况，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 Executors 了。</p>
<h4 id="threadpoolexecutor-原理"><a class="header-anchor" href="#threadpoolexecutor-原理">¶</a>ThreadPoolExecutor 原理</h4>
<p><img src="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ThreadPoolExecutor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="ThreadPoolExecutor工作原理" title="ThreadPoolExecutor工作原理"></p>
<ul>
<li>用户线程调用 submit、execute 提交线程任务 addWorker，如果当前线程池活跃任务数 &lt; corePoolSize，则直接 addWorker，否则添加到 workQueue</li>
<li>addWorker 成功则执行线程任务 runWorker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    /*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">     * start a new thread with the given command as its first</span><br><span class="line">     * task.  The call to addWorker atomically checks runState and</span><br><span class="line">     * workerCount, and so prevents false alarms that would add</span><br><span class="line">     * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *</span><br><span class="line">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">     * and so reject the task.</span><br><span class="line">     */</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 第一步，使用corePoolSize个线程资源</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // corePoolSize个线程正在被使用，此时将command压入队列</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 继续创建线程，这时不再使用corePoolSize，而是继续创建线程直到达到maxPoolSize</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>比较反直觉的是，ThreadPoolExecutor 并不是把任务分给线程去执行，而是由线程不断地从阻塞队列获取任务（<code>ThreadPoolExecutor.runWorker</code> -&gt; <code>ThreadPoolExecutor.getTask</code>）</li>
</ul>
<h4 id="scheduledthreadpoolexecutor-原理"><a class="header-anchor" href="#scheduledthreadpoolexecutor-原理">¶</a>ScheduledThreadPoolExecutor 原理</h4>
<ul>
<li>使用<code>DelayedWorkQueue</code>保存<code>ScheduledFutureTask</code>，<code>DelayedWorkQueue</code>内部使用优先队列实现，优先级是调度的间隔时间；</li>
<li>用户线程只负责提交任务到队列、必要时启动新的线程，并不负责把任务提交给任何工作线程来执行，那么如何实现到了调度时间才执行目标任务的特性？其实是在上一步工作线程从队列获取任务时，会根据队首任务的延迟时间来进行等待。当向队列中投放任务时，会唤醒正在等待的线程，同样的，为了防止虚假唤醒，源码中在被唤醒后会计算剩余睡眠时间。（<code>ScheduledThreadPoolExecutor.DelayedWorkQueue.poll(long timeout, TimeUnit unit)</code>、<code>ScheduledThreadPoolExecutor.DelayedWorkQueue.take</code>）</li>
</ul>
<h4 id="为什么使用-threadpoolexecutor-而不是-executors"><a class="header-anchor" href="#为什么使用-threadpoolexecutor-而不是-executors">¶</a>为什么使用 ThreadPoolExecutor 而不是 Executors</h4>
<p>Executors 提供了一些常用的线程池类别，它本质上是创建了一些具有特定功能的 ThreadPoolExecutor 实例，建议直接创建 ThreadPoolExecutor 实例而不是使用 Executors 创建，因为这样会促使我们明确线程池的运行规则，避免资源耗尽。</p>
<ol>
<li>FixedThreadPool 和 SingleThreadPool<br>
因为阻塞队列的实现为<code>LinkedBlockingQueue</code>，因此允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而发生内存溢出现象（OOM）</li>
<li>CachedThreadPool 和 ScheduledThreadPool<br>
因为<code>maximumPoolSize=Integer.MAX_VALUE</code>，允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致内存溢出现象（OOM）</li>
</ol>
<h3 id="executors"><a class="header-anchor" href="#executors">¶</a>Executors</h3>
<p>Executors 提供了一些工厂方法，用于创建一些适用于特定场景的线程池。</p>
<h4 id="newcachedthreadpool"><a class="header-anchor" href="#newcachedthreadpool">¶</a>newCachedThreadPool</h4>
<p>返回 ThreadPoolExecutor 实例，corePoolSize 为 0；maximumPoolSize 为 Integer.MAX_VALUE；keepAliveTime 为 60L；unit 为 TimeUnit.SECONDS；workQueue 为 SynchronousQueue(同步队列)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                              60L, TimeUnit.SECONDS,</span><br><span class="line">                              new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有新任务到来，则插入到 SynchronousQueue 中，由于 SynchronousQueue 是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；<br>
若池中线程空闲时间超过指定大小，则该线程会被销毁。</p>
<ul>
<li>优势：1.线程数无限制 2.有空闲线程则复用空闲线程，若无空闲线程则新建线程 3.一定程序减少频繁创建/销毁线程，减少系统开销</li>
<li>适用：执行很多短期异步的小程序或者负载较轻的服务器，比如 MQ 消息的发送。</li>
</ul>
<h4 id="newfixedthreadpool"><a class="header-anchor" href="#newfixedthreadpool">¶</a>newFixedThreadPool</h4>
<p>返回 ThreadPoolExecutor 实例，接收参数为所设定线程数量 nThread，corePoolSize 为 nThread，maximumPoolSize 为 nThread；keepAliveTime 为 0L(不限时)；unit 为：TimeUnit.MILLISECONDS；WorkQueue 为：new LinkedBlockingQueue() 无界阻塞队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                              new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；<br>
如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)。</p>
<ul>
<li>优势：1.可控制线程最大并发数（同时执行的线程数） 2.超出的线程会在队列中等待</li>
<li>适用：执行长期的任务，性能好很多</li>
</ul>
<h4 id="newsinglethreadexecutor"><a class="header-anchor" href="#newsinglethreadexecutor">¶</a>newSingleThreadExecutor</h4>
<p>FinalizableDelegatedExecutorService 包装的 ThreadPoolExecutor 实例，corePoolSize 为 1；maximumPoolSize 为 1；keepAliveTime 为 0L；unit 为：TimeUnit.MILLISECONDS；workQueue 为：new LinkedBlockingQueue() 无解阻塞队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</p>
<ul>
<li>优势：1.有且仅有一个工作线程执行任务 2.所有任务按照指定顺序执行，即遵循队列的入队出队规则</li>
<li>适用：一个任务一个任务执行的场景</li>
</ul>
<h4 id="newscheduledthreadpool"><a class="header-anchor" href="#newscheduledthreadpool">¶</a>newScheduledThreadPool</h4>
<p>创建 ScheduledThreadPoolExecutor 实例，corePoolSize 为传递来的参数，maximumPoolSize 为 Integer.MAX_VALUE；keepAliveTime 为 0；unit 为：TimeUnit.NANOSECONDS；workQueue 为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">//ScheduledThreadPoolExecutor()</span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入 DelayedWorkQueue 队列中，这是一种按照超时时间排序的队列结构<br>
适用：定时及周期性执行任务的场景</p>
<h3 id="线程池预热"><a class="header-anchor" href="#线程池预热">¶</a>线程池预热</h3>
<p>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，（除非调用了 prestartAllCoreThreads() 或者 prestartCoreThread() 方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程）。</p>
<h3 id="参数调优"><a class="header-anchor" href="#参数调优">¶</a>参数调优</h3>
<p>参数的设置跟系统的负载有直接的关系，下面为系统负载的相关参数：</p>
<ul>
<li>tasks：每秒需要处理的最大任务数量</li>
<li>tasktime：处理第个任务所需要的时间</li>
<li>responsetime：系统允许任务最大的响应时间，比如每个任务的响应时间不得超过 2 秒。</li>
</ul>
<p>下面结合线程池原理来解释 ThreadPoolExecutor 参数应该怎么设置：</p>
<ul>
<li>corePoolSize<br>
每个任务需要 tasktime 秒处理，则每个线程每秒可处理 1 / tasktime 个任务。<br>
系统每秒有 tasks 个任务需要处理，则需要的线程数为：tasks / ( 1 / tasktime )，即 tasks * tasktime 个线程数。<br>
假设系统每秒任务数为 100 ~ 1000，每个任务耗时 0.1 秒，则需要 100 * 0.1 至 1000 * 0.1，即 10 ~ 100 个线程。<br>
那么 corePoolSize 应该设置为大于 10，具体数字最好根据 8020 原则，即 80 % 情况下系统每秒任务数，若系统 80%的情况下第秒任务数小于 200，最多时为 1000，则 corePoolSize 可设置为 20。</li>
<li>queueCapacity<br>
任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。 队列长度可以设置为 ( corePoolSize / tasktime ) * responsetime ： ( 20 / 0.1 ) * 2 = 400，即队列长度可设置为 400。<br>
队列长度设置过大，会导致任务响应时间过长，切忌以下写法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingQueue queue = new LinkedBlockingQueue();</span><br></pre></td></tr></table></figure>
<p>这实际上是将队列长度设置为 Integer.MAX_VALUE，将会导致线程数量永远为 corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。</p>
<ul>
<li>maxPoolSize<br>
当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。<br>
每秒 200 个任务需要 20 个线程，那么当每秒达到 1000 个任务时，则需要 ( 1000 - queueCapacity ) * ( 20 / 200 )，即 60 个线程，可将 maxPoolSize 设置为 60。<br>
若结合 CPU 的情况，比如，当线程数量达到 50 时，CPU 达到 100%，则将 maxPoolSize 设置为 60 也不合适，此时若系统负载长时间维持在每秒 1000 个 任务，则超出线程池处理能力，应设法降低每个任务的处理时间 ( tasktime )。</li>
<li>keepAliveTime:<br>
线程数量只增加不减少也不行。当负载降低时，可减少线程数量，如果一个线程空闲时间达到 keepAliveTiime，该线程就退出。 默认情况下线程池最少会保持 corePoolSize 个线程。</li>
<li>allowCoreThreadTimeout:<br>
默认情况下核心线程不会退出，可通过将该参数设置为 true，让核心线程也退出。</li>
</ul>
<h3 id="spring-threadpooltaskexecutor"><a class="header-anchor" href="#spring-threadpooltaskexecutor">¶</a>Spring - ThreadPoolTaskExecutor</h3>
<p>Spring 的 TaskExecutor 接口等同于 Java.util.concurrent.Executor 接口。 实际上，它存在的主要原因是为了在使用线程池的时候，将对 Java 5 的依赖抽象出来，在需要时给其他 Spring 组件提供一个线程池的抽象。 这个接口只有一个方法 execute(Runnable task)，它根据线程池的语义和配置，来接受一个执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;taskExecutor&quot; name=&quot;taskExecutor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;  </span><br><span class="line">    &lt;!-- 核心线程数 线程池维护线程的最少数量 --&gt;</span><br><span class="line">    &lt;property name=&quot;corePoolSize&quot; value=&quot;10&quot; /&gt;  </span><br><span class="line">    &lt;!-- 线程池维护线程所允许的空闲时间 --&gt;</span><br><span class="line">    &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;200&quot; /&gt;  </span><br><span class="line">    &lt;!-- 线程池维护线程的最大数量 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot; /&gt;  </span><br><span class="line">    &lt;!-- 线程池所使用的缓冲队列 --&gt;</span><br><span class="line">    &lt;property name=&quot;queueCapacity&quot; value=&quot;100&quot; /&gt; </span><br><span class="line">    &lt;!-- 线程池对拒绝任务(无线程可用)的处理策略 ThreadPoolExecutor.CallerRunsPolicy策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃. --&gt;</span><br><span class="line">    &lt;property name=&quot;rejectedExecutionHandler&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot; /&gt;</span><br><span class="line">    &lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name = &quot;taskExecutor&quot;)</span><br><span class="line">private ThreadPoolTaskExecutor taskExecutor;</span><br></pre></td></tr></table></figure>
<p>提交线程任务主要有以下两个 API：</p>
<ul>
<li>void taskExecutor.execute(…)</li>
<li>Future taskExecutor.submit(…)</li>
</ul>
<p>任务处理的逻辑和 JDK ExecutorService 类似：<br>
如果此时线程池中的数量<strong>小于</strong>corePoolSize，即使线程池中的线程都处于空闲状态，也要<strong>创建新的线程</strong>来处理被添加的任务。<br>
如果此时线程池中的数量<strong>等于</strong>corePoolSize，但是缓冲队列 workQueue 未满，那么<strong>任务被放入缓冲队列</strong>。<br>
如果此时线程池中的数量<strong>大于</strong>corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量小于 maxPoolSize，建新的线程来处理被添加的任务。<br>
如果此时线程池中的数量<strong>大于</strong>corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等于 maxPoolSize，那么通过 handler 所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程 corePoolSize、任务队列 workQueue、最大线程 maximumPoolSize，如果三者都满了，使用 handler 处理被拒绝的任务。<br>
当线程池中的线程数量<strong>大于</strong>corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</p>
<ul>
<li>SimpleAsyncTaskExecutor 类<br>
这个实现不重用任何线程，或者说它每次调用都启动一个新线程。但是，它还是支持对并发总数设限，当超过线程并发总数限制时，阻塞新的调用，直到有位置被释放。如果你需要真正的池，请继续往下看。</li>
<li>SyncTaskExecutor 类<br>
这个实现不会异步执行。相反，每次调用都在发起调用的线程中执行。它的主要用处是在不需要多线程的时候，比如简单的 test case。</li>
<li>ConcurrentTaskExecutor 类<br>
这个实现是对 Java 5 java.util.concurrent.Executor 类的包装。有另一个备选, ThreadPoolTaskExecutor 类，它暴露了 Executor 的配置参数作为 bean 属性。很少需要使用 ConcurrentTaskExecutor, 但是如果 ThreadPoolTaskExecutor 不敷所需，ConcurrentTaskExecutor 是另外一个备选。</li>
<li>SimpleThreadPoolTaskExecutor 类<br>
这个实现实际上是 Quartz 的 SimpleThreadPool 类的子类，它会监听 Spring 的生命周期回调。当你有线程池，需要在 Quartz 和非 Quartz 组件中共用时，这是它的典型用处。</li>
<li>ThreadPoolTaskExecutor 类<br>
它不支持任何对 java.util.concurrent 包的替换或者下行移植。Doug Lea 和 Dawid Kurzyniec 对 java.util.concurrent 的实现都采用了不同的包结构，导致它们无法正确运行。<br>
这个实现只能在 Java 5 环境中使用，但是却是这个环境中最常用的。它暴露的 bean properties 可以用来配置一个 java.util.concurrent.ThreadPoolExecutor，把它包装到一个 TaskExecutor 中。如果你需要更加先进的类，比如 ScheduledThreadPoolExecutor,我们建议你使用 ConcurrentTaskExecutor 来替代。</li>
<li>TimerTaskExecutor 类<br>
这个实现使用一个 TimerTask 作为其背后的实现。它和 SyncTaskExecutor 的不同在于，方法调用是在一个独立的线程中进行的，虽然在那个线程中是同步的。</li>
<li>WorkManagerTaskExecutor 类<br>
CommonJ 是 BEA 和 IBM 联合开发的一套规范。这些规范并非 java ee 的标准，但它是 BEA 和 IBM 的应用服务器实现的共同标准<br>
这个实现使用了 CommonJ WorkManager 作为其底层实现，是在 Spring context 中配置 CommonJ WorkManager 应用的最重要的类。和 SimpleThreadPoolTaskExecutor 类似，这个类实现了 WorkManager 接口，因此可以直接作为 WorkManager 使用。</li>
</ul>
<h2 id="线程池优化-用最少的资源干最多的活"><a class="header-anchor" href="#线程池优化-用最少的资源干最多的活">¶</a>线程池优化 - 用最少的资源干最多的活</h2>
<h3 id="线程任务特性分析"><a class="header-anchor" href="#线程任务特性分析">¶</a>线程任务特性分析</h3>
<p>任务的性质：CPU 密集型任务、IO 密集型任务、混合型任务。<br>
任务的优先级：高、中、低。<br>
任务的执行时间：长、中、短。<br>
任务的依赖性：是否依赖其他系统资源，如数据库连接等。</p>
<h3 id="线程池容量评估"><a class="header-anchor" href="#线程池容量评估">¶</a>线程池容量评估</h3>
<p>评估线程池要开多大一般会借助于一个公式：<br>
<code>TN = CN * CU * (1 + w/c)</code><br>
<code>TN = 线程池中总线程数</code><br>
<code>CN = CPU核心数</code><br>
<code>CU = CPU使用率</code><br>
<code>w = 等待时间</code><br>
<code>c = 计算时间</code></p>
<blockquote>
<p>《java 并发编程实践》和《Java 虚拟机并发编程》都有描述。</p>
</blockquote>
<p>对线程池大小的计算需要区分所需执行的任务特点：</p>
<ul>
<li>IO 密集型<br>
若任务对其他系统资源有依赖，如某个任务依赖数据库的连接返回的结果，这时候等待的时间越长，则 CPU 空闲的时间越长，那么线程数量应设置得越大，才能更好的利用 CPU。<br>
一般情况下，如果存在 IO，那么肯定 w/c&gt;1（阻塞耗时一般都是计算耗时的很多倍）,但是需要考虑系统内存有限（每开启一个线程都需要内存空间），这里需要上服务器测试具体多少个线程数适合（CPU 占比、线程数、总耗时、内存消耗）。如果不想去测试，保守点取 1 即：<br>
<code>TN = 2CN</code></li>
<li>计算密集型<br>
假设没有等待或者近似为没有等待 w=0，则 w/c=0，有：<br>
<code>TN = CN</code><br>
对于计算密集型的任务，在拥有 N 个处理器的系统上，当线程池的大小为 N+1 时，通常能实现最优的效率，这样，即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费，但也同时会多一个 CPU 上下文切换。</li>
<li>混合型<br>
如果可以拆分，拆分成 IO 密集型和 CPU 密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。</li>
</ul>
<p>总而言之：</p>
<ol>
<li>高并发、任务执行时间短的业务<br>
线程池线程数可以设置为<strong>CPU 核数+1</strong>，减少线程上下文的切换</li>
<li>并发不高、任务执行时间长的业务<br>
要区分开看：
<ul>
<li>假如是业务时间长集中在 IO 操作上，也就是 IO 密集型的任务，因为 IO 操作并不占用 CPU，所以不要让所有的 CPU 闲下来，可以<strong>适当加大线程池中的线程数目</strong>，让 CPU 处理更多的业务</li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>
</ul>
</li>
<li>并发高、业务执行时间长<br>
解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，然后再考虑如何设置线程池属性。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li>
</ol>
<p>当然具体合理设置线程池大小，需要结合系统实际情况，在大量的尝试下比较才能得出，以上只是前人总结的规律。</p>
<h3 id="forkjoinpool"><a class="header-anchor" href="#forkjoinpool">¶</a>ForkJoinPool</h3>
<ul>
<li>控制并行度：理想情况下每个 CPU 线程执行一个线程任务，极大减少了线程上下文切换耗费的时间，并行度在构造时确定，默认是 CPU 的可用线程数（<code>Runtime.getRuntime().availableProcessors()</code>）。</li>
<li>Work-stealing：get 或 join 的时候会触发（<code>ForkJoinTask</code>），从存放 Task 的<strong>双端队列</strong>末尾“窃取”任务交给空闲的线程来执行，避免线程资源的浪费。<br>
<img src="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/ForkJoinPool%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="ForkJoinPool工作原理" title="ForkJoinPool工作原理"></li>
</ul>
<h3 id="线程池隔离"><a class="header-anchor" href="#线程池隔离">¶</a>线程池隔离</h3>
<p>默认情况下，<code>CompletableFuture</code>这样的并发工具类使用一个默认的线程池来执行任务，如果进程的多个地方都在使用<code>CompletableFuture</code>，那么它们无疑是会竞争这个线程池的。</p>
<h2 id="future-好莱坞原则的应用"><a class="header-anchor" href="#future-好莱坞原则的应用">¶</a>Future - 好莱坞原则的应用</h2>
<h3 id="futuretask"><a class="header-anchor" href="#futuretask">¶</a>FutureTask</h3>
<h4 id="并行化"><a class="header-anchor" href="#并行化">¶</a>并行化</h4>
<p>刚开始接触并发编程，容易写出下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">List&lt;Future&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    Future&lt;?&gt; future = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 假设这里是一个一直阻塞着的调用</span><br><span class="line">            Thread.sleep(1000000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    futures.add(future);</span><br><span class="line">&#125;</span><br><span class="line">futures.forEach(future -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        future.get(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println((System.currentTimeMillis() - startTime));</span><br></pre></td></tr></table></figure>
<p>此时开发很有可能会误以为结果是 1s 左右，毕竟 3 个<code>FutureTask</code>同时执行、每个只等待 1s，结果确实应该是 1s，但是这里并没有实现并行化，因为<code>future.get</code>是轮询调用的，第一个执行完毕后，第二个仍然需要等待 1s，因此结果是 3s。<br>
虽然每个 FutureTask 是同时开始执行的，但是<code>future.get</code>并不是同时开始等待的，如果想要达到并行执行的效果，一定是在上一个执行完毕的时候，下一个就已经执行完毕了，此时就可以直接获取结果了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService innerThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">List&lt;Future&gt; futures = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    Future&lt;?&gt; future = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        // 假设这里是一个一直阻塞着的调用</span><br><span class="line">        Future&lt;?&gt; innerFuture = innerThreadPool.submit(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        try &#123;</span><br><span class="line">            innerFuture.get(800, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    futures.add(future);</span><br><span class="line">&#125;</span><br><span class="line">futures.forEach(future -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        future.get(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println((System.currentTimeMillis() - startTime));</span><br></pre></td></tr></table></figure>
<h4 id="阻塞还是轮询"><a class="header-anchor" href="#阻塞还是轮询">¶</a>阻塞还是轮询</h4>
<p>阻塞虽然看起来很廉价，似乎线程阻塞后就不占用资源了，实际上很多阻塞都是通过轮询标志位实现的，比如 FutureTask 内部实现了这样的一种状态机：<br>
<img src="http://tallate.top/imgs/%E5%B9%B6%E5%8F%91/FutureTask%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="FutureTask状态机" title="FutureTask状态机"><br>
每次状态的变更都是通过<code>CAS</code>（<code>UNSAFE</code>）实现线程安全的，比如<code>set</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="guava-listenablefuture"><a class="header-anchor" href="#guava-listenablefuture">¶</a>Guava - ListenableFuture</h3>
<p>ListenableFuture 是在 JDK1.8 之前出现的，现在 CompletableFuture 一般是更好的选择。</p>
<h3 id="completionservice"><a class="header-anchor" href="#completionservice">¶</a>CompletionService</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">CompletionService&lt;String&gt; cs = new ExecutorCompletionService&lt;&gt;(Executors.newFixedThreadPool(3));</span><br><span class="line">cs.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    return &quot;x&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">cs.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    return &quot;x&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">    String s = cs.take().get();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br></pre></td></tr></table></figure>
<ul>
<li>将线程任务提交到线程池执行，并将 Future 提交到阻塞队列供客户端获取，阻塞队列默认是<code>LinkedBlockingQueue</code>；</li>
<li>CompletionService 内部只有在任务完成的时候才会把 Future 丢到队列中，因此如果任务特别耗时，会导致<code>take</code>调用一直不返回，注意下面源码中的<code>done</code>方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private class QueueingFuture extends FutureTask&lt;Void&gt; &#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        super(task, null);</span><br><span class="line">        this.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    protected void done() &#123; completionQueue.add(task); &#125;</span><br><span class="line">    private final Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="completablefuture"><a class="header-anchor" href="#completablefuture">¶</a>CompletableFuture</h3>
<p><code>CompletableFuture</code>实现了 Future 接口，这意味着它本身也提供了通过阻塞或轮询获取结果的方式，相对 Future 来说，它的相对优势在于任务的编排，相对 CompletionService 来说，<code>CompletableFuture</code>又有接口更灵活的优势。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">List&lt;String&gt; items = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; futures = items.stream().map(</span><br><span class="line">        item -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            return item + &quot;x&quot;;</span><br><span class="line">        &#125;))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; strs = futures.stream().map(CompletableFuture::join)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">strs.forEach(System.out::println);</span><br><span class="line">System.out.println(System.currentTimeMillis() - start);</span><br></pre></td></tr></table></figure>
<p>TODO</p>
<ul>
<li>编排<br>
当任务之间有互相依赖的关系时，容易导致线程被饿死。</li>
<li>合并</li>
</ul>
<h2 id="对象池-commons-pools2"><a class="header-anchor" href="#对象池-commons-pools2">¶</a>对象池 - commons-pools2</h2>
<p>池化技术主要分为两种：对象池和线程池。</p>
<ul>
<li>对象池提供了对象的回收机制，这些对象一般是非常&quot;重&quot;的，每次需要时都实例化一次非常浪费资源，常见的实现如数据库连接池、客户端实例等。</li>
<li>线程池相对对象池，增加了销毁、状态机、预热等机制，线程的调度规则也复杂很多。<br>
<img src="http://tallate.top/imgs/%E6%B1%A0%E5%8C%96/commons-pool2%E7%B1%BB%E5%9B%BE.png" alt="commons-pool2类图" title="commons-pool2类图"></li>
</ul>
<h3 id="创建对象流程"><a class="header-anchor" href="#创建对象流程">¶</a>创建对象流程</h3>
<p>以<code>GenericObjectPool</code>为例：</p>
<ul>
<li>获取对象：<code>org.apache.commons.pool2.impl.GenericObjectPool#borrowObject(long)</code></li>
<li>返还对象：<code>org.apache.commons.pool2.impl.GenericObjectPool#returnObject</code></li>
</ul>
<h4 id="获取对象基本流程"><a class="header-anchor" href="#获取对象基本流程">¶</a>获取对象基本流程</h4>
<blockquote>
<p>org.apache.commons.pool2.impl.GenericObjectPool#borrowObject(long borrowMaxWaitMillis</p>
</blockquote>
<ol>
<li>从一个双端队列（<code>LinkedBlockingDeque</code>）的头部弹出（<code>unlink</code>）一个对象；</li>
<li>如果队列为空，则尝试创建（<code>org.apache.commons.pool2.impl.GenericObjectPool#create</code>）；</li>
<li>使用<code>PooledObjectFactory</code>激活（<code>activateObject</code>）该对象（一般是做一些初始化）；</li>
</ol>
<h4 id="返还对象"><a class="header-anchor" href="#返还对象">¶</a>返还对象</h4>
<blockquote>
<p>org.apache.commons.pool2.impl.GenericObjectPool#returnObject</p>
</blockquote>
<ol>
<li>反初始化（<code>passivateObject</code>）对象；</li>
<li>将对象插入队列。</li>
</ol>
<h4 id="线程安全性"><a class="header-anchor" href="#线程安全性">¶</a>线程安全性</h4>
<p>线程安全主要体现在队列上，LinkedBlockingDeque 采用<code>InterruptibleReentrantLock</code>来同步写线程。</p>
<h2 id="qa"><a class="header-anchor" href="#qa">¶</a>QA</h2>
<ol>
<li>当设置 allowCoreThreadTimeOut = true 时，long keepAliveTime 会转而作用于核心线程，那么同时我还想设置非核心线程的闲置超时时常要怎样做呢？<br>
allowCoreThreadTimeOut 的值不管是 false 还是 true，都会对非核心线程起作用的。只不过在为 true 时，对核心线程也会起作用</li>
<li>线程的创建 / 销毁伴随着系统开销 具体是指什么？<br>
分两个部分说<br>
第一点：我们会在服务器上创建线程的大小，现在默认 1M。这个是一个很大的内存。<br>
第二点：需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被清空,切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。 所以多线程在某些情况下并不是 100% 能提高效率，反而会比单线程慢。当然池化后，可以降低一部分创建，销毁的开销， 但是调度的资源是一定会被浪费的。</li>
</ol>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ol>
<li><a href="https://www.cnblogs.com/leesf456/p/5453091.html" target="_blank" rel="noopener">【目录】JUC 锁框架目录</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5550043.html" target="_blank" rel="noopener">【目录】JUC 集合框架目录</a></li>
</ol>
<h3 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h3>
<ol>
<li><a href="https://github.com/liuzhengyang/hsdis" target="_blank" rel="noopener">liuzhengyang/hsdis</a></li>
<li><a href="https://blog.csdn.net/moakun/article/details/100171632" target="_blank" rel="noopener">面试官问：为什么 Java 线程没有 Running 状态？我懵了</a></li>
<li><a href="http://ifeve.com/context-switch-definition/" target="_blank" rel="noopener">上下文切换详解</a></li>
</ol>
<h3 id="线程任务"><a class="header-anchor" href="#线程任务">¶</a>线程任务</h3>
<ol>
<li><a href="https://www.zhihu.com/question/36560619" target="_blank" rel="noopener">多线程并发读写是否一定要加锁？</a></li>
</ol>
<h3 id="线程池"><a class="header-anchor" href="#线程池">¶</a>线程池</h3>
<ol>
<li><a href="https://juejin.im/post/5cd6cf685188256964773543" target="_blank" rel="noopener">手动造一个线程池(Java)</a></li>
<li><a href="http://www.baeldung.com/java-executor-wait-for-threads" target="_blank" rel="noopener">ExecutorService – Waiting for Threads to Finish</a></li>
<li><a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">如何合理地估算线程池大小？</a><br>
提供了一个<code>Dark Magic</code>方法来计算线程池大小。</li>
</ol>
<h3 id="并发工具类"><a class="header-anchor" href="#并发工具类">¶</a>并发工具类</h3>
<ol>
<li><a href="https://colobu.com/2018/03/12/20-Examples-of-Using-Java%E2%80%99s-CompletableFuture/" target="_blank" rel="noopener">[译]20 个使用 Java CompletableFuture 的例子</a></li>
<li><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">Java CompletableFuture 详解</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/54dfb258.html" rel="next" title="异地多活">
                <i class="fa fa-chevron-left"></i> 异地多活
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/9d02e43e.html" rel="prev" title="并发的定义">
                并发的定义 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tallate</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">133</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk-executorservice"><span class="nav-number">1.</span> <span class="nav-text">¶JDK - ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#executorservice"><span class="nav-number">1.1.</span> <span class="nav-text">¶ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#execute-submit-任务提交"><span class="nav-number">1.1.1.</span> <span class="nav-text">¶execute、submit - 任务提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokeall-invokeany-调用-callable-任务"><span class="nav-number">1.1.2.</span> <span class="nav-text">¶invokeAll、invokeAny - 调用 Callable 任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown-终止"><span class="nav-number">1.1.3.</span> <span class="nav-text">¶shutdown - 终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threadpoolexecutor"><span class="nav-number">1.2.</span> <span class="nav-text">¶ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#corepoolsize"><span class="nav-number">1.2.1.</span> <span class="nav-text">¶corePoolSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maximumpoolsize"><span class="nav-number">1.2.2.</span> <span class="nav-text">¶maximumPoolSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poolsize"><span class="nav-number">1.2.3.</span> <span class="nav-text">¶poolSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keepalivetime"><span class="nav-number">1.2.4.</span> <span class="nav-text">¶keepAliveTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeunit-unit"><span class="nav-number">1.2.5.</span> <span class="nav-text">¶TimeUnit unit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#blockingqueue-runnable-workqueue"><span class="nav-number">1.2.6.</span> <span class="nav-text">¶BlockingQueue workQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#threadfactory-threadfactory"><span class="nav-number">1.2.7.</span> <span class="nav-text">¶ThreadFactory threadFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rejectedexecutionhandler-handler"><span class="nav-number">1.2.8.</span> <span class="nav-text">¶RejectedExecutionHandler handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行策略"><span class="nav-number">1.2.9.</span> <span class="nav-text">¶执行策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池状态"><span class="nav-number">1.2.10.</span> <span class="nav-text">¶线程池状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程回收策略"><span class="nav-number">1.2.11.</span> <span class="nav-text">¶线程回收策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排队策略"><span class="nav-number">1.2.12.</span> <span class="nav-text">¶排队策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#饱和策略"><span class="nav-number">1.2.13.</span> <span class="nav-text">¶饱和策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#threadpoolexecutor-原理"><span class="nav-number">1.2.14.</span> <span class="nav-text">¶ThreadPoolExecutor 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scheduledthreadpoolexecutor-原理"><span class="nav-number">1.2.15.</span> <span class="nav-text">¶ScheduledThreadPoolExecutor 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用-threadpoolexecutor-而不是-executors"><span class="nav-number">1.2.16.</span> <span class="nav-text">¶为什么使用 ThreadPoolExecutor 而不是 Executors</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#executors"><span class="nav-number">1.3.</span> <span class="nav-text">¶Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newcachedthreadpool"><span class="nav-number">1.3.1.</span> <span class="nav-text">¶newCachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newfixedthreadpool"><span class="nav-number">1.3.2.</span> <span class="nav-text">¶newFixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newsinglethreadexecutor"><span class="nav-number">1.3.3.</span> <span class="nav-text">¶newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newscheduledthreadpool"><span class="nav-number">1.3.4.</span> <span class="nav-text">¶newScheduledThreadPool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池预热"><span class="nav-number">1.4.</span> <span class="nav-text">¶线程池预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数调优"><span class="nav-number">1.5.</span> <span class="nav-text">¶参数调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-threadpooltaskexecutor"><span class="nav-number">1.6.</span> <span class="nav-text">¶Spring - ThreadPoolTaskExecutor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池优化-用最少的资源干最多的活"><span class="nav-number">2.</span> <span class="nav-text">¶线程池优化 - 用最少的资源干最多的活</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程任务特性分析"><span class="nav-number">2.1.</span> <span class="nav-text">¶线程任务特性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池容量评估"><span class="nav-number">2.2.</span> <span class="nav-text">¶线程池容量评估</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forkjoinpool"><span class="nav-number">2.3.</span> <span class="nav-text">¶ForkJoinPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池隔离"><span class="nav-number">2.4.</span> <span class="nav-text">¶线程池隔离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#future-好莱坞原则的应用"><span class="nav-number">3.</span> <span class="nav-text">¶Future - 好莱坞原则的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#futuretask"><span class="nav-number">3.1.</span> <span class="nav-text">¶FutureTask</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并行化"><span class="nav-number">3.1.1.</span> <span class="nav-text">¶并行化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞还是轮询"><span class="nav-number">3.1.2.</span> <span class="nav-text">¶阻塞还是轮询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#guava-listenablefuture"><span class="nav-number">3.2.</span> <span class="nav-text">¶Guava - ListenableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#completionservice"><span class="nav-number">3.3.</span> <span class="nav-text">¶CompletionService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#completablefuture"><span class="nav-number">3.4.</span> <span class="nav-text">¶CompletableFuture</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象池-commons-pools2"><span class="nav-number">4.</span> <span class="nav-text">¶对象池 - commons-pools2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象流程"><span class="nav-number">4.1.</span> <span class="nav-text">¶创建对象流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取对象基本流程"><span class="nav-number">4.1.1.</span> <span class="nav-text">¶获取对象基本流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返还对象"><span class="nav-number">4.1.2.</span> <span class="nav-text">¶返还对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全性"><span class="nav-number">4.1.3.</span> <span class="nav-text">¶线程安全性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#qa"><span class="nav-number">5.</span> <span class="nav-text">¶QA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">¶参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">6.1.</span> <span class="nav-text">¶线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程任务"><span class="nav-number">6.2.</span> <span class="nav-text">¶线程任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">6.3.</span> <span class="nav-text">¶线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发工具类"><span class="nav-number">6.4.</span> <span class="nav-text">¶并发工具类</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tallate</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '72bdd1c9479eb0679788',
          clientSecret: '62c9c0cb45aadb1478ca66cfc3c69c9623f50290',
          repo: 'tallate.github.io',
          owner: 'tallate',
          admin: ['tallate'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
